/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import java.text.NumberFormat; import java.util.Calendar;  /**  * Tests the difference in performance between CharUtils and CharSet.  *  * Sample runs:  Now: Thu Mar 18 14:29:48 PST 2004 Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.3.1_10-b03 Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.3.1_10-b03 Windows XP 5.1 x86 pentium i486 i386 Do nothing: 0 milliseconds. run_CharUtils_isAsciiNumeric: 4,545 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 3,417 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 85,679 milliseconds.   Now: Thu Mar 18 14:24:51 PST 2004 Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05 Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.4.2_04-b05 Windows XP 5.1 x86 pentium i486 i386 Do nothing: 0 milliseconds. run_CharUtils_isAsciiNumeric: 2,578 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 2,477 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 114,429 milliseconds.  Now: Thu Mar 18 14:27:55 PST 2004 Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05 Sun Microsystems Inc. Java HotSpot(TM) Server VM 1.4.2_04-b05 Windows XP 5.1 x86 pentium i486 i386 Do nothing: 0 milliseconds. run_CharUtils_isAsciiNumeric: 630 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 709 milliseconds. run_inlined_CharUtils_isAsciiNumeric: 84,420 milliseconds.    */ public class CharUtilsPerfRun {     private static final String VERSION = "$Id$";      private static final int WARM_UP = 100;      private static final int COUNT = 5000;      private static final char[] CHAR_SAMPLES;      static {         CHAR_SAMPLES = new char[Character.MAX_VALUE];         for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {             CHAR_SAMPLES[i] = i;         }     }      public static void main(final String[] args) {         new CharUtilsPerfRun().run();     }      private void printSysInfo() {         System.out.println(VERSION);         System.out.println("Now: " + Calendar.getInstance().getTime());         System.out.println(System.getProperty("java.vendor")                 + " "                 + System.getProperty("java.runtime.name")                 + " "                 + System.getProperty("java.runtime.version"));         System.out.println(System.getProperty("java.vm.vendor")                 + " "                 + System.getProperty("java.vm.name")                 + " "                 + System.getProperty("java.vm.version"));         System.out.println(System.getProperty("os.name")             + " "             + System.getProperty("os.version")             + " "             + System.getProperty("os.arch")             + " "             + System.getProperty("sun.cpu.isalist"));     }      private void run() {         this.printSysInfo();         long start;         start = System.currentTimeMillis();         this.printlnTotal("Do nothing", start);         run_CharUtils_isAsciiNumeric(WARM_UP);         start = System.currentTimeMillis();         run_CharUtils_isAsciiNumeric(COUNT);         this.printlnTotal("run_CharUtils_isAsciiNumeric", start);         run_inlined_CharUtils_isAsciiNumeric(WARM_UP);         start = System.currentTimeMillis();         run_inlined_CharUtils_isAsciiNumeric(COUNT);         this.printlnTotal("run_inlined_CharUtils_isAsciiNumeric", start);         run_CharSet(WARM_UP);         start = System.currentTimeMillis();         run_CharSet(COUNT);         this.printlnTotal("run_CharSet", start);     }      private int run_CharSet(final int loopCount) {         int t = 0;         for (int i = 0; i < loopCount; i++) {             for (final char ch : CHAR_SAMPLES) {                 final boolean b = CharSet.ASCII_NUMERIC.contains(ch);                 t += b ? 1 : 0;             }         }         return t;     }      private int run_CharUtils_isAsciiNumeric(final int loopCount) {         int t = 0;         for (int i = 0; i < loopCount; i++) {             for (final char ch : CHAR_SAMPLES) {                 final boolean b = CharUtils.isAsciiNumeric(ch);                 t += b ? 1 : 0;             }         }         return t;     }      private int run_inlined_CharUtils_isAsciiNumeric(final int loopCount) {         int t = 0;         for (int i = 0; i < loopCount; i++) {             for (final char ch : CHAR_SAMPLES) {                 final boolean b = ch >= '0' && ch <= '9';                 t += b ? 1 : 0;             }         }         return t;     }      private void printlnTotal(final String prefix, final long start) {         final long total = System.currentTimeMillis() - start;         System.out.println(prefix + ": " + NumberFormat.getInstance().format(total) + " milliseconds.");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.BitSet; import java.util.Collections; import java.util.Comparator; import java.util.Date; import java.util.Map; import java.util.Random;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.ArrayUtils}.  */ @SuppressWarnings("deprecation") // deliberate use of deprecated code public class ArrayUtilsTest {      private class TestClass {     }      /** A predefined seed used to initialize {@link Random} in order to get predictable results */     private static final long SEED = 16111981L;      @SafeVarargs     private static <T> T[] toArrayPropagatingType(final T... items) {         return ArrayUtils.toArray(items);     }      private void assertIsEquals(final Object array1, final Object array2, final Object array3) {         assertTrue(ArrayUtils.isEquals(array1, array1));         assertTrue(ArrayUtils.isEquals(array2, array2));         assertTrue(ArrayUtils.isEquals(array3, array3));         assertFalse(ArrayUtils.isEquals(array1, array2));         assertFalse(ArrayUtils.isEquals(array2, array1));         assertFalse(ArrayUtils.isEquals(array1, array3));         assertFalse(ArrayUtils.isEquals(array3, array1));         assertFalse(ArrayUtils.isEquals(array1, array2));         assertFalse(ArrayUtils.isEquals(array2, array1));     }      /**      * Tests generic array creation with parameters of same type.      */     @Test     public void testArrayCreation() {         final String[] array = ArrayUtils.toArray("foo", "bar");         assertEquals(2, array.length);         assertEquals("foo", array[0]);         assertEquals("bar", array[1]);     }      /**      * Tests generic array creation with parameters of common base type.      */     @Test     public void testArrayCreationWithDifferentTypes() {         final Number[] array = ArrayUtils.<Number>toArray(Integer.valueOf(42), Double.valueOf(Math.PI));         assertEquals(2, array.length);         assertEquals(Integer.valueOf(42), array[0]);         assertEquals(Double.valueOf(Math.PI), array[1]);     }      /**      * Tests generic array creation with general return type.      */     @Test     public void testArrayCreationWithGeneralReturnType() {         final Object obj = ArrayUtils.toArray("foo", "bar");         assertTrue(obj instanceof String[]);     }      @Test     public void testClone() {         assertArrayEquals(null, ArrayUtils.clone((Object[]) null));         Object[] original1 = new Object[0];         Object[] cloned1 = ArrayUtils.clone(original1);         assertArrayEquals(original1, cloned1);         assertNotSame(original1, cloned1);          final StringBuilder builder = new StringBuilder("pick");         original1 = new Object[]{builder, "a", new String[]{"stick"}};         cloned1 = ArrayUtils.clone(original1);         assertArrayEquals(original1, cloned1);         assertNotSame(original1, cloned1);         assertSame(original1[0], cloned1[0]);         assertSame(original1[1], cloned1[1]);         assertSame(original1[2], cloned1[2]);     }      @Test     public void testCloneBoolean() {         assertNull(ArrayUtils.clone((boolean[]) null));         final boolean[] original = new boolean[]{true, false};         final boolean[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneByte() {         assertNull(ArrayUtils.clone((byte[]) null));         final byte[] original = new byte[]{1, 6};         final byte[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneChar() {         assertNull(ArrayUtils.clone((char[]) null));         final char[] original = new char[]{'a', '4'};         final char[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneDouble() {         assertNull(ArrayUtils.clone((double[]) null));         final double[] original = new double[]{2.4d, 5.7d};         final double[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneFloat() {         assertNull(ArrayUtils.clone((float[]) null));         final float[] original = new float[]{2.6f, 6.4f};         final float[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneInt() {         assertNull(ArrayUtils.clone((int[]) null));         final int[] original = new int[]{5, 8};         final int[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneLong() {         assertNull(ArrayUtils.clone((long[]) null));         final long[] original = new long[]{0L, 1L};         final long[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testCloneShort() {         assertNull(ArrayUtils.clone((short[]) null));         final short[] original = new short[]{1, 4};         final short[] cloned = ArrayUtils.clone(original);         assertArrayEquals(original, cloned);         assertNotSame(original, cloned);     }      @Test     public void testConstructor() {         assertNotNull(new ArrayUtils());         final Constructor<?>[] cons = ArrayUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ArrayUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ArrayUtils.class.getModifiers()));     }      @Test     public void testContains() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         assertFalse(ArrayUtils.contains(null, null));         assertFalse(ArrayUtils.contains(null, "1"));         assertTrue(ArrayUtils.contains(array, "0"));         assertTrue(ArrayUtils.contains(array, "1"));         assertTrue(ArrayUtils.contains(array, "2"));         assertTrue(ArrayUtils.contains(array, "3"));         assertTrue(ArrayUtils.contains(array, null));         assertFalse(ArrayUtils.contains(array, "notInArray"));     }      @Test     public void testContains_LANG_1261() {         class LANG1261ParentObject {             @Override             public boolean equals(final Object o) {                 return true;             }         }         class LANG1261ChildObject extends LANG1261ParentObject {         }          final Object[] array = new LANG1261ChildObject[]{new LANG1261ChildObject()};          assertTrue(ArrayUtils.contains(array, new LANG1261ParentObject()));     }      @Test     public void testContainsBoolean() {         boolean[] array = null;         assertFalse(ArrayUtils.contains(array, true));         array = new boolean[]{true, false, true};         assertTrue(ArrayUtils.contains(array, true));         assertTrue(ArrayUtils.contains(array, false));         array = new boolean[]{true, true};         assertTrue(ArrayUtils.contains(array, true));         assertFalse(ArrayUtils.contains(array, false));     }      @Test     public void testContainsByte() {         byte[] array = null;         assertFalse(ArrayUtils.contains(array, (byte) 1));         array = new byte[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, (byte) 0));         assertTrue(ArrayUtils.contains(array, (byte) 1));         assertTrue(ArrayUtils.contains(array, (byte) 2));         assertTrue(ArrayUtils.contains(array, (byte) 3));         assertFalse(ArrayUtils.contains(array, (byte) 99));     }      @Test     public void testContainsChar() {         char[] array = null;         assertFalse(ArrayUtils.contains(array, 'b'));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         assertTrue(ArrayUtils.contains(array, 'a'));         assertTrue(ArrayUtils.contains(array, 'b'));         assertTrue(ArrayUtils.contains(array, 'c'));         assertTrue(ArrayUtils.contains(array, 'd'));         assertFalse(ArrayUtils.contains(array, 'e'));     }      @SuppressWarnings("cast")     @Test     public void testContainsDouble() {         double[] array = null;         assertFalse(ArrayUtils.contains(array, (double) 1));         array = new double[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, (double) 0));         assertTrue(ArrayUtils.contains(array, (double) 1));         assertTrue(ArrayUtils.contains(array, (double) 2));         assertTrue(ArrayUtils.contains(array, (double) 3));         assertFalse(ArrayUtils.contains(array, (double) 99));     }      @SuppressWarnings("cast")     @Test     public void testContainsDoubleTolerance() {         double[] array = null;         assertFalse(ArrayUtils.contains(array, (double) 1, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertFalse(ArrayUtils.contains(array, 4.0, 0.33));         assertFalse(ArrayUtils.contains(array, 2.5, 0.49));         assertTrue(ArrayUtils.contains(array, 2.5, 0.50));         assertTrue(ArrayUtils.contains(array, 2.5, 0.51));     }      @SuppressWarnings("cast")     @Test     public void testContainsFloat() {         float[] array = null;         assertFalse(ArrayUtils.contains(array, (float) 1));         array = new float[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, (float) 0));         assertTrue(ArrayUtils.contains(array, (float) 1));         assertTrue(ArrayUtils.contains(array, (float) 2));         assertTrue(ArrayUtils.contains(array, (float) 3));         assertFalse(ArrayUtils.contains(array, (float) 99));     }      @Test     public void testContainsInt() {         int[] array = null;         assertFalse(ArrayUtils.contains(array, 1));         array = new int[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, 0));         assertTrue(ArrayUtils.contains(array, 1));         assertTrue(ArrayUtils.contains(array, 2));         assertTrue(ArrayUtils.contains(array, 3));         assertFalse(ArrayUtils.contains(array, 99));     }      @Test     public void testContainsLong() {         long[] array = null;         assertFalse(ArrayUtils.contains(array, 1));         array = new long[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, 0));         assertTrue(ArrayUtils.contains(array, 1));         assertTrue(ArrayUtils.contains(array, 2));         assertTrue(ArrayUtils.contains(array, 3));         assertFalse(ArrayUtils.contains(array, 99));     }      @Test     public void testContainsShort() {         short[] array = null;         assertFalse(ArrayUtils.contains(array, (short) 1));         array = new short[]{0, 1, 2, 3, 0};         assertTrue(ArrayUtils.contains(array, (short) 0));         assertTrue(ArrayUtils.contains(array, (short) 1));         assertTrue(ArrayUtils.contains(array, (short) 2));         assertTrue(ArrayUtils.contains(array, (short) 3));         assertFalse(ArrayUtils.contains(array, (short) 99));     }      @Test     public void testCreatePrimitiveArray() {         assertNull(ArrayUtils.toPrimitive((Object[]) null));         assertArrayEquals(new boolean[]{true}, ArrayUtils.toPrimitive(new Boolean[]{true}));         assertArrayEquals(new char[]{'a'}, ArrayUtils.toPrimitive(new Character[]{'a'}));         assertArrayEquals(new byte[]{1}, ArrayUtils.toPrimitive(new Byte[]{1}));         assertArrayEquals(new int[]{}, ArrayUtils.toPrimitive(new Integer[]{}));         assertArrayEquals(new short[]{2}, ArrayUtils.toPrimitive(new Short[]{2}));         assertArrayEquals(new long[]{2, 3}, ArrayUtils.toPrimitive(new Long[]{2L, 3L}));         assertArrayEquals(new float[]{3.14f}, ArrayUtils.toPrimitive(new Float[]{3.14f}), 0.1f);         assertArrayEquals(new double[]{2.718}, ArrayUtils.toPrimitive(new Double[]{2.718}), 0.1);     }      @Test     public void testCreatePrimitiveArrayViaObjectArray() {         assertNull(ArrayUtils.toPrimitive((Object) null));         assertArrayEquals(new boolean[]{true}, (boolean[]) ArrayUtils.toPrimitive((Object) new Boolean[]{true}));         assertArrayEquals(new char[]{'a'}, (char[]) ArrayUtils.toPrimitive((Object) new Character[]{'a'}));         assertArrayEquals(new byte[]{1}, (byte[]) ArrayUtils.toPrimitive((Object) new Byte[]{1}));         assertArrayEquals(new int[]{}, (int[]) ArrayUtils.toPrimitive((Object) new Integer[]{}));         assertArrayEquals(new short[]{2}, (short[]) ArrayUtils.toPrimitive((Object) new Short[]{2}));         assertArrayEquals(new long[]{2, 3}, (long[]) ArrayUtils.toPrimitive((Object) new Long[]{2L, 3L}));         assertArrayEquals(new float[]{3.14f}, (float[]) ArrayUtils.toPrimitive((Object) new Float[]{3.14f}), 0.1f);         assertArrayEquals(new double[]{2.718}, (double[]) ArrayUtils.toPrimitive((Object) new Double[]{2.718}), 0.1);     }      /**      * Tests generic empty array creation with generic type.      */     @Test     public void testEmptyArrayCreation() {         final String[] array = ArrayUtils.<String>toArray();         assertEquals(0, array.length);     }      @Test     public void testGet() {         assertNull(ArrayUtils.get(null, -1));         assertNull(ArrayUtils.get(null, 0));         assertNull(ArrayUtils.get(null, 1));         final String[] array0 = {};         assertNull(ArrayUtils.get(array0, -1));         assertNull(ArrayUtils.get(array0, 0));         assertNull(ArrayUtils.get(array0, 1));         final String[] array1 = { StringUtils.EMPTY };         assertEquals(null, ArrayUtils.get(array1, -1));         assertEquals(StringUtils.EMPTY, ArrayUtils.get(array1, 0));         assertEquals(null, ArrayUtils.get(array1, 1));     }      @Test     public void testGetDefault() {         // null default         {             assertNull(ArrayUtils.get(null, -1, null));             assertNull(ArrayUtils.get(null, 0, null));             assertNull(ArrayUtils.get(null, 1, null));             final String[] array0 = {};             assertNull(ArrayUtils.get(array0, -1, null));             assertNull(ArrayUtils.get(array0, 0, null));             assertNull(ArrayUtils.get(array0, 1, null));             final String[] array1 = { StringUtils.EMPTY };             assertEquals(null, ArrayUtils.get(array1, -1, null));             assertEquals(StringUtils.EMPTY, ArrayUtils.get(array1, 0, null));             assertEquals(null, ArrayUtils.get(array1, 1, null));         }         // non-null default         {             final String defaultValue = "defaultValue";             final String[] array1 = { StringUtils.EMPTY };             assertEquals(defaultValue, ArrayUtils.get(array1, -1, defaultValue));             assertEquals(StringUtils.EMPTY, ArrayUtils.get(array1, 0, defaultValue));             assertEquals(defaultValue, ArrayUtils.get(array1, 1, defaultValue));         }     }      @Test     public void testGetLength() {         assertEquals(0, ArrayUtils.getLength(null));          final Object[] emptyObjectArray = new Object[0];         final Object[] notEmptyObjectArray = new Object[]{"aValue"};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyObjectArray));         assertEquals(1, ArrayUtils.getLength(notEmptyObjectArray));          final int[] emptyIntArray = new int[]{};         final int[] notEmptyIntArray = new int[]{1};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyIntArray));         assertEquals(1, ArrayUtils.getLength(notEmptyIntArray));          final short[] emptyShortArray = new short[]{};         final short[] notEmptyShortArray = new short[]{1};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyShortArray));         assertEquals(1, ArrayUtils.getLength(notEmptyShortArray));          final char[] emptyCharArray = new char[]{};         final char[] notEmptyCharArray = new char[]{1};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyCharArray));         assertEquals(1, ArrayUtils.getLength(notEmptyCharArray));          final byte[] emptyByteArray = new byte[]{};         final byte[] notEmptyByteArray = new byte[]{1};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyByteArray));         assertEquals(1, ArrayUtils.getLength(notEmptyByteArray));          final double[] emptyDoubleArray = new double[]{};         final double[] notEmptyDoubleArray = new double[]{1.0};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyDoubleArray));         assertEquals(1, ArrayUtils.getLength(notEmptyDoubleArray));          final float[] emptyFloatArray = new float[]{};         final float[] notEmptyFloatArray = new float[]{1.0F};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyFloatArray));         assertEquals(1, ArrayUtils.getLength(notEmptyFloatArray));          final boolean[] emptyBooleanArray = new boolean[]{};         final boolean[] notEmptyBooleanArray = new boolean[]{true};         assertEquals(0, ArrayUtils.getLength(null));         assertEquals(0, ArrayUtils.getLength(emptyBooleanArray));         assertEquals(1, ArrayUtils.getLength(notEmptyBooleanArray));          assertThrows(IllegalArgumentException.class, () -> ArrayUtils.getLength("notAnArray"));     }      @Test     public void testHashCode() {         final long[][] array1 = new long[][]{{2, 5}, {4, 5}};         final long[][] array2 = new long[][]{{2, 5}, {4, 6}};         assertEquals(ArrayUtils.hashCode(array1), ArrayUtils.hashCode(array1));         assertNotEquals(ArrayUtils.hashCode(array1), ArrayUtils.hashCode(array2));          final Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};         final Object[] array4 = new Object[]{"AB"};         assertEquals(ArrayUtils.hashCode(array3), ArrayUtils.hashCode(array3));         assertEquals(ArrayUtils.hashCode(array3), ArrayUtils.hashCode(array4));          final Object[] arrayA = new Object[]{new boolean[]{true, false}, new int[]{6, 7}};         final Object[] arrayB = new Object[]{new boolean[]{true, false}, new int[]{6, 7}};         assertEquals(ArrayUtils.hashCode(arrayB), ArrayUtils.hashCode(arrayA));     }      @Test     public void testIndexesOf() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf((Object[]) null, null));         assertEquals(emptySet, ArrayUtils.indexesOf(new Object[0], "0"));         testSet.set(5);         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, "0"));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, "2"));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, "3"));         testSet.clear();         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, null));         assertEquals(emptySet, ArrayUtils.indexesOf(array, "notInArray"));     }      @Test     public void testIndexesOfBoolean() {         boolean[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, true));         array = new boolean[0];         assertEquals(emptySet, ArrayUtils.indexesOf(array, true));         array = new boolean[]{true, false, true};         testSet.set(0);         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, true));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, false));         array = new boolean[]{true, true};         assertEquals(emptySet, ArrayUtils.indexesOf(array, false));     }      @Test     public void testIndexesOfBooleanWithStartIndex() {         boolean[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, true, 0));         array = new boolean[0];         assertEquals(emptySet, ArrayUtils.indexesOf(array, true, 0));         array = new boolean[]{true, false, true};         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, true, 1));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, true, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, false, 1));         array = new boolean[]{true, true};         assertEquals(emptySet, ArrayUtils.indexesOf(array, false, 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, false, -1));     }      @Test     public void testIndexesOfByte() {         byte[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (byte) 0));         array = new byte[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 3));         assertEquals(emptySet, ArrayUtils.indexesOf(array, (byte) 99));     }      @Test     public void testIndexesOfByteWithStartIndex() {         byte[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (byte) 0, 2));         array = new byte[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 0, 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 0, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 1, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 3, 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, (byte) 3, -1));         assertEquals(emptySet, ArrayUtils.indexesOf(array, (byte) 99, 0));     }      @Test     public void testIndexesOfChar() {         char[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 'a'));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'a'));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'b'));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'c'));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'd'));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 'e'));     }      @Test     public void testIndexesOfCharWithStartIndex() {         char[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 'a', 0));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'a', 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'a', 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, 'a', -1));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'b', 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'c', 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 'd', 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 'd', 5));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 'e', 0));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfDouble() {         double[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0));         array = new double[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfDoubleTolerance() {         double[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (double) 0, (double) 0));         array = new double[0];         assertEquals(emptySet, ArrayUtils.indexesOf(array, (double) 0, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (double) 0, 0.3));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 4.15, 2.0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1.00001324, 0.0001));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfDoubleWithStartIndex() {         double[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0, 2));         array = new double[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, -1));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99, 0));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfDoubleWithStartIndexTolerance() {         double[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (double) 0, 0, (double) 0));         array = new double[0];         assertEquals(emptySet, ArrayUtils.indexesOf(array, (double) 0, 0, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (double) 0, 1, 0.3));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, (double) 0, 0, 0.3));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 0, 0.35));         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 2, 0.35));         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, -1, 0.35));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 2, 3, 0.35));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 4.15, 0, 2.0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1.00001324, 0, 0.0001));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfFloat() {         float[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0));         array = new float[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99));     }      @SuppressWarnings("cast")     @Test     public void testIndexesOfFloatWithStartIndex() {         float[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0, 2));         array = new float[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, -1));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99, 0));     }      @Test     public void testIndexesOfIntWithStartIndex() {         int[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0, 2));         array = new int[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, -1));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99, 0));     }      @Test     public void testIndexesOfLong() {         final long[] array = new long[]{0, 1, 2, 3};         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf((long[]) null, 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 4));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3));     }      @Test     public void testIndexesOfLongWithStartIndex() {         final long[] array = new long[]{0, 1, 2, 3, 2, 1, 0, 1};         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf((long[]) null, 0, 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 4, 0));         testSet.set(6);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 1));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0, 0));         testSet.clear();         testSet.set(1);         testSet.set(5);         testSet.set(7);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1, 0));         testSet.clear();         testSet.set(2);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3, 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 3, 8));     }      @Test     public void testIndexesOfShort() {         short[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (short) 0));         array = new short[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 3));         assertEquals(emptySet, ArrayUtils.indexesOf(array, (short) 99));     }      @Test     public void testIndexesOfShortWithStartIndex() {         short[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, (short) 0, 2));         array = new short[]{0, 1, 2, 3, 0};         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 0, 2));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 0, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 1, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 2, 0));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 3, 0));         assertEquals(testSet, ArrayUtils.indexesOf(array, (short) 3, -1));         assertEquals(emptySet, ArrayUtils.indexesOf(array, (short) 99, 0));     }      @Test     public void testIndexesOfWithStartIndex() {         final Object[] array = new Object[]{"0", "1", "2", "3", "2", "3", "1", null, "0"};         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(null, null, 2));         assertEquals(emptySet, ArrayUtils.indexesOf(new Object[0], "0", 0));         assertEquals(emptySet, ArrayUtils.indexesOf(null, "0", 2));         testSet.set(8);         assertEquals(testSet, ArrayUtils.indexesOf(array, "0", 8));         testSet.set(0);         assertEquals(testSet, ArrayUtils.indexesOf(array, "0", 0));         testSet.clear();         testSet.set(6);         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, "1", 0));         assertEquals(emptySet, ArrayUtils.indexesOf(array, "1", 9));         testSet.clear();         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, "2", 3));         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, "2", 0));         testSet.clear();         testSet.set(3);         testSet.set(5);         assertEquals(testSet, ArrayUtils.indexesOf(array, "3", 0));         testSet.clear();         testSet.set(7);         assertEquals(testSet, ArrayUtils.indexesOf(array, null, 0));      }      @Test     public void testIndexOf() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         assertEquals(-1, ArrayUtils.indexOf(null, null));         assertEquals(-1, ArrayUtils.indexOf(null, "0"));         assertEquals(-1, ArrayUtils.indexOf(new Object[0], "0"));         assertEquals(0, ArrayUtils.indexOf(array, "0"));         assertEquals(1, ArrayUtils.indexOf(array, "1"));         assertEquals(2, ArrayUtils.indexOf(array, "2"));         assertEquals(3, ArrayUtils.indexOf(array, "3"));         assertEquals(4, ArrayUtils.indexOf(array, null));         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray"));     }      @Test     public void testIndexOfBoolean() {         boolean[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, true));         array = new boolean[0];         assertEquals(-1, ArrayUtils.indexOf(array, true));         array = new boolean[]{true, false, true};         assertEquals(0, ArrayUtils.indexOf(array, true));         assertEquals(1, ArrayUtils.indexOf(array, false));         array = new boolean[]{true, true};         assertEquals(-1, ArrayUtils.indexOf(array, false));     }      @Test     public void testIndexOfBooleanWithStartIndex() {         boolean[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, true, 2));         array = new boolean[0];         assertEquals(-1, ArrayUtils.indexOf(array, true, 2));         array = new boolean[]{true, false, true};         assertEquals(2, ArrayUtils.indexOf(array, true, 1));         assertEquals(-1, ArrayUtils.indexOf(array, false, 2));         assertEquals(1, ArrayUtils.indexOf(array, false, 0));         assertEquals(1, ArrayUtils.indexOf(array, false, -1));         array = new boolean[]{true, true};         assertEquals(-1, ArrayUtils.indexOf(array, false, 0));         assertEquals(-1, ArrayUtils.indexOf(array, false, -1));     }      @Test     public void testIndexOfByte() {         byte[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0));         array = new byte[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, (byte) 0));         assertEquals(1, ArrayUtils.indexOf(array, (byte) 1));         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2));         assertEquals(3, ArrayUtils.indexOf(array, (byte) 3));         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99));     }      @Test     public void testIndexOfByteWithStartIndex() {         byte[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2));         array = new byte[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, 2));         assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 6));     }      @Test     public void testIndexOfChar() {         char[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 'a'));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         assertEquals(0, ArrayUtils.indexOf(array, 'a'));         assertEquals(1, ArrayUtils.indexOf(array, 'b'));         assertEquals(2, ArrayUtils.indexOf(array, 'c'));         assertEquals(3, ArrayUtils.indexOf(array, 'd'));         assertEquals(-1, ArrayUtils.indexOf(array, 'e'));     }      @Test     public void testIndexOfCharWithStartIndex() {         char[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         assertEquals(4, ArrayUtils.indexOf(array, 'a', 2));         assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2));         assertEquals(2, ArrayUtils.indexOf(array, 'c', 2));         assertEquals(3, ArrayUtils.indexOf(array, 'd', 2));         assertEquals(3, ArrayUtils.indexOf(array, 'd', -1));         assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0));         assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfDouble() {         double[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, (double) 0));         assertEquals(1, ArrayUtils.indexOf(array, (double) 1));         assertEquals(2, ArrayUtils.indexOf(array, (double) 2));         assertEquals(3, ArrayUtils.indexOf(array, (double) 3));         assertEquals(3, ArrayUtils.indexOf(array, (double) 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, (double) 99));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfDoubleTolerance() {         double[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, (double) 0, 0.3));         assertEquals(2, ArrayUtils.indexOf(array, 2.2, 0.35));         assertEquals(3, ArrayUtils.indexOf(array, 4.15, 2.0));         assertEquals(1, ArrayUtils.indexOf(array, 1.00001324, 0.0001));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfDoubleWithStartIndex() {         double[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));         array = new double[0];         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, (double) 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, (double) 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, (double) 3, 2));         assertEquals(-1, ArrayUtils.indexOf(array, (double) 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 6));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfDoubleWithStartIndexTolerance() {         double[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 99, 0.3));         assertEquals(0, ArrayUtils.indexOf(array, (double) 0, 0, 0.3));         assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 3, 0.3));         assertEquals(2, ArrayUtils.indexOf(array, 2.2, 0, 0.35));         assertEquals(3, ArrayUtils.indexOf(array, 4.15, 0, 2.0));         assertEquals(1, ArrayUtils.indexOf(array, 1.00001324, 0, 0.0001));         assertEquals(3, ArrayUtils.indexOf(array, 4.15, -1, 2.0));         assertEquals(1, ArrayUtils.indexOf(array, 1.00001324, -300, 0.0001));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfFloat() {         float[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));         array = new float[0];         assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));         array = new float[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, (float) 0));         assertEquals(1, ArrayUtils.indexOf(array, (float) 1));         assertEquals(2, ArrayUtils.indexOf(array, (float) 2));         assertEquals(3, ArrayUtils.indexOf(array, (float) 3));         assertEquals(-1, ArrayUtils.indexOf(array, (float) 99));     }      @SuppressWarnings("cast")     @Test     public void testIndexOfFloatWithStartIndex() {         float[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));         array = new float[0];         assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));         array = new float[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, (float) 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, (float) 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, (float) 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, (float) 3, 2));         assertEquals(3, ArrayUtils.indexOf(array, (float) 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, (float) 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 6));     }      @Test     public void testIndexOfInt() {         int[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 0));         array = new int[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, 0));         assertEquals(1, ArrayUtils.indexOf(array, 1));         assertEquals(2, ArrayUtils.indexOf(array, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3));         assertEquals(-1, ArrayUtils.indexOf(array, 99));     }      @Test     public void testIndexOfIntWithStartIndex() {         int[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));         array = new int[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));     }      @Test     public void testIndexOfLong() {         long[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 0));         array = new long[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, 0));         assertEquals(1, ArrayUtils.indexOf(array, 1));         assertEquals(2, ArrayUtils.indexOf(array, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3));         assertEquals(-1, ArrayUtils.indexOf(array, 99));     }      @Test     public void testIndexOfLongWithStartIndex() {         long[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));         array = new long[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3, 2));         assertEquals(3, ArrayUtils.indexOf(array, 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));     }      @Test     public void testIndexOfShort() {         short[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (short) 0));         array = new short[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.indexOf(array, (short) 0));         assertEquals(1, ArrayUtils.indexOf(array, (short) 1));         assertEquals(2, ArrayUtils.indexOf(array, (short) 2));         assertEquals(3, ArrayUtils.indexOf(array, (short) 3));         assertEquals(-1, ArrayUtils.indexOf(array, (short) 99));     }      @Test     public void testIndexOfShortWithStartIndex() {         short[] array = null;         assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 2));         array = new short[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.indexOf(array, (short) 0, 2));         assertEquals(-1, ArrayUtils.indexOf(array, (short) 1, 2));         assertEquals(2, ArrayUtils.indexOf(array, (short) 2, 2));         assertEquals(3, ArrayUtils.indexOf(array, (short) 3, 2));         assertEquals(3, ArrayUtils.indexOf(array, (short) 3, -1));         assertEquals(-1, ArrayUtils.indexOf(array, (short) 99, 0));         assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 6));     }      @Test     public void testIndexOfWithStartIndex() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         assertEquals(-1, ArrayUtils.indexOf(null, null, 2));         assertEquals(-1, ArrayUtils.indexOf(new Object[0], "0", 0));         assertEquals(-1, ArrayUtils.indexOf(null, "0", 2));         assertEquals(5, ArrayUtils.indexOf(array, "0", 2));         assertEquals(-1, ArrayUtils.indexOf(array, "1", 2));         assertEquals(2, ArrayUtils.indexOf(array, "2", 2));         assertEquals(3, ArrayUtils.indexOf(array, "3", 2));         assertEquals(4, ArrayUtils.indexOf(array, null, 2));         assertEquals(-1, ArrayUtils.indexOf(array, "notInArray", 2));          assertEquals(4, ArrayUtils.indexOf(array, null, -1));         assertEquals(-1, ArrayUtils.indexOf(array, null, 8));         assertEquals(-1, ArrayUtils.indexOf(array, "0", 8));     }      /**      * Tests generic array creation with generic type.      */     @Test     public void testIndirectArrayCreation() {         final String[] array = toArrayPropagatingType("foo", "bar");         assertEquals(2, array.length);         assertEquals("foo", array[0]);         assertEquals("bar", array[1]);     }      /**      * Tests indirect generic empty array creation with generic type.      */     @Test     public void testIndirectEmptyArrayCreation() {         final String[] array = ArrayUtilsTest.<String>toArrayPropagatingType();         assertEquals(0, array.length);     }      @Test     public void testIsArrayIndexValid() {         assertFalse(ArrayUtils.isArrayIndexValid(null, 0));         final String[] array = new String[1];          //too big         assertFalse(ArrayUtils.isArrayIndexValid(array, 1));          //negative index         assertFalse(ArrayUtils.isArrayIndexValid(array, -1));          //good to go         assertTrue(ArrayUtils.isArrayIndexValid(array, 0));     }      /**      * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}.      */     @Test     public void testIsEmptyObject() {         final Object[] emptyArray = new Object[]{};         final Object[] notEmptyArray = new Object[]{new String("Value")};         assertTrue(ArrayUtils.isEmpty((Object[]) null));         assertTrue(ArrayUtils.isEmpty(emptyArray));         assertFalse(ArrayUtils.isEmpty(notEmptyArray));     }      /**      * Tests for {@link ArrayUtils#isEmpty(long[])},      * {@link ArrayUtils#isEmpty(int[])},      * {@link ArrayUtils#isEmpty(short[])},      * {@link ArrayUtils#isEmpty(char[])},      * {@link ArrayUtils#isEmpty(byte[])},      * {@link ArrayUtils#isEmpty(double[])},      * {@link ArrayUtils#isEmpty(float[])} and      * {@link ArrayUtils#isEmpty(boolean[])}.      */     @Test     public void testIsEmptyPrimitives() {         final long[] emptyLongArray = new long[]{};         final long[] notEmptyLongArray = new long[]{1L};         assertTrue(ArrayUtils.isEmpty((long[]) null));         assertTrue(ArrayUtils.isEmpty(emptyLongArray));         assertFalse(ArrayUtils.isEmpty(notEmptyLongArray));          final int[] emptyIntArray = new int[]{};         final int[] notEmptyIntArray = new int[]{1};         assertTrue(ArrayUtils.isEmpty((int[]) null));         assertTrue(ArrayUtils.isEmpty(emptyIntArray));         assertFalse(ArrayUtils.isEmpty(notEmptyIntArray));          final short[] emptyShortArray = new short[]{};         final short[] notEmptyShortArray = new short[]{1};         assertTrue(ArrayUtils.isEmpty((short[]) null));         assertTrue(ArrayUtils.isEmpty(emptyShortArray));         assertFalse(ArrayUtils.isEmpty(notEmptyShortArray));          final char[] emptyCharArray = new char[]{};         final char[] notEmptyCharArray = new char[]{1};         assertTrue(ArrayUtils.isEmpty((char[]) null));         assertTrue(ArrayUtils.isEmpty(emptyCharArray));         assertFalse(ArrayUtils.isEmpty(notEmptyCharArray));          final byte[] emptyByteArray = new byte[]{};         final byte[] notEmptyByteArray = new byte[]{1};         assertTrue(ArrayUtils.isEmpty((byte[]) null));         assertTrue(ArrayUtils.isEmpty(emptyByteArray));         assertFalse(ArrayUtils.isEmpty(notEmptyByteArray));          final double[] emptyDoubleArray = new double[]{};         final double[] notEmptyDoubleArray = new double[]{1.0};         assertTrue(ArrayUtils.isEmpty((double[]) null));         assertTrue(ArrayUtils.isEmpty(emptyDoubleArray));         assertFalse(ArrayUtils.isEmpty(notEmptyDoubleArray));          final float[] emptyFloatArray = new float[]{};         final float[] notEmptyFloatArray = new float[]{1.0F};         assertTrue(ArrayUtils.isEmpty((float[]) null));         assertTrue(ArrayUtils.isEmpty(emptyFloatArray));         assertFalse(ArrayUtils.isEmpty(notEmptyFloatArray));          final boolean[] emptyBooleanArray = new boolean[]{};         final boolean[] notEmptyBooleanArray = new boolean[]{true};         assertTrue(ArrayUtils.isEmpty((boolean[]) null));         assertTrue(ArrayUtils.isEmpty(emptyBooleanArray));         assertFalse(ArrayUtils.isEmpty(notEmptyBooleanArray));     }      @Test     public void testIsEquals() {         final long[][] larray1 = new long[][]{{2, 5}, {4, 5}};         final long[][] larray2 = new long[][]{{2, 5}, {4, 6}};         final long[] larray3 = new long[]{2, 5};         this.assertIsEquals(larray1, larray2, larray3);          final int[][] iarray1 = new int[][]{{2, 5}, {4, 5}};         final int[][] iarray2 = new int[][]{{2, 5}, {4, 6}};         final int[] iarray3 = new int[]{2, 5};         this.assertIsEquals(iarray1, iarray2, iarray3);          final short[][] sarray1 = new short[][]{{2, 5}, {4, 5}};         final short[][] sarray2 = new short[][]{{2, 5}, {4, 6}};         final short[] sarray3 = new short[]{2, 5};         this.assertIsEquals(sarray1, sarray2, sarray3);          final float[][] farray1 = new float[][]{{2, 5}, {4, 5}};         final float[][] farray2 = new float[][]{{2, 5}, {4, 6}};         final float[] farray3 = new float[]{2, 5};         this.assertIsEquals(farray1, farray2, farray3);          final double[][] darray1 = new double[][]{{2, 5}, {4, 5}};         final double[][] darray2 = new double[][]{{2, 5}, {4, 6}};         final double[] darray3 = new double[]{2, 5};         this.assertIsEquals(darray1, darray2, darray3);          final byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}};         final byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}};         final byte[] byteArray3 = new byte[]{2, 5};         this.assertIsEquals(byteArray1, byteArray2, byteArray3);          final char[][] charArray1 = new char[][]{{2, 5}, {4, 5}};         final char[][] charArray2 = new char[][]{{2, 5}, {4, 6}};         final char[] charArray3 = new char[]{2, 5};         this.assertIsEquals(charArray1, charArray2, charArray3);          final boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}};         final boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}};         final boolean[] barray3 = new boolean[]{false, true};         this.assertIsEquals(barray1, barray2, barray3);          final Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};         final Object[] array4 = new Object[]{"AB"};         assertTrue(ArrayUtils.isEquals(array3, array3));         assertTrue(ArrayUtils.isEquals(array3, array4));          assertTrue(ArrayUtils.isEquals(null, null));         assertFalse(ArrayUtils.isEquals(null, array4));     }      /**      * Test for {@link ArrayUtils#isNotEmpty(java.lang.Object[])}.      */     @Test     public void testIsNotEmptyObject() {         final Object[] emptyArray = new Object[]{};         final Object[] notEmptyArray = new Object[]{new String("Value")};         assertFalse(ArrayUtils.isNotEmpty((Object[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyArray));     }      /**      * Tests for {@link ArrayUtils#isNotEmpty(long[])},      * {@link ArrayUtils#isNotEmpty(int[])},      * {@link ArrayUtils#isNotEmpty(short[])},      * {@link ArrayUtils#isNotEmpty(char[])},      * {@link ArrayUtils#isNotEmpty(byte[])},      * {@link ArrayUtils#isNotEmpty(double[])},      * {@link ArrayUtils#isNotEmpty(float[])} and      * {@link ArrayUtils#isNotEmpty(boolean[])}.      */     @Test     public void testIsNotEmptyPrimitives() {         final long[] emptyLongArray = new long[]{};         final long[] notEmptyLongArray = new long[]{1L};         assertFalse(ArrayUtils.isNotEmpty((long[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyLongArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyLongArray));          final int[] emptyIntArray = new int[]{};         final int[] notEmptyIntArray = new int[]{1};         assertFalse(ArrayUtils.isNotEmpty((int[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyIntArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyIntArray));          final short[] emptyShortArray = new short[]{};         final short[] notEmptyShortArray = new short[]{1};         assertFalse(ArrayUtils.isNotEmpty((short[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyShortArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyShortArray));          final char[] emptyCharArray = new char[]{};         final char[] notEmptyCharArray = new char[]{1};         assertFalse(ArrayUtils.isNotEmpty((char[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyCharArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyCharArray));          final byte[] emptyByteArray = new byte[]{};         final byte[] notEmptyByteArray = new byte[]{1};         assertFalse(ArrayUtils.isNotEmpty((byte[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyByteArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyByteArray));          final double[] emptyDoubleArray = new double[]{};         final double[] notEmptyDoubleArray = new double[]{1.0};         assertFalse(ArrayUtils.isNotEmpty((double[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyDoubleArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyDoubleArray));          final float[] emptyFloatArray = new float[]{};         final float[] notEmptyFloatArray = new float[]{1.0F};         assertFalse(ArrayUtils.isNotEmpty((float[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyFloatArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyFloatArray));          final boolean[] emptyBooleanArray = new boolean[]{};         final boolean[] notEmptyBooleanArray = new boolean[]{true};         assertFalse(ArrayUtils.isNotEmpty((boolean[]) null));         assertFalse(ArrayUtils.isNotEmpty(emptyBooleanArray));         assertTrue(ArrayUtils.isNotEmpty(notEmptyBooleanArray));     }      @Test     public void testIsSorted() {         Integer[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new Integer[]{1};         assertTrue(ArrayUtils.isSorted(array));          array = new Integer[]{1, 2, 3};         assertTrue(ArrayUtils.isSorted(array));          array = new Integer[]{1, 3, 2};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedBool() {         boolean[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new boolean[]{true};         assertTrue(ArrayUtils.isSorted(array));          array = new boolean[]{false, true};         assertTrue(ArrayUtils.isSorted(array));          array = new boolean[]{true, false};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedByte() {         byte[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new byte[]{0x10};         assertTrue(ArrayUtils.isSorted(array));          array = new byte[]{0x10, 0x20, 0x30};         assertTrue(ArrayUtils.isSorted(array));          array = new byte[]{0x10, 0x30, 0x20};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedChar() {         char[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new char[]{'a'};         assertTrue(ArrayUtils.isSorted(array));          array = new char[]{'a', 'b', 'c'};         assertTrue(ArrayUtils.isSorted(array));          array = new char[]{'a', 'c', 'b'};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedComparator() {         final Comparator<Integer> c = Comparator.reverseOrder();          Integer[] array = null;         assertTrue(ArrayUtils.isSorted(array, c));          array = new Integer[]{1};         assertTrue(ArrayUtils.isSorted(array, c));          array = new Integer[]{3, 2, 1};         assertTrue(ArrayUtils.isSorted(array, c));          array = new Integer[]{1, 3, 2};         assertFalse(ArrayUtils.isSorted(array, c));     }      @Test     public void testIsSortedDouble() {         double[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new double[]{0.0};         assertTrue(ArrayUtils.isSorted(array));          array = new double[]{-1.0, 0.0, 0.1, 0.2};         assertTrue(ArrayUtils.isSorted(array));          array = new double[]{-1.0, 0.2, 0.1, 0.0};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedFloat() {         float[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new float[]{0f};         assertTrue(ArrayUtils.isSorted(array));          array = new float[]{-1f, 0f, 0.1f, 0.2f};         assertTrue(ArrayUtils.isSorted(array));          array = new float[]{-1f, 0.2f, 0.1f, 0f};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedInt() {         int[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new int[]{1};         assertTrue(ArrayUtils.isSorted(array));          array = new int[]{1, 2, 3};         assertTrue(ArrayUtils.isSorted(array));          array = new int[]{1, 3, 2};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedLong() {         long[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new long[]{0L};         assertTrue(ArrayUtils.isSorted(array));          array = new long[]{-1L, 0L, 1L};         assertTrue(ArrayUtils.isSorted(array));          array = new long[]{-1L, 1L, 0L};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testIsSortedNullComparator() {         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.isSorted(null, null));     }      @Test     public void testIsSortedShort() {         short[] array = null;         assertTrue(ArrayUtils.isSorted(array));          array = new short[]{0};         assertTrue(ArrayUtils.isSorted(array));          array = new short[]{-1, 0, 1};         assertTrue(ArrayUtils.isSorted(array));          array = new short[]{-1, 1, 0};         assertFalse(ArrayUtils.isSorted(array));     }      @Test     public void testLastIndexOf() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         assertEquals(-1, ArrayUtils.lastIndexOf(null, null));         assertEquals(-1, ArrayUtils.lastIndexOf(null, "0"));         assertEquals(5, ArrayUtils.lastIndexOf(array, "0"));         assertEquals(1, ArrayUtils.lastIndexOf(array, "1"));         assertEquals(2, ArrayUtils.lastIndexOf(array, "2"));         assertEquals(3, ArrayUtils.lastIndexOf(array, "3"));         assertEquals(4, ArrayUtils.lastIndexOf(array, null));         assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray"));     }      @Test     public void testLastIndexOfBoolean() {         boolean[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, true));         array = new boolean[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, true));         array = new boolean[]{true, false, true};         assertEquals(2, ArrayUtils.lastIndexOf(array, true));         assertEquals(1, ArrayUtils.lastIndexOf(array, false));         array = new boolean[]{true, true};         assertEquals(-1, ArrayUtils.lastIndexOf(array, false));     }      @Test     public void testLastIndexOfBooleanWithStartIndex() {         boolean[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));         array = new boolean[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));         array = new boolean[]{true, false, true};         assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2));         assertEquals(0, ArrayUtils.lastIndexOf(array, true, 1));         assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));         array = new boolean[]{true, true};         assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));     }      @Test     public void testLastIndexOfByte() {         byte[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0));         array = new byte[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, (byte) 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));     }      @Test     public void testLastIndexOfByteWithStartIndex() {         byte[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0, 2));         array = new byte[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, (byte) 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));         assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0, 88));     }      @Test     public void testLastIndexOfChar() {         char[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a'));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         assertEquals(4, ArrayUtils.lastIndexOf(array, 'a'));         assertEquals(1, ArrayUtils.lastIndexOf(array, 'b'));         assertEquals(2, ArrayUtils.lastIndexOf(array, 'c'));         assertEquals(3, ArrayUtils.lastIndexOf(array, 'd'));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));     }      @Test     public void testLastIndexOfCharWithStartIndex() {         char[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2));         array = new char[]{'a', 'b', 'c', 'd', 'a'};         assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));         assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfDouble() {         double[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfDoubleTolerance() {         double[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 0.3));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2.2, 0.35));         assertEquals(3, ArrayUtils.lastIndexOf(array, 4.15, 2.0));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1.00001324, 0.0001));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfDoubleWithStartIndex() {         double[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));         array = new double[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));         assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 88));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfDoubleWithStartIndexTolerance() {         double[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));         array = new double[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));         array = new double[]{(double) 3};         assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 1, 0, (double) 0));         array = new double[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 99, 0.3));         assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 3, 0.3));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2.2, 3, 0.35));         assertEquals(3, ArrayUtils.lastIndexOf(array, 4.15, array.length, 2.0));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1.00001324, array.length, 0.0001));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 4.15, -200, 2.0));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfFloat() {         float[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));         array = new float[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));         array = new float[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, (float) 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));     }      @SuppressWarnings("cast")     @Test     public void testLastIndexOfFloatWithStartIndex() {         float[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));         array = new float[0];         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));         array = new float[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));         assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88));     }      @Test     public void testLastIndexOfInt() {         int[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));         array = new int[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));     }      @Test     public void testLastIndexOfIntWithStartIndex() {         int[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));         array = new int[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));     }      @Test     public void testLastIndexOfLong() {         long[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));         array = new long[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));     }      @Test     public void testLastIndexOfLongWithStartIndex() {         long[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));         array = new long[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4));         assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));     }      @Test     public void testLastIndexOfShort() {         short[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0));         array = new short[]{0, 1, 2, 3, 0};         assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0));         assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1));         assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2));         assertEquals(3, ArrayUtils.lastIndexOf(array, (short) 3));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));     }      @Test     public void testLastIndexOfShortWithStartIndex() {         short[] array = null;         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2));         array = new short[]{0, 1, 2, 3, 0};         assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1));         assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));         assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88));     }      @Test     public void testLastIndexOfWithStartIndex() {         final Object[] array = new Object[]{"0", "1", "2", "3", null, "0"};         assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(null, "0", 2));         assertEquals(0, ArrayUtils.lastIndexOf(array, "0", 2));         assertEquals(1, ArrayUtils.lastIndexOf(array, "1", 2));         assertEquals(2, ArrayUtils.lastIndexOf(array, "2", 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", -1));         assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5));         assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2));         assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray", 5));          assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1));         assertEquals(5, ArrayUtils.lastIndexOf(array, "0", 88));     }      @Test     public void testNullToEmptyBoolean() {         final boolean[] original = new boolean[]{true, false};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyBooleanEmptyArray() {         final boolean[] empty = new boolean[]{};         final boolean[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyBooleanNull() {         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.nullToEmpty((boolean[]) null));     }      @Test     public void testNullToEmptyBooleanObject() {         final Boolean[] original = new Boolean[]{Boolean.TRUE, Boolean.FALSE};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyBooleanObjectEmptyArray() {         final Boolean[] empty = new Boolean[]{};         final Boolean[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyBooleanObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Boolean[]) null));     }      @Test     public void testNullToEmptyByte() {         final byte[] original = new byte[]{0x0F, 0x0E};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyByteEmptyArray() {         final byte[] empty = new byte[]{};         final byte[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyByteNull() {         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.nullToEmpty((byte[]) null));     }      @Test     public void testNullToEmptyByteObject() {         final Byte[] original = new Byte[]{0x0F, 0x0E};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyByteObjectEmptyArray() {         final Byte[] empty = new Byte[]{};         final Byte[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyByteObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null));     }      @Test     public void testNullToEmptyChar() {         final char[] original = new char[]{'a', 'b'};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyCharEmptyArray() {         final char[] empty = new char[]{};         final char[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyCharNull() {         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.nullToEmpty((char[]) null));     }      @Test     public void testNullToEmptyCharObject() {         final Character[] original = new Character[]{'a', 'b'};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyCharObjectEmptyArray() {         final Character[] empty = new Character[]{};         final Character[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNUllToEmptyCharObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Character[]) null));     }      @Test     public void testNullToEmptyClass() {         final Class<?>[] original = {Object.class, String.class};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyClassEmptyArray() {         final Class<?>[] empty = {};         final Class<?>[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyClassNull() {         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.nullToEmpty((Class<?>[]) null));     }      @Test     public void testNullToEmptyDouble() {         final double[] original = new double[]{1L, 2L};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyDoubleEmptyArray() {         final double[] empty = new double[]{};         final double[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyDoubleNull() {         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.nullToEmpty((double[]) null));     }      @Test     public void testNullToEmptyDoubleObject() {         final Double[] original = new Double[]{1D, 2D};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyDoubleObjectEmptyArray() {         final Double[] empty = new Double[]{};         final Double[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyDoubleObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Double[]) null));     }      @Test     public void testNullToEmptyFloat() {         final float[] original = new float[]{2.6f, 3.8f};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyFloatEmptyArray() {         final float[] empty = new float[]{};         final float[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyFloatNull() {         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.nullToEmpty((float[]) null));     }      @Test     public void testNullToEmptyFloatObject() {         final Float[] original = new Float[]{2.6f, 3.8f};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyFloatObjectEmptyArray() {         final Float[] empty = new Float[]{};         final Float[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyFloatObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null));     }      @Test     public void testNullToEmptyGeneric() {         final TestClass[] input = new TestClass[]{new TestClass(), new TestClass()};         final TestClass[] output = ArrayUtils.nullToEmpty(input, TestClass[].class);          assertSame(input, output);     }      @Test     public void testNullToEmptyGenericEmpty() {         final TestClass[] input = new TestClass[]{};         final TestClass[] output = ArrayUtils.nullToEmpty(input, TestClass[].class);          assertSame(input, output);     }      @Test     public void testNullToEmptyGenericNull() {         final TestClass[] output = ArrayUtils.nullToEmpty(null, TestClass[].class);          assertNotNull(output);         assertEquals(0, output.length);     }      @Test     public void testNullToEmptyGenericNullType() {         final TestClass[] input = new TestClass[]{};         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.nullToEmpty(input, null));     }      @Test     public void testNullToEmptyInt() {         final int[] original = new int[]{1, 2};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyIntEmptyArray() {         final int[] empty = new int[]{};         final int[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyIntNull() {         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.nullToEmpty((int[]) null));     }      @Test     public void testNullToEmptyIntObject() {         final Integer[] original = new Integer[]{1, 2};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyIntObjectEmptyArray() {         final Integer[] empty = new Integer[]{};         final Integer[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyIntObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Integer[]) null));     }      @Test     public void testNullToEmptyLong() {         final long[] original = new long[]{1L, 2L};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyLongEmptyArray() {         final long[] empty = new long[]{};         final long[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyLongNull() {         assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.nullToEmpty((long[]) null));     }      @Test     public void testNullToEmptyLongObject() {         @SuppressWarnings("boxing") final Long[] original = new Long[]{1L, 2L};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyLongObjectEmptyArray() {         final Long[] empty = new Long[]{};         final Long[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyLongObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null));     }      @Test     public void testNullToEmptyObject() {         final Object[] original = new Object[]{Boolean.TRUE, Boolean.FALSE};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyObjectEmptyArray() {         final Object[] empty = new Object[]{};         final Object[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Object[]) null));     }      @Test     public void testNullToEmptyShort() {         final short[] original = new short[]{1, 2};         assertEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyShortEmptyArray() {         final short[] empty = new short[]{};         final short[] result = ArrayUtils.nullToEmpty(empty);         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyShortNull() {         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.nullToEmpty((short[]) null));     }      @Test     public void testNullToEmptyShortObject() {         @SuppressWarnings("boxing") final Short[] original = new Short[]{1, 2};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyShortObjectEmptyArray() {         final Short[] empty = new Short[]{};         final Short[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyShortObjectNull() {         assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null));     }      @Test     public void testNullToEmptyString() {         final String[] original = new String[]{"abc", "def"};         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));     }      @Test     public void testNullToEmptyStringEmptyArray() {         final String[] empty = new String[]{};         final String[] result = ArrayUtils.nullToEmpty(empty);         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result);         assertNotSame(empty, result);     }      @Test     public void testNullToEmptyStringNull() {         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.nullToEmpty((String[]) null));     }      @Test     public void testReverse() {         final StringBuffer str1 = new StringBuffer("pick");         final String str2 = "a";         final String[] str3 = new String[]{"stick"};         final String str4 = "up";          Object[] array = new Object[]{str1, str2, str3};         ArrayUtils.reverse(array);         assertEquals(array[0], str3);         assertEquals(array[1], str2);         assertEquals(array[2], str1);          array = new Object[]{str1, str2, str3, str4};         ArrayUtils.reverse(array);         assertEquals(array[0], str4);         assertEquals(array[1], str3);         assertEquals(array[2], str2);         assertEquals(array[3], str1);          array = null;         ArrayUtils.reverse(array);         assertArrayEquals(null, array);     }      @Test     public void testReverseBoolean() {         boolean[] array = new boolean[]{false, false, true};         ArrayUtils.reverse(array);         assertTrue(array[0]);         assertFalse(array[1]);         assertFalse(array[2]);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseBooleanRange() {         boolean[] array = new boolean[]{false, false, true};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertTrue(array[0]);         assertFalse(array[1]);         assertFalse(array[2]);         // a range         array = new boolean[]{false, false, true};         ArrayUtils.reverse(array, 0, 2);         assertFalse(array[0]);         assertFalse(array[1]);         assertTrue(array[2]);         // a range with a negative start         array = new boolean[]{false, false, true};         ArrayUtils.reverse(array, -1, 3);         assertTrue(array[0]);         assertFalse(array[1]);         assertFalse(array[2]);         // a range with a large stop index         array = new boolean[]{false, false, true};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertTrue(array[0]);         assertFalse(array[1]);         assertFalse(array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseByte() {         byte[] array = new byte[]{2, 3, 4};         ArrayUtils.reverse(array);         assertEquals(array[0], 4);         assertEquals(array[1], 3);         assertEquals(array[2], 2);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseByteRange() {         byte[] array = new byte[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new byte[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new byte[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new byte[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseChar() {         char[] array = new char[]{'a', 'f', 'C'};         ArrayUtils.reverse(array);         assertEquals(array[0], 'C');         assertEquals(array[1], 'f');         assertEquals(array[2], 'a');          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseCharRange() {         char[] array = new char[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new char[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new char[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new char[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseDouble() {         double[] array = new double[]{0.3d, 0.4d, 0.5d};         ArrayUtils.reverse(array);         assertEquals(0.5d, array[0]);         assertEquals(0.4d, array[1]);         assertEquals(0.3d, array[2]);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseDoubleRange() {         double[] array = new double[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new double[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new double[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new double[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseFloat() {         float[] array = new float[]{0.3f, 0.4f, 0.5f};         ArrayUtils.reverse(array);         assertEquals(0.5f, array[0]);         assertEquals(0.4f, array[1]);         assertEquals(0.3f, array[2]);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseFloatRange() {         float[] array = new float[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new float[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new float[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new float[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseInt() {         int[] array = new int[]{1, 2, 3};         ArrayUtils.reverse(array);         assertEquals(array[0], 3);         assertEquals(array[1], 2);         assertEquals(array[2], 1);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseIntRange() {         int[] array = new int[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new int[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new int[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new int[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseLong() {         long[] array = new long[]{1L, 2L, 3L};         ArrayUtils.reverse(array);         assertEquals(array[0], 3L);         assertEquals(array[1], 2L);         assertEquals(array[2], 1L);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseLongRange() {         long[] array = new long[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new long[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new long[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new long[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseObjectRange() {         String[] array = new String[]{"1", "2", "3"};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals("3", array[0]);         assertEquals("2", array[1]);         assertEquals("1", array[2]);         // a range         array = new String[]{"1", "2", "3"};         ArrayUtils.reverse(array, 0, 2);         assertEquals("2", array[0]);         assertEquals("1", array[1]);         assertEquals("3", array[2]);         // a range with a negative start         array = new String[]{"1", "2", "3"};         ArrayUtils.reverse(array, -1, 3);         assertEquals("3", array[0]);         assertEquals("2", array[1]);         assertEquals("1", array[2]);         // a range with a large stop index         array = new String[]{"1", "2", "3"};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals("3", array[0]);         assertEquals("2", array[1]);         assertEquals("1", array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testReverseShort() {         short[] array = new short[]{1, 2, 3};         ArrayUtils.reverse(array);         assertEquals(array[0], 3);         assertEquals(array[1], 2);         assertEquals(array[2], 1);          array = null;         ArrayUtils.reverse(array);         assertNull(array);     }      @Test     public void testReverseShortRange() {         short[] array = new short[]{1, 2, 3};         // The whole array         ArrayUtils.reverse(array, 0, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range         array = new short[]{1, 2, 3};         ArrayUtils.reverse(array, 0, 2);         assertEquals(2, array[0]);         assertEquals(1, array[1]);         assertEquals(3, array[2]);         // a range with a negative start         array = new short[]{1, 2, 3};         ArrayUtils.reverse(array, -1, 3);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // a range with a large stop index         array = new short[]{1, 2, 3};         ArrayUtils.reverse(array, -1, array.length + 1000);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);         // null         array = null;         ArrayUtils.reverse(array, 0, 3);         assertNull(array);     }      @Test     public void testSameLength() {         final Object[] nullArray = null;         final Object[] emptyArray = new Object[0];         final Object[] oneArray = new Object[]{"pick"};         final Object[] twoArray = new Object[]{"pick", "stick"};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthAll() {         final Object[] nullArrayObject = null;         final Object[] emptyArrayObject = new Object[0];         final Object[] oneArrayObject = new Object[]{"pick"};         final Object[] twoArrayObject = new Object[]{"pick", "stick"};         final boolean[] nullArrayBoolean = null;         final boolean[] emptyArrayBoolean = new boolean[0];         final boolean[] oneArrayBoolean = new boolean[]{true};         final boolean[] twoArrayBoolean = new boolean[]{true, false};         final long[] nullArrayLong = null;         final long[] emptyArrayLong = new long[0];         final long[] oneArrayLong = new long[]{0L};         final long[] twoArrayLong = new long[]{0L, 76L};         final int[] nullArrayInt = null;         final int[] emptyArrayInt = new int[0];         final int[] oneArrayInt = new int[]{4};         final int[] twoArrayInt = new int[]{5, 7};         final short[] nullArrayShort = null;         final short[] emptyArrayShort = new short[0];         final short[] oneArrayShort = new short[]{4};         final short[] twoArrayShort = new short[]{6, 8};         final char[] nullArrayChar = null;         final char[] emptyArrayChar = new char[0];         final char[] oneArrayChar = new char[]{'f'};         final char[] twoArrayChar = new char[]{'d', 't'};         final byte[] nullArrayByte = null;         final byte[] emptyArrayByte = new byte[0];         final byte[] oneArrayByte = new byte[]{3};         final byte[] twoArrayByte = new byte[]{4, 6};         final double[] nullArrayDouble = null;         final double[] emptyArrayDouble = new double[0];         final double[] oneArrayDouble = new double[]{1.3d};         final double[] twoArrayDouble = new double[]{4.5d, 6.3d};         final float[] nullArrayFloat = null;         final float[] emptyArrayFloat = new float[0];         final float[] oneArrayFloat = new float[]{2.5f};         final float[] twoArrayFloat = new float[]{6.4f, 5.8f};         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayObject, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayBoolean, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayLong, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayInt, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayShort, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayChar, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayByte, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayDouble, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(nullArrayFloat, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayObject, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayBoolean, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayLong, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayInt, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayShort, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayChar, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayByte, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayDouble, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(nullArrayFloat, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, nullArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayObject, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayBoolean, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayLong, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayInt, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayShort, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayChar, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayByte, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayDouble, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayObject));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayBoolean));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayLong));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayInt));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayShort));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayChar));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayByte));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayDouble));         assertTrue(ArrayUtils.isSameLength(emptyArrayFloat, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayObject, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayBoolean, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayLong, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayInt, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayShort, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayChar, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayByte, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayDouble, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(emptyArrayFloat, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, emptyArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayObject, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayBoolean, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayLong, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayInt, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayShort, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayChar, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayByte, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayDouble, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayObject));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayBoolean));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayLong));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayInt));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayShort));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayChar));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayByte));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayDouble));         assertTrue(ArrayUtils.isSameLength(oneArrayFloat, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayObject, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayBoolean, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayLong, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayInt, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayShort, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayChar, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayByte, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayDouble, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayObject));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayBoolean));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayLong));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayInt));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayShort));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayChar));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayByte));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayDouble));         assertFalse(ArrayUtils.isSameLength(oneArrayFloat, twoArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, nullArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, emptyArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayObject, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayBoolean, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayLong, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayInt, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayShort, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayChar, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayByte, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayDouble, oneArrayFloat));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayObject));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayBoolean));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayLong));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayInt));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayShort));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayChar));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayByte));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayDouble));         assertFalse(ArrayUtils.isSameLength(twoArrayFloat, oneArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayObject, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayBoolean, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayLong, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayInt, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayShort, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayChar, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayByte, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayDouble, twoArrayFloat));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayObject));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayBoolean));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayLong));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayInt));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayShort));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayChar));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayByte));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayDouble));         assertTrue(ArrayUtils.isSameLength(twoArrayFloat, twoArrayFloat));     }      @Test     public void testSameLengthBoolean() {         final boolean[] nullArray = null;         final boolean[] emptyArray = new boolean[0];         final boolean[] oneArray = new boolean[]{true};         final boolean[] twoArray = new boolean[]{true, false};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthByte() {         final byte[] nullArray = null;         final byte[] emptyArray = new byte[0];         final byte[] oneArray = new byte[]{3};         final byte[] twoArray = new byte[]{4, 6};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthChar() {         final char[] nullArray = null;         final char[] emptyArray = new char[0];         final char[] oneArray = new char[]{'f'};         final char[] twoArray = new char[]{'d', 't'};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthDouble() {         final double[] nullArray = null;         final double[] emptyArray = new double[0];         final double[] oneArray = new double[]{1.3d};         final double[] twoArray = new double[]{4.5d, 6.3d};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthFloat() {         final float[] nullArray = null;         final float[] emptyArray = new float[0];         final float[] oneArray = new float[]{2.5f};         final float[] twoArray = new float[]{6.4f, 5.8f};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthInt() {         final int[] nullArray = null;         final int[] emptyArray = new int[0];         final int[] oneArray = new int[]{4};         final int[] twoArray = new int[]{5, 7};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthLong() {         final long[] nullArray = null;         final long[] emptyArray = new long[0];         final long[] oneArray = new long[]{0L};         final long[] twoArray = new long[]{0L, 76L};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameLengthShort() {         final short[] nullArray = null;         final short[] emptyArray = new short[0];         final short[] oneArray = new short[]{4};         final short[] twoArray = new short[]{6, 8};          assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(nullArray, oneArray));         assertFalse(ArrayUtils.isSameLength(nullArray, twoArray));          assertTrue(ArrayUtils.isSameLength(emptyArray, nullArray));         assertTrue(ArrayUtils.isSameLength(emptyArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, oneArray));         assertFalse(ArrayUtils.isSameLength(emptyArray, twoArray));          assertFalse(ArrayUtils.isSameLength(oneArray, nullArray));         assertFalse(ArrayUtils.isSameLength(oneArray, emptyArray));         assertTrue(ArrayUtils.isSameLength(oneArray, oneArray));         assertFalse(ArrayUtils.isSameLength(oneArray, twoArray));          assertFalse(ArrayUtils.isSameLength(twoArray, nullArray));         assertFalse(ArrayUtils.isSameLength(twoArray, emptyArray));         assertFalse(ArrayUtils.isSameLength(twoArray, oneArray));         assertTrue(ArrayUtils.isSameLength(twoArray, twoArray));     }      @Test     public void testSameType() {         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.isSameType(null, null));         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.isSameType(null, new Object[0]));         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.isSameType(new Object[0], null));          assertTrue(ArrayUtils.isSameType(new Object[0], new Object[0]));         assertFalse(ArrayUtils.isSameType(new String[0], new Object[0]));         assertTrue(ArrayUtils.isSameType(new String[0][0], new String[0][0]));         assertFalse(ArrayUtils.isSameType(new String[0], new String[0][0]));         assertFalse(ArrayUtils.isSameType(new String[0][0], new String[0]));     }      @Test     public void testShiftAllByte() {         final byte[] array = new byte[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllChar() {         final char[] array = new char[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllDouble() {         final double[] array = new double[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllFloat() {         final float[] array = new float[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllInt() {         final int[] array = new int[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllLong() {         final long[] array = new long[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftAllObject() {         final String[] array = new String[]{"1", "2", "3", "4"};         ArrayUtils.shift(array, 4);         assertEquals("1", array[0]);         assertEquals("2", array[1]);         assertEquals("3", array[2]);         assertEquals("4", array[3]);         ArrayUtils.shift(array, -4);         assertEquals("1", array[0]);         assertEquals("2", array[1]);         assertEquals("3", array[2]);         assertEquals("4", array[3]);     }      @Test     public void testShiftAllShort() {         final short[] array = new short[]{1, 2, 3, 4};         ArrayUtils.shift(array, 4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, -4);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftBoolean() {         final boolean[] array = new boolean[]{true, true, false, false};          ArrayUtils.shift(array, 1);         assertFalse(array[0]);         assertTrue(array[1]);         assertTrue(array[2]);         assertFalse(array[3]);          ArrayUtils.shift(array, -1);         assertTrue(array[0]);         assertTrue(array[1]);         assertFalse(array[2]);         assertFalse(array[3]);          ArrayUtils.shift(array, 5);         assertFalse(array[0]);         assertTrue(array[1]);         assertTrue(array[2]);         assertFalse(array[3]);          ArrayUtils.shift(array, -3);         assertFalse(array[0]);         assertFalse(array[1]);         assertTrue(array[2]);         assertTrue(array[3]);     }      @Test     public void testShiftByte() {         final byte[] array = new byte[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }      @Test     public void testShiftChar() {         final char[] array = new char[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }      @Test     public void testShiftDouble() {         final double[] array = new double[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }       @Test     public void testShiftFloat() {         final float[] array = new float[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }      @Test     public void testShiftInt() {         final int[] array = new int[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }      @Test     public void testShiftLong() {         final long[] array = new long[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);     }      @Test     public void testShiftNullBoolean() {         final boolean[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullDouble() {         final double[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullFloat() {         final float[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullInt() {         final int[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullLong() {         final long[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullObject() {         final String[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftNullShort() {         final short[] array = null;          ArrayUtils.shift(array, 1);         assertNull(array);     }      @Test     public void testShiftObject() {         final String[] array = new String[]{"1", "2", "3", "4"};         ArrayUtils.shift(array, 1);         assertEquals("4", array[0]);         assertEquals("1", array[1]);         assertEquals("2", array[2]);         assertEquals("3", array[3]);         ArrayUtils.shift(array, -1);         assertEquals("1", array[0]);         assertEquals("2", array[1]);         assertEquals("3", array[2]);         assertEquals("4", array[3]);         ArrayUtils.shift(array, 5);         assertEquals("4", array[0]);         assertEquals("1", array[1]);         assertEquals("2", array[2]);         assertEquals("3", array[3]);         ArrayUtils.shift(array, -3);         assertEquals("3", array[0]);         assertEquals("4", array[1]);         assertEquals("1", array[2]);         assertEquals("2", array[3]);     }      @Test     public void testShiftRangeByte() {         final byte[] array = new byte[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeChar() {         final char[] array = new char[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeDouble() {         final double[] array = new double[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeFloat() {         final float[] array = new float[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeInt() {         final int[] array = new int[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeLong() {         final long[] array = new long[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftRangeNoElemByte() {         final byte[] array = new byte[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemChar() {         final char[] array = new char[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemDouble() {         final double[] array = new double[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemFloat() {         final float[] array = new float[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemInt() {         final int[] array = new int[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemLong() {         final long[] array = new long[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNoElemObject() {         final String[] array = new String[]{"1", "2", "3", "4"};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals("1", array[0]);         assertEquals("2", array[1]);         assertEquals("3", array[2]);         assertEquals("4", array[3]);     }      @Test     public void testShiftRangeNoElemShort() {         final short[] array = new short[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1, 1, 1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);     }      @Test     public void testShiftRangeNullByte() {         final byte[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullChar() {         final char[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullDouble() {         final double[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullFloat() {         final float[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullInt() {         final int[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullLong() {         final long[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullObject() {         final String[] array = null;         ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeNullShort() {         final short[] array = null;          ArrayUtils.shift(array, 1, 1, 1);         assertNull(array);     }      @Test     public void testShiftRangeObject() {         final String[] array = new String[]{"1", "2", "3", "4", "5"};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals("1", array[0]);         assertEquals("3", array[1]);         assertEquals("2", array[2]);         assertEquals("4", array[3]);         assertEquals("5", array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals("1", array[0]);         assertEquals("2", array[1]);         assertEquals("4", array[2]);         assertEquals("3", array[3]);         assertEquals("5", array[4]);     }      @Test     public void testShiftRangeShort() {         final short[] array = new short[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 1, 3, 1);         assertEquals(1, array[0]);         assertEquals(3, array[1]);         assertEquals(2, array[2]);         assertEquals(4, array[3]);         assertEquals(5, array[4]);         ArrayUtils.shift(array, 1, 4, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(4, array[2]);         assertEquals(3, array[3]);         assertEquals(5, array[4]);     }      @Test     public void testShiftShort() {         short[] array = new short[]{1, 2, 3, 4};         ArrayUtils.shift(array, 1);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -1);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);         assertEquals(4, array[3]);         ArrayUtils.shift(array, 5);         assertEquals(4, array[0]);         assertEquals(1, array[1]);         assertEquals(2, array[2]);         assertEquals(3, array[3]);         ArrayUtils.shift(array, -3);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);         array = new short[]{1, 2, 3, 4, 5};         ArrayUtils.shift(array, 2);         assertEquals(4, array[0]);         assertEquals(5, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);         assertEquals(3, array[4]);     }      @Test     public void testShuffle() {         final String[] array1 = new String[]{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10"};         final String[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final String element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleBoolean() {         final boolean[] array1 = new boolean[]{true, false, true, true, false, false, true, false, false, true};         final boolean[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         assertEquals(5, ArrayUtils.removeAllOccurrences(array1, true).length);     }      @Test     public void testShuffleByte() {         final byte[] array1 = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final byte[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final byte element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleChar() {         final char[] array1 = new char[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final char[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final char element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleDouble() {         final double[] array1 = new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final double[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final double element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleFloat() {         final float[] array1 = new float[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final float[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final float element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleInt() {         final int[] array1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final int[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final int element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleLong() {         final long[] array1 = new long[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final long[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final long element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testShuffleShort() {         final short[] array1 = new short[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};         final short[] array2 = ArrayUtils.clone(array1);          ArrayUtils.shuffle(array1, new Random(SEED));         assertFalse(Arrays.equals(array1, array2));         for (final short element : array2) {             assertTrue(ArrayUtils.contains(array1, element), "Element " + element + " not found");         }     }      @Test     public void testSubarrayBoolean() {         final boolean[] nullArray = null;         final boolean[] array = {true, true, false, true, false, true};         final boolean[] leftSubarray = {true, true, false, true};         final boolean[] midSubarray = {true, false, true, false};         final boolean[] rightSubarray = {false, true, false, true};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(boolean.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "boolean type");     }      @Test     public void testSubarrayByte() {         final byte[] nullArray = null;         final byte[] array = {10, 11, 12, 13, 14, 15};         final byte[] leftSubarray = {10, 11, 12, 13};         final byte[] midSubarray = {11, 12, 13, 14};         final byte[] rightSubarray = {12, 13, 14, 15};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(byte.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "byte type");     }      @Test     public void testSubarrayDouble() {         final double[] nullArray = null;         final double[] array = {10.123, 11.234, 12.345, 13.456, 14.567, 15.678};         final double[] leftSubarray = {10.123, 11.234, 12.345, 13.456};         final double[] midSubarray = {11.234, 12.345, 13.456, 14.567};         final double[] rightSubarray = {12.345, 13.456, 14.567, 15.678};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(double.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "double type");     }      @Test     public void testSubarrayFloat() {         final float[] nullArray = null;         final float[] array = {10, 11, 12, 13, 14, 15};         final float[] leftSubarray = {10, 11, 12, 13};         final float[] midSubarray = {11, 12, 13, 14};         final float[] rightSubarray = {12, 13, 14, 15};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(float.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "float type");     }      @Test     public void testSubarrayInt() {         final int[] nullArray = null;         final int[] array = {10, 11, 12, 13, 14, 15};         final int[] leftSubarray = {10, 11, 12, 13};         final int[] midSubarray = {11, 12, 13, 14};         final int[] rightSubarray = {12, 13, 14, 15};           assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");          assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");          assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");          assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");           assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");          assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2), "empty array");          assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");          assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");          assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");          assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");          assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2),                 "empty array, object test");          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");          assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(int.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "int type");     }      @Test     public void testSubarrayLong() {         final long[] nullArray = null;         final long[] array = {999910, 999911, 999912, 999913, 999914, 999915};         final long[] leftSubarray = {999910, 999911, 999912, 999913};         final long[] midSubarray = {999911, 999912, 999913, 999914};         final long[] rightSubarray = {999912, 999913, 999914, 999915};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");          assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");          assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");          assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");          assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2),                 "empty array");          assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");          assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");          assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");          assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");          assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2),                 "empty array, object test");          assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");          assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");          assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(long.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "long type");      }      @Test     public void testSubarrayObject() {         final Object[] nullArray = null;         final Object[] objectArray = {"a", "b", "c", "d", "e", "f"};          assertEquals("abcd", StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4)), "0 start, mid end");         assertEquals("abcdef", StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length)),                 "0 start, length end");         assertEquals("bcd", StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4)), "mid start, mid end");         assertEquals("bcdef", StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals("", StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2)), "empty array");         assertEquals("", StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2)), "start > end");         assertEquals("", StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3)), "start == end");         assertEquals("abcd", StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4)), "start undershoot, normal end");         assertEquals("", StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4)), "start overshoot, any end");         assertEquals("cdef", StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33)), "normal start, end overshoot");         assertEquals("abcdef", StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12)),                 "start undershoot, end overshoot");          // array type tests         final Date[] dateArray = {new java.sql.Date(new Date().getTime()),                 new Date(), new Date(), new Date(), new Date()};          assertSame(Object.class, ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType(), "Object type");         assertSame(Date.class, ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType(),                 "java.util.Date type");         assertNotSame(java.sql.Date.class, ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType(),                 "java.sql.Date type");         assertThrows(ClassCastException.class,                 () -> java.sql.Date[].class.cast(ArrayUtils.subarray(dateArray, 1, 3)),                 "Invalid downcast");     }      @Test     public void testSubarrayShort() {         final short[] nullArray = null;         final short[] array = {10, 11, 12, 13, 14, 15};         final short[] leftSubarray = {10, 11, 12, 13};         final short[] midSubarray = {11, 12, 13, 14};         final short[] rightSubarray = {12, 13, 14, 15};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(short.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "short type");     }      @Test     public void testSubarrChar() {         final char[] nullArray = null;         final char[] array = {'a', 'b', 'c', 'd', 'e', 'f'};         final char[] leftSubarray = {'a', 'b', 'c', 'd'};         final char[] midSubarray = {'b', 'c', 'd', 'e'};         final char[] rightSubarray = {'c', 'd', 'e', 'f'};          assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, 0, 4)), "0 start, mid end");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, 0, array.length)), "0 start, length end");         assertTrue(ArrayUtils.isEquals(midSubarray, ArrayUtils.subarray(array, 1, 5)), "mid start, mid end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, array.length)),                 "mid start, length end");          assertNull(ArrayUtils.subarray(nullArray, 0, 3), "null input");         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2),                 "empty array");         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 4, 2), "start > end");         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end");         assertTrue(ArrayUtils.isEquals(leftSubarray, ArrayUtils.subarray(array, -2, 4)),                 "start undershoot, normal end");         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 33, 4), "start overshoot, any end");         assertTrue(ArrayUtils.isEquals(rightSubarray, ArrayUtils.subarray(array, 2, 33)),                 "normal start, end overshoot");         assertTrue(ArrayUtils.isEquals(array, ArrayUtils.subarray(array, -2, 12)), "start undershoot, end overshoot");          // empty-return tests          assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2),                 "empty array, object test");         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 4, 1), "start > end, object test");         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 3, 3), "start == end, object test");         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 8733, 4),                 "start overshoot, any end, object test");          // array type tests          assertSame(char.class, ArrayUtils.subarray(array, 2, 4).getClass().getComponentType(), "char type");     }      @Test     public void testSwapBoolean() {         final boolean[] array = new boolean[]{true, false, false};         ArrayUtils.swap(array, 0, 2);         assertFalse(array[0]);         assertFalse(array[1]);         assertTrue(array[2]);     }      @Test     public void testSwapBooleanRange() {         boolean[] array = new boolean[]{false, false, true, true};         ArrayUtils.swap(array, 0, 2, 2);         assertTrue(array[0]);         assertTrue(array[1]);         assertFalse(array[2]);         assertFalse(array[3]);          array = new boolean[]{false, true, false};         ArrayUtils.swap(array, 0, 3);         assertFalse(array[0]);         assertTrue(array[1]);         assertFalse(array[2]);          array = new boolean[]{true, true, false};         ArrayUtils.swap(array, 0, 2, 2);         assertFalse(array[0]);         assertTrue(array[1]);         assertTrue(array[2]);          array = new boolean[]{true, true, false};         ArrayUtils.swap(array, -1, 2, 2);         assertFalse(array[0]);         assertTrue(array[1]);         assertTrue(array[2]);          array = new boolean[]{true, true, false};         ArrayUtils.swap(array, 0, -1, 2);         assertTrue(array[0]);         assertTrue(array[1]);         assertFalse(array[2]);          array = new boolean[]{true, true, false};         ArrayUtils.swap(array, -1, -1, 2);         assertTrue(array[0]);         assertTrue(array[1]);         assertFalse(array[2]);     }      @Test     public void testSwapByte() {         final byte[] array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapByteRange() {         byte[] array = new byte[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, 0, 3);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new byte[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapChar() {         char[] array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertArrayEquals(new char[]{3, 2, 1}, array);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 0, 0);         assertArrayEquals(new char[]{1, 2, 3}, array);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 1, 0);         assertArrayEquals(new char[]{2, 1, 3}, array);     }      @Test     public void testSwapCharRange() {         char[] array = new char[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 0, 3);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new char[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapDouble() {         final double[] array = new double[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapDoubleRange() {         double[] array = new double[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new double[]{1, 2, 3};         ArrayUtils.swap(array, 0, 3);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new double[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new double[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new double[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new double[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapEmptyBooleanArray() {         final boolean[] array = new boolean[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyByteArray() {         final byte[] array = new byte[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyCharArray() {         final char[] array = new char[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyDoubleArray() {         final double[] array = new double[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyFloatArray() {         final float[] array = new float[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyIntArray() {         final int[] array = new int[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyLongArray() {         final long[] array = new long[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyObjectArray() {         final String[] array = new String[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapEmptyShortArray() {         final short[] array = new short[0];         ArrayUtils.swap(array, 0, 2);         assertEquals(0, array.length);     }      @Test     public void testSwapFloat() {         final float[] array = new float[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapFloatRange() {         float[] array = new float[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new float[]{1, 2, 3};         ArrayUtils.swap(array, 0, 3);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new float[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new float[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new float[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new float[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapInt() {         final int[] array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapIntExchangedOffsets() {         int[] array;         array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 0, 1, 2);         assertArrayEquals(new int[]{2, 3, 1}, array);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 1, 0, 2);         assertArrayEquals(new int[]{2, 3, 1}, array);     }      @Test     public void testSwapIntRange() {         int[] array = new int[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 3, 0);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new int[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapLong() {         final long[] array = new long[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapLongRange() {         long[] array = new long[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new long[]{1, 2, 3};         ArrayUtils.swap(array, 0, 3);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new long[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new long[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new long[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new long[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testSwapNullBooleanArray() {         final boolean[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullByteArray() {         final byte[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullCharArray() {         final char[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullDoubleArray() {         final double[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullFloatArray() {         final float[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullIntArray() {         final int[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullLongArray() {         final long[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullObjectArray() {         final String[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapNullShortArray() {         final short[] array = null;         ArrayUtils.swap(array, 0, 2);         assertNull(array);     }      @Test     public void testSwapObject() {         final String[] array = new String[]{"1", "2", "3"};         ArrayUtils.swap(array, 0, 2);         assertEquals("3", array[0]);         assertEquals("2", array[1]);         assertEquals("1", array[2]);     }      @Test     public void testSwapObjectRange() {         String[] array = new String[]{"1", "2", "3", "4"};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals("3", array[0]);         assertEquals("4", array[1]);         assertEquals("1", array[2]);         assertEquals("2", array[3]);          array = new String[]{"1", "2", "3", "4"};         ArrayUtils.swap(array, -1, 2, 3);         assertEquals("3", array[0]);         assertEquals("4", array[1]);         assertEquals("1", array[2]);         assertEquals("2", array[3]);          array = new String[]{"1", "2", "3", "4", "5"};         ArrayUtils.swap(array, -3, 2, 3);         assertEquals("3", array[0]);         assertEquals("4", array[1]);         assertEquals("5", array[2]);         assertEquals("2", array[3]);         assertEquals("1", array[4]);          array = new String[]{"1", "2", "3", "4", "5"};         ArrayUtils.swap(array, 2, -2, 3);         assertEquals("3", array[0]);         assertEquals("4", array[1]);         assertEquals("5", array[2]);         assertEquals("2", array[3]);         assertEquals("1", array[4]);          array = new String[0];         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(0, array.length);          array = null;         ArrayUtils.swap(array, 0, 2, 2);         assertNull(array);     }      @Test     public void testSwapShort() {         final short[] array = new short[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);     }      @Test     public void testSwapShortRange() {         short[] array = new short[]{1, 2, 3, 4};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(4, array[1]);         assertEquals(1, array[2]);         assertEquals(2, array[3]);          array = new short[]{1, 2, 3};         ArrayUtils.swap(array, 3, 0);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new short[]{1, 2, 3};         ArrayUtils.swap(array, 0, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new short[]{1, 2, 3};         ArrayUtils.swap(array, -1, 2, 2);         assertEquals(3, array[0]);         assertEquals(2, array[1]);         assertEquals(1, array[2]);          array = new short[]{1, 2, 3};         ArrayUtils.swap(array, 0, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);          array = new short[]{1, 2, 3};         ArrayUtils.swap(array, -1, -1, 2);         assertEquals(1, array[0]);         assertEquals(2, array[1]);         assertEquals(3, array[2]);     }      @Test     public void testToMap() {         Map<?, ?> map = ArrayUtils.toMap(new String[][]{{"foo", "bar"}, {"hello", "world"}});          assertEquals("bar", map.get("foo"));         assertEquals("world", map.get("hello"));          assertNull(ArrayUtils.toMap(null));         assertThrows(IllegalArgumentException.class, () ->                 ArrayUtils.toMap(new String[][]{{"foo", "bar"}, {"short"}}));         assertThrows(IllegalArgumentException.class, () ->                 ArrayUtils.toMap(new Object[]{new Object[]{"foo", "bar"}, "illegal type"}));         assertThrows(IllegalArgumentException.class, () ->                 ArrayUtils.toMap(new Object[]{new Object[]{"foo", "bar"}, null}));          map = ArrayUtils.toMap(new Object[]{new Map.Entry<Object, Object>() {             @Override             public boolean equals(final Object o) {                 throw new UnsupportedOperationException();             }              @Override             public Object getKey() {                 return "foo";             }              @Override             public Object getValue() {                 return "bar";             }              @Override             public int hashCode() {                 throw new UnsupportedOperationException();             }              @Override             public Object setValue(final Object value) {                 throw new UnsupportedOperationException();             }         }});         assertEquals("bar", map.get("foo"));          // Return empty map when got input array with length = 0         assertEquals(Collections.emptyMap(), ArrayUtils.toMap(new Object[0]));          // Test all null values         map = ArrayUtils.toMap(new Object[][] { {null, null}, {null, null} });         assertEquals(Collections.singletonMap(null, null), map);          // Test duplicate keys         map = ArrayUtils.toMap(new Object[][] { {"key", "value2"}, {"key", "value1"} });         assertEquals(Collections.singletonMap("key", "value1"), map);     }      @Test     public void testToObject_boolean() {         final boolean[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));         assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0]));         assertArrayEquals(new Boolean[]{Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, ArrayUtils.toObject(new boolean[]{true, false, true}));     }      @Test     public void testToObject_byte() {         final byte[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY,                 ArrayUtils.toObject(new byte[0]));          assertArrayEquals(new Byte[]{Byte.valueOf(Byte.MIN_VALUE),                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999)}, ArrayUtils.toObject(new byte[]{Byte.MIN_VALUE, Byte.MAX_VALUE,                 (byte) 9999999}));     }      @Test     public void testToObject_char() {         final char[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY,                 ArrayUtils.toObject(new char[0]));          assertArrayEquals(new Character[]{Character.valueOf(Character.MIN_VALUE),                 Character.valueOf(Character.MAX_VALUE), Character.valueOf('0')}, ArrayUtils.toObject(new char[]{Character.MIN_VALUE, Character.MAX_VALUE,                 '0'}));     }      @Test     public void testToObject_double() {         final double[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(                 ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY,                 ArrayUtils.toObject(new double[0]));          assertArrayEquals(new Double[]{                 Double.valueOf(Double.MIN_VALUE),                 Double.valueOf(Double.MAX_VALUE),                 Double.valueOf(9999999)}, ArrayUtils.toObject(                 new double[]{Double.MIN_VALUE, Double.MAX_VALUE, 9999999}));     }      @Test     public void testToObject_float() {         final float[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(                 ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY,                 ArrayUtils.toObject(new float[0]));          assertArrayEquals(new Float[]{                 Float.valueOf(Float.MIN_VALUE),                 Float.valueOf(Float.MAX_VALUE),                 Float.valueOf(9999999)}, ArrayUtils.toObject(                 new float[]{Float.MIN_VALUE, Float.MAX_VALUE, 9999999}));     }      @Test     public void testToObject_int() {         final int[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(                 ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY,                 ArrayUtils.toObject(new int[0]));          assertArrayEquals(new Integer[]{                 Integer.valueOf(Integer.MIN_VALUE),                 Integer.valueOf(Integer.MAX_VALUE),                 Integer.valueOf(9999999)}, ArrayUtils.toObject(                 new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}));     }      @Test     public void testToObject_long() {         final long[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(                 ArrayUtils.EMPTY_LONG_OBJECT_ARRAY,                 ArrayUtils.toObject(new long[0]));          assertArrayEquals(new Long[]{                 Long.valueOf(Long.MIN_VALUE),                 Long.valueOf(Long.MAX_VALUE),                 Long.valueOf(9999999)}, ArrayUtils.toObject(                 new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 9999999}));     }      @Test     public void testToObject_short() {         final short[] b = null;         assertArrayEquals(null, ArrayUtils.toObject(b));          assertSame(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY,                 ArrayUtils.toObject(new short[0]));          assertArrayEquals(new Short[]{Short.valueOf(Short.MIN_VALUE), Short.valueOf(Short.MAX_VALUE),                 Short.valueOf((short) 9999999)}, ArrayUtils.toObject(new short[]{Short.MIN_VALUE, Short.MAX_VALUE,                 (short) 9999999}));     }      // testToPrimitive/Object for boolean     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_boolean() {         final Boolean[] b = null;         assertNull(ArrayUtils.toPrimitive(b));         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0]));         assertArrayEquals(new boolean[]{true, false, true}, ArrayUtils.toPrimitive(new Boolean[]{Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}));          assertThrows(NullPointerException.class, () -> ArrayUtils.toPrimitive(new Boolean[]{Boolean.TRUE, null}));     }      @Test     public void testToPrimitive_boolean_boolean() {         assertNull(ArrayUtils.toPrimitive(null, false));         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false));         assertArrayEquals(new boolean[]{true, false, true}, ArrayUtils.toPrimitive(new Boolean[]{Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false));         assertArrayEquals(new boolean[]{true, false, false}, ArrayUtils.toPrimitive(new Boolean[]{Boolean.TRUE, null, Boolean.FALSE}, false));         assertArrayEquals(new boolean[]{true, true, false}, ArrayUtils.toPrimitive(new Boolean[]{Boolean.TRUE, null, Boolean.FALSE}, true));     }      // testToPrimitive/Object for byte     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_byte() {         final Byte[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0]));          assertArrayEquals(new byte[]{Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999}, ArrayUtils.toPrimitive(new Byte[]{Byte.valueOf(Byte.MIN_VALUE),                 Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Byte[]{Byte.valueOf(Byte.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_byte_byte() {         final Byte[] b = null;         assertNull(ArrayUtils.toPrimitive(b, Byte.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_BYTE_ARRAY,                 ArrayUtils.toPrimitive(new Byte[0], (byte) 1));          assertArrayEquals(new byte[]{Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999}, ArrayUtils.toPrimitive(new Byte[]{Byte.valueOf(Byte.MIN_VALUE),                         Byte.valueOf(Byte.MAX_VALUE), Byte.valueOf((byte) 9999999)},                 Byte.MIN_VALUE));          assertArrayEquals(new byte[]{Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 9999999}, ArrayUtils.toPrimitive(new Byte[]{Byte.valueOf(Byte.MIN_VALUE), null,                 Byte.valueOf((byte) 9999999)}, Byte.MAX_VALUE));     }      // testToPrimitive/Object for byte     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_char() {         final Character[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0]));          assertArrayEquals(new char[]{Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[]{Character.valueOf(Character.MIN_VALUE),                 Character.valueOf(Character.MAX_VALUE), Character.valueOf('0')}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Character[]{Character.valueOf(Character.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_char_char() {         final Character[] b = null;         assertNull(ArrayUtils.toPrimitive(b, Character.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_CHAR_ARRAY,                 ArrayUtils.toPrimitive(new Character[0], (char) 0));          assertArrayEquals(new char[]{Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[]{Character.valueOf(Character.MIN_VALUE),                         Character.valueOf(Character.MAX_VALUE), Character.valueOf('0')},                 Character.MIN_VALUE));          assertArrayEquals(new char[]{Character.MIN_VALUE, Character.MAX_VALUE, '0'}, ArrayUtils.toPrimitive(new Character[]{Character.valueOf(Character.MIN_VALUE), null,                 Character.valueOf('0')}, Character.MAX_VALUE));     }      //  testToPrimitive/Object for double     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_double() {         final Double[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,                 ArrayUtils.toPrimitive(new Double[0]));          assertArrayEquals(new double[]{Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[]{Double.valueOf(Double.MIN_VALUE),                 Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Float[]{Float.valueOf(Float.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_double_double() {         final Double[] l = null;         assertNull(ArrayUtils.toPrimitive(l, Double.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY,                 ArrayUtils.toPrimitive(new Double[0], 1));          assertArrayEquals(new double[]{Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[]{Double.valueOf(Double.MIN_VALUE),                 Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)}, 1));          assertArrayEquals(new double[]{Double.MIN_VALUE, Double.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Double[]{Double.valueOf(Double.MIN_VALUE),                 null, Double.valueOf(9999999)}, Double.MAX_VALUE));     }      //  testToPrimitive/Object for float     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_float() {         final Float[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,                 ArrayUtils.toPrimitive(new Float[0]));          assertArrayEquals(new float[]{Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[]{Float.valueOf(Float.MIN_VALUE),                 Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Float[]{Float.valueOf(Float.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_float_float() {         final Float[] l = null;         assertNull(ArrayUtils.toPrimitive(l, Float.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY,                 ArrayUtils.toPrimitive(new Float[0], 1));          assertArrayEquals(new float[]{Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[]{Float.valueOf(Float.MIN_VALUE),                 Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}, 1));          assertArrayEquals(new float[]{Float.MIN_VALUE, Float.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Float[]{Float.valueOf(Float.MIN_VALUE),                 null, Float.valueOf(9999999)}, Float.MAX_VALUE));     }      //  testToPrimitive/Object for int     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_int() {         final Integer[] b = null;         assertNull(ArrayUtils.toPrimitive(b));         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0]));         assertArrayEquals(new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[]{Integer.valueOf(Integer.MIN_VALUE),                 Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Integer[]{Integer.valueOf(Integer.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_int_int() {         final Long[] l = null;         assertNull(ArrayUtils.toPrimitive(l, Integer.MIN_VALUE));         assertSame(ArrayUtils.EMPTY_INT_ARRAY,                 ArrayUtils.toPrimitive(new Integer[0], 1));         assertArrayEquals(new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[]{Integer.valueOf(Integer.MIN_VALUE),                 Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)}, 1));         assertArrayEquals(new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Integer[]{Integer.valueOf(Integer.MIN_VALUE),                 null, Integer.valueOf(9999999)}, Integer.MAX_VALUE));     }      @Test     public void testToPrimitive_intNull() {         final Integer[] iArray = null;         assertNull(ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE));     }      //  testToPrimitive/Object for long     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_long() {         final Long[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,                 ArrayUtils.toPrimitive(new Long[0]));          assertArrayEquals(new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[]{Long.valueOf(Long.MIN_VALUE),                 Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Long[]{Long.valueOf(Long.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_long_long() {         final Long[] l = null;         assertNull(ArrayUtils.toPrimitive(l, Long.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_LONG_ARRAY,                 ArrayUtils.toPrimitive(new Long[0], 1));          assertArrayEquals(new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[]{Long.valueOf(Long.MIN_VALUE),                 Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)}, 1));          assertArrayEquals(new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 9999999}, ArrayUtils.toPrimitive(new Long[]{Long.valueOf(Long.MIN_VALUE),                 null, Long.valueOf(9999999)}, Long.MAX_VALUE));     }      // testToPrimitive/Object for short     //  -----------------------------------------------------------------------     @Test     public void testToPrimitive_short() {         final Short[] b = null;         assertNull(ArrayUtils.toPrimitive(b));          assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0]));          assertArrayEquals(new short[]{Short.MIN_VALUE, Short.MAX_VALUE, (short) 9999999}, ArrayUtils.toPrimitive(new Short[]{Short.valueOf(Short.MIN_VALUE),                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short) 9999999)}));          assertThrows(NullPointerException.class,                 () -> ArrayUtils.toPrimitive(new Short[]{Short.valueOf(Short.MIN_VALUE), null}));     }      @Test     public void testToPrimitive_short_short() {         final Short[] s = null;         assertNull(ArrayUtils.toPrimitive(s, Short.MIN_VALUE));          assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0],                 Short.MIN_VALUE));          assertArrayEquals(new short[]{Short.MIN_VALUE, Short.MAX_VALUE, (short) 9999999}, ArrayUtils.toPrimitive(new Short[]{Short.valueOf(Short.MIN_VALUE),                 Short.valueOf(Short.MAX_VALUE), Short.valueOf((short) 9999999)}, Short.MIN_VALUE));          assertArrayEquals(new short[]{Short.MIN_VALUE, Short.MAX_VALUE, (short) 9999999}, ArrayUtils.toPrimitive(new Short[]{Short.valueOf(Short.MIN_VALUE), null,                 Short.valueOf((short) 9999999)}, Short.MAX_VALUE));     }      @Test     public void testToString() {         assertEquals("{}", ArrayUtils.toString(null));         assertEquals("{}", ArrayUtils.toString(new Object[0]));         assertEquals("{}", ArrayUtils.toString(new String[0]));         assertEquals("{<null>}", ArrayUtils.toString(new String[]{null}));         assertEquals("{pink,blue}", ArrayUtils.toString(new String[]{"pink", "blue"}));          assertEquals("<empty>", ArrayUtils.toString(null, "<empty>"));         assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>"));         assertEquals("{}", ArrayUtils.toString(new String[0], "<empty>"));         assertEquals("{<null>}", ArrayUtils.toString(new String[]{null}, "<empty>"));         assertEquals("{pink,blue}", ArrayUtils.toString(new String[]{"pink", "blue"}, "<empty>"));     }      @Test     public void testToStringArray_array() {         assertNull(ArrayUtils.toStringArray(null));          assertArrayEquals(new String[0], ArrayUtils.toStringArray(new Object[0]));          final Object[] array = new Object[]{1, 2, 3, "array", "test"};         assertArrayEquals(new String[]{"1", "2", "3", "array", "test"}, ArrayUtils.toStringArray(array));          assertThrows(NullPointerException.class, () -> ArrayUtils.toStringArray(new Object[]{null}));     }      @Test     public void testToStringArray_array_string() {         assertNull(ArrayUtils.toStringArray(null, ""));          assertArrayEquals(new String[0], ArrayUtils.toStringArray(new Object[0], ""));          final Object[] array = new Object[]{1, null, "test"};         assertArrayEquals(new String[]{"1", "valueForNullElements", "test"},                 ArrayUtils.toStringArray(array, "valueForNullElements"));     }      @Test     public void textIndexesOfInt() {         int[] array = null;         final BitSet emptySet = new BitSet();         final BitSet testSet = new BitSet();         assertEquals(emptySet, ArrayUtils.indexesOf(array, 0));         array = new int[]{0, 1, 2, 3, 0};         testSet.set(0);         testSet.set(4);         assertEquals(testSet, ArrayUtils.indexesOf(array, 0));         testSet.clear();         testSet.set(1);         assertEquals(testSet, ArrayUtils.indexesOf(array, 1));         testSet.clear();         testSet.set(2);         assertEquals(testSet, ArrayUtils.indexesOf(array, 2));         testSet.clear();         testSet.set(3);         assertEquals(testSet, ArrayUtils.indexesOf(array, 3));         assertEquals(emptySet, ArrayUtils.indexesOf(array, 99));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import java.io.IOException; import java.net.URL; import java.net.URLClassLoader;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  /**  * Tests {@link ClassLoaderUtils}.  */ public class ClassLoaderUtilsTest {      @Test     public void testToString_ClassLoader() throws IOException {         final URL url = new URL("http://localhost");         try (URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { url })) {             @SuppressWarnings("resource")             final ClassLoader classLoader = urlClassLoader;             Assertions.assertEquals(String.format("%s[%s]", classLoader, url), ClassLoaderUtils.toString(classLoader));         }     }      @Test     public void testToString_URLClassLoader() throws IOException {         final URL url = new URL("http://localhost");         try (URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { url })) {             Assertions.assertEquals(String.format("%s[%s]", urlClassLoader, url),                     ClassLoaderUtils.toString(urlClassLoader));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.BooleanUtils}.  */ public class BooleanUtilsTest {      @Test     public void test_booleanValues() {         final Boolean[] expected = new Boolean[] {false, true};         Arrays.sort(expected);         assertArrayEquals(expected, BooleanUtils.booleanValues());     }      @Test     public void test_isFalse_Boolean() {         assertFalse(BooleanUtils.isFalse(Boolean.TRUE));         assertTrue(BooleanUtils.isFalse(Boolean.FALSE));         assertFalse(BooleanUtils.isFalse(null));     }      @Test     public void test_isNotFalse_Boolean() {         assertTrue(BooleanUtils.isNotFalse(Boolean.TRUE));         assertFalse(BooleanUtils.isNotFalse(Boolean.FALSE));         assertTrue(BooleanUtils.isNotFalse(null));     }      @Test     public void test_isNotTrue_Boolean() {         assertFalse(BooleanUtils.isNotTrue(Boolean.TRUE));         assertTrue(BooleanUtils.isNotTrue(Boolean.FALSE));         assertTrue(BooleanUtils.isNotTrue(null));     }      @Test     public void test_isTrue_Boolean() {         assertTrue(BooleanUtils.isTrue(Boolean.TRUE));         assertFalse(BooleanUtils.isTrue(Boolean.FALSE));         assertFalse(BooleanUtils.isTrue(null));     }      @Test     public void test_negate_Boolean() {         assertSame(null, BooleanUtils.negate(null));         assertSame(Boolean.TRUE, BooleanUtils.negate(Boolean.FALSE));         assertSame(Boolean.FALSE, BooleanUtils.negate(Boolean.TRUE));     }      @Test     public void test_primitiveValues() {         assertArrayEquals(new boolean[] {false, true}, BooleanUtils.primitiveValues());     }      @Test     public void test_toBoolean_Boolean() {         assertTrue(BooleanUtils.toBoolean(Boolean.TRUE));         assertFalse(BooleanUtils.toBoolean(Boolean.FALSE));         assertFalse(BooleanUtils.toBoolean((Boolean) null));     }      @Test     public void test_toBoolean_int() {         assertTrue(BooleanUtils.toBoolean(1));         assertTrue(BooleanUtils.toBoolean(-1));         assertFalse(BooleanUtils.toBoolean(0));     }      @Test     public void test_toBoolean_int_int_int() {         assertTrue(BooleanUtils.toBoolean(6, 6, 7));         assertFalse(BooleanUtils.toBoolean(7, 6, 7));     }      @Test     public void test_toBoolean_int_int_int_noMatch() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBoolean(8, 6, 7));     }      @Test     public void test_toBoolean_Integer_Integer_Integer() {         final Integer six = Integer.valueOf(6);         final Integer seven = Integer.valueOf(7);          assertTrue(BooleanUtils.toBoolean(null, null, seven));         assertFalse(BooleanUtils.toBoolean(null, six, null));          assertTrue(BooleanUtils.toBoolean(Integer.valueOf(6), six, seven));         assertFalse(BooleanUtils.toBoolean(Integer.valueOf(7), six, seven));     }      @Test     public void test_toBoolean_Integer_Integer_Integer_noMatch() {         assertThrows(IllegalArgumentException.class,                 () -> BooleanUtils.toBoolean(Integer.valueOf(8), Integer.valueOf(6), Integer.valueOf(7)));     }      @Test     public void test_toBoolean_Integer_Integer_Integer_nullValue() {         assertThrows(IllegalArgumentException.class,                 () -> BooleanUtils.toBoolean(null, Integer.valueOf(6), Integer.valueOf(7)));     }      @Test     public void test_toBoolean_String() {         assertFalse(BooleanUtils.toBoolean((String) null));         assertFalse(BooleanUtils.toBoolean(""));         assertFalse(BooleanUtils.toBoolean("off"));         assertFalse(BooleanUtils.toBoolean("oof"));         assertFalse(BooleanUtils.toBoolean("yep"));         assertFalse(BooleanUtils.toBoolean("trux"));         assertFalse(BooleanUtils.toBoolean("false"));         assertFalse(BooleanUtils.toBoolean("a"));         assertTrue(BooleanUtils.toBoolean("true")); // interned handled differently         assertTrue(BooleanUtils.toBoolean(new StringBuilder("tr").append("ue").toString()));         assertTrue(BooleanUtils.toBoolean("truE"));         assertTrue(BooleanUtils.toBoolean("trUe"));         assertTrue(BooleanUtils.toBoolean("trUE"));         assertTrue(BooleanUtils.toBoolean("tRue"));         assertTrue(BooleanUtils.toBoolean("tRuE"));         assertTrue(BooleanUtils.toBoolean("tRUe"));         assertTrue(BooleanUtils.toBoolean("tRUE"));         assertTrue(BooleanUtils.toBoolean("TRUE"));         assertTrue(BooleanUtils.toBoolean("TRUe"));         assertTrue(BooleanUtils.toBoolean("TRuE"));         assertTrue(BooleanUtils.toBoolean("TRue"));         assertTrue(BooleanUtils.toBoolean("TrUE"));         assertTrue(BooleanUtils.toBoolean("TrUe"));         assertTrue(BooleanUtils.toBoolean("TruE"));         assertTrue(BooleanUtils.toBoolean("True"));         assertTrue(BooleanUtils.toBoolean("on"));         assertTrue(BooleanUtils.toBoolean("oN"));         assertTrue(BooleanUtils.toBoolean("On"));         assertTrue(BooleanUtils.toBoolean("ON"));         assertTrue(BooleanUtils.toBoolean("yes"));         assertTrue(BooleanUtils.toBoolean("yeS"));         assertTrue(BooleanUtils.toBoolean("yEs"));         assertTrue(BooleanUtils.toBoolean("yES"));         assertTrue(BooleanUtils.toBoolean("Yes"));         assertTrue(BooleanUtils.toBoolean("YeS"));         assertTrue(BooleanUtils.toBoolean("YEs"));         assertTrue(BooleanUtils.toBoolean("YES"));         assertTrue(BooleanUtils.toBoolean("1"));         assertFalse(BooleanUtils.toBoolean("yes?"));         assertFalse(BooleanUtils.toBoolean("0"));         assertFalse(BooleanUtils.toBoolean("tru"));          assertFalse(BooleanUtils.toBoolean("no"));         assertFalse(BooleanUtils.toBoolean("off"));         assertFalse(BooleanUtils.toBoolean("yoo"));     }      @Test     public void test_toBoolean_String_String_String() {         assertTrue(BooleanUtils.toBoolean(null, null, "N"));         assertFalse(BooleanUtils.toBoolean(null, "Y", null));         assertTrue(BooleanUtils.toBoolean("Y", "Y", "N"));         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("N")));         assertFalse(BooleanUtils.toBoolean("N", "Y", "N"));         assertFalse(BooleanUtils.toBoolean("N", new String("Y"), new String("N")));         assertTrue(BooleanUtils.toBoolean((String) null, null, null));         assertTrue(BooleanUtils.toBoolean("Y", "Y", "Y"));         assertTrue(BooleanUtils.toBoolean("Y", new String("Y"), new String("Y")));     }      @Test     public void test_toBoolean_String_String_String_noMatch() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBoolean("X", "Y", "N"));     }      @Test     public void test_toBoolean_String_String_String_nullValue() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBoolean(null, "Y", "N"));     }      @Test     public void test_toBooleanDefaultIfNull_Boolean_boolean() {         assertTrue(BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true));         assertTrue(BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false));         assertFalse(BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true));         assertFalse(BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false));         assertTrue(BooleanUtils.toBooleanDefaultIfNull(null, true));         assertFalse(BooleanUtils.toBooleanDefaultIfNull(null, false));     }      @Test     public void test_toBooleanObject_int() {         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(-1));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0));     }      @Test     public void test_toBooleanObject_int_int_int() {         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(6, 6, 7, 8));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(7, 6, 7, 8));         assertNull(BooleanUtils.toBooleanObject(8, 6, 7, 8));     }      @Test     public void test_toBooleanObject_int_int_int_noMatch() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBooleanObject(9, 6, 7, 8));     }      @Test     public void test_toBooleanObject_Integer() {         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(1)));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(-1)));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(0)));         assertNull(BooleanUtils.toBooleanObject((Integer) null));     }      @Test     public void test_toBooleanObject_Integer_Integer_Integer_Integer() {         final Integer six = Integer.valueOf(6);         final Integer seven = Integer.valueOf(7);         final Integer eight = Integer.valueOf(8);          assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject(null, null, seven, eight));         assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject(null, six, null, eight));         assertSame(null, BooleanUtils.toBooleanObject(null, six, seven, null));          assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(6), six, seven, eight));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(7), six, seven, eight));         assertNull(BooleanUtils.toBooleanObject(Integer.valueOf(8), six, seven, eight));     }      @Test     public void test_toBooleanObject_Integer_Integer_Integer_Integer_noMatch() {         assertThrows(IllegalArgumentException.class,                 () -> BooleanUtils.toBooleanObject(Integer.valueOf(9), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8)));     }      @Test     public void test_toBooleanObject_Integer_Integer_Integer_Integer_nullValue() {         assertThrows(IllegalArgumentException.class,                 () -> BooleanUtils.toBooleanObject(null, Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8)));     }      @Test     public void test_toBooleanObject_String() {         assertNull(BooleanUtils.toBooleanObject((String) null));         assertNull(BooleanUtils.toBooleanObject(""));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF"));         assertNull(BooleanUtils.toBooleanObject("oof"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("YES"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE"));          assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("y")); // yes         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("t")); // true         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("T"));         assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("1"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("f")); // false         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("F"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("n")); // No         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("0"));         assertNull(BooleanUtils.toBooleanObject("z"));          assertNull(BooleanUtils.toBooleanObject("ab"));         assertNull(BooleanUtils.toBooleanObject("yoo"));         assertNull(BooleanUtils.toBooleanObject("true "));         assertNull(BooleanUtils.toBooleanObject("ono"));     }      @Test     public void test_toBooleanObject_String_String_String_String() {         assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject(null, null, "N", "U"));         assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject(null, "Y", null, "U"));         assertSame(null, BooleanUtils.toBooleanObject(null, "Y", "N", null));          assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y", "Y", "N", "U"));         assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N", "Y", "N", "U"));         assertNull(BooleanUtils.toBooleanObject("U", "Y", "N", "U"));     }      @Test     public void test_toBooleanObject_String_String_String_String_noMatch() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBooleanObject("X", "Y", "N", "U"));     }      @Test     public void test_toBooleanObject_String_String_String_String_nullValue() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.toBooleanObject(null, "Y", "N", "U"));     }      @Test     public void test_toInteger_boolean() {         assertEquals(1, BooleanUtils.toInteger(true));         assertEquals(0, BooleanUtils.toInteger(false));     }      @Test     public void test_toInteger_boolean_int_int() {         assertEquals(6, BooleanUtils.toInteger(true, 6, 7));         assertEquals(7, BooleanUtils.toInteger(false, 6, 7));     }      @Test     public void test_toInteger_Boolean_int_int_int() {         assertEquals(6, BooleanUtils.toInteger(Boolean.TRUE, 6, 7, 8));         assertEquals(7, BooleanUtils.toInteger(Boolean.FALSE, 6, 7, 8));         assertEquals(8, BooleanUtils.toInteger(null, 6, 7, 8));     }      @Test     public void test_toIntegerObject_boolean() {         assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(true));         assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(false));     }      @Test     public void test_toIntegerObject_Boolean() {         assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(Boolean.TRUE));         assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(Boolean.FALSE));         assertNull(BooleanUtils.toIntegerObject(null));     }      @Test     public void test_toIntegerObject_boolean_Integer_Integer() {         final Integer six = Integer.valueOf(6);         final Integer seven = Integer.valueOf(7);         assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven));         assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven));     }      @Test     public void test_toIntegerObject_Boolean_Integer_Integer_Integer() {         final Integer six = Integer.valueOf(6);         final Integer seven = Integer.valueOf(7);         final Integer eight = Integer.valueOf(8);         assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight));         assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight));         assertEquals(eight, BooleanUtils.toIntegerObject(null, six, seven, eight));         assertNull(BooleanUtils.toIntegerObject(null, six, seven, null));     }      @Test     public void test_toString_boolean_String_String_String() {         assertEquals("Y", BooleanUtils.toString(true, "Y", "N"));         assertEquals("N", BooleanUtils.toString(false, "Y", "N"));     }      @Test     public void test_toString_Boolean_String_String_String() {         assertEquals("U", BooleanUtils.toString(null, "Y", "N", "U"));         assertEquals("Y", BooleanUtils.toString(Boolean.TRUE, "Y", "N", "U"));         assertEquals("N", BooleanUtils.toString(Boolean.FALSE, "Y", "N", "U"));     }      @Test     public void test_toStringOnOff_boolean() {         assertEquals("on", BooleanUtils.toStringOnOff(true));         assertEquals("off", BooleanUtils.toStringOnOff(false));     }      @Test     public void test_toStringOnOff_Boolean() {         assertNull(BooleanUtils.toStringOnOff(null));         assertEquals("on", BooleanUtils.toStringOnOff(Boolean.TRUE));         assertEquals("off", BooleanUtils.toStringOnOff(Boolean.FALSE));     }      @Test     public void test_toStringTrueFalse_boolean() {         assertEquals("true", BooleanUtils.toStringTrueFalse(true));         assertEquals("false", BooleanUtils.toStringTrueFalse(false));     }      @Test     public void test_toStringTrueFalse_Boolean() {         assertNull(BooleanUtils.toStringTrueFalse(null));         assertEquals("true", BooleanUtils.toStringTrueFalse(Boolean.TRUE));         assertEquals("false", BooleanUtils.toStringTrueFalse(Boolean.FALSE));     }      @Test     public void test_toStringYesNo_boolean() {         assertEquals("yes", BooleanUtils.toStringYesNo(true));         assertEquals("no", BooleanUtils.toStringYesNo(false));     }      @Test     public void test_toStringYesNo_Boolean() {         assertNull(BooleanUtils.toStringYesNo(null));         assertEquals("yes", BooleanUtils.toStringYesNo(Boolean.TRUE));         assertEquals("no", BooleanUtils.toStringYesNo(Boolean.FALSE));     }      @Test     public void testAnd_object_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.and(new Boolean[] {}));     }      @Test     public void testAnd_object_nullElementInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.and(new Boolean[] {null}));     }      @Test     public void testAnd_object_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.and((Boolean[]) null));     }      @Test     public void testAnd_object_validInput_2items() {         assertTrue(                 BooleanUtils                     .and(new Boolean[] { Boolean.TRUE, Boolean.TRUE })                     .booleanValue(),                 "False result for (true, true)");          assertTrue(                 ! BooleanUtils                     .and(new Boolean[] { Boolean.FALSE, Boolean.FALSE })                     .booleanValue(),                 "True result for (false, false)");          assertTrue(                 ! BooleanUtils                     .and(new Boolean[] { Boolean.TRUE, Boolean.FALSE })                     .booleanValue(),                 "True result for (true, false)");          assertTrue(                 ! BooleanUtils                     .and(new Boolean[] { Boolean.FALSE, Boolean.TRUE })                     .booleanValue(),                 "True result for (false, true)");     }      @Test     public void testAnd_object_validInput_3items() {         assertTrue(                 ! BooleanUtils                     .and(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.FALSE,                             Boolean.TRUE })                             .booleanValue(),                 "True result for (false, false, true)");          assertTrue(                 ! BooleanUtils                     .and(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.TRUE,                             Boolean.FALSE })                             .booleanValue(),                 "True result for (false, true, false)");          assertTrue(                 ! BooleanUtils                     .and(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.FALSE,                             Boolean.FALSE })                             .booleanValue(),                 "True result for (true, false, false)");          assertTrue(                 BooleanUtils                     .and(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE })                     .booleanValue(),                 "False result for (true, true, true)");          assertTrue(                 ! BooleanUtils.and(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.FALSE,                             Boolean.FALSE })                             .booleanValue(),                 "True result for (false, false)");          assertTrue(                 ! BooleanUtils.and(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.TRUE,                             Boolean.FALSE })                             .booleanValue(),                 "True result for (true, true, false)");          assertTrue(                 ! BooleanUtils.and(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.FALSE,                             Boolean.TRUE })                             .booleanValue(),                 "True result for (true, false, true)");          assertTrue(                 ! BooleanUtils.and(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.TRUE,                             Boolean.TRUE })                             .booleanValue(),                 "True result for (false, true, true)");     }      @Test     public void testAnd_primitive_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.and(new boolean[] {}));     }      @Test     public void testAnd_primitive_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.and((boolean[]) null));     }      @Test     public void testAnd_primitive_validInput_2items() {         assertTrue(                 BooleanUtils.and(new boolean[] { true, true }),                 "False result for (true, true)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { false, false }),                 "True result for (false, false)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { true, false }),                 "True result for (true, false)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { false, true }),                 "True result for (false, true)");     }      @Test     public void testAnd_primitive_validInput_3items() {         assertTrue(                 ! BooleanUtils.and(new boolean[] { false, false, true }),                 "True result for (false, false, true)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { false, true, false }),                 "True result for (false, true, false)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { true, false, false }),                 "True result for (true, false, false)");          assertTrue(                 BooleanUtils.and(new boolean[] { true, true, true }),                 "False result for (true, true, true)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { false, false, false }),                 "True result for (false, false)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { true, true, false }),                 "True result for (true, true, false)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { true, false, true }),                 "True result for (true, false, true)");          assertTrue(                 ! BooleanUtils.and(new boolean[] { false, true, true }),                 "True result for (false, true, true)");     }      @Test     public void testCompare() {         assertTrue(BooleanUtils.compare(true, false) > 0);         assertEquals(0, BooleanUtils.compare(true, true));         assertEquals(0, BooleanUtils.compare(false, false));         assertTrue(BooleanUtils.compare(false, true) < 0);     }      @Test     public void testConstructor() {         assertNotNull(new BooleanUtils());         final Constructor<?>[] cons = BooleanUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(BooleanUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(BooleanUtils.class.getModifiers()));     }      @Test     public void testOr_object_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.or(new Boolean[] {}));     }      @Test     public void testOr_object_nullElementInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.or(new Boolean[] {null}));     }      @Test     public void testOr_object_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.or((Boolean[]) null));     }      @Test     public void testOr_object_validInput_2items() {         assertTrue(                 BooleanUtils                     .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE })                     .booleanValue(),                 "False result for (true, true)");          assertTrue(                 ! BooleanUtils                     .or(new Boolean[] { Boolean.FALSE, Boolean.FALSE })                     .booleanValue(),                 "True result for (false, false)");          assertTrue(                 BooleanUtils                     .or(new Boolean[] { Boolean.TRUE, Boolean.FALSE })                     .booleanValue(),                 "False result for (true, false)");          assertTrue(                 BooleanUtils                     .or(new Boolean[] { Boolean.FALSE, Boolean.TRUE })                     .booleanValue(),                 "False result for (false, true)");     }      @Test     public void testOr_object_validInput_3items() {         assertTrue(                 BooleanUtils                     .or(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.FALSE,                             Boolean.TRUE })                             .booleanValue(),                 "False result for (false, false, true)");          assertTrue(                 BooleanUtils                     .or(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.TRUE,                             Boolean.FALSE })                             .booleanValue(),                 "False result for (false, true, false)");          assertTrue(                 BooleanUtils                     .or(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.FALSE,                             Boolean.FALSE })                             .booleanValue(),                 "False result for (true, false, false)");          assertTrue(                 BooleanUtils                     .or(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE })                     .booleanValue(),                 "False result for (true, true, true)");          assertTrue(                 ! BooleanUtils.or(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.FALSE,                             Boolean.FALSE })                             .booleanValue(),                 "True result for (false, false)");          assertTrue(                 BooleanUtils.or(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.TRUE,                             Boolean.FALSE })                             .booleanValue(),                 "False result for (true, true, false)");          assertTrue(                 BooleanUtils.or(                         new Boolean[] {                             Boolean.TRUE,                             Boolean.FALSE,                             Boolean.TRUE })                             .booleanValue(),                 "False result for (true, false, true)");          assertTrue(                 BooleanUtils.or(                         new Boolean[] {                             Boolean.FALSE,                             Boolean.TRUE,                             Boolean.TRUE })                             .booleanValue(),                 "False result for (false, true, true)");     }      @Test     public void testOr_primitive_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.or(new boolean[] {}));     }      @Test     public void testOr_primitive_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.or((boolean[]) null));     }      @Test     public void testOr_primitive_validInput_2items() {         assertTrue(                 BooleanUtils.or(new boolean[] { true, true }),                 "False result for (true, true)");          assertTrue(                 ! BooleanUtils.or(new boolean[] { false, false }),                 "True result for (false, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { true, false }),                 "False result for (true, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { false, true }),                 "False result for (false, true)");     }      @Test     public void testOr_primitive_validInput_3items() {         assertTrue(                 BooleanUtils.or(new boolean[] { false, false, true }),                 "False result for (false, false, true)");          assertTrue(                 BooleanUtils.or(new boolean[] { false, true, false }),                 "False result for (false, true, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { true, false, false }),                 "False result for (true, false, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { true, true, true }),                 "False result for (true, true, true)");          assertTrue(                 ! BooleanUtils.or(new boolean[] { false, false, false }),                 "True result for (false, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { true, true, false }),                 "False result for (true, true, false)");          assertTrue(                 BooleanUtils.or(new boolean[] { true, false, true }),                 "False result for (true, false, true)");          assertTrue(                 BooleanUtils.or(new boolean[] { false, true, true }),                 "False result for (false, true, true)");      }      @Test     public void testXor_object_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.xor(new Boolean[] {}));     }      @Test     public void testXor_object_nullElementInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.xor(new Boolean[] {null}));     }      @Test     public void testXor_object_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.xor((Boolean[]) null));     }     @Test     public void testXor_object_validInput_2items() {         assertEquals(                 false ^ false,                 BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }).booleanValue(),                 "false ^ false");          assertEquals(                 false ^ true,                 BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.TRUE }).booleanValue(),                 "false ^ true");          assertEquals(                 true ^ false,                 BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE }).booleanValue(),                 "true ^ false");          assertEquals(                 true ^ true,                 BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE }).booleanValue(),                 "true ^ true");     }      @Test     public void testXor_object_validInput_3items() {         assertEquals(                 false ^ false ^ false,                 BooleanUtils.xor(                                 new Boolean[] {                                         Boolean.FALSE,                                         Boolean.FALSE,                                         Boolean.FALSE })                                 .booleanValue(),                 "false ^ false ^ false");          assertEquals(                 false ^ false ^ true,                 BooleanUtils                         .xor(                             new Boolean[] {                                 Boolean.FALSE,                                 Boolean.FALSE,                                 Boolean.TRUE })                         .booleanValue(),                 "false ^ false ^ true");          assertEquals(                 false ^ true ^ false,                 BooleanUtils                         .xor(                             new Boolean[] {                                 Boolean.FALSE,                                 Boolean.TRUE,                                 Boolean.FALSE })                         .booleanValue(),                 "false ^ true ^ false");          assertEquals(                 true ^ false ^ false,                 BooleanUtils                         .xor(                             new Boolean[] {                                 Boolean.TRUE,                                 Boolean.FALSE,                                 Boolean.FALSE })                         .booleanValue(),                 "true ^ false ^ false");          assertEquals(                 true ^ false ^ true,                 BooleanUtils.xor(                                 new Boolean[] {                                         Boolean.TRUE,                                         Boolean.FALSE,                                         Boolean.TRUE })                                 .booleanValue(),                 "true ^ false ^ true");          assertEquals(                 true ^ true ^ false,                 BooleanUtils.xor(                             new Boolean[] {                                 Boolean.TRUE,                                 Boolean.TRUE,                                 Boolean.FALSE })                         .booleanValue(),                 "true ^ true ^ false");          assertEquals(                 false ^ true ^ true,                 BooleanUtils.xor(                             new Boolean[] {                                 Boolean.FALSE,                                 Boolean.TRUE,                                 Boolean.TRUE })                         .booleanValue(),                 "false ^ true ^ true");          assertEquals(                 true ^ true ^ true,                 BooleanUtils.xor(                         new Boolean[] {                                 Boolean.TRUE,                                 Boolean.TRUE,                                 Boolean.TRUE })                         .booleanValue(),                 "true ^ true ^ true");     }      @Test     public void testXor_primitive_emptyInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.xor(new boolean[] {}));     }      @Test     public void testXor_primitive_nullInput() {         assertThrows(IllegalArgumentException.class, () -> BooleanUtils.xor((boolean[]) null));     }      @Test     public void testXor_primitive_validInput_2items() {         assertEquals(                 true ^ true,                 BooleanUtils.xor(new boolean[] { true, true }),                 "true ^ true");          assertEquals(                 false ^ false,                 BooleanUtils.xor(new boolean[] { false, false }),                 "false ^ false");          assertEquals(                 true ^ false,                 BooleanUtils.xor(new boolean[] { true, false }),                 "true ^ false");          assertEquals(                 false ^ true,                 BooleanUtils.xor(new boolean[] { false, true }),                 "false ^ true");     }      @Test     public void testXor_primitive_validInput_3items() {         assertEquals(                 false ^ false ^ false,                 BooleanUtils.xor(new boolean[] { false, false, false }),                 "false ^ false ^ false");          assertEquals(                 false ^ false ^ true,                 BooleanUtils.xor(new boolean[] { false, false, true }),                 "false ^ false ^ true");          assertEquals(                 false ^ true ^ false,                 BooleanUtils.xor(new boolean[] { false, true, false }),                 "false ^ true ^ false");          assertEquals(                 false ^ true ^ true,                 BooleanUtils.xor(new boolean[] { false, true, true }),                 "false ^ true ^ true");          assertEquals(                 true ^ false ^ false,                 BooleanUtils.xor(new boolean[] { true, false, false }),                 "true ^ false ^ false");          assertEquals(                 true ^ false ^ true,                 BooleanUtils.xor(new boolean[] { true, false, true }),                 "true ^ false ^ true");          assertEquals(                 true ^ true ^ false,                 BooleanUtils.xor(new boolean[] { true, true, false }),                 "true ^ true ^ false");          assertEquals(                 true ^ true ^ true,                 BooleanUtils.xor(new boolean[] { true, true, true }),                 "true ^ true ^ true");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.fail;  import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Arrays; import java.util.Calendar; import java.util.Collections; import java.util.Comparator; import java.util.Date; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.function.Supplier;  import org.apache.commons.lang3.exception.CloneFailedException; import org.apache.commons.lang3.mutable.MutableInt; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.commons.lang3.text.StrBuilder; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.ObjectUtils}.  */ @SuppressWarnings("deprecation") // deliberate use of deprecated code public class ObjectUtilsTest {     private static final String FOO = "foo";     private static final String BAR = "bar";     private static final String[] NON_EMPTY_ARRAY = new String[] { FOO, BAR, };     private static final List<String> NON_EMPTY_LIST = Arrays.asList(NON_EMPTY_ARRAY);     private static final Set<String> NON_EMPTY_SET = new HashSet<>(NON_EMPTY_LIST);     private static final Map<String, String> NON_EMPTY_MAP = new HashMap<>();     static {         NON_EMPTY_MAP.put(FOO, BAR);     }      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new ObjectUtils());         final Constructor<?>[] cons = ObjectUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ObjectUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ObjectUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testIsEmpty() {         assertTrue(ObjectUtils.isEmpty(null));         assertTrue(ObjectUtils.isEmpty(""));         assertTrue(ObjectUtils.isEmpty(new int[] {}));         assertTrue(ObjectUtils.isEmpty(Collections.emptyList()));         assertTrue(ObjectUtils.isEmpty(Collections.emptySet()));         assertTrue(ObjectUtils.isEmpty(Collections.emptyMap()));          assertFalse(ObjectUtils.isEmpty("  "));         assertFalse(ObjectUtils.isEmpty("ab"));         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_ARRAY));         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_LIST));         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_SET));         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_MAP));     }      @Test     public void testIsNotEmpty() {         assertFalse(ObjectUtils.isNotEmpty(null));         assertFalse(ObjectUtils.isNotEmpty(""));         assertFalse(ObjectUtils.isNotEmpty(new int[] {}));         assertFalse(ObjectUtils.isNotEmpty(Collections.emptyList()));         assertFalse(ObjectUtils.isNotEmpty(Collections.emptySet()));         assertFalse(ObjectUtils.isNotEmpty(Collections.emptyMap()));          assertTrue(ObjectUtils.isNotEmpty("  "));         assertTrue(ObjectUtils.isNotEmpty("ab"));         assertTrue(ObjectUtils.isNotEmpty(NON_EMPTY_ARRAY));         assertTrue(ObjectUtils.isNotEmpty(NON_EMPTY_LIST));         assertTrue(ObjectUtils.isNotEmpty(NON_EMPTY_SET));         assertTrue(ObjectUtils.isNotEmpty(NON_EMPTY_MAP));     }      //-----------------------------------------------------------------------     @Test     public void testDefaultIfNull() {         final Object o = FOO;         final Object dflt = BAR;         assertSame(dflt, ObjectUtils.defaultIfNull(null, dflt), "dflt was not returned when o was null");         assertSame(o, ObjectUtils.defaultIfNull(o, dflt), "dflt was returned when o was not null");         assertSame(dflt, ObjectUtils.getIfNull(null, () -> dflt), "dflt was not returned when o was null");         assertSame(o, ObjectUtils.getIfNull(o, () -> dflt), "dflt was returned when o was not null");         assertSame(o, ObjectUtils.getIfNull(FOO, () -> dflt), "dflt was returned when o was not null");         assertSame(o, ObjectUtils.getIfNull("foo", () -> dflt), "dflt was returned when o was not null");         final MutableInt callsCounter = new MutableInt(0);         final Supplier<Object> countingDefaultSupplier = () -> {             callsCounter.increment();             return dflt;         };         ObjectUtils.getIfNull(o, countingDefaultSupplier);         assertEquals(0, callsCounter.getValue());         ObjectUtils.getIfNull(null, countingDefaultSupplier);         assertEquals(1, callsCounter.getValue());     }      @Test     public void testFirstNonNull() {         assertEquals("", ObjectUtils.firstNonNull(null, ""));         final String firstNonNullGenerics = ObjectUtils.firstNonNull(null, null, "123", "456");         assertEquals("123", firstNonNullGenerics);         assertEquals("123", ObjectUtils.firstNonNull("123", null, "456", null));         assertSame(Boolean.TRUE, ObjectUtils.firstNonNull(Boolean.TRUE));          // Explicitly pass in an empty array of Object type to ensure compiler doesn't complain of unchecked generic array creation         assertNull(ObjectUtils.firstNonNull());          // Cast to Object in line below ensures compiler doesn't complain of unchecked generic array creation         assertNull(ObjectUtils.firstNonNull(null, null));          assertNull(ObjectUtils.firstNonNull((Object) null));         assertNull(ObjectUtils.firstNonNull((Object[]) null));     }      @Test     public void testGetFirstNonNull() {         // first non null         assertEquals("", ObjectUtils.getFirstNonNull(() -> null, () -> ""));         // first encountered value is used         assertEquals("1", ObjectUtils.getFirstNonNull(() -> null, () -> "1", () -> "2", () -> null));         assertEquals("123", ObjectUtils.getFirstNonNull(() -> "123", () -> null, () -> "456"));         // don't evaluate suppliers after first value is found         assertEquals("123", ObjectUtils.getFirstNonNull(() -> null, () -> "123", () -> fail("Supplier after first non-null value should not be evaluated")));         // supplier returning null and null supplier both result in null         assertNull(ObjectUtils.getFirstNonNull(null, () -> null));         // Explicitly pass in an empty array of Object type to ensure compiler doesn't complain of unchecked generic array creation         assertNull(ObjectUtils.getFirstNonNull());         // supplier is null         assertNull(ObjectUtils.getFirstNonNull((Supplier<Object>) null));         // varargs array itself is null         assertNull(ObjectUtils.getFirstNonNull((Supplier<Object>[]) null));         // test different types         assertEquals(1, ObjectUtils.getFirstNonNull(() -> null, () -> 1));         assertEquals(Boolean.TRUE, ObjectUtils.getFirstNonNull(() -> null, () -> Boolean.TRUE));     }      /**      * Tests {@link ObjectUtils#anyNull(Object...)}.      */     @Test     public void testAnyNull() {         assertTrue(ObjectUtils.anyNull((Object) null));         assertTrue(ObjectUtils.anyNull(null, null, null));         assertTrue(ObjectUtils.anyNull(null, FOO, BAR));         assertTrue(ObjectUtils.anyNull(FOO, BAR, null));         assertTrue(ObjectUtils.anyNull(FOO, BAR, null, FOO, BAR));          assertFalse(ObjectUtils.anyNull());         assertFalse(ObjectUtils.anyNull(FOO));         assertFalse(ObjectUtils.anyNull(FOO, BAR, 1, Boolean.TRUE, new Object(), new Object[]{}));     }      /**      * Tests {@link ObjectUtils#anyNotNull(Object...)}.      */     @Test     public void testAnyNotNull() {         assertFalse(ObjectUtils.anyNotNull());         assertFalse(ObjectUtils.anyNotNull((Object) null));         assertFalse(ObjectUtils.anyNotNull((Object[]) null));         assertFalse(ObjectUtils.anyNotNull(null, null, null));          assertTrue(ObjectUtils.anyNotNull(FOO));         assertTrue(ObjectUtils.anyNotNull(null, FOO, null));         assertTrue(ObjectUtils.anyNotNull(null, null, null, null, FOO, BAR));     }      /**      * Tests {@link ObjectUtils#allNull(Object...)}.      */     @Test     public void testAllNull() {         assertTrue(ObjectUtils.allNull());         assertTrue(ObjectUtils.allNull((Object) null));         assertTrue(ObjectUtils.allNull((Object[]) null));         assertTrue(ObjectUtils.allNull(null, null, null));          assertFalse(ObjectUtils.allNull(FOO));         assertFalse(ObjectUtils.allNull(null, FOO, null));         assertFalse(ObjectUtils.allNull(null, null, null, null, FOO, BAR));     }      /**      * Tests {@link ObjectUtils#allNotNull(Object...)}.      */     @Test     public void testAllNotNull() {         assertFalse(ObjectUtils.allNotNull((Object) null));         assertFalse(ObjectUtils.allNotNull((Object[]) null));         assertFalse(ObjectUtils.allNotNull(null, null, null));         assertFalse(ObjectUtils.allNotNull(null, FOO, BAR));         assertFalse(ObjectUtils.allNotNull(FOO, BAR, null));         assertFalse(ObjectUtils.allNotNull(FOO, BAR, null, FOO, BAR));          assertTrue(ObjectUtils.allNotNull());         assertTrue(ObjectUtils.allNotNull(FOO));         assertTrue(ObjectUtils.allNotNull(FOO, BAR, 1, Boolean.TRUE, new Object(), new Object[]{}));     }      //-----------------------------------------------------------------------     @Test     public void testEquals() {         assertTrue(ObjectUtils.equals(null, null), "ObjectUtils.equals(null, null) returned false");         assertTrue(!ObjectUtils.equals(FOO, null), "ObjectUtils.equals(\"foo\", null) returned true");         assertTrue(!ObjectUtils.equals(null, BAR), "ObjectUtils.equals(null, \"bar\") returned true");         assertTrue(!ObjectUtils.equals(FOO, BAR), "ObjectUtils.equals(\"foo\", \"bar\") returned true");         assertTrue(ObjectUtils.equals(FOO, FOO), "ObjectUtils.equals(\"foo\", \"foo\") returned false");     }      @Test     public void testNotEqual() {         assertFalse(ObjectUtils.notEqual(null, null), "ObjectUtils.notEqual(null, null) returned false");         assertTrue(ObjectUtils.notEqual(FOO, null), "ObjectUtils.notEqual(\"foo\", null) returned true");         assertTrue(ObjectUtils.notEqual(null, BAR), "ObjectUtils.notEqual(null, \"bar\") returned true");         assertTrue(ObjectUtils.notEqual(FOO, BAR), "ObjectUtils.notEqual(\"foo\", \"bar\") returned true");         assertFalse(ObjectUtils.notEqual(FOO, FOO), "ObjectUtils.notEqual(\"foo\", \"foo\") returned false");     }      @Test     public void testHashCode() {         assertEquals(0, ObjectUtils.hashCode(null));         assertEquals("a".hashCode(), ObjectUtils.hashCode("a"));     }      @Test     public void testHashCodeMulti_multiple_emptyArray() {         final Object[] array = new Object[0];         assertEquals(1, ObjectUtils.hashCodeMulti(array));     }      @Test     public void testHashCodeMulti_multiple_nullArray() {         final Object[] array = null;         assertEquals(1, ObjectUtils.hashCodeMulti(array));     }      @Test     public void testHashCodeMulti_multiple_likeList() {         final List<Object> list0 = new ArrayList<>(Collections.emptyList());         assertEquals(list0.hashCode(), ObjectUtils.hashCodeMulti());          final List<Object> list1 = new ArrayList<>(Collections.singletonList("a"));         assertEquals(list1.hashCode(), ObjectUtils.hashCodeMulti("a"));          final List<Object> list2 = new ArrayList<>(Arrays.asList("a", "b"));         assertEquals(list2.hashCode(), ObjectUtils.hashCodeMulti("a", "b"));          final List<Object> list3 = new ArrayList<>(Arrays.asList("a", "b", "c"));         assertEquals(list3.hashCode(), ObjectUtils.hashCodeMulti("a", "b", "c"));     }      @Test     public void testIdentityToStringStringBuffer() {         final Integer i = Integer.valueOf(45);         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          final StringBuffer buffer = new StringBuffer();         ObjectUtils.identityToString(buffer, i);         assertEquals(expected, buffer.toString());          assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString((StringBuffer) null, "tmp"));         assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString(new StringBuffer(), null));     }      @Test     public void testIdentityToStringObjectNull() {         assertNull(ObjectUtils.identityToString(null));     }      @Test     public void testIdentityToStringInteger() {         final Integer i = Integer.valueOf(90);         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          assertEquals(expected, ObjectUtils.identityToString(i));     }      @Test     public void testIdentityToStringString() {         assertEquals(                 "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)),                 ObjectUtils.identityToString(FOO));     }      @Test     public void testIdentityToStringStringBuilder() {         final Integer i = Integer.valueOf(90);         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          final StringBuilder builder = new StringBuilder();         ObjectUtils.identityToString(builder, i);         assertEquals(expected, builder.toString());     }      @Test     public void testIdentityToStringStringBuilderInUse() {         final Integer i = Integer.valueOf(90);         final String expected = "ABC = java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          final StringBuilder builder = new StringBuilder("ABC = ");         ObjectUtils.identityToString(builder, i);         assertEquals(expected, builder.toString());     }      @Test     public void testIdentityToStringStringBuilderNullValue() {         assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString(new StringBuilder(), null));     }      @Test     public  void testIdentityToStringStringBuilderNullStringBuilder() {         assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString((StringBuilder) null, "tmp"));     }      @Test     public void testIdentityToStringStrBuilder() {         final Integer i = Integer.valueOf(102);         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          final StrBuilder builder = new StrBuilder();         ObjectUtils.identityToString(builder, i);         assertEquals(expected, builder.toString());          assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString((StrBuilder) null, "tmp"));          assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString(new StrBuilder(), null));     }      @Test     public void testIdentityToStringAppendable() throws IOException {         final Integer i = Integer.valueOf(121);         final String expected = "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i));          final Appendable appendable = new StringBuilder();         ObjectUtils.identityToString(appendable, i);         assertEquals(expected, appendable.toString());          assertThrows(NullPointerException.class, () -> ObjectUtils.identityToString((Appendable) null, "tmp"));          assertThrows(                 NullPointerException.class,                 () -> ObjectUtils.identityToString((Appendable) (new StringBuilder()), null));     }      @Test     public void testToString_Object() {         assertEquals("", ObjectUtils.toString(null) );         assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE) );     }      @Test     public void testToString_ObjectString() {         assertEquals(BAR, ObjectUtils.toString(null, BAR) );         assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE, BAR) );     }      @Test     public void testToString_SupplierString() {         assertEquals(null, ObjectUtils.toString(null, (Supplier<String>) null));         assertEquals(null, ObjectUtils.toString(null, () -> null));         // Pretend computing BAR is expensive.         assertEquals(BAR, ObjectUtils.toString(null, () -> BAR));         assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE, () -> BAR));     }      @SuppressWarnings("cast") // 1 OK, because we are checking for code change     @Test     public void testNull() {         assertNotNull(ObjectUtils.NULL);         // 1 Check that NULL really is a Null i.e. the definition has not been changed         assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null);         assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL));     }      @Test     public void testMax() {         final Calendar calendar = Calendar.getInstance();         final Date nonNullComparable1 = calendar.getTime();         final Date nonNullComparable2 = calendar.getTime();         final String[] nullArray = null;          calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );         final Date minComparable = calendar.getTime();          assertNotSame( nonNullComparable1, nonNullComparable2 );          assertNull(ObjectUtils.max( (String) null ) );         assertNull(ObjectUtils.max( nullArray ) );         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1 ) );         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, null ) );         assertSame( nonNullComparable1, ObjectUtils.max( null, nonNullComparable1, null ) );         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, nonNullComparable2 ) );         assertSame( nonNullComparable2, ObjectUtils.max( nonNullComparable2, nonNullComparable1 ) );         assertSame( nonNullComparable1, ObjectUtils.max( nonNullComparable1, minComparable ) );         assertSame( nonNullComparable1, ObjectUtils.max( minComparable, nonNullComparable1 ) );         assertSame( nonNullComparable1, ObjectUtils.max( null, minComparable, null, nonNullComparable1 ) );          assertNull( ObjectUtils.max(null, null) );     }      @Test     public void testMin() {         final Calendar calendar = Calendar.getInstance();         final Date nonNullComparable1 = calendar.getTime();         final Date nonNullComparable2 = calendar.getTime();         final String[] nullArray = null;          calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );         final Date minComparable = calendar.getTime();          assertNotSame( nonNullComparable1, nonNullComparable2 );          assertNull(ObjectUtils.min( (String) null ) );         assertNull(ObjectUtils.min( nullArray ) );         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1 ) );         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, null ) );         assertSame( nonNullComparable1, ObjectUtils.min( null, nonNullComparable1, null ) );         assertSame( nonNullComparable1, ObjectUtils.min( nonNullComparable1, nonNullComparable2 ) );         assertSame( nonNullComparable2, ObjectUtils.min( nonNullComparable2, nonNullComparable1 ) );         assertSame( minComparable, ObjectUtils.min( nonNullComparable1, minComparable ) );         assertSame( minComparable, ObjectUtils.min( minComparable, nonNullComparable1 ) );         assertSame( minComparable, ObjectUtils.min( null, nonNullComparable1, null, minComparable ) );          assertNull( ObjectUtils.min(null, null) );     }      /**      * Tests {@link ObjectUtils#compare(Comparable, Comparable, boolean)}.      */     @Test     public void testCompare() {         final Integer one = Integer.valueOf(1);         final Integer two = Integer.valueOf(2);         final Integer nullValue = null;          assertEquals(0, ObjectUtils.compare(nullValue, nullValue), "Null Null false");         assertEquals(0, ObjectUtils.compare(nullValue, nullValue, true), "Null Null true");          assertEquals(-1, ObjectUtils.compare(nullValue, one), "Null one false");         assertEquals(1, ObjectUtils.compare(nullValue, one, true), "Null one true");          assertEquals(1, ObjectUtils.compare(one, nullValue), "one Null false");         assertEquals(-1, ObjectUtils.compare(one, nullValue, true), "one Null true");          assertEquals(-1, ObjectUtils.compare(one, two), "one two false");         assertEquals(-1, ObjectUtils.compare(one, two, true), "one two true");     }      @Test     public void testMedian() {         assertEquals("foo", ObjectUtils.median("foo"));         assertEquals("bar", ObjectUtils.median("foo", "bar"));         assertEquals("baz", ObjectUtils.median("foo", "bar", "baz"));         assertEquals("baz", ObjectUtils.median("foo", "bar", "baz", "blah"));         assertEquals("blah", ObjectUtils.median("foo", "bar", "baz", "blah", "wah"));         assertEquals(Integer.valueOf(5),             ObjectUtils.median(Integer.valueOf(1), Integer.valueOf(5), Integer.valueOf(10)));         assertEquals(             Integer.valueOf(7),             ObjectUtils.median(Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8),                 Integer.valueOf(9)));         assertEquals(Integer.valueOf(6),             ObjectUtils.median(Integer.valueOf(5), Integer.valueOf(6), Integer.valueOf(7), Integer.valueOf(8)));     }      @Test     public void testMedian_nullItems() {         assertThrows(NullPointerException.class, () -> ObjectUtils.median((String[]) null));     }      @Test     public void testMedian_emptyItems() {         assertThrows(IllegalArgumentException.class, ObjectUtils::<String>median);     }      @Test     public void testComparatorMedian() {         final CharSequenceComparator cmp = new CharSequenceComparator();         final NonComparableCharSequence foo = new NonComparableCharSequence("foo");         final NonComparableCharSequence bar = new NonComparableCharSequence("bar");         final NonComparableCharSequence baz = new NonComparableCharSequence("baz");         final NonComparableCharSequence blah = new NonComparableCharSequence("blah");         final NonComparableCharSequence wah = new NonComparableCharSequence("wah");         assertSame(foo, ObjectUtils.median(cmp, foo));         assertSame(bar, ObjectUtils.median(cmp, foo, bar));         assertSame(baz, ObjectUtils.median(cmp, foo, bar, baz));         assertSame(baz, ObjectUtils.median(cmp, foo, bar, baz, blah));         assertSame(blah, ObjectUtils.median(cmp, foo, bar, baz, blah, wah));     }      @Test     public void testComparatorMedian_nullComparator() {         assertThrows(NullPointerException.class,                 () -> ObjectUtils.median((Comparator<CharSequence>) null, new NonComparableCharSequence("foo")));     }      @Test     public void testComparatorMedian_nullItems() {         assertThrows(NullPointerException.class,                 () -> ObjectUtils.median(new CharSequenceComparator(), (CharSequence[]) null));     }      @Test     public void testComparatorMedian_emptyItems() {         assertThrows(IllegalArgumentException.class, () -> ObjectUtils.median(new CharSequenceComparator()));     }      @Test     public void testMode() {         assertNull(ObjectUtils.mode((Object[]) null));         assertNull(ObjectUtils.mode());         assertNull(ObjectUtils.mode("foo", "bar", "baz"));         assertNull(ObjectUtils.mode("foo", "bar", "baz", "foo", "bar"));         assertEquals("foo", ObjectUtils.mode("foo", "bar", "baz", "foo"));         assertEquals(Integer.valueOf(9),             ObjectUtils.mode("foo", "bar", "baz", Integer.valueOf(9), Integer.valueOf(10), Integer.valueOf(9)));     }      /**      * Tests {@link ObjectUtils#clone(Object)} with a cloneable object.      */     @Test     public void testCloneOfCloneable() {         final CloneableString string = new CloneableString("apache");         final CloneableString stringClone = ObjectUtils.clone(string);         assertEquals("apache", stringClone.getValue());     }      /**      * Tests {@link ObjectUtils#clone(Object)} with a not cloneable object.      */     @Test     public void testCloneOfNotCloneable() {         final String string = new String("apache");         assertNull(ObjectUtils.clone(string));     }      /**      * Tests {@link ObjectUtils#clone(Object)} with an uncloneable object.      */     @Test     public void testCloneOfUncloneable() {         final UncloneableString string = new UncloneableString("apache");         final CloneFailedException e = assertThrows(CloneFailedException.class, () -> ObjectUtils.clone(string));         assertEquals(NoSuchMethodException.class, e.getCause().getClass());     }      /**      * Tests {@link ObjectUtils#clone(Object)} with an object array.      */     @Test     public void testCloneOfStringArray() {         assertTrue(Arrays.deepEquals(             new String[]{"string"}, ObjectUtils.clone(new String[]{"string"})));     }      /**      * Tests {@link ObjectUtils#clone(Object)} with an array of primitives.      */     @Test     public void testCloneOfPrimitiveArray() {         assertArrayEquals(new int[]{1}, ObjectUtils.clone(new int[]{1}));     }      /**      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a cloneable object.      */     @Test     public void testPossibleCloneOfCloneable() {         final CloneableString string = new CloneableString("apache");         final CloneableString stringClone = ObjectUtils.cloneIfPossible(string);         assertEquals("apache", stringClone.getValue());     }      /**      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with a not cloneable object.      */     @Test     public void testPossibleCloneOfNotCloneable() {         final String string = new String("apache");         assertSame(string, ObjectUtils.cloneIfPossible(string));     }      /**      * Tests {@link ObjectUtils#cloneIfPossible(Object)} with an uncloneable object.      */     @Test     public void testPossibleCloneOfUncloneable() {         final UncloneableString string = new UncloneableString("apache");         final CloneFailedException e = assertThrows(CloneFailedException.class, () -> ObjectUtils.cloneIfPossible(string));         assertEquals(NoSuchMethodException.class, e.getCause().getClass());     }      @Test     public void testConstMethods() {          // To truly test the CONST() method, we'd want to look in the         // bytecode to see if the literals were folded into the         // class, or if the bytecode kept the method call.          assertTrue(ObjectUtils.CONST(true), "CONST(boolean)");         assertEquals((byte) 3, ObjectUtils.CONST((byte) 3), "CONST(byte)");         assertEquals((char) 3, ObjectUtils.CONST((char) 3), "CONST(char)");         assertEquals((short) 3, ObjectUtils.CONST((short) 3), "CONST(short)");         assertEquals(3, ObjectUtils.CONST(3), "CONST(int)");         assertEquals(3L, ObjectUtils.CONST(3L), "CONST(long)");         assertEquals(3f, ObjectUtils.CONST(3f), "CONST(float)");         assertEquals(3.0, ObjectUtils.CONST(3.0), "CONST(double)");         assertEquals("abc", ObjectUtils.CONST("abc"), "CONST(Object)");          // Make sure documentation examples from Javadoc all work         // (this fixed a lot of my bugs when I these!)         //         // My bugs should be in a software engineering textbook         // for "Can you screw this up?"  The answer is, yes,         // you can even screw this up.  (When you == Julius)         // .         final boolean MAGIC_FLAG = ObjectUtils.CONST(true);         final byte MAGIC_BYTE1 = ObjectUtils.CONST((byte) 127);         final byte MAGIC_BYTE2 = ObjectUtils.CONST_BYTE(127);         final char MAGIC_CHAR = ObjectUtils.CONST('a');         final short MAGIC_SHORT1 = ObjectUtils.CONST((short) 123);         final short MAGIC_SHORT2 = ObjectUtils.CONST_SHORT(127);         final int MAGIC_INT = ObjectUtils.CONST(123);         final long MAGIC_LONG1 = ObjectUtils.CONST(123L);         final long MAGIC_LONG2 = ObjectUtils.CONST(3);         final float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);         final double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);         final String MAGIC_STRING = ObjectUtils.CONST("abc");          assertTrue(MAGIC_FLAG);         assertEquals(127, MAGIC_BYTE1);         assertEquals(127, MAGIC_BYTE2);         assertEquals('a', MAGIC_CHAR);         assertEquals(123, MAGIC_SHORT1);         assertEquals(127, MAGIC_SHORT2);         assertEquals(123, MAGIC_INT);         assertEquals(123, MAGIC_LONG1);         assertEquals(3, MAGIC_LONG2);         assertEquals(1.0f, MAGIC_FLOAT);         assertEquals(1.0, MAGIC_DOUBLE);         assertEquals("abc", MAGIC_STRING);         assertThrows(                 IllegalArgumentException.class,                 () -> ObjectUtils.CONST_BYTE(-129),                 "CONST_BYTE(-129): IllegalArgumentException should have been thrown.");         assertThrows(                 IllegalArgumentException.class,                 () -> ObjectUtils.CONST_BYTE(128),                 "CONST_BYTE(128): IllegalArgumentException should have been thrown.");         assertThrows(                 IllegalArgumentException.class,                 () -> ObjectUtils.CONST_SHORT(-32769),                 "CONST_SHORT(-32769): IllegalArgumentException should have been thrown.");         assertThrows(                 IllegalArgumentException.class,                 () -> ObjectUtils.CONST_BYTE(32768),                 "CONST_SHORT(32768): IllegalArgumentException should have been thrown.");     }      /**      * String that is cloneable.      */     static final class CloneableString extends MutableObject<String> implements Cloneable {         private static final long serialVersionUID = 1L;         CloneableString(final String s) {             super(s);         }          @Override         public CloneableString clone() throws CloneNotSupportedException {             return (CloneableString) super.clone();         }     }      /**      * String that is not cloneable.      */     static final class UncloneableString extends MutableObject<String> implements Cloneable {         private static final long serialVersionUID = 1L;         UncloneableString(final String s) {             super(s);         }     }      static final class NonComparableCharSequence implements CharSequence {         final String value;          /**          * Create a new NonComparableCharSequence instance.          *          * @param value the CharSequence value          */         NonComparableCharSequence(final String value) {             super();             Validate.notNull(value);             this.value = value;         }          @Override         public char charAt(final int arg0) {             return value.charAt(arg0);         }          @Override         public int length() {             return value.length();         }          @Override         public CharSequence subSequence(final int arg0, final int arg1) {             return value.subSequence(arg0, arg1);         }          @Override         public String toString() {             return value;         }     }      static final class CharSequenceComparator implements Comparator<CharSequence> {          @Override         public int compare(final CharSequence o1, final CharSequence o2) {             return o1.toString().compareTo(o2.toString());         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Empty/Blank methods  */ public class StringUtilsEmptyBlankTest  {      @Test     public void testIsEmpty() {         assertTrue(StringUtils.isEmpty(null));         assertTrue(StringUtils.isEmpty(""));         assertFalse(StringUtils.isEmpty(" "));         assertFalse(StringUtils.isEmpty("foo"));         assertFalse(StringUtils.isEmpty("  foo  "));     }      @Test     public void testIsNotEmpty() {         assertFalse(StringUtils.isNotEmpty(null));         assertFalse(StringUtils.isNotEmpty(""));         assertTrue(StringUtils.isNotEmpty(" "));         assertTrue(StringUtils.isNotEmpty("foo"));         assertTrue(StringUtils.isNotEmpty("  foo  "));     }      @Test     public void testIsAnyEmpty() {         assertTrue(StringUtils.isAnyEmpty((String) null));         assertFalse(StringUtils.isAnyEmpty((String[]) null));         assertTrue(StringUtils.isAnyEmpty(null, "foo"));         assertTrue(StringUtils.isAnyEmpty("", "bar"));         assertTrue(StringUtils.isAnyEmpty("bob", ""));         assertTrue(StringUtils.isAnyEmpty("  bob  ", null));         assertFalse(StringUtils.isAnyEmpty(" ", "bar"));         assertFalse(StringUtils.isAnyEmpty("foo", "bar"));     }      @Test     public void testIsNoneEmpty() {         assertFalse(StringUtils.isNoneEmpty((String) null));         assertTrue(StringUtils.isNoneEmpty((String[]) null));         assertFalse(StringUtils.isNoneEmpty(null, "foo"));         assertFalse(StringUtils.isNoneEmpty("", "bar"));         assertFalse(StringUtils.isNoneEmpty("bob", ""));         assertFalse(StringUtils.isNoneEmpty("  bob  ", null));         assertTrue(StringUtils.isNoneEmpty(" ", "bar"));         assertTrue(StringUtils.isNoneEmpty("foo", "bar"));     }      @Test     public void testIsAllEmpty() {         assertTrue(StringUtils.isAllEmpty());         assertTrue(StringUtils.isAllEmpty());         assertTrue(StringUtils.isAllEmpty((String) null));         assertTrue(StringUtils.isAllEmpty((String[]) null));         assertFalse(StringUtils.isAllEmpty(null, "foo"));         assertFalse(StringUtils.isAllEmpty("", "bar"));         assertFalse(StringUtils.isAllEmpty("bob", ""));         assertFalse(StringUtils.isAllEmpty("  bob  ", null));         assertFalse(StringUtils.isAllEmpty(" ", "bar"));         assertFalse(StringUtils.isAllEmpty("foo", "bar"));         assertTrue(StringUtils.isAllEmpty("", null));     }      @Test     public void testIsBlank() {         assertTrue(StringUtils.isBlank(null));         assertTrue(StringUtils.isBlank(""));         assertTrue(StringUtils.isBlank(StringUtilsTest.WHITESPACE));         assertFalse(StringUtils.isBlank("foo"));         assertFalse(StringUtils.isBlank("  foo  "));     }      @Test     public void testIsNotBlank() {         assertFalse(StringUtils.isNotBlank(null));         assertFalse(StringUtils.isNotBlank(""));         assertFalse(StringUtils.isNotBlank(StringUtilsTest.WHITESPACE));         assertTrue(StringUtils.isNotBlank("foo"));         assertTrue(StringUtils.isNotBlank("  foo  "));     }      @Test     public void testIsAnyBlank() {         assertTrue(StringUtils.isAnyBlank((String) null));         assertFalse(StringUtils.isAnyBlank((String[]) null));         assertTrue(StringUtils.isAnyBlank(null, "foo"));         assertTrue(StringUtils.isAnyBlank(null, null));         assertTrue(StringUtils.isAnyBlank("", "bar"));         assertTrue(StringUtils.isAnyBlank("bob", ""));         assertTrue(StringUtils.isAnyBlank("  bob  ", null));         assertTrue(StringUtils.isAnyBlank(" ", "bar"));         assertFalse(StringUtils.isAnyBlank("foo", "bar"));     }      @Test     public void testIsNoneBlank() {         assertFalse(StringUtils.isNoneBlank((String) null));         assertTrue(StringUtils.isNoneBlank((String[]) null));         assertFalse(StringUtils.isNoneBlank(null, "foo"));         assertFalse(StringUtils.isNoneBlank(null, null));         assertFalse(StringUtils.isNoneBlank("", "bar"));         assertFalse(StringUtils.isNoneBlank("bob", ""));         assertFalse(StringUtils.isNoneBlank("  bob  ", null));         assertFalse(StringUtils.isNoneBlank(" ", "bar"));         assertTrue(StringUtils.isNoneBlank("foo", "bar"));     }      @Test     public void testIsAllBlank() {         assertTrue(StringUtils.isAllBlank((String) null));         assertTrue(StringUtils.isAllBlank((String[]) null));         assertTrue(StringUtils.isAllBlank(null, null));         assertTrue(StringUtils.isAllBlank(null, " "));         assertFalse(StringUtils.isAllBlank(null, "foo"));         assertFalse(StringUtils.isAllBlank("", "bar"));         assertFalse(StringUtils.isAllBlank("bob", ""));         assertFalse(StringUtils.isAllBlank("  bob  ", null));         assertFalse(StringUtils.isAllBlank(" ", "bar"));         assertFalse(StringUtils.isAllBlank("foo", "bar"));     }      @Test     public void testFirstNonBlank() {         assertNull(StringUtils.firstNonBlank());         assertNull(StringUtils.firstNonBlank((String[]) null));         assertNull(StringUtils.firstNonBlank(null, null, null));         assertNull(StringUtils.firstNonBlank(null, "", " "));         assertNull(StringUtils.firstNonBlank(null, null, " "));         assertEquals("zz", StringUtils.firstNonBlank(null, "zz"));         assertEquals("abc", StringUtils.firstNonBlank("abc"));         assertEquals("xyz", StringUtils.firstNonBlank(null, "xyz"));         assertEquals("xyz", StringUtils.firstNonBlank(null, "xyz", "abc"));     }      @Test     public void testFirstNonEmpty() {         assertNull(StringUtils.firstNonEmpty());         assertNull(StringUtils.firstNonEmpty((String[]) null));         assertNull(StringUtils.firstNonEmpty(null, null, null));         assertEquals(" ", StringUtils.firstNonEmpty(null, "", " "));         assertNull(StringUtils.firstNonEmpty(null, null, ""));         assertEquals("zz", StringUtils.firstNonEmpty(null, "zz"));         assertEquals("abc", StringUtils.firstNonEmpty("abc"));         assertEquals("xyz", StringUtils.firstNonEmpty(null, "xyz"));         assertEquals("xyz", StringUtils.firstNonEmpty(null, "xyz", "abc"));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.allOf; import static org.hamcrest.Matchers.greaterThanOrEqualTo; import static org.hamcrest.Matchers.is; import static org.hamcrest.Matchers.lessThanOrEqualTo; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.fail;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.Random;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.RandomStringUtils}.  */ public class RandomStringUtilsTest {      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new RandomStringUtils());         final Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(RandomStringUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(RandomStringUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     /**      * Test the implementation      */     @Test     public void testRandomStringUtils() {         String r1 = RandomStringUtils.random(50);         assertEquals(50, r1.length(), "random(50) length");         String r2 = RandomStringUtils.random(50);         assertEquals(50, r2.length(), "random(50) length");         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomAscii(50);         assertEquals(50, r1.length(), "randomAscii(50) length");         for (int i = 0; i < r1.length(); i++) {             assertTrue(r1.charAt(i) >= 32 && r1.charAt(i) <= 127, "char between 32 and 127");         }         r2 = RandomStringUtils.randomAscii(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomAlphabetic(50);         assertEquals(50, r1.length(), "randomAlphabetic(50)");         for (int i = 0; i < r1.length(); i++) {             assertTrue(Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)), "r1 contains alphabetic");         }         r2 = RandomStringUtils.randomAlphabetic(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomAlphanumeric(50);         assertEquals(50, r1.length(), "randomAlphanumeric(50)");         for (int i = 0; i < r1.length(); i++) {             assertTrue(Character.isLetterOrDigit(r1.charAt(i)), "r1 contains alphanumeric");         }         r2 = RandomStringUtils.randomAlphabetic(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomGraph(50);         assertEquals(50, r1.length(), "randomGraph(50) length");         for (int i = 0; i < r1.length(); i++) {             assertTrue(r1.charAt(i) >= 33 && r1.charAt(i) <= 126, "char between 33 and 126");         }         r2 = RandomStringUtils.randomGraph(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomNumeric(50);         assertEquals(50, r1.length(), "randomNumeric(50)");         for (int i = 0; i < r1.length(); i++) {             assertTrue(Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)), "r1 contains numeric");         }         r2 = RandomStringUtils.randomNumeric(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.randomPrint(50);         assertEquals(50, r1.length(), "randomPrint(50) length");         for (int i = 0; i < r1.length(); i++) {             assertTrue(r1.charAt(i) >= 32 && r1.charAt(i) <= 126, "char between 32 and 126");         }         r2 = RandomStringUtils.randomPrint(50);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          String set = "abcdefg";         r1 = RandomStringUtils.random(50, set);         assertEquals(50, r1.length(), "random(50, \"abcdefg\")");         for (int i = 0; i < r1.length(); i++) {             assertTrue(set.indexOf(r1.charAt(i)) > -1, "random char in set");         }         r2 = RandomStringUtils.random(50, set);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.random(50, (String) null);         assertEquals(50, r1.length(), "random(50) length");         r2 = RandomStringUtils.random(50, (String) null);         assertEquals(50, r2.length(), "random(50) length");         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          set = "stuvwxyz";         r1 = RandomStringUtils.random(50, set.toCharArray());         assertEquals(50, r1.length(), "random(50, \"stuvwxyz\")");         for (int i = 0; i < r1.length(); i++) {             assertTrue(set.indexOf(r1.charAt(i)) > -1, "random char in set");         }         r2 = RandomStringUtils.random(50, set);         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          r1 = RandomStringUtils.random(50, (char[]) null);         assertEquals(50, r1.length(), "random(50) length");         r2 = RandomStringUtils.random(50, (char[]) null);         assertEquals(50, r2.length(), "random(50) length");         assertTrue(!r1.equals(r2), "!r1.equals(r2)");          final long seed = System.currentTimeMillis();         r1 = RandomStringUtils.random(50, 0, 0, true, true, null, new Random(seed));         r2 = RandomStringUtils.random(50, 0, 0, true, true, null, new Random(seed));         assertEquals(r1, r2, "r1.equals(r2)");          r1 = RandomStringUtils.random(0);         assertEquals("", r1, "random(0).equals(\"\")");     }      @Test     public void testLANG805() {         final long seed = System.currentTimeMillis();         assertEquals("aaa", RandomStringUtils.random(3, 0, 0, false, false, new char[]{'a'}, new Random(seed)));     }      @Test     public void testLANG807() {         final IllegalArgumentException ex =                 assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(3, 5, 5, false, false));         final String msg = ex.getMessage();         assertTrue(msg.contains("start"), "Message (" + msg + ") must contain 'start'");         assertTrue(msg.contains("end"), "Message (" + msg + ") must contain 'end'");     }      @Test     public void testExceptions() {         final char[] DUMMY = new char[]{'a'}; // valid char array         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, true, true));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, DUMMY));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(1, new char[0]));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, ""));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, (String) null));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, 'a', 'z', false, false));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY));         assertThrows(                 IllegalArgumentException.class,                 () -> RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(8, 32, 48, false, true));         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(8, 32, 65, true, false));     }      /**      * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric      * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7      */     @Test     public void testRandomAlphaNumeric() {         final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};         final boolean[] found = {false, false, false, false, false, false};         for (int i = 0; i < 100; i++) {             final String randString = RandomStringUtils.randomAlphanumeric(10);             for (int j = 0; j < testChars.length; j++) {                 if (randString.indexOf(testChars[j]) > 0) {                     found[j] = true;                 }             }         }         for (int i = 0; i < testChars.length; i++) {             assertTrue(found[i],                     "alphanumeric character not generated in 1000 attempts: " +                             testChars[i] + " -- repeated failures indicate a problem ");         }     }      /**      * Make sure '0' and '9' are generated by randomNumeric      * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46      */     @Test     public void testRandomNumeric() {         final char[] testChars = {'0', '9'};         final boolean[] found = {false, false};         for (int i = 0; i < 100; i++) {             final String randString = RandomStringUtils.randomNumeric(10);             for (int j = 0; j < testChars.length; j++) {                 if (randString.indexOf(testChars[j]) > 0) {                     found[j] = true;                 }             }         }         for (int i = 0; i < testChars.length; i++) {             assertTrue(found[i],                     "digit not generated in 1000 attempts: " + testChars[i] +                             " -- repeated failures indicate a problem ");         }     }      /**      * Make sure boundary alpha characters are generated by randomAlphabetic      * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8      */     @Test     public void testRandomAlphabetic() {         final char[] testChars = {'a', 'z', 'A', 'Z'};         final boolean[] found = {false, false, false, false};         for (int i = 0; i < 100; i++) {             final String randString = RandomStringUtils.randomAlphabetic(10);             for (int j = 0; j < testChars.length; j++) {                 if (randString.indexOf(testChars[j]) > 0) {                     found[j] = true;                 }             }         }         for (int i = 0; i < testChars.length; i++) {             assertTrue(found[i],                     "alphanumeric character not generated in 1000 attempts: " + testChars[i] +                             " -- repeated failures indicate a problem ");         }     }      /**      * Make sure 32 and 127 are generated by randomNumeric      * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5      */     @Test     public void testRandomAscii() {         final char[] testChars = {(char) 32, (char) 126};         final boolean[] found = {false, false};         for (int i = 0; i < 100; i++) {             final String randString = RandomStringUtils.randomAscii(10);             for (int j = 0; j < testChars.length; j++) {                 if (randString.indexOf(testChars[j]) > 0) {                     found[j] = true;                 }             }         }         for (int i = 0; i < testChars.length; i++) {             assertTrue(found[i],                     "ascii character not generated in 1000 attempts: " + (int) testChars[i] +                             " -- repeated failures indicate a problem");         }     }      @Test     public void testRandomAsciiRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{ASCII}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomAscii(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      @Test     public void testRandomAlphabeticRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{Alpha}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomAlphabetic(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      @Test     public void testRandomAlphanumericRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{Alnum}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomAlphanumeric(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      @Test     public void testRandomGraphRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{Graph}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomGraph(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      @Test     public void testRandomNumericRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{Digit}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomNumeric(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      @Test     public void testRandomPrintRange() {         final int expectedMinLengthInclusive = 1;         final int expectedMaxLengthExclusive = 11;         final String pattern = "^\\p{Print}{" + expectedMinLengthInclusive + ',' + expectedMaxLengthExclusive + "}$";          int maxCreatedLength = expectedMinLengthInclusive;         int minCreatedLength = expectedMaxLengthExclusive - 1;         for (int i = 0; i < 1000; i++) {             final String s = RandomStringUtils.randomPrint(expectedMinLengthInclusive, expectedMaxLengthExclusive);             assertThat("within range", s.length(), allOf(greaterThanOrEqualTo(expectedMinLengthInclusive), lessThanOrEqualTo(expectedMaxLengthExclusive - 1)));             assertTrue(s.matches(pattern), s);              if (s.length() < minCreatedLength) {                 minCreatedLength = s.length();             }              if (s.length() > maxCreatedLength) {                 maxCreatedLength = s.length();             }         }         assertThat("min generated, may fail randomly rarely", minCreatedLength, is(expectedMinLengthInclusive));         assertThat("max generated, may fail randomly rarely", maxCreatedLength, is(expectedMaxLengthExclusive - 1));     }      /**      * Test homogeneity of random strings generated --      * i.e., test that characters show up with expected frequencies      * in generated strings.  Will fail randomly about 1 in 1000 times.      * Repeated failures indicate a problem.      */     @Test     public void testRandomStringUtilsHomog() {         final String set = "abc";         final char[] chars = set.toCharArray();         String gen = "";         final int[] counts = {0, 0, 0};         final int[] expected = {200, 200, 200};         for (int i = 0; i< 100; i++) {             gen = RandomStringUtils.random(6, chars);             for (int j = 0; j < 6; j++) {                 switch (gen.charAt(j)) {                     case 'a': {                         counts[0]++;                         break;                     }                     case 'b': {                         counts[1]++;                         break;                     }                     case 'c': {                         counts[2]++;                         break;                     }                     default: {                         fail("generated character not in set");                     }                 }             }         }         // Perform chi-square test with df = 3-1 = 2, testing at .001 level         assertTrue(chiSquare(expected, counts) < 13.82, "test homogeneity -- will fail about 1 in 1000 times");     }      /**      * Computes Chi-Square statistic given observed and expected counts      * @param observed array of observed frequency counts      * @param expected array of expected frequency counts      */     private double chiSquare(final int[] expected, final int[] observed) {         double sumSq = 0.0d;         double dev = 0.0d;         for (int i = 0; i < observed.length; i++) {             dev = observed[i] - expected[i];             sumSq += dev * dev / expected[i];         }         return sumSq;     }      /**      * Checks if the string got by {@link RandomStringUtils#random(int)}      * can be converted to UTF-8 and back without loss.      *      * @see <a href="https://issues.apache.org/jira/browse/LANG-100">LANG-100</a>      */     @Test     public void testLang100() {         final int size = 5000;         final Charset charset = StandardCharsets.UTF_8;         final String orig = RandomStringUtils.random(size);         final byte[] bytes = orig.getBytes(charset);         final String copy = new String(bytes, charset);          // for a verbose compare:         for (int i=0; i < orig.length() && i < copy.length(); i++) {             final char o = orig.charAt(i);             final char c = copy.charAt(i);             assertEquals(o, c,                     "differs at " + i + "(" + Integer.toHexString(Character.valueOf(o).hashCode()) + "," +                             Integer.toHexString(Character.valueOf(c).hashCode()) + ")");         }         // compare length also         assertEquals(orig.length(), copy.length());         // just to be complete         assertEquals(orig, copy);     }       /**      * Test for LANG-1286. Creates situation where old code would      * overflow a char and result in a code point outside the specified      * range.      */     @Test     public void testCharOverflow() {         final int start = Character.MAX_VALUE;         final int end = Integer.MAX_VALUE;          @SuppressWarnings("serial")         final         Random fixedRandom = new Random() {             @Override             public int nextInt(final int n) {                 // Prevents selection of 'start' as the character                 return super.nextInt(n - 1) + 1;             }         };          final String result = RandomStringUtils.random(2, start, end, false, false, null, fixedRandom);         final int c = result.codePointAt(0);         assertTrue(c >= start && c < end, String.format("Character '%d' not in range [%d,%d).", c, start, end));     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;   /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - StartsWith/EndsWith methods  */ public class StringUtilsStartsEndsWithTest {     private static final String foo    = "foo";     private static final String bar    = "bar";     private static final String foobar = "foobar";     private static final String FOO    = "FOO";     private static final String BAR    = "BAR";     private static final String FOOBAR = "FOOBAR";      //-----------------------------------------------------------------------      /**      * Test StringUtils.startsWith()      */     @Test     public void testStartsWith() {         assertTrue(StringUtils.startsWith(null, null), "startsWith(null, null)");         assertFalse(StringUtils.startsWith(FOOBAR, null), "startsWith(FOOBAR, null)");         assertFalse(StringUtils.startsWith(null, FOO), "startsWith(null, FOO)");         assertTrue(StringUtils.startsWith(FOOBAR, ""), "startsWith(FOOBAR, \"\")");          assertTrue(StringUtils.startsWith(foobar, foo), "startsWith(foobar, foo)");         assertTrue(StringUtils.startsWith(FOOBAR, FOO), "startsWith(FOOBAR, FOO)");         assertFalse(StringUtils.startsWith(foobar, FOO), "startsWith(foobar, FOO)");         assertFalse(StringUtils.startsWith(FOOBAR, foo), "startsWith(FOOBAR, foo)");          assertFalse(StringUtils.startsWith(foo, foobar), "startsWith(foo, foobar)");         assertFalse(StringUtils.startsWith(bar, foobar), "startsWith(foo, foobar)");          assertFalse(StringUtils.startsWith(foobar, bar), "startsWith(foobar, bar)");         assertFalse(StringUtils.startsWith(FOOBAR, BAR), "startsWith(FOOBAR, BAR)");         assertFalse(StringUtils.startsWith(foobar, BAR), "startsWith(foobar, BAR)");         assertFalse(StringUtils.startsWith(FOOBAR, bar), "startsWith(FOOBAR, bar)");     }      /**      * Test StringUtils.testStartsWithIgnoreCase()      */     @Test     public void testStartsWithIgnoreCase() {         assertTrue(StringUtils.startsWithIgnoreCase(null, null), "startsWithIgnoreCase(null, null)");         assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, null), "startsWithIgnoreCase(FOOBAR, null)");         assertFalse(StringUtils.startsWithIgnoreCase(null, FOO), "startsWithIgnoreCase(null, FOO)");         assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, ""), "startsWithIgnoreCase(FOOBAR, \"\")");          assertTrue(StringUtils.startsWithIgnoreCase(foobar, foo), "startsWithIgnoreCase(foobar, foo)");         assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, FOO), "startsWithIgnoreCase(FOOBAR, FOO)");         assertTrue(StringUtils.startsWithIgnoreCase(foobar, FOO), "startsWithIgnoreCase(foobar, FOO)");         assertTrue(StringUtils.startsWithIgnoreCase(FOOBAR, foo), "startsWithIgnoreCase(FOOBAR, foo)");          assertFalse(StringUtils.startsWithIgnoreCase(foo, foobar), "startsWithIgnoreCase(foo, foobar)");         assertFalse(StringUtils.startsWithIgnoreCase(bar, foobar), "startsWithIgnoreCase(foo, foobar)");          assertFalse(StringUtils.startsWithIgnoreCase(foobar, bar), "startsWithIgnoreCase(foobar, bar)");         assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, BAR), "startsWithIgnoreCase(FOOBAR, BAR)");         assertFalse(StringUtils.startsWithIgnoreCase(foobar, BAR), "startsWithIgnoreCase(foobar, BAR)");         assertFalse(StringUtils.startsWithIgnoreCase(FOOBAR, bar), "startsWithIgnoreCase(FOOBAR, bar)");     }      @Test     public void testStartsWithAny() {         assertFalse(StringUtils.startsWithAny(null, (String[]) null));         assertFalse(StringUtils.startsWithAny(null, "abc"));         assertFalse(StringUtils.startsWithAny("abcxyz", (String[]) null));         assertFalse(StringUtils.startsWithAny("abcxyz"));         assertTrue(StringUtils.startsWithAny("abcxyz", "abc"));         assertTrue(StringUtils.startsWithAny("abcxyz", null, "xyz", "abc"));         assertFalse(StringUtils.startsWithAny("abcxyz", null, "xyz", "abcd"));         assertTrue(StringUtils.startsWithAny("abcxyz", ""));         assertFalse(StringUtils.startsWithAny("abcxyz", null, "xyz", "ABCX"));         assertFalse(StringUtils.startsWithAny("ABCXYZ", null, "xyz", "abc"));          assertTrue(StringUtils.startsWithAny("abcxyz", new StringBuilder("xyz"), new StringBuffer("abc")), "StringUtils.startsWithAny(abcxyz, StringBuilder(xyz), StringBuffer(abc))");         assertTrue(StringUtils.startsWithAny(new StringBuffer("abcxyz"), new StringBuilder("xyz"), new StringBuffer("abc")), "StringUtils.startsWithAny(StringBuffer(abcxyz), StringBuilder(xyz), StringBuffer(abc))");     }       /**      * Test StringUtils.endsWith()      */     @Test     public void testEndsWith() {         assertTrue(StringUtils.endsWith(null, null), "endsWith(null, null)");         assertFalse(StringUtils.endsWith(FOOBAR, null), "endsWith(FOOBAR, null)");         assertFalse(StringUtils.endsWith(null, FOO), "endsWith(null, FOO)");         assertTrue(StringUtils.endsWith(FOOBAR, ""), "endsWith(FOOBAR, \"\")");          assertFalse(StringUtils.endsWith(foobar, foo), "endsWith(foobar, foo)");         assertFalse(StringUtils.endsWith(FOOBAR, FOO), "endsWith(FOOBAR, FOO)");         assertFalse(StringUtils.endsWith(foobar, FOO), "endsWith(foobar, FOO)");         assertFalse(StringUtils.endsWith(FOOBAR, foo), "endsWith(FOOBAR, foo)");          assertFalse(StringUtils.endsWith(foo, foobar), "endsWith(foo, foobar)");         assertFalse(StringUtils.endsWith(bar, foobar), "endsWith(foo, foobar)");          assertTrue(StringUtils.endsWith(foobar, bar), "endsWith(foobar, bar)");         assertTrue(StringUtils.endsWith(FOOBAR, BAR), "endsWith(FOOBAR, BAR)");         assertFalse(StringUtils.endsWith(foobar, BAR), "endsWith(foobar, BAR)");         assertFalse(StringUtils.endsWith(FOOBAR, bar), "endsWith(FOOBAR, bar)");          // "alpha, beta, gamma, delta".endsWith("delta")         assertTrue(StringUtils.endsWith("\u03B1\u03B2\u03B3\u03B4", "\u03B4"),                 "endsWith(\u03B1\u03B2\u03B3\u03B4, \u03B4)");         // "alpha, beta, gamma, delta".endsWith("gamma, DELTA")         assertFalse(StringUtils.endsWith("\u03B1\u03B2\u03B3\u03B4", "\u03B3\u0394"),                 "endsWith(\u03B1\u03B2\u03B3\u03B4, \u03B3\u0394)");     }      /**      * Test StringUtils.endsWithIgnoreCase()      */     @Test     public void testEndsWithIgnoreCase() {         assertTrue(StringUtils.endsWithIgnoreCase(null, null), "endsWithIgnoreCase(null, null)");         assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, null), "endsWithIgnoreCase(FOOBAR, null)");         assertFalse(StringUtils.endsWithIgnoreCase(null, FOO), "endsWithIgnoreCase(null, FOO)");         assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, ""), "endsWithIgnoreCase(FOOBAR, \"\")");          assertFalse(StringUtils.endsWithIgnoreCase(foobar, foo), "endsWithIgnoreCase(foobar, foo)");         assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, FOO), "endsWithIgnoreCase(FOOBAR, FOO)");         assertFalse(StringUtils.endsWithIgnoreCase(foobar, FOO), "endsWithIgnoreCase(foobar, FOO)");         assertFalse(StringUtils.endsWithIgnoreCase(FOOBAR, foo), "endsWithIgnoreCase(FOOBAR, foo)");          assertFalse(StringUtils.endsWithIgnoreCase(foo, foobar), "endsWithIgnoreCase(foo, foobar)");         assertFalse(StringUtils.endsWithIgnoreCase(bar, foobar), "endsWithIgnoreCase(foo, foobar)");          assertTrue(StringUtils.endsWithIgnoreCase(foobar, bar), "endsWithIgnoreCase(foobar, bar)");         assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, BAR), "endsWithIgnoreCase(FOOBAR, BAR)");         assertTrue(StringUtils.endsWithIgnoreCase(foobar, BAR), "endsWithIgnoreCase(foobar, BAR)");         assertTrue(StringUtils.endsWithIgnoreCase(FOOBAR, bar), "endsWithIgnoreCase(FOOBAR, bar)");          // javadoc         assertTrue(StringUtils.endsWithIgnoreCase("abcdef", "def"));         assertTrue(StringUtils.endsWithIgnoreCase("ABCDEF", "def"));         assertFalse(StringUtils.endsWithIgnoreCase("ABCDEF", "cde"));          // "alpha, beta, gamma, delta".endsWith("DELTA")         assertTrue(StringUtils.endsWithIgnoreCase("\u03B1\u03B2\u03B3\u03B4", "\u0394"),                 "endsWith(\u03B1\u03B2\u03B3\u03B4, \u0394)");         // "alpha, beta, gamma, delta".endsWith("GAMMA")         assertFalse(StringUtils.endsWithIgnoreCase("\u03B1\u03B2\u03B3\u03B4", "\u0393"),                 "endsWith(\u03B1\u03B2\u03B3\u03B4, \u0393)");     }      @Test     public void testEndsWithAny() {         assertFalse(StringUtils.endsWithAny(null, (String) null), "StringUtils.endsWithAny(null, null)");         assertFalse(StringUtils.endsWithAny(null, "abc"), "StringUtils.endsWithAny(null, new String[] {abc})");         assertFalse(StringUtils.endsWithAny("abcxyz", (String) null), "StringUtils.endsWithAny(abcxyz, null)");         assertTrue(StringUtils.endsWithAny("abcxyz", ""), "StringUtils.endsWithAny(abcxyz, new String[] {\"\"})");         assertTrue(StringUtils.endsWithAny("abcxyz", "xyz"), "StringUtils.endsWithAny(abcxyz, new String[] {xyz})");         assertTrue(StringUtils.endsWithAny("abcxyz", null, "xyz", "abc"), "StringUtils.endsWithAny(abcxyz, new String[] {null, xyz, abc})");         assertFalse(StringUtils.endsWithAny("defg", null, "xyz", "abc"), "StringUtils.endsWithAny(defg, new String[] {null, xyz, abc})");         assertTrue(StringUtils.endsWithAny("abcXYZ", "def", "XYZ"));         assertFalse(StringUtils.endsWithAny("abcXYZ", "def", "xyz"));         assertTrue(StringUtils.endsWithAny("abcXYZ", "def", "YZ"));          /*          * Type null of the last argument to method endsWithAny(CharSequence, CharSequence...)          * doesn't exactly match the vararg parameter type.          * Cast to CharSequence[] to confirm the non-varargs invocation,          * or pass individual arguments of type CharSequence for a varargs invocation.          *          * assertFalse(StringUtils.endsWithAny("abcXYZ", null)); // replace with specific types to avoid warning          */         assertFalse(StringUtils.endsWithAny("abcXYZ", (CharSequence) null));         assertFalse(StringUtils.endsWithAny("abcXYZ", (CharSequence[]) null));         assertTrue(StringUtils.endsWithAny("abcXYZ", ""));          assertTrue(StringUtils.endsWithAny("abcxyz", new StringBuilder("abc"), new StringBuffer("xyz")), "StringUtils.endsWithAny(abcxyz, StringBuilder(abc), StringBuffer(xyz))");         assertTrue(StringUtils.endsWithAny(new StringBuffer("abcxyz"), new StringBuilder("abc"), new StringBuffer("xyz")), "StringUtils.endsWithAny(StringBuffer(abcxyz), StringBuilder(abc), StringBuffer(xyz))");     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Tests ArrayUtils add methods.  */ public class ArrayUtilsAddTest {      @Test     public void testAddFirstBoolean() {         boolean[] newArray;         newArray = ArrayUtils.addFirst(null, false);         assertArrayEquals(new boolean[]{false}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(null, true);         assertArrayEquals(new boolean[]{true}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());         final boolean[] array1 = new boolean[]{true, false, true};         newArray = ArrayUtils.addFirst(array1, false);         assertArrayEquals(new boolean[]{false, true, false, true}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstByte() {         byte[] newArray;         newArray = ArrayUtils.addFirst((byte[]) null, (byte) 0);         assertArrayEquals(new byte[]{0}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((byte[]) null, (byte) 1);         assertArrayEquals(new byte[]{1}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         final byte[] array1 = new byte[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, (byte) 0);         assertArrayEquals(new byte[]{0, 1, 2, 3}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, (byte) 4);         assertArrayEquals(new byte[]{4, 1, 2, 3}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstChar() {         char[] newArray;         newArray = ArrayUtils.addFirst((char[]) null, (char) 0);         assertArrayEquals(new char[]{0}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((char[]) null, (char) 1);         assertArrayEquals(new char[]{1}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         final char[] array1 = new char[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, (char) 0);         assertArrayEquals(new char[]{0, 1, 2, 3}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, (char) 4);         assertArrayEquals(new char[]{4, 1, 2, 3}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstDouble() {         double[] newArray;         newArray = ArrayUtils.addFirst((double[]) null, 0);         assertArrayEquals(new double[]{0}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((double[]) null, 1);         assertArrayEquals(new double[]{1}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         final double[] array1 = new double[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, 0);         assertArrayEquals(new double[]{0, 1, 2, 3}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, 4);         assertArrayEquals(new double[]{4, 1, 2, 3}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstFloat() {         float[] newArray;         newArray = ArrayUtils.addFirst((float[]) null, 0);         assertArrayEquals(new float[]{0}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((float[]) null, 1);         assertArrayEquals(new float[]{1}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         final float[] array1 = new float[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, 0);         assertArrayEquals(new float[]{0, 1, 2, 3}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, 4);         assertArrayEquals(new float[]{4, 1, 2, 3}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstInt() {         int[] newArray;         newArray = ArrayUtils.addFirst((int[]) null, 0);         assertArrayEquals(new int[]{0}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((int[]) null, 1);         assertArrayEquals(new int[]{1}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         final int[] array1 = new int[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, 0);         assertArrayEquals(new int[]{0, 1, 2, 3}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, 4);         assertArrayEquals(new int[]{4, 1, 2, 3}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstLong() {         long[] newArray;         newArray = ArrayUtils.addFirst((long[]) null, 0);         assertArrayEquals(new long[]{0}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((long[]) null, 1);         assertArrayEquals(new long[]{1}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         final long[] array1 = new long[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, 0);         assertArrayEquals(new long[]{0, 1, 2, 3}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, 4);         assertArrayEquals(new long[]{4, 1, 2, 3}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstObject() {         Object[] newArray;          //show that not casting is okay         newArray = ArrayUtils.add((Object[]) null, "a");         assertArrayEquals(new String[]{"a"}, newArray);         assertArrayEquals(new Object[]{"a"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          //show that not casting to Object[] is okay and will assume String based on "a"         final String[] newStringArray = ArrayUtils.add(null, "a");         assertArrayEquals(new String[]{"a"}, newStringArray);         assertArrayEquals(new Object[]{"a"}, newStringArray);         assertEquals(String.class, newStringArray.getClass().getComponentType());          final String[] stringArray1 = new String[] { "a", "b", "c" };         newArray = ArrayUtils.addFirst(stringArray1, null);         assertArrayEquals(new String[] { null, "a", "b", "c" }, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          newArray = ArrayUtils.addFirst(stringArray1, "d");         assertArrayEquals(new String[] { "d", "a", "b", "c" }, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          Number[] numberArray1 = new Number[] { Integer.valueOf(1), Double.valueOf(2) };         newArray = ArrayUtils.addFirst(numberArray1, Float.valueOf(3));         assertArrayEquals(new Number[] { Float.valueOf(3), Integer.valueOf(1), Double.valueOf(2) }, newArray);         assertEquals(Number.class, newArray.getClass().getComponentType());          numberArray1 = null;         newArray = ArrayUtils.addFirst(numberArray1, Float.valueOf(3));         assertArrayEquals(new Float[] { Float.valueOf(3) }, newArray);         assertEquals(Float.class, newArray.getClass().getComponentType());     }      @Test     public void testAddFirstShort() {         short[] newArray;         newArray = ArrayUtils.addFirst((short[]) null, (short) 0);         assertArrayEquals(new short[]{0}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst((short[]) null, (short) 1);         assertArrayEquals(new short[]{1}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         final short[] array1 = new short[]{1, 2, 3};         newArray = ArrayUtils.addFirst(array1, (short) 0);         assertArrayEquals(new short[]{0, 1, 2, 3}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.addFirst(array1, (short) 4);         assertArrayEquals(new short[]{4, 1, 2, 3}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayBoolean() {         boolean[] newArray;         newArray = ArrayUtils.add(null, false);         assertArrayEquals(new boolean[]{false}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(null, true);         assertArrayEquals(new boolean[]{true}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());         final boolean[] array1 = new boolean[]{true, false, true};         newArray = ArrayUtils.add(array1, false);         assertArrayEquals(new boolean[]{true, false, true, false}, newArray);         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayByte() {         byte[] newArray;         newArray = ArrayUtils.add((byte[]) null, (byte) 0);         assertArrayEquals(new byte[]{0}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((byte[]) null, (byte) 1);         assertArrayEquals(new byte[]{1}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         final byte[] array1 = new byte[]{1, 2, 3};         newArray = ArrayUtils.add(array1, (byte) 0);         assertArrayEquals(new byte[]{1, 2, 3, 0}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, (byte) 4);         assertArrayEquals(new byte[]{1, 2, 3, 4}, newArray);         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayChar() {         char[] newArray;         newArray = ArrayUtils.add((char[]) null, (char) 0);         assertArrayEquals(new char[]{0}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((char[]) null, (char) 1);         assertArrayEquals(new char[]{1}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         final char[] array1 = new char[]{1, 2, 3};         newArray = ArrayUtils.add(array1, (char) 0);         assertArrayEquals(new char[]{1, 2, 3, 0}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, (char) 4);         assertArrayEquals(new char[]{1, 2, 3, 4}, newArray);         assertEquals(Character.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayDouble() {         double[] newArray;         newArray = ArrayUtils.add((double[]) null, 0);         assertArrayEquals(new double[]{0}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((double[]) null, 1);         assertArrayEquals(new double[]{1}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         final double[] array1 = new double[]{1, 2, 3};         newArray = ArrayUtils.add(array1, 0);         assertArrayEquals(new double[]{1, 2, 3, 0}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, 4);         assertArrayEquals(new double[]{1, 2, 3, 4}, newArray);         assertEquals(Double.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayFloat() {         float[] newArray;         newArray = ArrayUtils.add((float[]) null, 0);         assertArrayEquals(new float[]{0}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((float[]) null, 1);         assertArrayEquals(new float[]{1}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         final float[] array1 = new float[]{1, 2, 3};         newArray = ArrayUtils.add(array1, 0);         assertArrayEquals(new float[]{1, 2, 3, 0}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, 4);         assertArrayEquals(new float[]{1, 2, 3, 4}, newArray);         assertEquals(Float.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayInt() {         int[] newArray;         newArray = ArrayUtils.add((int[]) null, 0);         assertArrayEquals(new int[]{0}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((int[]) null, 1);         assertArrayEquals(new int[]{1}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         final int[] array1 = new int[]{1, 2, 3};         newArray = ArrayUtils.add(array1, 0);         assertArrayEquals(new int[]{1, 2, 3, 0}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, 4);         assertArrayEquals(new int[]{1, 2, 3, 4}, newArray);         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayLong() {         long[] newArray;         newArray = ArrayUtils.add((long[]) null, 0);         assertArrayEquals(new long[]{0}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((long[]) null, 1);         assertArrayEquals(new long[]{1}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         final long[] array1 = new long[]{1, 2, 3};         newArray = ArrayUtils.add(array1, 0);         assertArrayEquals(new long[]{1, 2, 3, 0}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, 4);         assertArrayEquals(new long[]{1, 2, 3, 4}, newArray);         assertEquals(Long.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayObject() {         Object[] newArray;          //show that not casting is okay         newArray = ArrayUtils.add((Object[]) null, "a");         assertArrayEquals(new String[]{"a"}, newArray);         assertArrayEquals(new Object[]{"a"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          //show that not casting to Object[] is okay and will assume String based on "a"         final String[] newStringArray = ArrayUtils.add(null, "a");         assertArrayEquals(new String[]{"a"}, newStringArray);         assertArrayEquals(new Object[]{"a"}, newStringArray);         assertEquals(String.class, newStringArray.getClass().getComponentType());          final String[] stringArray1 = new String[]{"a", "b", "c"};         newArray = ArrayUtils.add(stringArray1, null);         assertArrayEquals(new String[]{"a", "b", "c", null}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          newArray = ArrayUtils.add(stringArray1, "d");         assertArrayEquals(new String[]{"a", "b", "c", "d"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          Number[] numberArray1 = new Number[]{Integer.valueOf(1), Double.valueOf(2)};         newArray = ArrayUtils.add(numberArray1, Float.valueOf(3));         assertArrayEquals(new Number[]{Integer.valueOf(1), Double.valueOf(2), Float.valueOf(3)}, newArray);         assertEquals(Number.class, newArray.getClass().getComponentType());          numberArray1 = null;         newArray = ArrayUtils.add(numberArray1, Float.valueOf(3));         assertArrayEquals(new Float[]{Float.valueOf(3)}, newArray);         assertEquals(Float.class, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayShort() {         short[] newArray;         newArray = ArrayUtils.add((short[]) null, (short) 0);         assertArrayEquals(new short[]{0}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add((short[]) null, (short) 1);         assertArrayEquals(new short[]{1}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         final short[] array1 = new short[]{1, 2, 3};         newArray = ArrayUtils.add(array1, (short) 0);         assertArrayEquals(new short[]{1, 2, 3, 0}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(array1, (short) 4);         assertArrayEquals(new short[]{1, 2, 3, 4}, newArray);         assertEquals(Short.TYPE, newArray.getClass().getComponentType());     }      @Test     public void testAddObjectArrayToObjectArray() {         assertNull(ArrayUtils.addAll(null, (Object[]) null));         Object[] newArray;         final String[] stringArray1 = new String[]{"a", "b", "c"};         final String[] stringArray2 = new String[]{"1", "2", "3"};         newArray = ArrayUtils.addAll(stringArray1, (String[]) null);         assertNotSame(stringArray1, newArray);         assertArrayEquals(stringArray1, newArray);         assertArrayEquals(new String[]{"a", "b", "c"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.addAll(null, stringArray2);         assertNotSame(stringArray2, newArray);         assertArrayEquals(stringArray2, newArray);         assertArrayEquals(new String[]{"1", "2", "3"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.addAll(stringArray1, stringArray2);         assertArrayEquals(new String[]{"a", "b", "c", "1", "2", "3"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null);         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, newArray);         assertArrayEquals(new String[]{}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY);         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, newArray);         assertArrayEquals(new String[]{}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY);         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, newArray);         assertArrayEquals(new String[]{}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         final String[] stringArrayNull = new String []{null};         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull);         assertArrayEquals(new String[]{null, null}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());          // boolean         assertArrayEquals(new boolean[]{true, false, false, true}, ArrayUtils.addAll(new boolean[]{true, false}, false, true));          assertArrayEquals(new boolean[]{false, true}, ArrayUtils.addAll(null, new boolean[]{false, true}));          assertArrayEquals(new boolean[]{true, false}, ArrayUtils.addAll(new boolean[]{true, false}, null));          // char         assertArrayEquals(new char[]{'a', 'b', 'c', 'd'}, ArrayUtils.addAll(new char[]{'a', 'b'}, 'c', 'd'));          assertArrayEquals(new char[]{'c', 'd'}, ArrayUtils.addAll(null, new char[]{'c', 'd'}));          assertArrayEquals(new char[]{'a', 'b'}, ArrayUtils.addAll(new char[]{'a', 'b'}, null));          // byte         assertArrayEquals(new byte[]{(byte) 0, (byte) 1, (byte) 2, (byte) 3}, ArrayUtils.addAll(new byte[]{(byte) 0, (byte) 1}, (byte) 2, (byte) 3));          assertArrayEquals(new byte[]{(byte) 2, (byte) 3}, ArrayUtils.addAll(null, new byte[]{(byte) 2, (byte) 3}));          assertArrayEquals(new byte[]{(byte) 0, (byte) 1}, ArrayUtils.addAll(new byte[]{(byte) 0, (byte) 1}, null));          // short         assertArrayEquals(new short[]{(short) 10, (short) 20, (short) 30, (short) 40}, ArrayUtils.addAll(new short[]{(short) 10, (short) 20}, (short) 30, (short) 40));          assertArrayEquals(new short[]{(short) 30, (short) 40}, ArrayUtils.addAll(null, new short[]{(short) 30, (short) 40}));          assertArrayEquals(new short[]{(short) 10, (short) 20}, ArrayUtils.addAll(new short[]{(short) 10, (short) 20}, null));          // int         assertArrayEquals(new int[]{1, 1000, -1000, -1}, ArrayUtils.addAll(new int[]{1, 1000}, -1000, -1));          assertArrayEquals(new int[]{-1000, -1}, ArrayUtils.addAll(null, new int[]{-1000, -1}));          assertArrayEquals(new int[]{1, 1000}, ArrayUtils.addAll(new int[]{1, 1000}, null));          // long         assertArrayEquals(new long[]{1L, -1L, 1000L, -1000L}, ArrayUtils.addAll(new long[]{1L, -1L}, 1000L, -1000L));          assertArrayEquals(new long[]{1000L, -1000L}, ArrayUtils.addAll(null, new long[]{1000L, -1000L}));          assertArrayEquals(new long[]{1L, -1L}, ArrayUtils.addAll(new long[]{1L, -1L}, null));          // float         assertArrayEquals(new float[]{10.5f, 10.1f, 1.6f, 0.01f}, ArrayUtils.addAll(new float[]{10.5f, 10.1f}, 1.6f, 0.01f));          assertArrayEquals(new float[]{1.6f, 0.01f}, ArrayUtils.addAll(null, new float[]{1.6f, 0.01f}));          assertArrayEquals(new float[]{10.5f, 10.1f}, ArrayUtils.addAll(new float[]{10.5f, 10.1f}, null));          // double         assertArrayEquals(new double[]{Math.PI, -Math.PI, 0, 9.99}, ArrayUtils.addAll(new double[]{Math.PI, -Math.PI}, 0, 9.99));          assertArrayEquals(new double[]{0, 9.99}, ArrayUtils.addAll(null, new double[]{0, 9.99}));          assertArrayEquals(new double[]{Math.PI, -Math.PI}, ArrayUtils.addAll(new double[]{Math.PI, -Math.PI}, null));      }      @SuppressWarnings("deprecation")     @Test     public void testAddObjectAtIndex() {         Object[] newArray;         newArray = ArrayUtils.add((Object[]) null, 0, "a");         assertArrayEquals(new String[]{"a"}, newArray);         assertArrayEquals(new Object[]{"a"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         final String[] stringArray1 = new String[]{"a", "b", "c"};         newArray = ArrayUtils.add(stringArray1, 0, null);         assertArrayEquals(new String[]{null, "a", "b", "c"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(stringArray1, 1, null);         assertArrayEquals(new String[]{"a", null, "b", "c"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(stringArray1, 3, null);         assertArrayEquals(new String[]{"a", "b", "c", null}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         newArray = ArrayUtils.add(stringArray1, 3, "d");         assertArrayEquals(new String[]{"a", "b", "c", "d"}, newArray);         assertEquals(String.class, newArray.getClass().getComponentType());         assertEquals(String.class, newArray.getClass().getComponentType());          final Object[] o = new Object[] {"1", "2", "4"};         final Object[] result = ArrayUtils.add(o, 2, "3");         final Object[] result2 = ArrayUtils.add(o, 3, "5");          assertNotNull(result);         assertEquals(4, result.length);         assertEquals("1", result[0]);         assertEquals("2", result[1]);         assertEquals("3", result[2]);         assertEquals("4", result[3]);         assertNotNull(result2);         assertEquals(4, result2.length);         assertEquals("1", result2[0]);         assertEquals("2", result2[1]);         assertEquals("4", result2[2]);         assertEquals("5", result2[3]);          // boolean tests         boolean[] booleanArray = ArrayUtils.add( null, 0, true );         assertArrayEquals(new boolean[]{true}, booleanArray);         IndexOutOfBoundsException e =                 assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( null, -1, true));         assertEquals("Index: -1, Length: 0", e.getMessage());         booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false);         assertArrayEquals(new boolean[]{false, true}, booleanArray);         booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true);         assertArrayEquals(new boolean[]{false, true}, booleanArray);         booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true);         assertArrayEquals(new boolean[]{true, true, false}, booleanArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add(new boolean[] { true, false }, 4, true));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add(new boolean[] { true, false }, -1, true));         assertEquals("Index: -1, Length: 2", e.getMessage());          // char tests         char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' );         assertArrayEquals(new char[]{'a'}, charArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (char[]) null, -1, 'a' ));         assertEquals("Index: -1, Length: 0", e.getMessage());         charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b');         assertArrayEquals(new char[]{'b', 'a'}, charArray);         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c');         assertArrayEquals(new char[]{'c', 'a', 'b'}, charArray);         charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k');         assertArrayEquals(new char[]{'a', 'k', 'b'}, charArray);         charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't');         assertArrayEquals(new char[]{'a', 't', 'b', 'c'}, charArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c'));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c'));         assertEquals("Index: -1, Length: 2", e.getMessage());          // short tests         short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2);         assertArrayEquals(new short[]{2, 1}, shortArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (short[]) null, -1, (short) 2));         assertEquals("Index: -1, Length: 0", e.getMessage());         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10);         assertArrayEquals(new short[]{2, 6, 10}, shortArray);         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4);         assertArrayEquals(new short[]{-4, 2, 6}, shortArray);         shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1);         assertArrayEquals(new short[]{2, 6, 1, 3}, shortArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10));         assertEquals("Index: -1, Length: 2", e.getMessage());          // byte tests         byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2);         assertArrayEquals(new byte[]{2, 1}, byteArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (byte[]) null, -1, (byte) 2));         assertEquals("Index: -1, Length: 0", e.getMessage());         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3);         assertArrayEquals(new byte[]{2, 6, 3}, byteArray);         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1);         assertArrayEquals(new byte[]{1, 2, 6}, byteArray);         byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1);         assertArrayEquals(new byte[]{2, 6, 1, 3}, byteArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3));         assertEquals("Index: -1, Length: 2", e.getMessage());          // int tests         int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2);         assertArrayEquals(new int[]{2, 1}, intArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (int[]) null, -1, 2));         assertEquals("Index: -1, Length: 0", e.getMessage());         intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10);         assertArrayEquals(new int[]{2, 6, 10}, intArray);         intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4);         assertArrayEquals(new int[]{-4, 2, 6}, intArray);         intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1);         assertArrayEquals(new int[]{2, 6, 1, 3}, intArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new int[] { 2, 6 }, 4, 10));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new int[] { 2, 6 }, -1, 10));         assertEquals("Index: -1, Length: 2", e.getMessage());          // long tests         long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L);         assertArrayEquals(new long[]{2L, 1L}, longArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (long[]) null, -1, 2L));         assertEquals("Index: -1, Length: 0", e.getMessage());         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L);         assertArrayEquals(new long[]{2L, 6L, 10L}, longArray);         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L);         assertArrayEquals(new long[]{-4L, 2L, 6L}, longArray);         longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L);         assertArrayEquals(new long[]{2L, 6L, 1L, 3L}, longArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L));         assertEquals("Index: -1, Length: 2", e.getMessage());          // float tests         float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f);         assertArrayEquals(new float[]{2.2f, 1.1f}, floatArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( (float[]) null, -1, 2.2f));         assertEquals("Index: -1, Length: 0", e.getMessage());         floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f);         assertArrayEquals(new float[]{2.3f, 6.4f, 10.5f}, floatArray);         floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f);         assertArrayEquals(new float[]{-4.8f, 2.6f, 6.7f}, floatArray);         floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f);         assertArrayEquals(new float[]{2.9f, 6.0f, 1.0f, 0.3f}, floatArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f));         assertEquals("Index: -1, Length: 2", e.getMessage());          // double tests         double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2);         assertArrayEquals(new double[]{2.2, 1.1}, doubleArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add(null, -1, 2.2));         assertEquals("Index: -1, Length: 0", e.getMessage());         doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5);         assertArrayEquals(new double[]{2.3, 6.4, 10.5}, doubleArray);         doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8);         assertArrayEquals(new double[]{-4.8, 2.6, 6.7}, doubleArray);         doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0);         assertArrayEquals(new double[]{2.9, 6.0, 1.0, 0.3}, doubleArray);         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5));         assertEquals("Index: 4, Length: 2", e.getMessage());         e = assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5));         assertEquals("Index: -1, Length: 2", e.getMessage());     }      @Test     public void testJira567() {         Number[] n;         // Valid array construction         n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});         assertEquals(2, n.length);         assertEquals(Number.class, n.getClass().getComponentType());         // Invalid - can't store Long in Integer array         assertThrows(IllegalArgumentException.class,                 () -> ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)}));     }      @Test     @SuppressWarnings("deprecation")     public void testLANG571() {         final String[] stringArray=null;         final String aString=null;         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.add(stringArray, aString));         assertThrows(IllegalArgumentException.class, () -> ArrayUtils.add(stringArray, 0, aString));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import java.util.BitSet; import java.util.HashSet; import java.util.concurrent.TimeUnit;  import org.openjdk.jmh.annotations.Benchmark; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.OutputTimeUnit; import org.openjdk.jmh.annotations.Scope; import org.openjdk.jmh.annotations.State;  /**  * Test to show whether using BitSet for removeAll() methods is faster than using HashSet.  */ @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @State(Scope.Thread) public class HashSetvBitSetTest {      private static final int numberOfElementsToCompute = 10;      @Benchmark     public int[] testHashSet() {         final HashSet<Integer> toRemove = new HashSet<>();         int found = 0;         for (int i = 0; i < numberOfElementsToCompute; i++) {             toRemove.add(found++);         }         return extractIndices(toRemove);     }      @Benchmark     public int[] testBitSet() {         final BitSet toRemove = new BitSet();         int found = 0;         for (int i = 0; i < numberOfElementsToCompute; i++) {             toRemove.set(found++);         }         return extractIndices(toRemove);     }      @Benchmark     public int[] timeBitSetRemoveAll() {         final BitSet toRemove = new BitSet();         final int[] array = new int[100];         toRemove.set(10, 20);         return (int[]) ArrayUtils.removeAll(array, toRemove);     }      @Benchmark     public int[] timeExtractRemoveAll() {         final BitSet toRemove = new BitSet();         final int[] array = new int[100];         toRemove.set(10, 20);         final int[] extractIndices = extractIndices(toRemove);         return (int[]) ArrayUtils.removeAll((Object) array, extractIndices);     }      // --- utility methods     private static int[] extractIndices(final HashSet<Integer> coll) {         final int[] result = new int[coll.size()];         int i = 0;         for (final Integer index : coll) {             result[i++] = index.intValue();         }         return result;     }      private static int[] extractIndices(final BitSet coll) {         final int[] result = new int[coll.cardinality()];         int i = 0;         int j=0;         while ((j=coll.nextSetBit(j)) != -1) {             result[i++] = j++;         }         return result;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  */ public class ClassPathUtilsTest {      @Test     public void testConstructor() {         assertNotNull(new ClassPathUtils());         final Constructor<?>[] cons = ClassPathUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ClassPathUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ClassPathUtils.class.getModifiers()));     }      @Test     public void testToFullyQualifiedNameNullClassString() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedName((Class<?>) null, "Test.properties"));     }      @Test     public void testToFullyQualifiedNameClassNull() {         assertThrows(NullPointerException.class, () -> ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class, null));     }      @Test     public void testToFullyQualifiedNameClassString() {         final String expected = "org.apache.commons.lang3.Test.properties";         final String actual = ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class, "Test.properties");          assertEquals(expected, actual);     }      @Test     public void testToFullyQualifiedNameNullPackageString() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedName((Package) null, "Test.properties"));     }      @Test     public void testToFullyQualifiedNamePackageNull() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class.getPackage(), null));     }      @Test     public void testToFullyQualifiedNamePackageString() {         final String expected = "org.apache.commons.lang3.Test.properties";         final String actual = ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class.getPackage(), "Test.properties");          assertEquals(expected, actual);     }      @Test     public void testToFullyQualifiedPathClassNullString() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedPath((Class<?>) null, "Test.properties"));     }      @Test     public void testToFullyQualifiedPathClassNull() {         assertThrows(NullPointerException.class, () -> ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class, null));     }      @Test     public void testToFullyQualifiedPathClass() {         final String expected = "org/apache/commons/lang3/Test.properties";         final String actual = ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class, "Test.properties");          assertEquals(expected, actual);     }      @Test     public void testToFullyQualifiedPathPackageNullString() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedPath((Package) null, "Test.properties"));     }      @Test     public void testToFullyQualifiedPathPackageNull() {         assertThrows(NullPointerException.class,                 () -> ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class.getPackage(), null));     }      @Test     public void testToFullyQualifiedPathPackage() {         final String expected = "org/apache/commons/lang3/Test.properties";         final String actual = ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class.getPackage(), "Test.properties");          assertEquals(expected, actual);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Tests ArrayUtils remove and removeElement methods.  */ public class ArrayUtilsRemoveMultipleTest {      @Test     public void testRemoveAllBooleanArray() {         boolean[] array;          array = ArrayUtils.removeAll(new boolean[] { true }, 0);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false }, 0);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false }, 1);         assertArrayEquals(new boolean[]{true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true }, 1);         assertArrayEquals(new boolean[]{true, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 1);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 0, 2);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, false }, 1, 2);         assertArrayEquals(new boolean[]{true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 0, 2, 4);         assertArrayEquals(new boolean[]{false, false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3);         assertArrayEquals(new boolean[]{true, true, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true }, 1, 3, 4);         assertArrayEquals(new boolean[]{true, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 2, 4, 6);         assertArrayEquals(new boolean[]{false, false, false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 1, 3, 5);         assertArrayEquals(new boolean[]{true, true, true, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new boolean[] { true, false, true, false, true, false, true }, 0, 1, 2);         assertArrayEquals(new boolean[]{false, true, false, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllBooleanArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new boolean[] { true, false }, -1));     }      @Test     public void testRemoveAllBooleanArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new boolean[] { true, false }, 2));     }      @Test     public void testRemoveAllBooleanArrayRemoveNone() {         final boolean[] array1 = new boolean[] { true, false };         final boolean[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(boolean.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllByteArray() {         byte[] array;          array = ArrayUtils.removeAll(new byte[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 1);         assertArrayEquals(new byte[]{1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 1 }, 1);         assertArrayEquals(new byte[]{1, 1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new byte[]{3}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new byte[]{1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new byte[]{1, 3, 5}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new byte[]{2, 4}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new byte[]{1, 3, 5, 7}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new byte[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new byte[]{2, 4, 6}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllByteArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new byte[] { 1, 2 }, -1));     }      @Test     public void testRemoveAllByteArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new byte[] { 1, 2 }, 2));     }      @Test     public void testRemoveAllByteArrayRemoveNone() {         final byte[] array1 = new byte[] { 1, 2 };         final byte[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(byte.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllCharArray() {         char[] array;          array = ArrayUtils.removeAll(new char[] { 'a' }, 0);         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0);         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 1);         assertArrayEquals(new char[]{'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1);         assertArrayEquals(new char[]{'a', 'c'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b' }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 1);         assertArrayEquals(new char[]{'c'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 1, 2);         assertArrayEquals(new char[]{'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c' }, 0, 2);         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 1, 3);         assertArrayEquals(new char[]{'a', 'c', 'e'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e' }, 0, 2, 4);         assertArrayEquals(new char[]{'b', 'd'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 1, 3, 5);         assertArrayEquals(new char[]{'a', 'c', 'e', 'g'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g' }, 0, 2, 4, 6);         assertArrayEquals(new char[]{'b', 'd', 'f'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllCharArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new char[] { 'a', 'b' }, -1));     }      @Test     public void testRemoveAllCharArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new char[] { 'a', 'b' }, 2));     }      @Test     public void testRemoveAllCharArrayRemoveNone() {         final char[] array1 = new char[] { 'a', 'b' };         final char[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(char.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllDoubleArray() {         double[] array;          array = ArrayUtils.removeAll(new double[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2 }, 1);         assertArrayEquals(new double[]{1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 1 }, 1);         assertArrayEquals(new double[]{1, 1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new double[]{3}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new double[]{1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new double[]{1, 3, 5}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new double[]{2, 4}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new double[]{1, 3, 5, 7}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new double[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new double[]{2, 4, 6}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllDoubleArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new double[] { 1, 2 }, -1));     }      @Test     public void testRemoveAllDoubleArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new double[] { 1, 2 }, 2));     }      @Test     public void testRemoveAllDoubleArrayRemoveNone() {         final double[] array1 = new double[] { 1, 2 };         final double[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(double.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllFloatArray() {         float[] array;          array = ArrayUtils.removeAll(new float[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2 }, 1);         assertArrayEquals(new float[]{1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 1 }, 1);         assertArrayEquals(new float[]{1, 1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new float[]{3}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new float[]{1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new float[]{1, 3, 5}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new float[]{2, 4}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new float[]{1, 3, 5, 7}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new float[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new float[]{2, 4, 6}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllFloatArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new float[] { 1, 2 }, -1));     }      @Test     public void testRemoveAllFloatArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new float[] { 1, 2 }, 2));     }      @Test     public void testRemoveAllFloatArrayRemoveNone() {         final float[] array1 = new float[] { 1, 2 };         final float[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(float.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllIntArray() {         int[] array;          array = ArrayUtils.removeAll(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.EMPTY_INT_ARRAY);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);          array = ArrayUtils.removeAll(new int[] { 1 }, ArrayUtils.EMPTY_INT_ARRAY);         assertArrayEquals(new int[]{1}, array);          array = ArrayUtils.removeAll(new int[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2 }, 1);         assertArrayEquals(new int[]{1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 1 }, 1);         assertArrayEquals(new int[]{1, 1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new int[]{3}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new int[]{1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new int[]{1, 3, 5}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new int[]{2, 4}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new int[]{1, 3, 5, 7}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new int[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new int[]{2, 4, 6}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllIntArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new int[] { 1, 2 }, -1));     }      @Test     public void testRemoveAllIntArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new int[] { 1, 2 }, 2));     }      @Test     public void testRemoveAllIntArrayRemoveNone() {         final int[] array1 = new int[] { 1, 2 };         final int[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(int.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllLongArray() {         long[] array;          array = ArrayUtils.removeAll(new long[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2 }, 1);         assertArrayEquals(new long[]{1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 1 }, 1);         assertArrayEquals(new long[]{1, 1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new long[]{3}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new long[]{1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new long[]{1, 3, 5}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new long[]{2, 4}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new long[]{1, 3, 5, 7}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new long[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new long[]{2, 4, 6}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllLongArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new long[] { 1, 2 }, -1));     }      @Test     public void testRemoveAllLongArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new long[] { 1, 2 }, 2));     }      @Test     public void testRemoveAllLongArrayRemoveNone() {         final long[] array1 = new long[] { 1, 2 };         final long[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(long.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllNullBooleanArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((boolean[]) null, 0));     }      @Test     public void testRemoveAllNullByteArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((byte[]) null, 0));     }      @Test     public void testRemoveAllNullCharArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((char[]) null, 0));     }      @Test     public void testRemoveAllNullDoubleArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((double[]) null, 0));     }      @Test     public void testRemoveAllNullFloatArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((float[]) null, 0));     }      @Test     public void testRemoveAllNullIntArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((int[]) null, 0));     }      @Test     public void testRemoveAllNullLongArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((long[]) null, 0));     }      @Test     public void testRemoveAllNullObjectArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((Object[]) null, 0));     }      @Test     public void testRemoveAllNullShortArray() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll((short[]) null, 0));     }      @Test     public void testRemoveAllNumberArray() {         final Number[] inarray = { Integer.valueOf(1), Long.valueOf(2L), Byte.valueOf((byte) 3) };         assertEquals(3, inarray.length);         Number[] outarray;          outarray = ArrayUtils.removeAll(inarray, 1);         assertArrayEquals(new Number[] { Integer.valueOf(1), Byte.valueOf((byte) 3) }, outarray);         assertEquals(Number.class, outarray.getClass().getComponentType());          outarray = ArrayUtils.removeAll(outarray, 1);         assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray);         assertEquals(Number.class, outarray.getClass().getComponentType());          outarray = ArrayUtils.removeAll(outarray, 0);         assertEquals(0, outarray.length);         assertEquals(Number.class, outarray.getClass().getComponentType());          outarray = ArrayUtils.removeAll(inarray, 0, 1);         assertArrayEquals(new Number[] { Byte.valueOf((byte) 3) }, outarray);         assertEquals(Number.class, outarray.getClass().getComponentType());          outarray = ArrayUtils.removeAll(inarray, 0, 2);         assertArrayEquals(new Number[] { Long.valueOf(2L) }, outarray);         assertEquals(Number.class, outarray.getClass().getComponentType());          outarray = ArrayUtils.removeAll(inarray, 1, 2);         assertArrayEquals(new Number[] { Integer.valueOf(1) }, outarray);         assertEquals(Number.class, outarray.getClass().getComponentType());     }      @Test     public void testRemoveAllObjectArray() {         Object[] array;          array = ArrayUtils.removeAll(new Object[] { "a" }, 0);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b" }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c" }, 1, 2);         assertArrayEquals(new Object[] { "a" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 1, 2);         assertArrayEquals(new Object[] { "a", "d" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 3);         assertArrayEquals(new Object[] { "b", "c" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 1, 3);         assertArrayEquals(new Object[] { "c" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d", "e" }, 0, 1, 3);         assertArrayEquals(new Object[] { "c", "e" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d", "e" }, 0, 2, 4);         assertArrayEquals(new Object[] { "b", "d" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 0, 1, 3, 0, 1, 3);         assertArrayEquals(new Object[] { "c" }, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 2, 1, 0, 3);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new Object[] { "a", "b", "c", "d" }, 2, 0, 1, 3, 0, 2, 1, 3);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());     }      @Test     public void testRemoveAllObjectArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new Object[] { "a", "b" }, -1));     }      @Test     public void testRemoveAllObjectArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new Object[] { "a", "b" }, 2));     }      @Test     public void testRemoveAllObjectArrayRemoveNone() {         final Object[] array1 = new Object[] { "foo", "bar", "baz" };         final Object[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(Object.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveAllShortArray() {         short[] array;          array = ArrayUtils.removeAll(new short[] { 1 }, 0);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2 }, 1);         assertArrayEquals(new short[]{1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 1 }, 1);         assertArrayEquals(new short[]{1, 1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2 }, 0, 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 1);         assertArrayEquals(new short[]{3}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 1, 2);         assertArrayEquals(new short[]{1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3 }, 0, 2);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 1, 3);         assertArrayEquals(new short[]{1, 3, 5}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5 }, 0, 2, 4);         assertArrayEquals(new short[]{2, 4}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 1, 3, 5);         assertArrayEquals(new short[]{1, 3, 5, 7}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeAll(new short[] { 1, 2, 3, 4, 5, 6, 7 }, 0, 2, 4, 6);         assertArrayEquals(new short[]{2, 4, 6}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveAllShortArrayNegativeIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new short[] { 1, 2 }, -1, 0));     }      @Test     public void testRemoveAllShortArrayOutOfBoundsIndex() {         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.removeAll(new short[] { 1, 2 }, 2, 0));     }      @Test     public void testRemoveAllShortArrayRemoveNone() {         final short[] array1 = new short[] { 1, 2 };         final short[] array2 = ArrayUtils.removeAll(array1);         assertNotSame(array1, array2);         assertArrayEquals(array1, array2);         assertEquals(short.class, array2.getClass().getComponentType());     }      @Test     public void testRemoveElementBooleanArray() {         boolean[] array;          array = ArrayUtils.removeElements((boolean[]) null, true);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true }, true);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false }, true);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true);         assertArrayEquals(new boolean[]{false, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((boolean[]) null, true, false);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true, false);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true }, true, false);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false }, true, false);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false }, true, true);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, false);         assertArrayEquals(new boolean[]{true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new boolean[] { true, false, true }, true, true, true, true);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementByteArray() {         byte[] array;          array = ArrayUtils.removeElements((byte[]) null, (byte) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1);         assertArrayEquals(new byte[]{2, 1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((byte[]) null, (byte) 1, (byte) 2);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1, (byte) 2);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1 }, (byte) 1, (byte) 2);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 2);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2 }, (byte) 1, (byte) 1);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 2);         assertArrayEquals(new byte[]{1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new byte[] { 1, 2, 1 }, (byte) 1, (byte) 1, (byte) 1, (byte) 1);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementCharArray() {         char[] array;          array = ArrayUtils.removeElements((char[]) null, 'a');         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a' }, 'a');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a');         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a');         assertArrayEquals(new char[]{'b', 'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((char[]) null, 'a', 'b');         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_CHAR_ARRAY, 'a', 'b');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a' }, 'a', 'b');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'b');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b' }, 'a', 'a');         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'b');         assertArrayEquals(new char[]{'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a');         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new char[] { 'a', 'b', 'a' }, 'a', 'a', 'a', 'a');         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());     }      @Test     @SuppressWarnings("cast")     public void testRemoveElementDoubleArray() {         double[] array;          array = ArrayUtils.removeElements((double[]) null, (double) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1);         assertArrayEquals(new double[]{2, 1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((double[]) null, (double) 1, (double) 2);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1, (double) 2);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1 }, (double) 1, (double) 2);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 2);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2 }, (double) 1, (double) 1);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 2);         assertArrayEquals(new double[]{1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new double[] { 1, 2, 1 }, (double) 1, (double) 1, (double) 1, (double) 1);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());     }      @Test     @SuppressWarnings("cast")     public void testRemoveElementFloatArray() {         float[] array;          array = ArrayUtils.removeElements((float[]) null, (float) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1);         assertArrayEquals(new float[]{2, 1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((float[]) null, (float) 1, (float) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1 }, (float) 1, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 2);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2 }, (float) 1, (float) 1);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 2);         assertArrayEquals(new float[]{1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new float[] { 1, 2, 1 }, (float) 1, (float) 1, (float) 1, (float) 1);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementIntArray() {         int[] array;          array = ArrayUtils.removeElements((int[]) null, 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1 }, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1);         assertArrayEquals(new int[]{2, 1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((int[]) null, 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_INT_ARRAY, 1, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1 }, 1, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 2);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2 }, 1, 1);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 2);         assertArrayEquals(new int[]{1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new int[] { 1, 2, 1 }, 1, 1, 1, 1);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());     }      @Test     @SuppressWarnings("cast")     public void testRemoveElementLongArray() {         long[] array;          array = ArrayUtils.removeElements((long[]) null, 1L);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1 }, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2 }, 1L);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, 1L);         assertArrayEquals(new long[]{2, 1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((long[]) null, 1L, 1L);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_LONG_ARRAY, 1L, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1 }, 1L, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2 }, 1L, 2L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2 }, 1L, 1L);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, 1L, 1L);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, 1L, 2L);         assertArrayEquals(new long[]{1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new long[] { 1, 2, 1 }, 1L, 1L, 1L, 1L);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementShortArray() {         short[] array;          array = ArrayUtils.removeElements((short[]) null, (short) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1);         assertArrayEquals(new short[]{2, 1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements((short[]) null, (short) 1, (short) 1);         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1 }, (short) 1, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 2);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2 }, (short) 1, (short) 1);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 2);         assertArrayEquals(new short[]{1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new short[] { 1, 2, 1 }, (short) 1, (short) 1, (short) 1, (short) 1);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementsObjectArray() {         Object[] array;          array = ArrayUtils.removeElements((Object[]) null, "a");         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a" }, "a");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a");         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a");         assertArrayEquals(new Object[]{"b", "a"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements((Object[]) null, "a", "b");         assertNull(array);          array = ArrayUtils.removeElements(ArrayUtils.EMPTY_OBJECT_ARRAY, "a", "b");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a" }, "a", "b");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b" }, "a", "c");         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a");         assertArrayEquals(new Object[]{"b", "a"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "b");         assertArrayEquals(new Object[]{"a"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a");         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());          array = ArrayUtils.removeElements(new Object[] { "a", "b", "a" }, "a", "a", "a", "a");         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Calendar; import java.util.HashSet;  import org.junit.jupiter.api.Test;  /**  * Test the Triple class.  */ public class TripleTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final Triple<Integer, String, Boolean>[] empty = (Triple<Integer, String, Boolean>[]) Triple.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final Triple<Integer, String, Boolean>[] empty = Triple.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testComparable1() {         final Triple<String, String, String> triple1 = Triple.of("A", "D", "A");         final Triple<String, String, String> triple2 = Triple.of("B", "C", "A");         assertEquals(0, triple1.compareTo(triple1));         assertTrue(triple1.compareTo(triple2) < 0);         assertEquals(0, triple2.compareTo(triple2));         assertTrue(triple2.compareTo(triple1) > 0);     }      @Test     public void testComparable2() {         final Triple<String, String, String> triple1 = Triple.of("A", "C", "B");         final Triple<String, String, String> triple2 = Triple.of("A", "D", "B");         assertEquals(0, triple1.compareTo(triple1));         assertTrue(triple1.compareTo(triple2) < 0);         assertEquals(0, triple2.compareTo(triple2));         assertTrue(triple2.compareTo(triple1) > 0);     }      @Test     public void testComparable3() {         final Triple<String, String, String> triple1 = Triple.of("A", "A", "D");         final Triple<String, String, String> triple2 = Triple.of("A", "B", "C");         assertEquals(0, triple1.compareTo(triple1));         assertTrue(triple1.compareTo(triple2) < 0);         assertEquals(0, triple2.compareTo(triple2));         assertTrue(triple2.compareTo(triple1) > 0);     }      @Test     public void testComparable4() {         final Triple<String, String, String> triple1 = Triple.of("B", "A", "C");         final Triple<String, String, String> triple2 = Triple.of("B", "A", "D");         assertEquals(0, triple1.compareTo(triple1));         assertTrue(triple1.compareTo(triple2) < 0);         assertEquals(0, triple2.compareTo(triple2));         assertTrue(triple2.compareTo(triple1) > 0);     }      @Test     public void testCompatibilityBetweenTriples() {         final Triple<Integer, String, Boolean> triple = ImmutableTriple.of(0, "foo", Boolean.TRUE);         final Triple<Integer, String, Boolean> triple2 = MutableTriple.of(0, "foo", Boolean.TRUE);         assertEquals(triple, triple2);         assertEquals(triple.hashCode(), triple2.hashCode());         final HashSet<Triple<Integer, String, Boolean>> set = new HashSet<>();         set.add(triple);         assertTrue(set.contains(triple2));     }      @Test     public void testFormattable_padded() {         final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value");         assertEquals("         (Key,Something,Value)", String.format("%1$30s", triple));     }      @Test     public void testFormattable_simple() {         final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value");         assertEquals("(Key,Something,Value)", String.format("%1$s", triple));     }      @Test     public void testToString() {         final Triple<String, String, String> triple = Triple.of("Key", "Something", "Value");         assertEquals("(Key,Something,Value)", triple.toString());     }      @Test     public void testToStringCustom() {         final Calendar date = Calendar.getInstance();         date.set(2011, Calendar.APRIL, 25);         final Triple<String, String, Calendar> triple = Triple.of("DOB", "string", date);         assertEquals("Test created on " + "04-25-2011", triple.toString("Test created on %3$tm-%3$td-%3$tY"));     }      @Test     public void testTripleOf() {         final Triple<Integer, String, Boolean> triple = Triple.of(0, "foo", Boolean.TRUE);         assertTrue(triple instanceof ImmutableTriple<?, ?, ?>);         assertEquals(0, ((ImmutableTriple<Integer, String, Boolean>) triple).left.intValue());         assertEquals("foo", ((ImmutableTriple<Integer, String, Boolean>) triple).middle);         assertEquals(Boolean.TRUE, ((ImmutableTriple<Integer, String, Boolean>) triple).right);         final Triple<Object, String, Long> triple2 = Triple.of(null, "bar", Long.valueOf(200L));         assertTrue(triple2 instanceof ImmutableTriple<?, ?, ?>);         assertNull(((ImmutableTriple<Object, String, Long>) triple2).left);         assertEquals("bar", ((ImmutableTriple<Object, String, Long>) triple2).middle);         assertEquals(new Long(200L), ((ImmutableTriple<Object, String, Long>) triple2).right);     }  }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Calendar; import java.util.HashMap; import java.util.HashSet; import java.util.Map.Entry;  import org.junit.jupiter.api.Test;  /**  * Test the Pair class.  */ public class PairTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final Pair<Integer, String>[] empty = (Pair<Integer, String>[]) Pair.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final Pair<Integer, String>[] empty = Pair.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testComparable1() {         final Pair<String, String> pair1 = Pair.of("A", "D");         final Pair<String, String> pair2 = Pair.of("B", "C");         assertEquals(0, pair1.compareTo(pair1));         assertTrue(pair1.compareTo(pair2) < 0);         assertEquals(0, pair2.compareTo(pair2));         assertTrue(pair2.compareTo(pair1) > 0);     }      @Test     public void testComparable2() {         final Pair<String, String> pair1 = Pair.of("A", "C");         final Pair<String, String> pair2 = Pair.of("A", "D");         assertEquals(0, pair1.compareTo(pair1));         assertTrue(pair1.compareTo(pair2) < 0);         assertEquals(0, pair2.compareTo(pair2));         assertTrue(pair2.compareTo(pair1) > 0);     }      @Test     public void testCompatibilityBetweenPairs() {         final Pair<Integer, String> pair = ImmutablePair.of(0, "foo");         final Pair<Integer, String> pair2 = MutablePair.of(0, "foo");         assertEquals(pair, pair2);         assertEquals(pair.hashCode(), pair2.hashCode());         final HashSet<Pair<Integer, String>> set = new HashSet<>();         set.add(pair);         assertTrue(set.contains(pair2));          pair2.setValue("bar");         assertNotEquals(pair, pair2);         assertNotEquals(pair.hashCode(), pair2.hashCode());     }      @Test     public void testFormattable_padded() {         final Pair<String, String> pair = Pair.of("Key", "Value");         assertEquals("         (Key,Value)", String.format("%1$20s", pair));     }      @Test     public void testFormattable_simple() {         final Pair<String, String> pair = Pair.of("Key", "Value");         assertEquals("(Key,Value)", String.format("%1$s", pair));     }      @Test     public void testMapEntry() {         final Pair<Integer, String> pair = ImmutablePair.of(0, "foo");         final HashMap<Integer, String> map = new HashMap<>();         map.put(0, "foo");         final Entry<Integer, String> entry = map.entrySet().iterator().next();         assertEquals(pair, entry);         assertEquals(pair.hashCode(), entry.hashCode());     }      @Test     public void testPairOfMapEntry() {         final HashMap<Integer, String> map = new HashMap<>();         map.put(0, "foo");         final Entry<Integer, String> entry = map.entrySet().iterator().next();         final Pair<Integer, String> pair = Pair.of(entry);         assertEquals(entry.getKey(), pair.getLeft());         assertEquals(entry.getValue(), pair.getRight());     }      @Test     public void testPairOfObjects() {         final Pair<Integer, String> pair = Pair.of(0, "foo");         assertTrue(pair instanceof ImmutablePair<?, ?>);         assertEquals(0, ((ImmutablePair<Integer, String>) pair).left.intValue());         assertEquals("foo", ((ImmutablePair<Integer, String>) pair).right);         final Pair<Object, String> pair2 = Pair.of(null, "bar");         assertTrue(pair2 instanceof ImmutablePair<?, ?>);         assertNull(((ImmutablePair<Object, String>) pair2).left);         assertEquals("bar", ((ImmutablePair<Object, String>) pair2).right);         final Pair pair3 = Pair.of(null, null);         assertNull(pair3.getLeft());         assertNull(pair3.getRight());     }      @Test     public void testToString() {         final Pair<String, String> pair = Pair.of("Key", "Value");         assertEquals("(Key,Value)", pair.toString());     }      @Test     public void testToStringCustom() {         final Calendar date = Calendar.getInstance();         date.set(2011, Calendar.APRIL, 25);         final Pair<String, Calendar> pair = Pair.of("DOB", date);         assertEquals("Test created on " + "04-25-2011", pair.toString("Test created on %2$tm-%2$td-%2$tY"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull;  import org.apache.commons.lang3.SerializationUtils; import org.junit.jupiter.api.Test;  /**  * Test the MutableTriple class.  */ public class MutableTripleTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final MutableTriple<Integer, String, Boolean>[] empty = (MutableTriple<Integer, String, Boolean>[]) MutableTriple.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final MutableTriple<Integer, String, Boolean>[] empty = MutableTriple.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testBasic() {         final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<>(0, "foo", Boolean.FALSE);         assertEquals(0, triple.getLeft().intValue());         assertEquals("foo", triple.getMiddle());         assertEquals(Boolean.FALSE, triple.getRight());         final MutableTriple<Object, String, String> triple2 = new MutableTriple<>(null, "bar", "hello");         assertNull(triple2.getLeft());         assertEquals("bar", triple2.getMiddle());         assertEquals("hello", triple2.getRight());     }      @Test     public void testDefault() {         final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<>();         assertNull(triple.getLeft());         assertNull(triple.getMiddle());         assertNull(triple.getRight());     }      @Test     public void testEquals() {         assertEquals(MutableTriple.of(null, "foo", "baz"), MutableTriple.of(null, "foo", "baz"));         assertNotEquals(MutableTriple.of("foo", 0, Boolean.TRUE), MutableTriple.of("foo", null, Boolean.TRUE));         assertNotEquals(MutableTriple.of("foo", "bar", "baz"), MutableTriple.of("xyz", "bar", "baz"));         assertNotEquals(MutableTriple.of("foo", "bar", "baz"), MutableTriple.of("foo", "bar", "blo"));          final MutableTriple<String, String, String> p = MutableTriple.of("foo", "bar", "baz");         assertEquals(p, p);         assertNotEquals(p, new Object());     }      @Test     public void testHashCode() {         assertEquals(MutableTriple.of(null, "foo", "baz").hashCode(), MutableTriple.of(null, "foo", "baz").hashCode());     }      @Test     public void testMutate() {         final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<>(0, "foo", Boolean.TRUE);         triple.setLeft(42);         triple.setMiddle("bar");         triple.setRight(Boolean.FALSE);         assertEquals(42, triple.getLeft().intValue());         assertEquals("bar", triple.getMiddle());         assertEquals(Boolean.FALSE, triple.getRight());     }      @Test     @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         final MutableTriple<Integer, String, Boolean> origTriple = MutableTriple.of(0, "foo", Boolean.TRUE);         final MutableTriple<Integer, String, Boolean> deserializedTriple = SerializationUtils.roundtrip(origTriple);         assertEquals(origTriple, deserializedTriple);         assertEquals(origTriple.hashCode(), deserializedTriple.hashCode());     }      @Test     public void testToString() {         assertEquals("(null,null,null)", MutableTriple.of(null, null, null).toString());         assertEquals("(null,two,null)", MutableTriple.of(null, "two", null).toString());         assertEquals("(one,null,null)", MutableTriple.of("one", null, null).toString());         assertEquals("(one,two,null)", MutableTriple.of("one", "two", null).toString());         assertEquals("(null,two,three)", MutableTriple.of(null, "two", "three").toString());         assertEquals("(one,null,three)", MutableTriple.of("one", null, "three").toString());         assertEquals("(one,two,three)", MutableTriple.of("one", "two", "three").toString());     }      @Test     public void testTripleOf() {         final MutableTriple<Integer, String, Boolean> triple = MutableTriple.of(0, "foo", Boolean.TRUE);         assertEquals(0, triple.getLeft().intValue());         assertEquals("foo", triple.getMiddle());         assertEquals(Boolean.TRUE, triple.getRight());         final MutableTriple<Object, String, String> triple2 = MutableTriple.of(null, "bar", "hello");         assertNull(triple2.getLeft());         assertEquals("bar", triple2.getMiddle());         assertEquals("hello", triple2.getRight());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.Map.Entry; import java.util.TreeMap;  import org.apache.commons.lang3.SerializationUtils; import org.junit.jupiter.api.Test;  /**  * Test the Pair class.  */ public class ImmutablePairTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final ImmutablePair<Integer, String>[] empty = (ImmutablePair<Integer, String>[]) ImmutablePair.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final ImmutablePair<Integer, String>[] empty = ImmutablePair.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testBasic() {         ImmutablePair<Integer, String> oldPair = new ImmutablePair<>(0, "foo");         ImmutablePair<Integer, String> nowPair;         for (int i=0; i<4; i++) {             nowPair = ImmutablePair.of(oldPair);             assertEquals(0, nowPair.left.intValue());             assertEquals(0, nowPair.getLeft().intValue());             assertEquals("foo", nowPair.right);             assertEquals("foo", nowPair.getRight());             assertEquals(oldPair, nowPair);             oldPair = nowPair;         }          ImmutablePair<Object, String> oldPair2 = new ImmutablePair<>(null, "bar");         ImmutablePair<Object, String> nowPair2;         for (int i=0; i<4; i++) {             nowPair2 = ImmutablePair.of(oldPair2);             assertNull(nowPair2.left);             assertNull(nowPair2.getLeft());             assertEquals("bar", nowPair2.right);             assertEquals("bar", nowPair2.getRight());             oldPair2 = nowPair2;         }     }      @Test     public void testEquals() {         assertEquals(ImmutablePair.of(null, "foo"), ImmutablePair.of(null, "foo"));         assertNotEquals(ImmutablePair.of("foo", 0), ImmutablePair.of("foo", null));         assertNotEquals(ImmutablePair.of("foo", "bar"), ImmutablePair.of("xyz", "bar"));          final ImmutablePair<String, String> p = ImmutablePair.of("foo", "bar");         assertEquals(p, p);         assertNotEquals(p, new Object());     }      @Test     public void testHashCode() {         assertEquals(ImmutablePair.of(null, "foo").hashCode(), ImmutablePair.of(null, "foo").hashCode());     }      @Test     public void testNullPairEquals() {         assertEquals(ImmutablePair.nullPair(), ImmutablePair.nullPair());     }      @Test     public void testNullPairKey() {         assertNull(ImmutablePair.nullPair().getKey());     }      @Test     public void testNullPairLeft() {         assertNull(ImmutablePair.nullPair().getLeft());     }      @Test     public void testNullPairRight() {         assertNull(ImmutablePair.nullPair().getRight());     }      @Test     public void testNullPairSame() {         assertSame(ImmutablePair.nullPair(), ImmutablePair.nullPair());     }      @Test     public void testNullPairTyped() {         // No compiler warnings         // How do we assert that?         final ImmutablePair<String, String> pair = ImmutablePair.nullPair();         assertNotNull(pair);     }      @Test     public void testNullPairValue() {         assertNull(ImmutablePair.nullPair().getValue());     }      @Test     public void testPairOfMapEntry() {         final HashMap<Integer, String> map = new HashMap<>();         map.put(0, "foo");         final Entry<Integer, String> entry = map.entrySet().iterator().next();         final Pair<Integer, String> pair = ImmutablePair.of(entry);         assertEquals(entry.getKey(), pair.getLeft());         assertEquals(entry.getValue(), pair.getRight());     }      @Test     public void testPairOfObjects() {         final ImmutablePair<Integer, String> pair = ImmutablePair.of(0, "foo");         assertEquals(0, pair.left.intValue());         assertEquals(0, pair.getLeft().intValue());         assertEquals("foo", pair.right);         assertEquals("foo", pair.getRight());         final ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, "bar");         assertNull(pair2.left);         assertNull(pair2.getLeft());         assertEquals("bar", pair2.right);         assertEquals("bar", pair2.getRight());         final ImmutablePair<?, ?> pair3 = ImmutablePair.of(null, null);         assertNull(pair3.left);         assertNull(pair3.right);     }      @Test     @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         final ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, "foo");         final ImmutablePair<Integer, String> deserializedPair = SerializationUtils.roundtrip(origPair);         assertEquals(origPair, deserializedPair);         assertEquals(origPair.hashCode(), deserializedPair.hashCode());     }      @Test     public void testToString() {         assertEquals("(null,null)", ImmutablePair.of(null, null).toString());         assertEquals("(null,two)", ImmutablePair.of(null, "two").toString());         assertEquals("(one,null)", ImmutablePair.of("one", null).toString());         assertEquals("(one,two)", ImmutablePair.of("one", "two").toString());     }      @Test     public void testUseAsKeyOfHashMap() {         final HashMap<ImmutablePair<Object, Object>, String> map = new HashMap<>();         final Object o1 = new Object();         final Object o2 = new Object();         final ImmutablePair<Object, Object> key1 = ImmutablePair.of(o1, o2);         final String value1 = "a1";         map.put(key1, value1);         assertEquals(value1, map.get(key1));         assertEquals(value1, map.get(ImmutablePair.of(o1, o2)));     }      @Test     public void testUseAsKeyOfTreeMap() {         final TreeMap<ImmutablePair<Integer, Integer>, String> map = new TreeMap<>();         map.put(ImmutablePair.of(1, 2), "12");         map.put(ImmutablePair.of(1, 1), "11");         map.put(ImmutablePair.of(0, 1), "01");         final ArrayList<ImmutablePair<Integer, Integer>> expected = new ArrayList<>();         expected.add(ImmutablePair.of(0, 1));         expected.add(ImmutablePair.of(1, 1));         expected.add(ImmutablePair.of(1, 2));         final Iterator<Entry<ImmutablePair<Integer, Integer>, String>> it = map.entrySet().iterator();         for (final ImmutablePair<Integer, Integer> item : expected) {             final Entry<ImmutablePair<Integer, Integer>, String> entry = it.next();             assertEquals(item, entry.getKey());             assertEquals(item.getLeft() + "" + item.getRight(), entry.getValue());         }     }      @Test     public void testComparableLeftOnly() {         final Pair<String, String> pair1 = ImmutablePair.left("A");         final Pair<String, String> pair2 = ImmutablePair.left("B");         assertEquals("A", pair1.getLeft());         assertEquals("B", pair2.getLeft());         assertEquals(0, pair1.compareTo(pair1));         assertTrue(pair1.compareTo(pair2) < 0);         assertEquals(0, pair2.compareTo(pair2));         assertTrue(pair2.compareTo(pair1) > 0);     }      @Test     public void testComparableRightOnly() {         final Pair<String, String> pair1 = ImmutablePair.right("A");         final Pair<String, String> pair2 = ImmutablePair.right("B");         assertEquals("A", pair1.getRight());         assertEquals("B", pair2.getRight());         assertEquals(0, pair1.compareTo(pair1));         assertTrue(pair1.compareTo(pair2) < 0);         assertEquals(0, pair2.compareTo(pair2));         assertTrue(pair2.compareTo(pair1) > 0);     }      @Test     public void testToStringLeft() {         final Pair<String, String> pair = ImmutablePair.left("Key");         assertEquals("(Key,null)", pair.toString());     }      @Test     public void testToStringRight() {         final Pair<String, String> pair = ImmutablePair.right("Value");         assertEquals("(null,Value)", pair.toString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull;  import java.util.HashMap; import java.util.Map.Entry;  import org.apache.commons.lang3.SerializationUtils; import org.junit.jupiter.api.Test;  /**  * Test the MutablePair class.  */ public class MutablePairTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final MutablePair<Integer, String>[] empty = (MutablePair<Integer, String>[]) MutablePair.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final MutablePair<Integer, String>[] empty = MutablePair.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testBasic() {         MutablePair<Integer, String> oldPair = new MutablePair<>(0, "foo");         MutablePair<Integer, String> nowPair;         for (int i=0; i<4; i++) {             nowPair = MutablePair.of(oldPair);             assertEquals(0, nowPair.left.intValue());             assertEquals(0, nowPair.getLeft().intValue());             assertEquals("foo", nowPair.right);             assertEquals("foo", nowPair.getRight());             assertEquals(oldPair, nowPair);             oldPair = nowPair;         }          MutablePair<Object, String> oldPair2 = new MutablePair<>(null, "bar");         MutablePair<Object, String> nowPair2;         for (int i=0; i<4; i++) {             nowPair2 = MutablePair.of(oldPair2);             assertNull(nowPair2.left);             assertNull(nowPair2.getLeft());             assertEquals("bar", nowPair2.right);             assertEquals("bar", nowPair2.getRight());             oldPair2 = nowPair2;         }     }      @Test     public void testDefault() {         final MutablePair<Integer, String> pair = new MutablePair<>();         assertNull(pair.getLeft());         assertNull(pair.getRight());     }      @Test     public void testEquals() {         assertEquals(MutablePair.of(null, "foo"), MutablePair.of(null, "foo"));         assertNotEquals(MutablePair.of("foo", 0), MutablePair.of("foo", null));         assertNotEquals(MutablePair.of("foo", "bar"), MutablePair.of("xyz", "bar"));          final MutablePair<String, String> p = MutablePair.of("foo", "bar");         assertEquals(p, p);         assertNotEquals(p, new Object());     }      @Test     public void testHashCode() {         assertEquals(MutablePair.of(null, "foo").hashCode(), MutablePair.of(null, "foo").hashCode());     }      @Test     public void testMutate() {         final MutablePair<Integer, String> pair = new MutablePair<>(0, "foo");         pair.setLeft(42);         pair.setRight("bar");         assertEquals(42, pair.getLeft().intValue());         assertEquals("bar", pair.getRight());     }      @Test     public void testPairOfMapEntry() {         final HashMap<Integer, String> map = new HashMap<>();         map.put(0, "foo");         final Entry<Integer, String> entry = map.entrySet().iterator().next();         final Pair<Integer, String> pair = MutablePair.of(entry);         assertEquals(entry.getKey(), pair.getLeft());         assertEquals(entry.getValue(), pair.getRight());     }      @Test     public void testPairOfObjects() {         final MutablePair<Integer, String> pair = MutablePair.of(0, "foo");         assertEquals(0, pair.getLeft().intValue());         assertEquals("foo", pair.getRight());         final MutablePair<Object, String> pair2 = MutablePair.of(null, "bar");         assertNull(pair2.getLeft());         assertEquals("bar", pair2.getRight());         final MutablePair pair3 = MutablePair.of(null, null);         assertNull(pair3.left);         assertNull(pair3.right);     }      @Test     @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         final MutablePair<Integer, String> origPair = MutablePair.of(0, "foo");         final MutablePair<Integer, String> deserializedPair = SerializationUtils.roundtrip(origPair);         assertEquals(origPair, deserializedPair);         assertEquals(origPair.hashCode(), deserializedPair.hashCode());     }      @Test     public void testToString() {         assertEquals("(null,null)", MutablePair.of(null, null).toString());         assertEquals("(null,two)", MutablePair.of(null, "two").toString());         assertEquals("(one,null)", MutablePair.of("one", null).toString());         assertEquals("(one,two)", MutablePair.of("one", "two").toString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.tuple;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.Map.Entry; import java.util.TreeMap;  import org.apache.commons.lang3.SerializationUtils; import org.junit.jupiter.api.Test;  /**  * Test the Triple class.  */ public class ImmutableTripleTest {      @Test     public void testEmptyArrayLength() {         @SuppressWarnings("unchecked")         final ImmutableTriple<Integer, String, Boolean>[] empty = (ImmutableTriple<Integer, String, Boolean>[]) ImmutableTriple.EMPTY_ARRAY;         assertEquals(0, empty.length);     }      @Test     public void testEmptyArrayGenerics() {         final ImmutableTriple<Integer, String, Boolean>[] empty = ImmutableTriple.emptyArray();         assertEquals(0, empty.length);     }      @Test     public void testBasic() {         final ImmutableTriple<Integer, String, Boolean> triple = new ImmutableTriple<>(0, "foo", Boolean.TRUE);         assertEquals(0, triple.left.intValue());         assertEquals(0, triple.getLeft().intValue());         assertEquals("foo", triple.middle);         assertEquals("foo", triple.getMiddle());         assertEquals(Boolean.TRUE, triple.right);         assertEquals(Boolean.TRUE, triple.getRight());         final ImmutableTriple<Object, String, Integer> triple2 = new ImmutableTriple<>(null, "bar", 42);         assertNull(triple2.left);         assertNull(triple2.getLeft());         assertEquals("bar", triple2.middle);         assertEquals("bar", triple2.getMiddle());         assertEquals(new Integer(42), triple2.right);         assertEquals(new Integer(42), triple2.getRight());     }      @Test     public void testEquals() {         assertEquals(ImmutableTriple.of(null, "foo", 42), ImmutableTriple.of(null, "foo", 42));         assertNotEquals(ImmutableTriple.of("foo", 0, Boolean.TRUE), ImmutableTriple.of("foo", null, null));         assertNotEquals(ImmutableTriple.of("foo", "bar", "baz"), ImmutableTriple.of("xyz", "bar", "blo"));          final ImmutableTriple<String, String, String> p = ImmutableTriple.of("foo", "bar", "baz");         assertEquals(p, p);         assertNotEquals(p, new Object());     }      @Test     public void testHashCode() {         assertEquals(ImmutableTriple.of(null, "foo", Boolean.TRUE).hashCode(), ImmutableTriple.of(null, "foo", Boolean.TRUE).hashCode());     }      @Test     public void testNullTripleEquals() {         assertEquals(ImmutableTriple.nullTriple(), ImmutableTriple.nullTriple());     }      @Test     public void testNullTripleLeft() {         assertNull(ImmutableTriple.nullTriple().getLeft());     }      @Test     public void testNullTripleMiddle() {         assertNull(ImmutableTriple.nullTriple().getMiddle());     }      @Test     public void testNullTripleRight() {         assertNull(ImmutableTriple.nullTriple().getRight());     }      @Test     public void testNullTripleSame() {         assertSame(ImmutableTriple.nullTriple(), ImmutableTriple.nullTriple());     }      @Test     public void testNullTripleTyped() {         // No compiler warnings         // How do we assert that?         final ImmutableTriple<String, String, String> triple = ImmutableTriple.nullTriple();         assertNotNull(triple);     }      @Test     @SuppressWarnings("unchecked")     public void testSerialization() throws Exception {         final ImmutableTriple<Integer, String, Boolean> origTriple = ImmutableTriple.of(0, "foo", Boolean.TRUE);         final ImmutableTriple<Integer, String, Boolean> deserializedTriple = SerializationUtils.roundtrip(origTriple);         assertEquals(origTriple, deserializedTriple);         assertEquals(origTriple.hashCode(), deserializedTriple.hashCode());     }      @Test     public void testToString() {         assertEquals("(null,null,null)", ImmutableTriple.of(null, null, null).toString());         assertEquals("(null,two,null)", ImmutableTriple.of(null, "two", null).toString());         assertEquals("(one,null,null)", ImmutableTriple.of("one", null, null).toString());         assertEquals("(one,two,null)", ImmutableTriple.of("one", "two", null).toString());         assertEquals("(null,two,three)", ImmutableTriple.of(null, "two", "three").toString());         assertEquals("(one,null,three)", ImmutableTriple.of("one", null, "three").toString());         assertEquals("(one,two,three)", MutableTriple.of("one", "two", "three").toString());     }      @Test     public void testTripleOf() {         final ImmutableTriple<Integer, String, Boolean> triple = ImmutableTriple.of(0, "foo", Boolean.FALSE);         assertEquals(0, triple.left.intValue());         assertEquals(0, triple.getLeft().intValue());         assertEquals("foo", triple.middle);         assertEquals("foo", triple.getMiddle());         assertEquals(Boolean.FALSE, triple.right);         assertEquals(Boolean.FALSE, triple.getRight());         final ImmutableTriple<Object, String, Boolean> triple2 = ImmutableTriple.of(null, "bar", Boolean.TRUE);         assertNull(triple2.left);         assertNull(triple2.getLeft());         assertEquals("bar", triple2.middle);         assertEquals("bar", triple2.getMiddle());         assertEquals(Boolean.TRUE, triple2.right);         assertEquals(Boolean.TRUE, triple2.getRight());     }      @Test     public void testUseAsKeyOfHashMap() {         final HashMap<ImmutableTriple<Object, Object, Object>, String> map = new HashMap<>();         final Object o1 = new Object();         final Object o2 = new Object();         final Object o3 = new Object();         final ImmutableTriple<Object, Object, Object> key1 = ImmutableTriple.of(o1, o2, o3);         final String value1 = "a1";         map.put(key1, value1);         assertEquals(value1, map.get(key1));         assertEquals(value1, map.get(ImmutableTriple.of(o1, o2, o3)));     }      @Test     public void testUseAsKeyOfTreeMap() {         final TreeMap<ImmutableTriple<Integer, Integer, Integer>, String> map = new TreeMap<>();         map.put(ImmutableTriple.of(0, 1, 2), "012");         map.put(ImmutableTriple.of(0, 1, 1), "011");         map.put(ImmutableTriple.of(0, 0, 1), "001");         final ArrayList<ImmutableTriple<Integer, Integer, Integer>> expected = new ArrayList<>();         expected.add(ImmutableTriple.of(0, 0, 1));         expected.add(ImmutableTriple.of(0, 1, 1));         expected.add(ImmutableTriple.of(0, 1, 2));         final Iterator<Entry<ImmutableTriple<Integer, Integer, Integer>, String>> it = map.entrySet().iterator();         for (final ImmutableTriple<Integer, Integer, Integer> item : expected) {             final Entry<ImmutableTriple<Integer, Integer, Integer>, String> entry = it.next();             assertEquals(item, entry.getKey());             assertEquals(item.getLeft() + "" + item.getMiddle() + "" + item.getRight(), entry.getValue());         }     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.CharSet}.  */ public class CharSetTest  {      //-----------------------------------------------------------------------     @Test     public void testClass() {         assertTrue(Modifier.isPublic(CharSet.class.getModifiers()));         assertFalse(Modifier.isFinal(CharSet.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testGetInstance() {         assertSame(CharSet.EMPTY, CharSet.getInstance( (String) null));         assertSame(CharSet.EMPTY, CharSet.getInstance(""));         assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance("a-zA-Z"));         assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance("A-Za-z"));         assertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance("a-z"));         assertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance("A-Z"));         assertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance("0-9"));     }      //-----------------------------------------------------------------------     @Test     public void testGetInstance_Stringarray() {         assertNull(CharSet.getInstance((String[]) null));         assertEquals("[]", CharSet.getInstance(new String[0]).toString());         assertEquals("[]", CharSet.getInstance(new String[] {null}).toString());         assertEquals("[a-e]", CharSet.getInstance(new String[] {"a-e"}).toString());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_String_simple() {         CharSet set;         CharRange[] array;          set = CharSet.getInstance((String) null);         array = set.getCharRanges();         assertEquals("[]", set.toString());         assertEquals(0, array.length);          set = CharSet.getInstance("");         array = set.getCharRanges();         assertEquals("[]", set.toString());         assertEquals(0, array.length);          set = CharSet.getInstance("a");         array = set.getCharRanges();         assertEquals("[a]", set.toString());         assertEquals(1, array.length);         assertEquals("a", array[0].toString());          set = CharSet.getInstance("^a");         array = set.getCharRanges();         assertEquals("[^a]", set.toString());         assertEquals(1, array.length);         assertEquals("^a", array[0].toString());          set = CharSet.getInstance("a-e");         array = set.getCharRanges();         assertEquals("[a-e]", set.toString());         assertEquals(1, array.length);         assertEquals("a-e", array[0].toString());          set = CharSet.getInstance("^a-e");         array = set.getCharRanges();         assertEquals("[^a-e]", set.toString());         assertEquals(1, array.length);         assertEquals("^a-e", array[0].toString());     }      @Test     public void testConstructor_String_combo() {         CharSet set;         CharRange[] array;          set = CharSet.getInstance("abc");         array = set.getCharRanges();         assertEquals(3, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));         assertTrue(ArrayUtils.contains(array, CharRange.is('b')));         assertTrue(ArrayUtils.contains(array, CharRange.is('c')));          set = CharSet.getInstance("a-ce-f");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'c')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f')));          set = CharSet.getInstance("ae-f");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f')));          set = CharSet.getInstance("e-fa");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f')));          set = CharSet.getInstance("ae-fm-pz");         array = set.getCharRanges();         assertEquals(4, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('e', 'f')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('m', 'p')));         assertTrue(ArrayUtils.contains(array, CharRange.is('z')));     }      @Test     public void testConstructor_String_comboNegated() {         CharSet set;         CharRange[] array;          set = CharSet.getInstance("^abc");         array = set.getCharRanges();         assertEquals(3, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('a')));         assertTrue(ArrayUtils.contains(array, CharRange.is('b')));         assertTrue(ArrayUtils.contains(array, CharRange.is('c')));          set = CharSet.getInstance("b^ac");         array = set.getCharRanges();         assertEquals(3, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('b')));         assertTrue(ArrayUtils.contains(array, CharRange.isNot('a')));         assertTrue(ArrayUtils.contains(array, CharRange.is('c')));          set = CharSet.getInstance("db^ac");         array = set.getCharRanges();         assertEquals(4, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('d')));         assertTrue(ArrayUtils.contains(array, CharRange.is('b')));         assertTrue(ArrayUtils.contains(array, CharRange.isNot('a')));         assertTrue(ArrayUtils.contains(array, CharRange.is('c')));          set = CharSet.getInstance("^b^a");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('b')));         assertTrue(ArrayUtils.contains(array, CharRange.isNot('a')));          set = CharSet.getInstance("b^a-c^z");         array = set.getCharRanges();         assertEquals(3, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('a', 'c')));         assertTrue(ArrayUtils.contains(array, CharRange.isNot('z')));         assertTrue(ArrayUtils.contains(array, CharRange.is('b')));     }      @Test     public void testConstructor_String_oddDash() {         CharSet set;         CharRange[] array;          set = CharSet.getInstance("-");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));          set = CharSet.getInstance("--");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));          set = CharSet.getInstance("---");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));          set = CharSet.getInstance("----");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));          set = CharSet.getInstance("-a");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));          set = CharSet.getInstance("a-");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a')));         assertTrue(ArrayUtils.contains(array, CharRange.is('-')));          set = CharSet.getInstance("a--");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', '-')));          set = CharSet.getInstance("--a");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('-', 'a')));     }      @Test     public void testConstructor_String_oddNegate() {         CharSet set;         CharRange[] array;         set = CharSet.getInstance("^");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^"          set = CharSet.getInstance("^^");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^"          set = CharSet.getInstance("^^^");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^"         assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^"          set = CharSet.getInstance("^^^^");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^" x2          set = CharSet.getInstance("a^");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.is('a'))); // "a"         assertTrue(ArrayUtils.contains(array, CharRange.is('^'))); // "^"          set = CharSet.getInstance("^a-");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('a'))); // "^a"         assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); // "-"          set = CharSet.getInstance("^^-c");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('^', 'c'))); // "^^-c"          set = CharSet.getInstance("^c-^");         array = set.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // "^c-^"          set = CharSet.getInstance("^c-^d");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('c', '^'))); // "^c-^"         assertTrue(ArrayUtils.contains(array, CharRange.is('d'))); // "d"          set = CharSet.getInstance("^^-");         array = set.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isNot('^'))); // "^^"         assertTrue(ArrayUtils.contains(array, CharRange.is('-'))); // "-"     }      @Test     public void testConstructor_String_oddCombinations() {         CharSet set;         CharRange[] array = null;          set = CharSet.getInstance("a-^c");         array = set.getCharRanges();         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', '^'))); // "a-^"         assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); // "c"         assertFalse(set.contains('b'));         assertTrue(set.contains('^'));         assertTrue(set.contains('_')); // between ^ and a         assertTrue(set.contains('c'));          set = CharSet.getInstance("^a-^c");         array = set.getCharRanges();         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('a', '^'))); // "^a-^"         assertTrue(ArrayUtils.contains(array, CharRange.is('c'))); // "c"         assertTrue(set.contains('b'));         assertFalse(set.contains('^'));         assertFalse(set.contains('_')); // between ^ and a          set = CharSet.getInstance("a- ^-- "); //contains everything         array = set.getCharRanges();         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', ' '))); // "a- "         assertTrue(ArrayUtils.contains(array, CharRange.isNotIn('-', ' '))); // "^-- "         assertTrue(set.contains('#'));         assertTrue(set.contains('^'));         assertTrue(set.contains('a'));         assertTrue(set.contains('*'));         assertTrue(set.contains('A'));          set = CharSet.getInstance("^-b");         array = set.getCharRanges();         assertTrue(ArrayUtils.contains(array, CharRange.isIn('^', 'b'))); // "^-b"         assertTrue(set.contains('b'));         assertTrue(set.contains('_')); // between ^ and a         assertFalse(set.contains('A'));         assertTrue(set.contains('^'));          set = CharSet.getInstance("b-^");         array = set.getCharRanges();         assertTrue(ArrayUtils.contains(array, CharRange.isIn('^', 'b'))); // "b-^"         assertTrue(set.contains('b'));         assertTrue(set.contains('^'));         assertTrue(set.contains('a')); // between ^ and b         assertFalse(set.contains('c'));     }      //-----------------------------------------------------------------------     @Test     public void testEquals_Object() {         final CharSet abc = CharSet.getInstance("abc");         final CharSet abc2 = CharSet.getInstance("abc");         final CharSet atoc = CharSet.getInstance("a-c");         final CharSet atoc2 = CharSet.getInstance("a-c");         final CharSet notatoc = CharSet.getInstance("^a-c");         final CharSet notatoc2 = CharSet.getInstance("^a-c");          assertNotEquals(null, abc);          assertEquals(abc, abc);         assertEquals(abc, abc2);         assertNotEquals(abc, atoc);         assertNotEquals(abc, notatoc);          assertNotEquals(atoc, abc);         assertEquals(atoc, atoc);         assertEquals(atoc, atoc2);         assertNotEquals(atoc, notatoc);          assertNotEquals(notatoc, abc);         assertNotEquals(notatoc, atoc);         assertEquals(notatoc, notatoc);         assertEquals(notatoc, notatoc2);     }      @Test     public void testHashCode() {         final CharSet abc = CharSet.getInstance("abc");         final CharSet abc2 = CharSet.getInstance("abc");         final CharSet atoc = CharSet.getInstance("a-c");         final CharSet atoc2 = CharSet.getInstance("a-c");         final CharSet notatoc = CharSet.getInstance("^a-c");         final CharSet notatoc2 = CharSet.getInstance("^a-c");          assertEquals(abc.hashCode(), abc.hashCode());         assertEquals(abc.hashCode(), abc2.hashCode());         assertEquals(atoc.hashCode(), atoc.hashCode());         assertEquals(atoc.hashCode(), atoc2.hashCode());         assertEquals(notatoc.hashCode(), notatoc.hashCode());         assertEquals(notatoc.hashCode(), notatoc2.hashCode());     }      //-----------------------------------------------------------------------     @Test     public void testContains_Char() {         final CharSet btod = CharSet.getInstance("b-d");         final CharSet dtob = CharSet.getInstance("d-b");         final CharSet bcd = CharSet.getInstance("bcd");         final CharSet bd = CharSet.getInstance("bd");         final CharSet notbtod = CharSet.getInstance("^b-d");          assertFalse(btod.contains('a'));         assertTrue(btod.contains('b'));         assertTrue(btod.contains('c'));         assertTrue(btod.contains('d'));         assertFalse(btod.contains('e'));          assertFalse(bcd.contains('a'));         assertTrue(bcd.contains('b'));         assertTrue(bcd.contains('c'));         assertTrue(bcd.contains('d'));         assertFalse(bcd.contains('e'));          assertFalse(bd.contains('a'));         assertTrue(bd.contains('b'));         assertFalse(bd.contains('c'));         assertTrue(bd.contains('d'));         assertFalse(bd.contains('e'));          assertTrue(notbtod.contains('a'));         assertFalse(notbtod.contains('b'));         assertFalse(notbtod.contains('c'));         assertFalse(notbtod.contains('d'));         assertTrue(notbtod.contains('e'));          assertFalse(dtob.contains('a'));         assertTrue(dtob.contains('b'));         assertTrue(dtob.contains('c'));         assertTrue(dtob.contains('d'));         assertFalse(dtob.contains('e'));          final CharRange[] array = dtob.getCharRanges();         assertEquals("[b-d]", dtob.toString());         assertEquals(1, array.length);     }      //-----------------------------------------------------------------------     @Test     public void testSerialization() {         CharSet set = CharSet.getInstance("a");         assertEquals(set, SerializationUtils.clone(set));         set = CharSet.getInstance("a-e");         assertEquals(set, SerializationUtils.clone(set));         set = CharSet.getInstance("be-f^a-z");         assertEquals(set, SerializationUtils.clone(set));     }      //-----------------------------------------------------------------------     @Test     public void testStatics() {         CharRange[] array;          array = CharSet.EMPTY.getCharRanges();         assertEquals(0, array.length);          array = CharSet.ASCII_ALPHA.getCharRanges();         assertEquals(2, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'z')));         assertTrue(ArrayUtils.contains(array, CharRange.isIn('A', 'Z')));          array = CharSet.ASCII_ALPHA_LOWER.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('a', 'z')));          array = CharSet.ASCII_ALPHA_UPPER.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('A', 'Z')));          array = CharSet.ASCII_NUMERIC.getCharRanges();         assertEquals(1, array.length);         assertTrue(ArrayUtils.contains(array, CharRange.isIn('0', '9')));     }      @Test     public void testJavadocExamples() {         assertFalse(CharSet.getInstance("^a-c").contains('a'));         assertTrue(CharSet.getInstance("^a-c").contains('d'));         assertTrue(CharSet.getInstance("^^a-c").contains('a'));         assertFalse(CharSet.getInstance("^^a-c").contains('^'));         assertTrue(CharSet.getInstance("^a-cd-f").contains('d'));         assertTrue(CharSet.getInstance("a-c^").contains('^'));         assertTrue(CharSet.getInstance("^", "a-c").contains('^'));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */  package org.apache.commons.lang3;  import static org.apache.commons.lang3.JavaVersion.JAVA_10; import static org.apache.commons.lang3.JavaVersion.JAVA_11; import static org.apache.commons.lang3.JavaVersion.JAVA_12; import static org.apache.commons.lang3.JavaVersion.JAVA_13; import static org.apache.commons.lang3.JavaVersion.JAVA_1_1; import static org.apache.commons.lang3.JavaVersion.JAVA_1_2; import static org.apache.commons.lang3.JavaVersion.JAVA_1_3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.apache.commons.lang3.JavaVersion.JAVA_1_5; import static org.apache.commons.lang3.JavaVersion.JAVA_1_6; import static org.apache.commons.lang3.JavaVersion.JAVA_1_7; import static org.apache.commons.lang3.JavaVersion.JAVA_1_8; import static org.apache.commons.lang3.JavaVersion.JAVA_9; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Locale;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.SystemUtils}.  *  * Only limited testing can be performed.  */ public class SystemUtilsTest {      @Test     public void testConstructor() {         assertNotNull(new SystemUtils());         final Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(SystemUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(SystemUtils.class.getModifiers()));     }      @Test     public void testGetEnvironmentVariableAbsent() {         final String name = "THIS_ENV_VAR_SHOULD_NOT_EXIST_FOR_THIS_TEST_TO_PASS";         final String expected = System.getenv(name);         assertNull(expected);         final String value = SystemUtils.getEnvironmentVariable(name, "DEFAULT");         assertEquals("DEFAULT", value);     }      @Test     public void testGetEnvironmentVariablePresent() {         final String name = "PATH";         final String expected = System.getenv(name);         final String value = SystemUtils.getEnvironmentVariable(name, null);         assertEquals(expected, value);     }      @Test     public void testGetHostName() {         final String hostName = SystemUtils.getHostName();         final String expected = SystemUtils.IS_OS_WINDOWS ? System.getenv("COMPUTERNAME") : System.getenv("HOSTNAME");         assertEquals(expected, hostName);     }      /**      * Assumes no security manager exists.      */     @Test     public void testGetJavaHome() {         final File dir = SystemUtils.getJavaHome();         assertNotNull(dir);         assertTrue(dir.exists());     }      /**      * Assumes no security manager exists.      */     @Test     public void testGetJavaIoTmpDir() {         final File dir = SystemUtils.getJavaIoTmpDir();         assertNotNull(dir);         assertTrue(dir.exists());     }      /**      * Assumes no security manager exists.      */     @Test     public void testGetUserDir() {         final File dir = SystemUtils.getUserDir();         assertNotNull(dir);         assertTrue(dir.exists());     }      /**      * Assumes no security manager exists.      */     @Test     public void testGetUserHome() {         final File dir = SystemUtils.getUserHome();         assertNotNull(dir);         assertTrue(dir.exists());     }      /**      * Assumes no security manager exists.      */     @Test     public void testGetUserName() {         assertEquals(System.getProperty("user.name"), SystemUtils.getUserName());         // Don't overwrite the system property in this test in case something goes awfully wrong.         assertEquals(System.getProperty("user.name", "foo"), SystemUtils.getUserName("foo"));     }      @Test     @SuppressWarnings("deprecation")     public void testIS_JAVA() {         final String javaVersion = SystemUtils.JAVA_VERSION;         if (javaVersion == null) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("1.8")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertTrue(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("9")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertTrue(SystemUtils.IS_JAVA_1_9);             assertTrue(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("10")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertTrue(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("11")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertTrue(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("12")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertTrue(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);         } else if (javaVersion.startsWith("13")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertTrue(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("14")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertTrue(SystemUtils.IS_JAVA_14);             assertFalse(SystemUtils.IS_JAVA_15);         } else if (javaVersion.startsWith("15")) {             assertFalse(SystemUtils.IS_JAVA_1_1);             assertFalse(SystemUtils.IS_JAVA_1_2);             assertFalse(SystemUtils.IS_JAVA_1_3);             assertFalse(SystemUtils.IS_JAVA_1_4);             assertFalse(SystemUtils.IS_JAVA_1_5);             assertFalse(SystemUtils.IS_JAVA_1_6);             assertFalse(SystemUtils.IS_JAVA_1_7);             assertFalse(SystemUtils.IS_JAVA_1_8);             assertFalse(SystemUtils.IS_JAVA_1_9);             assertFalse(SystemUtils.IS_JAVA_9);             assertFalse(SystemUtils.IS_JAVA_10);             assertFalse(SystemUtils.IS_JAVA_11);             assertFalse(SystemUtils.IS_JAVA_12);             assertFalse(SystemUtils.IS_JAVA_13);             assertFalse(SystemUtils.IS_JAVA_14);             assertTrue(SystemUtils.IS_JAVA_15);         } else {             System.out.println("Can't test IS_JAVA value: " + javaVersion);         }     }      @Test     public void testIS_OS() {         final String osName = System.getProperty("os.name");         if (osName == null) {             assertFalse(SystemUtils.IS_OS_WINDOWS);             assertFalse(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_SOLARIS);             assertFalse(SystemUtils.IS_OS_LINUX);             assertFalse(SystemUtils.IS_OS_MAC_OSX);         } else if (osName.startsWith("Windows")) {             assertFalse(SystemUtils.IS_OS_UNIX);             assertTrue(SystemUtils.IS_OS_WINDOWS);         } else if (osName.startsWith("Solaris")) {             assertTrue(SystemUtils.IS_OS_SOLARIS);             assertTrue(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else if (osName.toLowerCase(Locale.ENGLISH).startsWith("linux")) {             assertTrue(SystemUtils.IS_OS_LINUX);             assertTrue(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else if (osName.startsWith("Mac OS X")) {             assertTrue(SystemUtils.IS_OS_MAC_OSX);             assertTrue(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else if (osName.startsWith("OS/2")) {             assertTrue(SystemUtils.IS_OS_OS2);             assertFalse(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else if (osName.startsWith("SunOS")) {             assertTrue(SystemUtils.IS_OS_SUN_OS);             assertTrue(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else if (osName.startsWith("FreeBSD")) {             assertTrue(SystemUtils.IS_OS_FREE_BSD);             assertTrue(SystemUtils.IS_OS_UNIX);             assertFalse(SystemUtils.IS_OS_WINDOWS);         } else {             System.out.println("Can't test IS_OS value: " + osName);         }     }      @Test     public void testIS_zOS() {         final String osName = System.getProperty("os.name");         if (osName == null) {             assertFalse(SystemUtils.IS_OS_ZOS);         } else if (osName.contains("z/OS")) {             assertFalse(SystemUtils.IS_OS_WINDOWS);             assertTrue(SystemUtils.IS_OS_ZOS);         }     }      @Test     public void testJavaVersionMatches() {         String javaVersion = null;         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.0";         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.1";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.2";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.3.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.3.1";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.4.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.4.1";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.4.2";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.5.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.6.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.7.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "1.8.0";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "9"));         javaVersion = "9";         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.0"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.1"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.2"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.3"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.4"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.5"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.6"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.7"));         assertFalse(SystemUtils.isJavaVersionMatch(javaVersion, "1.8"));         assertTrue(SystemUtils.isJavaVersionMatch(javaVersion, "9"));     }      @Test     public void testIsJavaVersionAtLeast() {         if (SystemUtils.IS_JAVA_1_8) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_13));         } else if (SystemUtils.IS_JAVA_9) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_13));         } else if (SystemUtils.IS_JAVA_10) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_13));         } else if (SystemUtils.IS_JAVA_11) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_13));         } else if (SystemUtils.IS_JAVA_12) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertFalse(SystemUtils.isJavaVersionAtLeast(JAVA_13));         } else if (SystemUtils.IS_JAVA_13) {             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_1));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_2));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_3));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_4));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_5));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_6));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtLeast(JAVA_13));         }     }      @Test     public void testIsJavaVersionAtMost() {         if (SystemUtils.IS_JAVA_1_8) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         } else if (SystemUtils.IS_JAVA_9) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         } else if (SystemUtils.IS_JAVA_10) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         } else if (SystemUtils.IS_JAVA_11) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         } else if (SystemUtils.IS_JAVA_12) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         } else if (SystemUtils.IS_JAVA_13) {             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_1));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_2));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_3));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_4));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_5));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_6));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_7));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_1_8));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_9));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_10));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_11));             assertFalse(SystemUtils.isJavaVersionAtMost(JAVA_12));             assertTrue(SystemUtils.isJavaVersionAtMost(JAVA_13));         }     }      @Test     public void testOSMatchesName() {         String osName = null;         assertFalse(SystemUtils.isOSNameMatch(osName, "Windows"));         osName = "";         assertFalse(SystemUtils.isOSNameMatch(osName, "Windows"));         osName = "Windows 95";         assertTrue(SystemUtils.isOSNameMatch(osName, "Windows"));         osName = "Windows NT";         assertTrue(SystemUtils.isOSNameMatch(osName, "Windows"));         osName = "OS/2";         assertFalse(SystemUtils.isOSNameMatch(osName, "Windows"));     }      @Test     public void testOSMatchesNameAndVersion() {         String osName = null;         String osVersion = null;         assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "";         osVersion = "";         assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "Windows 95";         osVersion = "4.0";         assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "Windows 95";         osVersion = "4.1";         assertTrue(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "Windows 98";         osVersion = "4.1";         assertTrue(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "Windows NT";         osVersion = "4.0";         assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));         osName = "OS/2";         osVersion = "4.0";         assertFalse(SystemUtils.isOSMatch(osName, osVersion, "Windows 9", "4.1"));     }      @Test     public void testOsVersionMatches() {         String osVersion = null;         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1"));          osVersion = "";         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1"));          osVersion = "10";         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10.1"));          osVersion = "10.1";         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1.1"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.10"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.10.1"));          osVersion = "10.1.1";         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.1.1"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.10"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.10.1"));          osVersion = "10.10";         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10.1"));          osVersion = "10.10.1";         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1"));         assertFalse(SystemUtils.isOSVersionMatch(osVersion, "10.1.1"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10"));         assertTrue(SystemUtils.isOSVersionMatch(osVersion, "10.10.1"));     }      @Test     public void testJavaAwtHeadless() {         final String expectedStringValue = System.getProperty("java.awt.headless");         final String expectedStringValueWithDefault = System.getProperty("java.awt.headless", "false");         assertNotNull(expectedStringValueWithDefault);         final boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue();         if (expectedStringValue != null) {             assertEquals(expectedStringValue, SystemUtils.JAVA_AWT_HEADLESS);         }         assertEquals(expectedValue, SystemUtils.isJavaAwtHeadless());         assertEquals(expectedStringValueWithDefault, "" + SystemUtils.isJavaAwtHeadless());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.params.provider.Arguments.arguments;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Random; import java.util.stream.IntStream; import java.util.stream.Stream;  import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  /**  * Tests CharSequenceUtils  */ public class CharSequenceUtilsTest {      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new CharSequenceUtils());         final Constructor<?>[] cons = CharSequenceUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(CharSequenceUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(CharSequenceUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testSubSequence() {         //         // null input         //         assertNull(CharSequenceUtils.subSequence(null, -1));         assertNull(CharSequenceUtils.subSequence(null, 0));         assertNull(CharSequenceUtils.subSequence(null, 1));         //         // non-null input         //         assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0));         assertEquals("012", CharSequenceUtils.subSequence("012", 0));         assertEquals("12", CharSequenceUtils.subSequence("012", 1));         assertEquals("2", CharSequenceUtils.subSequence("012", 2));         assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence("012", 3));     }      @Test     public void testSubSequenceNegativeStart() {         assertThrows(IndexOutOfBoundsException.class, () -> CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));     }      @Test     public void testSubSequenceTooLong() {         assertThrows(IndexOutOfBoundsException.class, () -> CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));     }      static class TestData{         final String source;         final boolean ignoreCase;         final int toffset;         final String other;         final int ooffset;         final int len;         final boolean expected;         final Class<? extends Throwable> throwable;         TestData(final String source, final boolean ignoreCase, final int toffset,                 final String other, final int ooffset, final int len, final boolean expected) {             this.source = source;             this.ignoreCase = ignoreCase;             this.toffset = toffset;             this.other = other;             this.ooffset = ooffset;             this.len = len;             this.expected = expected;             this.throwable = null;         }         TestData(final String source, final boolean ignoreCase, final int toffset,                 final String other, final int ooffset, final int len, final Class<? extends Throwable> throwable) {             this.source = source;             this.ignoreCase = ignoreCase;             this.toffset = toffset;             this.other = other;             this.ooffset = ooffset;             this.len = len;             this.expected = false;             this.throwable = throwable;         }         @Override         public String toString() {             final StringBuilder sb = new StringBuilder();             sb.append(source).append("[").append(toffset).append("]");             sb.append(ignoreCase? " caseblind ":" samecase ");             sb.append(other).append("[").append(ooffset).append("]");             sb.append(" ").append(len).append(" => ");             if (throwable != null) {                 sb.append(throwable);             } else {                 sb.append(expected);             }             return sb.toString();         }     }      private static final TestData[] TEST_DATA = {             //          Source  IgnoreCase Offset Other  Offset Length Result             new TestData("",    true,      -1,    "",    -1,    -1,    false),             new TestData("",    true,      0,     "",    0,     1,     false),             new TestData("a",   true,      0,     "abc", 0,     0,     true),             new TestData("a",   true,      0,     "abc", 0,     1,     true),             new TestData("a",   true,      0,     null,  0,     0,     NullPointerException.class),             new TestData(null,  true,      0,     null,  0,     0,     NullPointerException.class),             new TestData(null,  true,      0,     "",    0,     0,     NullPointerException.class),             new TestData("Abc", true,      0,     "abc", 0,     3,     true),             new TestData("Abc", false,     0,     "abc", 0,     3,     false),             new TestData("Abc", true,      1,     "abc", 1,     2,     true),             new TestData("Abc", false,     1,     "abc", 1,     2,     true),             new TestData("Abcd", true,      1,     "abcD", 1,     2,     true),             new TestData("Abcd", false,     1,     "abcD", 1,     2,     true),     };      private abstract static class RunTest {          abstract boolean invoke();          void run(final TestData data, final String id) {             if (data.throwable != null) {                 assertThrows(data.throwable, this::invoke, id + " Expected " + data.throwable);             } else {                 final boolean stringCheck = invoke();                 assertEquals(data.expected, stringCheck, id + " Failed test " + data);             }         }      }      @Test     public void testRegionMatches() {         for (final TestData data : TEST_DATA) {             new RunTest() {                 @Override                 boolean invoke() {                     return data.source.regionMatches(data.ignoreCase, data.toffset, data.other, data.ooffset, data.len);                 }             }.run(data, "String");             new RunTest() {                 @Override                 boolean invoke() {                     return CharSequenceUtils.regionMatches(data.source, data.ignoreCase, data.toffset, data.other, data.ooffset, data.len);                 }             }.run(data, "CSString");             new RunTest() {                 @Override                 boolean invoke() {                     return CharSequenceUtils.regionMatches(new StringBuilder(data.source), data.ignoreCase, data.toffset, data.other, data.ooffset, data.len);                 }             }.run(data, "CSNonString");         }     }       @Test     public void testToCharArray() {         final StringBuilder builder = new StringBuilder("abcdefg");         final char[] expected = builder.toString().toCharArray();         assertArrayEquals(expected, CharSequenceUtils.toCharArray(builder));         assertArrayEquals(expected, CharSequenceUtils.toCharArray(builder.toString()));         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, CharSequenceUtils.toCharArray(null));     }      static class WrapperString implements CharSequence {         private final CharSequence inner;          WrapperString(final CharSequence inner) {             this.inner = inner;         }          @Override         public int length() {             return inner.length();         }          @Override         public char charAt(final int index) {             return inner.charAt(index);         }          @Override         public CharSequence subSequence(final int start, final int end) {             return inner.subSequence(start, end);         }          @Override         public String toString() {             return inner.toString();         }          @Override         public IntStream chars() {             return inner.chars();         }          @Override         public IntStream codePoints() {             return inner.codePoints();         }     }      @Test     public void testNewLastIndexOf() {         testNewLastIndexOfSingle("808087847-1321060740-635567660180086727-925755305", "-1321060740-635567660", 21);         testNewLastIndexOfSingle("", "");         testNewLastIndexOfSingle("1", "");         testNewLastIndexOfSingle("", "1");         testNewLastIndexOfSingle("1", "1");         testNewLastIndexOfSingle("11", "1");         testNewLastIndexOfSingle("1", "11");          testNewLastIndexOfSingle("apache", "a");         testNewLastIndexOfSingle("apache", "p");         testNewLastIndexOfSingle("apache", "e");         testNewLastIndexOfSingle("apache", "x");         testNewLastIndexOfSingle("oraoraoraora", "r");         testNewLastIndexOfSingle("mudamudamudamuda", "d");          final Random random = new Random();         final StringBuilder seg = new StringBuilder();         while (seg.length() <= CharSequenceUtils.TO_STRING_LIMIT) {             seg.append(random.nextInt());         }         StringBuilder original = new StringBuilder(seg);         testNewLastIndexOfSingle(original, seg);         for (int i = 0; i < 100; i++) {             if (random.nextDouble() < 0.5) {                 original.append(random.nextInt() % 10);             } else {                 original = new StringBuilder().append(String.valueOf(random.nextInt() % 100)).append(original);             }             testNewLastIndexOfSingle(original, seg);         }     }      @ParameterizedTest     @MethodSource("lastIndexWithStandardCharSequence")     public void testLastIndexOfWithDifferentCharSequences(CharSequence cs, CharSequence search, int start,                                                           int expected) {         assertEquals(expected, CharSequenceUtils.lastIndexOf(cs, search, start));     }      static Stream<Arguments> lastIndexWithStandardCharSequence() {         return Stream.of(             arguments("abc", "b", 2, 1),             arguments(new StringBuilder("abc"), "b", 2, 1),             arguments(new StringBuffer("abc"), "b", 2, 1),             arguments("abc", new StringBuilder("b"), 2, 1),             arguments(new StringBuilder("abc"), new StringBuilder("b"), 2, 1),             arguments(new StringBuffer("abc"), new StringBuffer("b"), 2, 1),             arguments(new StringBuilder("abc"), new StringBuffer("b"), 2, 1)         );     }      private void testNewLastIndexOfSingle(final CharSequence a, final CharSequence b) {         final int maxa = Math.max(a.length(), b.length());         for (int i = -maxa - 10; i <= maxa + 10; i++) {             testNewLastIndexOfSingle(a, b, i);         }         testNewLastIndexOfSingle(a, b, Integer.MIN_VALUE);         testNewLastIndexOfSingle(a, b, Integer.MAX_VALUE);     }      private void testNewLastIndexOfSingle(final CharSequence a, final CharSequence b, final int start) {         testNewLastIndexOfSingleSingle(a, b, start);         testNewLastIndexOfSingleSingle(b, a, start);     }      private void testNewLastIndexOfSingleSingle(final CharSequence a, final CharSequence b, final int start) {         assertEquals(                 a.toString().lastIndexOf(b.toString(), start),                 CharSequenceUtils.lastIndexOf(new WrapperString(a.toString()), new WrapperString(b.toString()), start),                 "testNewLastIndexOf fails! original : " + a + " seg : " + b + " start : " + start         );     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.List; import java.util.concurrent.CountDownLatch;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.ThreadUtils}.  */ public class ThreadUtilsTest {      @Test     public void testNullThreadName() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName(null));     }      @Test     public void testNullThreadGroupName() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadGroupsByName(null));     }      @Test     public void testNullThreadThreadGroupName1() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName(null, "tgname"));     }      @Test     public void testNullThreadThreadGroupName2() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName("tname", (String) null));     }      @Test     public void testNullThreadThreadGroupName3() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName(null, (String) null));     }      @Test     public void testNullThreadThreadGroup1() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName("tname", (ThreadGroup) null));     }      @Test     public void testNullThreadThreadGroup2() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadById(1L, (ThreadGroup) null));     }      @Test     public void testNullThreadThreadGroup3() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadsByName(null, (ThreadGroup) null));     }      @Test     public void testInvalidThreadId() {         assertThrows(IllegalArgumentException.class, () -> ThreadUtils.findThreadById(-5L));     }      @Test     public void testThreadGroupsByIdFail() {         assertThrows(NullPointerException.class,                 () -> ThreadUtils.findThreadById(Thread.currentThread().getId(), (String) null));     }      @Test     public void testThreadgroupsNullParent() {         assertThrows(NullPointerException.class,                 () -> ThreadUtils.findThreadGroups(null, true, ThreadUtils.ALWAYS_TRUE_PREDICATE));     }      @Test     public void testThreadgroupsNullPredicate() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreadGroups(null));     }      @Test     public void testThreadsNullPredicate() {         assertThrows(NullPointerException.class, () -> ThreadUtils.findThreads(null));     }      @Test     public void testNoThread() {         assertEquals(0, ThreadUtils.findThreadsByName("some_thread_which_does_not_exist_18762ZucTT").size());     }      @Test     public void testNoThreadGroup() {         assertEquals(0, ThreadUtils.findThreadGroupsByName("some_thread_group_which_does_not_exist_18762ZucTTII").size());     }      @Test     public void testSystemThreadGroupExists() {         final ThreadGroup systemThreadGroup = ThreadUtils.getSystemThreadGroup();         assertNotNull(systemThreadGroup);         assertNull(systemThreadGroup.getParent());         assertEquals("system", systemThreadGroup.getName());     }      @Test     public void testAtLeastOneThreadExists() {         assertTrue(ThreadUtils.getAllThreads().size() > 0);     }      @Test     public void testAtLeastOneThreadGroupsExists() {         assertTrue(ThreadUtils.getAllThreadGroups().size() > 0);     }      @Test     public void testThreadsSameName() throws InterruptedException {         final Thread t1 = new TestThread("thread1_XXOOLL__");         final Thread alsot1 = new TestThread("thread1_XXOOLL__");          try {             t1.start();             alsot1.start();             assertEquals(2, ThreadUtils.findThreadsByName("thread1_XXOOLL__").size());         } finally {             t1.interrupt();             alsot1.interrupt();             t1.join();             alsot1.join();         }     }      @Test     public void testThreads() throws InterruptedException {         final Thread t1 = new TestThread("thread1_XXOOLL__");         final Thread t2 = new TestThread("thread2_XXOOLL__");          try {             t1.start();             t2.start();             assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOLL__").size());         } finally {             t1.interrupt();             t2.interrupt();             t1.join();             t2.join();         }     }      @Test     public void testThreadsById() throws InterruptedException {         final Thread t1 = new TestThread("thread1_XXOOLL__");         final Thread t2 = new TestThread("thread2_XXOOLL__");          try {             t1.start();             t2.start();             assertSame(t1, ThreadUtils.findThreadById(t1.getId()));             assertSame(t2, ThreadUtils.findThreadById(t2.getId()));         } finally {             t1.interrupt();             t2.interrupt();             t1.join();             t2.join();         }     }      @Test     public void testThreadsByIdWrongGroup() throws InterruptedException {         final Thread t1 = new TestThread("thread1_XXOOLL__");         final ThreadGroup tg = new ThreadGroup("tg__HHEE22");          try {             t1.start();             assertNull(ThreadUtils.findThreadById(t1.getId(), tg));         } finally {             t1.interrupt();             t1.join();             tg.destroy();         }     }       @Test     public void testThreadGroups() throws InterruptedException {         final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");         final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");         final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");          try {             t1.start();             t2.start();             assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__").size());             assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__", "thread_group_DDZZ99__").size());             assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOPP__", "thread_group_DDZZ99__").size());             assertEquals(0, ThreadUtils.findThreadsByName("thread1_XXOOPP__", "non_existent_thread_group_JJHHZZ__").size());             assertEquals(0, ThreadUtils.findThreadsByName("non_existent_thread_BBDDWW__", "thread_group_DDZZ99__").size());             assertEquals(1, ThreadUtils.findThreadGroupsByName("thread_group_DDZZ99__").size());             assertEquals(0, ThreadUtils.findThreadGroupsByName("non_existent_thread_group_JJHHZZ__").size());             assertNotNull(ThreadUtils.findThreadById(t1.getId(), threadGroup));         } finally {             t1.interrupt();             t2.interrupt();             t1.join();             t2.join();             threadGroup.destroy();         }     }      @Test     public void testThreadGroupsRef() throws InterruptedException {         final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");         final ThreadGroup deadThreadGroup = new ThreadGroup("dead_thread_group_MMQQSS__");         deadThreadGroup.destroy();         final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");         final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");          try {             t1.start();             t2.start();             assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__").size());             assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__", threadGroup).size());             assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOPP__", threadGroup).size());             assertEquals(0, ThreadUtils.findThreadsByName("thread1_XXOOPP__", deadThreadGroup).size());         } finally {             t1.interrupt();             t2.interrupt();             t1.join();             t2.join();             threadGroup.destroy();             assertEquals(0, ThreadUtils.findThreadsByName("thread2_XXOOPP__", threadGroup).size());         }     }      @Test     public void testThreadGroupsById() throws InterruptedException {         final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");         final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");         final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");         final long nonExistingId = t1.getId()+t2.getId();          try {             t1.start();             t2.start();             assertSame(t1, ThreadUtils.findThreadById(t1.getId(), "thread_group_DDZZ99__"));             assertSame(t2, ThreadUtils.findThreadById(t2.getId(), "thread_group_DDZZ99__"));             assertNull(ThreadUtils.findThreadById(nonExistingId, "non_existent_thread_group_JJHHZZ__"));             assertNull(ThreadUtils.findThreadById(nonExistingId, "thread_group_DDZZ99__"));         } finally {             t1.interrupt();             t2.interrupt();             t1.join();             t2.join();             threadGroup.destroy();         }     }      @Test     public void testConstructor() {         assertNotNull(new ThreadUtils());         final Constructor<?>[] cons = ThreadUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ThreadUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ThreadUtils.class.getModifiers()));     }      @Test     public void testComplexThreadGroups() throws Exception {         final ThreadGroup threadGroup1 = new ThreadGroup("thread_group_1__");         final ThreadGroup threadGroup2 = new ThreadGroup("thread_group_2__");         final ThreadGroup threadGroup3 = new ThreadGroup(threadGroup2, "thread_group_3__");         final ThreadGroup threadGroup4 = new ThreadGroup(threadGroup2, "thread_group_4__");         final ThreadGroup threadGroup5 = new ThreadGroup(threadGroup1, "thread_group_5__");         final ThreadGroup threadGroup6 = new ThreadGroup(threadGroup4, "thread_group_6__");         final ThreadGroup threadGroup7 = new ThreadGroup(threadGroup4, "thread_group_7__");         final ThreadGroup threadGroup7Doubled = new ThreadGroup(threadGroup4, "thread_group_7__");         final List<ThreadGroup> threadGroups = Arrays.asList(threadGroup1, threadGroup2, threadGroup3, threadGroup4, threadGroup5, threadGroup6, threadGroup7, threadGroup7Doubled);          final Thread t1 = new TestThread("thread1_X__");         final Thread t2 = new TestThread(threadGroup1, "thread2_X__");         final Thread t3 = new TestThread(threadGroup2, "thread3_X__");         final Thread t4 = new TestThread(threadGroup3, "thread4_X__");         final Thread t5 = new TestThread(threadGroup4, "thread5_X__");         final Thread t6 = new TestThread(threadGroup5, "thread6_X__");         final Thread t7 = new TestThread(threadGroup6, "thread7_X__");         final Thread t8 = new TestThread(threadGroup4, "thread8_X__");         final Thread t9 = new TestThread(threadGroup6, "thread9_X__");         final Thread t10 = new TestThread(threadGroup3, "thread10_X__");         final Thread t11 = new TestThread(threadGroup7, "thread11_X__");         final Thread t11Doubled = new TestThread(threadGroup7Doubled, "thread11_X__");         final List<Thread> threads = Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t11Doubled);          try {             for (final Thread thread : threads) {                 thread.start();             }             assertTrue(ThreadUtils.getAllThreadGroups().size() >= 7);             assertTrue(ThreadUtils.getAllThreads().size() >= 11);             assertTrue(ThreadUtils.findThreads(ThreadUtils.ALWAYS_TRUE_PREDICATE).size() >= 11);             assertEquals(1, ThreadUtils.findThreadsByName(t4.getName(), threadGroup3.getName()).size());             assertEquals(0, ThreadUtils.findThreadsByName(t4.getName(), threadGroup2.getName()).size());             assertEquals(2, ThreadUtils.findThreadsByName(t11.getName(), threadGroup7.getName()).size());         } finally {             for (final Thread thread : threads) {                 thread.interrupt();                 thread.join();             }             for (final ThreadGroup threadGroup : threadGroups) {                 if (!threadGroup.isDestroyed()) {                     threadGroup.destroy();                 }             }         }     }       private static class TestThread extends Thread {         private final CountDownLatch latch = new CountDownLatch(1);          TestThread(final String name) {             super(name);         }          TestThread(final ThreadGroup group, final String name) {             super(group, name);         }          @Override         public synchronized void start() {             super.start();             try {                 latch.await();             } catch (final InterruptedException e) {                 Thread.currentThread().interrupt();             }         }          @Override         public void run() {             latch.countDown();             try {                 synchronized(this) {                     this.wait();                 }             } catch (final InterruptedException e) {                 Thread.currentThread().interrupt();             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.compare;  import static org.apache.commons.lang3.compare.ComparableUtils.is; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.math.BigDecimal;  import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.DisplayNameGeneration; import org.junit.jupiter.api.DisplayNameGenerator; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class) public class ComparableUtilsTest {      @Nested     class A_is_1 {          @DisplayName("B is 0 (B < A)")         @Nested         class B_is_0 {              @DisplayName("C is 0 ([B=C] < A)")             @Nested             class C_is_0 {                  BigDecimal c = BigDecimal.ZERO;                  @Test                 void between_returns_false() {                     assertFalse(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 1 (B < A = C)")             @Nested             class C_is_1 {                  BigDecimal c = BigDecimal.ONE;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 10 (B < A < C)")             @Nested             class C_is_10 {                  BigDecimal c = BigDecimal.TEN;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_true() {                     assertTrue(is(a).betweenExclusive(b, c));                 }             }              BigDecimal b = BigDecimal.ZERO;              @Test             void equalTo_returns_false() {                 assertFalse(is(a).equalTo(b));             }              @Test             void greaterThan_returns_true() {                 assertTrue(is(a).greaterThan(b));             }              @Test             void greaterThanOrEqualTo_returns_true() {                 assertTrue(is(a).greaterThanOrEqualTo(b));             }              @Test             void lessThan_returns_false() {                 assertFalse(is(a).lessThan(b));             }              @Test             void lessThanOrEqualTo_returns_false() {                 assertFalse(is(a).lessThanOrEqualTo(b));             }         }          @DisplayName("B is 1 (B = A)")         @Nested         class B_is_1 {              @DisplayName("C is 0 (B = A > C)")             @Nested             class C_is_0 {                  BigDecimal c = BigDecimal.ZERO;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 1 (B = A = C)")             @Nested             class C_is_1 {                  BigDecimal c = BigDecimal.ONE;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 10 (B = A < C)")             @Nested             class C_is_10 {                  BigDecimal c = BigDecimal.TEN;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              BigDecimal b = BigDecimal.ONE;              @Test             void equalTo_returns_true() {                 assertTrue(is(a).equalTo(b));             }              @Test             void greaterThan_returns_false() {                 assertFalse(is(a).greaterThan(b));             }              @Test             void greaterThanOrEqualTo_returns_true() {                 assertTrue(is(a).greaterThanOrEqualTo(b));             }              @Test             void lessThan_returns_false() {                 assertFalse(is(a).lessThan(b));             }              @Test             void lessThanOrEqualTo_returns_true() {                 assertTrue(is(a).lessThanOrEqualTo(b));             }         }          @DisplayName("B is 10 (B > A)")         @Nested         class B_is_10 {              @DisplayName("C is 0 (B > A > C)")             @Nested             class C_is_0 {                  BigDecimal c = BigDecimal.ZERO;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_true() {                     assertTrue(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 1 (B > A = C)")             @Nested             class C_is_1 {                  BigDecimal c = BigDecimal.ONE;                  @Test                 void between_returns_true() {                     assertTrue(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              @DisplayName("C is 10 ([B,C] > A)")             @Nested             class C_is_10 {                  BigDecimal c = BigDecimal.TEN;                  @Test                 void between_returns_false() {                     assertFalse(is(a).between(b, c));                 }                  @Test                 void betweenExclusive_returns_false() {                     assertFalse(is(a).betweenExclusive(b, c));                 }             }              BigDecimal b = BigDecimal.TEN;              @Test             void equalTo_returns_false() {                 assertFalse(is(a).equalTo(b));             }              @Test             void greaterThan_returns_false() {                 assertFalse(is(a).greaterThan(b));             }              @Test             void greaterThanOrEqualTo_returns_false() {                 assertFalse(is(a).greaterThanOrEqualTo(b));             }              @Test             void lessThan_returns_true() {                 assertTrue(is(a).lessThan(b));             }              @Test             void lessThanOrEqualTo_returns_true() {                 assertTrue(is(a).lessThanOrEqualTo(b));             }         }          BigDecimal a = BigDecimal.ONE;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.compare;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.List;  import org.junit.jupiter.api.Test;  /**  * Tests {@link ObjectToStringComparator}.  */ public class ObjectToStringComparatorTest {      private static class Thing {          final String string;          Thing(final String string) {             this.string = string;         }          @Override         public String toString() {             return string;         }     }      @Test     public void testNull() {         final List<Thing> things = Arrays.asList(null, new Thing("y"), null);         things.sort(ObjectToStringComparator.INSTANCE);         assertEquals("y", things.get(0).string);         assertEquals(null, things.get(1));         assertEquals(null, things.get(2));     }      @Test     public void testNullToString() {         final List<Thing> things = Arrays.asList(new Thing(null), new Thing("y"), new Thing(null));         things.sort(ObjectToStringComparator.INSTANCE);         assertEquals("y", things.get(0).string);         assertEquals(null, things.get(1).string);         assertEquals(null, things.get(2).string);     }      @Test     public void testSortCollection() {         final List<Thing> things = Arrays.asList(new Thing("z"), new Thing("y"), new Thing("x"));         things.sort(ObjectToStringComparator.INSTANCE);         assertEquals("x", things.get(0).string);         assertEquals("y", things.get(1).string);         assertEquals("z", things.get(2).string);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Trim/Strip methods  */ public class StringUtilsTrimStripTest  {     private static final String FOO = "foo";      @Test     public void testTrim() {         assertEquals(FOO, StringUtils.trim(FOO + "  "));         assertEquals(FOO, StringUtils.trim(" " + FOO + "  "));         assertEquals(FOO, StringUtils.trim(" " + FOO));         assertEquals(FOO, StringUtils.trim(FOO + ""));         assertEquals("", StringUtils.trim(" \t\r\n\b "));         assertEquals("", StringUtils.trim(StringUtilsTest.TRIMMABLE));         assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trim(StringUtilsTest.NON_TRIMMABLE));         assertEquals("", StringUtils.trim(""));         assertNull(StringUtils.trim(null));     }      @Test     public void testTrimToNull() {         assertEquals(FOO, StringUtils.trimToNull(FOO + "  "));         assertEquals(FOO, StringUtils.trimToNull(" " + FOO + "  "));         assertEquals(FOO, StringUtils.trimToNull(" " + FOO));         assertEquals(FOO, StringUtils.trimToNull(FOO + ""));         assertNull(StringUtils.trimToNull(" \t\r\n\b "));         assertNull(StringUtils.trimToNull(StringUtilsTest.TRIMMABLE));         assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToNull(StringUtilsTest.NON_TRIMMABLE));         assertNull(StringUtils.trimToNull(""));         assertNull(StringUtils.trimToNull(null));     }      @Test     public void testTrimToEmpty() {         assertEquals(FOO, StringUtils.trimToEmpty(FOO + "  "));         assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO + "  "));         assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO));         assertEquals(FOO, StringUtils.trimToEmpty(FOO + ""));         assertEquals("", StringUtils.trimToEmpty(" \t\r\n\b "));         assertEquals("", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE));         assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE));         assertEquals("", StringUtils.trimToEmpty(""));         assertEquals("", StringUtils.trimToEmpty(null));     }      //-----------------------------------------------------------------------     @Test     public void testStrip_String() {         assertNull(StringUtils.strip(null));         assertEquals("", StringUtils.strip(""));         assertEquals("", StringUtils.strip("        "));         assertEquals("abc", StringUtils.strip("  abc  "));         assertEquals(StringUtilsTest.NON_WHITESPACE,             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));     }      @Test     public void testStripToNull_String() {         assertNull(StringUtils.stripToNull(null));         assertNull(StringUtils.stripToNull(""));         assertNull(StringUtils.stripToNull("        "));         assertNull(StringUtils.stripToNull(StringUtilsTest.WHITESPACE));         assertEquals("ab c", StringUtils.stripToNull("  ab c  "));         assertEquals(StringUtilsTest.NON_WHITESPACE,             StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));     }      @Test     public void testStripToEmpty_String() {         assertEquals("", StringUtils.stripToEmpty(null));         assertEquals("", StringUtils.stripToEmpty(""));         assertEquals("", StringUtils.stripToEmpty("        "));         assertEquals("", StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE));         assertEquals("ab c", StringUtils.stripToEmpty("  ab c  "));         assertEquals(StringUtilsTest.NON_WHITESPACE,             StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));     }      @Test     public void testStrip_StringString() {         // null strip         assertNull(StringUtils.strip(null, null));         assertEquals("", StringUtils.strip("", null));         assertEquals("", StringUtils.strip("        ", null));         assertEquals("abc", StringUtils.strip("  abc  ", null));         assertEquals(StringUtilsTest.NON_WHITESPACE,             StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));          // "" strip         assertNull(StringUtils.strip(null, ""));         assertEquals("", StringUtils.strip("", ""));         assertEquals("        ", StringUtils.strip("        ", ""));         assertEquals("  abc  ", StringUtils.strip("  abc  ", ""));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, ""));          // " " strip         assertNull(StringUtils.strip(null, " "));         assertEquals("", StringUtils.strip("", " "));         assertEquals("", StringUtils.strip("        ", " "));         assertEquals("abc", StringUtils.strip("  abc  ", " "));          // "ab" strip         assertNull(StringUtils.strip(null, "ab"));         assertEquals("", StringUtils.strip("", "ab"));         assertEquals("        ", StringUtils.strip("        ", "ab"));         assertEquals("  abc  ", StringUtils.strip("  abc  ", "ab"));         assertEquals("c", StringUtils.strip("abcabab", "ab"));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, ""));     }      @Test     public void testStripStart_StringString() {         // null stripStart         assertNull(StringUtils.stripStart(null, null));         assertEquals("", StringUtils.stripStart("", null));         assertEquals("", StringUtils.stripStart("        ", null));         assertEquals("abc  ", StringUtils.stripStart("  abc  ", null));         assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE,             StringUtils.stripStart(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));          // "" stripStart         assertNull(StringUtils.stripStart(null, ""));         assertEquals("", StringUtils.stripStart("", ""));         assertEquals("        ", StringUtils.stripStart("        ", ""));         assertEquals("  abc  ", StringUtils.stripStart("  abc  ", ""));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, ""));          // " " stripStart         assertNull(StringUtils.stripStart(null, " "));         assertEquals("", StringUtils.stripStart("", " "));         assertEquals("", StringUtils.stripStart("        ", " "));         assertEquals("abc  ", StringUtils.stripStart("  abc  ", " "));          // "ab" stripStart         assertNull(StringUtils.stripStart(null, "ab"));         assertEquals("", StringUtils.stripStart("", "ab"));         assertEquals("        ", StringUtils.stripStart("        ", "ab"));         assertEquals("  abc  ", StringUtils.stripStart("  abc  ", "ab"));         assertEquals("cabab", StringUtils.stripStart("abcabab", "ab"));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, ""));     }      @Test     public void testStripEnd_StringString() {         // null stripEnd         assertNull(StringUtils.stripEnd(null, null));         assertEquals("", StringUtils.stripEnd("", null));         assertEquals("", StringUtils.stripEnd("        ", null));         assertEquals("  abc", StringUtils.stripEnd("  abc  ", null));         assertEquals(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE,             StringUtils.stripEnd(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));          // "" stripEnd         assertNull(StringUtils.stripEnd(null, ""));         assertEquals("", StringUtils.stripEnd("", ""));         assertEquals("        ", StringUtils.stripEnd("        ", ""));         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", ""));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, ""));          // " " stripEnd         assertNull(StringUtils.stripEnd(null, " "));         assertEquals("", StringUtils.stripEnd("", " "));         assertEquals("", StringUtils.stripEnd("        ", " "));         assertEquals("  abc", StringUtils.stripEnd("  abc  ", " "));          // "ab" stripEnd         assertNull(StringUtils.stripEnd(null, "ab"));         assertEquals("", StringUtils.stripEnd("", "ab"));         assertEquals("        ", StringUtils.stripEnd("        ", "ab"));         assertEquals("  abc  ", StringUtils.stripEnd("  abc  ", "ab"));         assertEquals("abc", StringUtils.stripEnd("abcabab", "ab"));         assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, ""));     }      @Test     public void testStripAll() {         // test stripAll method, merely an array version of the above strip         final String[] empty = new String[0];         final String[] fooSpace = new String[] { "  "+FOO+"  ", "  "+FOO, FOO+"  " };         final String[] fooDots = new String[] { ".."+FOO+"..", ".."+FOO, FOO+".." };         final String[] foo = new String[] { FOO, FOO, FOO };          assertNull(StringUtils.stripAll((String[]) null));         // Additional varargs tests         assertArrayEquals(empty, StringUtils.stripAll()); // empty array         assertArrayEquals(new String[]{null}, StringUtils.stripAll((String) null)); // == new String[]{null}          assertArrayEquals(empty, StringUtils.stripAll(empty));         assertArrayEquals(foo, StringUtils.stripAll(fooSpace));          assertNull(StringUtils.stripAll(null, null));         assertArrayEquals(foo, StringUtils.stripAll(fooSpace, null));         assertArrayEquals(foo, StringUtils.stripAll(fooDots, "."));     }      @Test     public void testStripAccents() {         final String cue = "\u00C7\u00FA\u00EA";         assertEquals("Cue", StringUtils.stripAccents(cue), "Failed to strip accents from " + cue);          final String lots = "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C7\u00C8\u00C9" +                       "\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D1\u00D2\u00D3" +                       "\u00D4\u00D5\u00D6\u00D9\u00DA\u00DB\u00DC\u00DD";         assertEquals("AAAAAACEEEEIIIINOOOOOUUUUY",                 StringUtils.stripAccents(lots),                 "Failed to strip accents from " + lots);          assertNull(StringUtils.stripAccents(null), "Failed null safety");         assertEquals("", StringUtils.stripAccents(""), "Failed empty String");         assertEquals("control", StringUtils.stripAccents("control"), "Failed to handle non-accented text");         assertEquals("eclair", StringUtils.stripAccents("\u00E9clair"), "Failed to handle easy example");         assertEquals("ALOSZZCN aloszzcn", StringUtils.stripAccents("\u0104\u0141\u00D3\u015A\u017B\u0179\u0106\u0143 "                 + "\u0105\u0142\u00F3\u015B\u017C\u017A\u0107\u0144"));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.ArrayList; import java.util.Collection; import java.util.List;  import org.apache.commons.lang3.ArrayUtils; import org.junit.jupiter.api.Test;  /**  */ public class ReflectionToStringBuilderExcludeTest {      class TestFixture {         @SuppressWarnings("unused")         private final String secretField = SECRET_VALUE;          @SuppressWarnings("unused")         private final String showField = NOT_SECRET_VALUE;     }      private static final String NOT_SECRET_FIELD = "showField";      private static final String NOT_SECRET_VALUE = "Hello World!";      private static final String SECRET_FIELD = "secretField";      private static final String SECRET_VALUE = "secret value";      @Test     public void test_toStringExclude() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);         this.validateSecretFieldAbsent(toString);     }      @Test     public void test_toStringExcludeArray() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);         this.validateSecretFieldAbsent(toString);     }      @Test     public void test_toStringExcludeArrayWithNull() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null});         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeArrayWithNulls() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), null, null);         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeCollection() {         final List<String> excludeList = new ArrayList<>();         excludeList.add(SECRET_FIELD);         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);         this.validateSecretFieldAbsent(toString);     }      @Test     public void test_toStringExcludeCollectionWithNull() {         final List<String> excludeList = new ArrayList<>();         excludeList.add(null);         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeCollectionWithNulls() {         final List<String> excludeList = new ArrayList<>();         excludeList.add(null);         excludeList.add(null);         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeEmptyArray() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY);         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeEmptyCollection() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList<>());         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeNullArray() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null);         this.validateSecretFieldPresent(toString);     }      @Test     public void test_toStringExcludeNullCollection() {         final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection<String>) null);         this.validateSecretFieldPresent(toString);     }      private void validateNonSecretField(final String toString) {         assertTrue(toString.contains(NOT_SECRET_FIELD));         assertTrue(toString.contains(NOT_SECRET_VALUE));     }      private void validateSecretFieldAbsent(final String toString) {         assertEquals(ArrayUtils.INDEX_NOT_FOUND, toString.indexOf(SECRET_VALUE));         this.validateNonSecretField(toString);     }      private void validateSecretFieldPresent(final String toString) {         assertTrue(toString.indexOf(SECRET_VALUE) > 0);         this.validateNonSecretField(toString);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.SimpleToStringStyleTest}.  */ public class SimpleToStringStyleTest {      private final Integer base = Integer.valueOf(5);      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals("", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals("", new ToStringBuilder(base).appendSuper("").toString());         assertEquals("<null>", new ToStringBuilder(base).appendSuper("<null>").toString());          assertEquals("hello", new ToStringBuilder(base).appendSuper("").append("a", "hello").toString());         assertEquals("<null>,hello", new ToStringBuilder(base).appendSuper("<null>").append("a", "hello").toString());         assertEquals("hello", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("<null>", new ToStringBuilder(base).append((Object) null).toString());         assertEquals("3", new ToStringBuilder(base).append(i3).toString());         assertEquals("<null>", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals("3", new ToStringBuilder(base).append("a", i3).toString());         assertEquals("3,4", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals("<Integer>", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("<size=0>", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals("[]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals("<size=1>", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals("[3]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals("<size=2>", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals("[3, 4]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals("<size=0>", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals("{}", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals("<size=1>", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals("{k=v}", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("<size=0>", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals("{}", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals("<size=1>", new ToStringBuilder(base).append("a", (Object) new Integer[]{i3}, false).toString());         assertEquals("{3}", new ToStringBuilder(base).append("a", (Object) new Integer[]{i3}, true).toString());         assertEquals("<size=2>", new ToStringBuilder(base).append("a", (Object) new Integer[]{i3, i4}, false).toString());         assertEquals("{3,4}", new ToStringBuilder(base).append("a", (Object) new Integer[]{i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "Jane Q. Public";         p.age = 47;         p.smoker = false;         assertEquals("Jane Q. Public,47,false", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals("3", new ToStringBuilder(base).append(3L).toString());         assertEquals("3", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals("3,4", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append(array).toString());         assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("<null>", new ToStringBuilder(base).append(array).toString());         assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append(array).toString());         assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("<null>", new ToStringBuilder(base).append(array).toString());         assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString());         assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("<null>", new ToStringBuilder(base).append(array).toString());         assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  /**  * Tests {@link org.apache.commons.lang3.builder.HashCodeBuilder} and  * {@link org.apache.commons.lang3.builder.EqualsBuilderTest} to insure that equal  * objects must have equal hash codes.  */ public class HashCodeBuilderAndEqualsBuilderTest {      //-----------------------------------------------------------------------      private void testInteger(final boolean testTransients) {         final Integer i1 = Integer.valueOf(12345);         final Integer i2 = Integer.valueOf(12345);         assertEqualsAndHashCodeContract(i1, i2, testTransients);     }      @Test     public void testInteger() {         testInteger(false);     }      @Test     public void testIntegerWithTransients() {         testInteger(true);     }      @Test     public void testFixture() {         testFixture(false);     }      @Test     public void testFixtureWithTransients() {         testFixture(true);     }      private void testFixture(final boolean testTransients) {         assertEqualsAndHashCodeContract(new TestFixture(2, 'c', "Test", (short) 2), new TestFixture(2, 'c', "Test", (short) 2), testTransients);         assertEqualsAndHashCodeContract(             new AllTransientFixture(2, 'c', "Test", (short) 2),             new AllTransientFixture(2, 'c', "Test", (short) 2),             testTransients);         assertEqualsAndHashCodeContract(             new SubTestFixture(2, 'c', "Test", (short) 2, "Same"),             new SubTestFixture(2, 'c', "Test", (short) 2, "Same"),             testTransients);         assertEqualsAndHashCodeContract(             new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"),             new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"),             testTransients);     }      /**      * Asserts that if {@code lhs} equals {@code rhs}      * then their hash codes MUST be identical.      *      * @param lhs The Left-Hand-Side of the equals test      * @param rhs The Right-Hand-Side of the equals test      * @param testTransients whether to test transient fields      */     private void assertEqualsAndHashCodeContract(final Object lhs, final Object rhs, final boolean testTransients) {         if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {             // test a couple of times for consistency.             assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));             assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));             assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));         }     }      static class TestFixture {         int i;         char c;         String string;         short s;          TestFixture(final int i, final char c, final String string, final short s) {             this.i = i;             this.c = c;             this.string = string;             this.s = s;         }     }      static class SubTestFixture extends TestFixture {         transient String tString;          SubTestFixture(final int i, final char c, final String string, final short s, final String tString) {             super(i, c, string, s);             this.tString = tString;         }     }      static class AllTransientFixture {         transient int i;         transient char c;         transient String string;         transient short s;          AllTransientFixture(final int i, final char c, final String string, final short s) {             this.i = i;             this.c = c;             this.string = string;             this.s = s;         }     }      static class SubAllTransientFixture extends AllTransientFixture {         transient String tString;          SubAllTransientFixture(final int i, final char c, final String string, final short s, final String tString) {             super(i, c, string, s);             this.tString = tString;         }     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import java.util.ArrayList; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Test;  /**  * Tests concurrent access for the default {@link ToStringStyle}.  * <p>  * The {@link ToStringStyle} class includes a registry to avoid infinite loops for objects with circular references. We  * want to make sure that we do not get concurrency exceptions accessing this registry.  * </p>  * <p>  * This test passes but only tests one aspect of the issue.  * </p>  *  * @see <a href="https://issues.apache.org/jira/browse/LANG-762">[LANG-762] Handle or document ReflectionToStringBuilder  *      and ToStringBuilder for collections that are not thread safe</a>  * @since 3.1  */ public class ToStringStyleConcurrencyTest {      static class CollectionHolder<T extends Collection<?>> {         T collection;          CollectionHolder(final T collection) {             this.collection = collection;         }     }      private static final List<Integer> LIST;     private static final int LIST_SIZE = 100000;     private static final int REPEAT = 100;      static {         LIST = new ArrayList<>(LIST_SIZE);         for (int i = 0; i < LIST_SIZE; i++) {             LIST.add(Integer.valueOf(i));         }     }      @Test     public void testLinkedList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new LinkedList<>()));     }      @Test     public void testArrayList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new ArrayList<>()));     }      @Test     public void testCopyOnWriteArrayList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new CopyOnWriteArrayList<>()));     }      private void testConcurrency(final CollectionHolder<List<Integer>> holder) throws InterruptedException,         ExecutionException {         final List<Integer> list = holder.collection;         // make a big array that takes a long time to toString()         list.addAll(LIST);         // Create a thread pool with two threads to cause the most contention on the underlying resource.         final ExecutorService threadPool = Executors.newFixedThreadPool(2);         try {             // Consumes toStrings             final Callable<Integer> consumer = () -> {                 for (int i = 0; i < REPEAT; i++) {                     // Calls ToStringStyle                     new ToStringBuilder(holder).append(holder.collection);                 }                 return Integer.valueOf(REPEAT);             };             final Collection<Callable<Integer>> tasks = new ArrayList<>();             tasks.add(consumer);             tasks.add(consumer);             final List<Future<Integer>> futures = threadPool.invokeAll(tasks);             for (final Future<Integer> future : futures) {                 future.get();             }         } finally {             threadPool.shutdown();             threadPool.awaitTermination(1, TimeUnit.SECONDS);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.NoFieldNamesToStringStyleTest}.  */ public class NoFieldNamesToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals(baseStr + "[[]]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals(baseStr + "[<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals(baseStr + "[[3]]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals(baseStr + "[<size=2>]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals(baseStr + "[[3, 4]]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals(baseStr + "[<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals(baseStr + "[{k=v}]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals(baseStr + "[<size=1>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals(baseStr + "[{3}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals(baseStr + "[<size=2>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals(baseStr + "[{3,4}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "Ron Paul";         p.age = 72;         p.smoker = false;         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p));         assertEquals(pBaseStr + "[Ron Paul,72,false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.containsString; import static org.hamcrest.Matchers.not;  import org.junit.jupiter.api.Test;  /**  * Test class for ToStringExclude annotation  */ public class ReflectionToStringBuilderExcludeWithAnnotationTest {      class TestFixture {         @ToStringExclude         private final String excludedField = EXCLUDED_FIELD_VALUE;          @SuppressWarnings("unused")         private final String includedField = INCLUDED_FIELD_VALUE;     }      private static final String INCLUDED_FIELD_NAME = "includedField";      private static final String INCLUDED_FIELD_VALUE = "Hello World!";      private static final String EXCLUDED_FIELD_NAME = "excludedField";      private static final String EXCLUDED_FIELD_VALUE = "excluded field value";      @Test     public void test_toStringExclude() {         final String toString = ReflectionToStringBuilder.toString(new TestFixture());          assertThat(toString, not(containsString(EXCLUDED_FIELD_NAME)));         assertThat(toString, not(containsString(EXCLUDED_FIELD_VALUE)));         assertThat(toString, containsString(INCLUDED_FIELD_NAME));         assertThat(toString, containsString(INCLUDED_FIELD_VALUE));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.ToStringStyle#SHORT_PREFIX_STYLE}.  */ public class ShortPrefixToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = "Integer";      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.SHORT_PREFIX_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals(baseStr + "[a=[3]]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals(baseStr + "[a=<size=2>]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals(baseStr + "[a=[3, 4]]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals(baseStr + "[a={k=v}]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals(baseStr + "[a={3}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals(baseStr + "[a=<size=2>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals(baseStr + "[a={3,4}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "John Q. Public";         p.age = 45;         p.smoker = true;         final String pBaseStr = "ToStringStyleTest.Person";         assertEquals(pBaseStr + "[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  public class ReflectionToStringBuilderExcludeNullValuesTest {      static class TestFixture {         @SuppressWarnings("unused")         private final Integer testIntegerField;         @SuppressWarnings("unused")         private final String testStringField;          TestFixture(final Integer a, final String b) {             this.testIntegerField = a;             this.testStringField = b;         }     }      private static final String INTEGER_FIELD_NAME = "testIntegerField";     private static final String STRING_FIELD_NAME = "testStringField";     private final TestFixture BOTH_NON_NULL = new TestFixture(0, "str");     private final TestFixture FIRST_NULL = new TestFixture(null, "str");     private final TestFixture SECOND_NULL = new TestFixture(0, null);     private final TestFixture BOTH_NULL = new TestFixture(null, null);      @Test     public void test_NonExclude() {         //normal case=         String toString = ReflectionToStringBuilder.toString(BOTH_NON_NULL, null, false, false, false, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          //make one null         toString = ReflectionToStringBuilder.toString(FIRST_NULL, null, false, false, false, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          //other one null         toString = ReflectionToStringBuilder.toString(SECOND_NULL, null, false, false, false, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          //make the both null         toString = ReflectionToStringBuilder.toString(BOTH_NULL, null, false, false, false, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));     }      @Test     public void test_excludeNull() {          //test normal case         String toString = ReflectionToStringBuilder.toString(BOTH_NON_NULL, null, false, false, true, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          //make one null         toString = ReflectionToStringBuilder.toString(FIRST_NULL, null, false, false, true, null);         assertFalse(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          //other one null         toString = ReflectionToStringBuilder.toString(SECOND_NULL, null, false, false, true, null);         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertFalse(toString.contains(STRING_FIELD_NAME));          //both null         toString = ReflectionToStringBuilder.toString(BOTH_NULL, null, false, false, true, null);         assertFalse(toString.contains(INTEGER_FIELD_NAME));         assertFalse(toString.contains(STRING_FIELD_NAME));     }      @Test     public void test_ConstructorOption() {         ReflectionToStringBuilder builder = new ReflectionToStringBuilder(BOTH_NON_NULL, null, null, null, false, false, true);         assertTrue(builder.isExcludeNullValues());         String toString = builder.toString();         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          builder = new ReflectionToStringBuilder(FIRST_NULL, null, null, null, false, false, true);         toString = builder.toString();         assertFalse(toString.contains(INTEGER_FIELD_NAME));         assertTrue(toString.contains(STRING_FIELD_NAME));          builder = new ReflectionToStringBuilder(SECOND_NULL, null, null, null, false, false, true);         toString = builder.toString();         assertTrue(toString.contains(INTEGER_FIELD_NAME));         assertFalse(toString.contains(STRING_FIELD_NAME));          builder = new ReflectionToStringBuilder(BOTH_NULL, null, null, null, false, false, true);         toString = builder.toString();         assertFalse(toString.contains(INTEGER_FIELD_NAME));         assertFalse(toString.contains(STRING_FIELD_NAME));     }      @Test     public void test_ConstructorOptionNormal() {         final ReflectionToStringBuilder builder = new ReflectionToStringBuilder(BOTH_NULL, null, null, null, false, false, false);         assertFalse(builder.isExcludeNullValues());         String toString = builder.toString();         assertTrue(toString.contains(STRING_FIELD_NAME));         assertTrue(toString.contains(INTEGER_FIELD_NAME));          //regression test older constructors         ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder(BOTH_NULL);         toString = oldBuilder.toString();         assertTrue(toString.contains(STRING_FIELD_NAME));         assertTrue(toString.contains(INTEGER_FIELD_NAME));          oldBuilder = new ReflectionToStringBuilder(BOTH_NULL, null, null, null, false, false);         toString = oldBuilder.toString();         assertTrue(toString.contains(STRING_FIELD_NAME));         assertTrue(toString.contains(INTEGER_FIELD_NAME));          oldBuilder = new ReflectionToStringBuilder(BOTH_NULL, null, null);         toString = oldBuilder.toString();         assertTrue(toString.contains(STRING_FIELD_NAME));         assertTrue(toString.contains(INTEGER_FIELD_NAME));     }      @Test     public void test_ConstructorOption_ExcludeNull() {         ReflectionToStringBuilder builder = new ReflectionToStringBuilder(BOTH_NULL, null, null, null, false, false, false);         builder.setExcludeNullValues(true);         assertTrue(builder.isExcludeNullValues());         String toString = builder.toString();         assertFalse(toString.contains(STRING_FIELD_NAME));         assertFalse(toString.contains(INTEGER_FIELD_NAME));          builder = new ReflectionToStringBuilder(BOTH_NULL, null, null, null, false, false, true);         toString = builder.toString();         assertFalse(toString.contains(STRING_FIELD_NAME));         assertFalse(toString.contains(INTEGER_FIELD_NAME));          final ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder(BOTH_NULL);         oldBuilder.setExcludeNullValues(true);         assertTrue(oldBuilder.isExcludeNullValues());         toString = oldBuilder.toString();         assertFalse(toString.contains(STRING_FIELD_NAME));         assertFalse(toString.contains(INTEGER_FIELD_NAME));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.ToStringStyle}.  */ public class StandardToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = "Integer";      private static final StandardToStringStyle STYLE = new StandardToStringStyle();      static {         STYLE.setUseShortClassName(true);         STYLE.setUseIdentityHashCode(false);         STYLE.setArrayStart("[");         STYLE.setArraySeparator(", ");         STYLE.setArrayEnd("]");         STYLE.setNullText("%NULL%");         STYLE.setSizeStartText("%SIZE=");         STYLE.setSizeEndText("%");         STYLE.setSummaryObjectStartText("%");         STYLE.setSummaryObjectEndText("%");     }      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[%NULL%,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[a=%NULL%]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[a=%Integer%]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals(baseStr + "[a=%SIZE=1%]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals(baseStr + "[a=[3]]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals(baseStr + "[a=%SIZE=2%]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals(baseStr + "[a=[3, 4]]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals(baseStr + "[a=%SIZE=1%]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals(baseStr + "[a={k=v}]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals(baseStr + "[a=%SIZE=1%]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals(baseStr + "[a=[3]]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals(baseStr + "[a=%SIZE=2%]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals(baseStr + "[a=[3, 4]]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "Suzy Queue";         p.age = 19;         p.smoker = false;         final String pBaseStr = "ToStringStyleTest.Person";         assertEquals(pBaseStr + "[name=Suzy Queue,age=19,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testDefaultValueOfUseClassName() {         assertTrue((new StandardToStringStyle()).isUseClassName());     }      @Test     public void testDefaultValueOfUseFieldNames() {         assertTrue((new StandardToStringStyle()).isUseFieldNames());     }      @Test     public void testDefaultValueOfUseShortClassName() {         assertFalse((new StandardToStringStyle()).isUseShortClassName());     }      @Test     public void testDefaultValueOfUseIdentityHashCode() {         assertTrue((new StandardToStringStyle()).isUseIdentityHashCode());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.ArrayList; import java.util.List;  import org.junit.jupiter.api.Test;  /**  */ public class MultilineRecursiveToStringStyleTest {      private final String BR = System.lineSeparator();      @Test     public void simpleObject() {         final Transaction tx = new Transaction("2014.10.15", 100);         final String expected = getClassPrefix(tx) + "[" + BR                         + "  amount=100.0," + BR                         + "  date=2014.10.15" + BR                         + "]";         assertEquals(expected, toString(tx));     }      @Test     public void nestedElements() {         final Customer customer = new Customer("Douglas Adams");         final Bank bank = new Bank("ASF Bank");         customer.bank = bank;         final String exp = getClassPrefix(customer) + "[" + BR                    + "  accounts=<null>," + BR                    + "  bank=" + getClassPrefix(bank) + "[" + BR                    + "    name=ASF Bank" + BR                    + "  ]," + BR                    + "  name=Douglas Adams" + BR                 + "]";         assertEquals(exp, toString(customer));     }      @Test     public void nestedAndArray() {         final Account acc = new Account();         final Transaction tx1 = new Transaction("2014.10.14", 100);         final Transaction tx2 = new Transaction("2014.10.15", 50);         acc.transactions.add(tx1);         acc.transactions.add(tx2);         final String expected = getClassPrefix(acc) + "[" + BR                         + "  owner=<null>," + BR                         + "  transactions=" + getClassPrefix(acc.transactions) + "{" + BR                         + "    " + getClassPrefix(tx1) + "[" + BR                         + "      amount=100.0," + BR                         + "      date=2014.10.14" + BR                         + "    ]," + BR                         + "    " + getClassPrefix(tx2) + "[" + BR                         + "      amount=50.0," + BR                         + "      date=2014.10.15" + BR                         + "    ]" + BR                         + "  }" + BR                         + "]";         assertEquals(expected, toString(acc));     }      @Test     public void noArray() {         final WithArrays wa = new WithArrays();         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray=<null>," + BR                    + "  longArray=<null>," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void boolArray() {         final WithArrays wa = new WithArrays();         wa.boolArray = new boolean[] { true, false, true };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray={" + BR                    + "    true," + BR                    + "    false," + BR                    + "    true" + BR                    + "  }," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray=<null>," + BR                    + "  longArray=<null>," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void charArray() {         final WithArrays wa = new WithArrays();         wa.charArray = new char[] { 'a', 'A' };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray={" + BR                    + "    a," + BR                    + "    A" + BR                    + "  }," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray=<null>," + BR                    + "  longArray=<null>," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void intArray() {         final WithArrays wa = new WithArrays();         wa.intArray = new int[] { 1, 2 };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray={" + BR                    + "    1," + BR                    + "    2" + BR                    + "  }," + BR                    + "  longArray=<null>," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void doubleArray() {         final WithArrays wa = new WithArrays();         wa.doubleArray = new double[] { 1, 2 };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray={" + BR                    + "    1.0," + BR                    + "    2.0" + BR                    + "  }," + BR                    + "  intArray=<null>," + BR                    + "  longArray=<null>," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void longArray() {         final WithArrays wa = new WithArrays();         wa.longArray = new long[] { 1L, 2L };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray=<null>," + BR                    + "  longArray={" + BR                    + "    1," + BR                    + "    2" + BR                    + "  }," + BR                    + "  stringArray=<null>" + BR                    + "]";         assertEquals(exp, toString(wa));     }      @Test     public void stringArray() {         final WithArrays wa = new WithArrays();         wa.stringArray = new String[] { "a", "A" };         final String exp = getClassPrefix(wa) + "[" + BR                    + "  boolArray=<null>," + BR                    + "  charArray=<null>," + BR                    + "  doubleArray=<null>," + BR                    + "  intArray=<null>," + BR                    + "  longArray=<null>," + BR                    + "  stringArray={" + BR                    + "    a," + BR                    + "    A" + BR                    + "  }" + BR                    + "]";         assertEquals(exp, toString(wa));     }       @Test     public void testLANG1319() {         final String[] stringArray = {"1", "2"};          final String exp = getClassPrefix(stringArray) + "[" + BR                 + "  {" + BR                 + "    1," + BR                 + "    2" + BR                 + "  }" + BR                 + "]";         assertEquals(exp, toString(stringArray));     }      private String getClassPrefix(final Object object) {         return object.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object));     }      private String toString(final Object object) {         return new ReflectionToStringBuilder(object, new MultilineRecursiveToStringStyle()).toString();     }      static class WithArrays {         boolean[] boolArray;         char[] charArray;         double[] doubleArray;         int[] intArray;         long[] longArray;         String[] stringArray;     }      static class Bank {         String name;          Bank(final String name) {             this.name = name;         }     }      static class Customer {         String name;         Bank bank;         List<Account> accounts;          Customer(final String name) {             this.name = name;         }     }      static class Account {         Customer owner;         List<Transaction> transactions = new ArrayList<>();          public double getBalance() {             double balance = 0;             for (final Transaction tx : transactions) {                 balance += tx.amount;             }             return balance;         }     }      static class Transaction {         double amount;         String date;          Transaction(final String datum, final double betrag) {             this.date = datum;             this.amount = betrag;         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import java.util.LinkedList; import java.util.Random;  import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test;  /**  * Tests concurrent access for {@link ReflectionToStringBuilder}.  * <p>  * The {@link ToStringStyle} class includes a registry to avoid infinite loops for objects with circular references. We  * want to make sure that we do not get concurrency exceptions accessing this registry.  * </p>  *  * @see <a href="https://issues.apache.org/jira/browse/LANG-762">[LANG-762] Handle or document ReflectionToStringBuilder  *      and ToStringBuilder for collections that are not thread safe</a>  * @since 3.1  */ public class ReflectionToStringBuilderMutateInspectConcurrencyTest {      class TestFixture {         private final LinkedList<Integer> listField = new LinkedList<>();         private final Random random = new Random();         private final int N = 100;          TestFixture() {             synchronized (this) {                 for (int i = 0; i < N; i++) {                     listField.add(Integer.valueOf(i));                 }             }         }          public synchronized void add() {             listField.add(Integer.valueOf(random.nextInt(N)));         }          public synchronized void delete() {             listField.remove(Integer.valueOf(random.nextInt(N)));         }     }      class MutatingClient implements Runnable {         private final TestFixture testFixture;         private final Random random = new Random();          MutatingClient(final TestFixture testFixture) {             this.testFixture = testFixture;         }          @Override         public void run() {             if (random.nextBoolean()) {                 testFixture.add();             } else {                 testFixture.delete();             }         }     }      class InspectingClient implements Runnable {         private final TestFixture testFixture;          InspectingClient(final TestFixture testFixture) {             this.testFixture = testFixture;         }          @Override         public void run() {             ReflectionToStringBuilder.toString(testFixture);         }     }      @Test     @Disabled     public void testConcurrency() {         final TestFixture testFixture = new TestFixture();         final int numMutators = 10;         final int numIterations = 10;         for (int i = 0; i < numIterations; i++) {             for (int j = 0; j < numMutators; j++) {                 final Thread t = new Thread(new MutatingClient(testFixture));                 t.start();                 final Thread s = new Thread(new InspectingClient(testFixture));                 s.start();             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  public class ReflectionToStringBuilderSummaryTest {      @SuppressWarnings("unused")     private final String stringField = "string";      @ToStringSummary     private final String summaryString = "summary";      @Test     public void testSummary() {         assertEquals("[stringField=string,summaryString=<String>]",                 new ReflectionToStringBuilder(this, ToStringStyle.NO_CLASS_NAME_STYLE).build());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  public class ReflectionToStringBuilderTest {      @Test     public void testConstructorWithNullObject() {         assertThrows(NullPointerException.class,             () -> new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, new StringBuffer()));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.DefaultToStringStyleTest}.  */ public class DefaultToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals(baseStr + "[a=[3]]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals(baseStr + "[a=<size=2>]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals(baseStr + "[a=[3, 4]]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals(baseStr + "[a={k=v}]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals(baseStr + "[a=<size=1>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals(baseStr + "[a={3}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals(baseStr + "[a=<size=2>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals(baseStr + "[a={3,4}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "John Doe";         p.age = 33;         p.smoker = false;         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p));         assertEquals(pBaseStr + "[name=John Doe,age=33,smoker=false]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;   /**  * Unit tests {@link Diff}.  */ public class DiffTest {      private static final String FIELD_NAME = "field";     private static final Diff<Boolean> booleanDiff = new BooleanDiff(FIELD_NAME);      private static class BooleanDiff extends Diff<Boolean> {         private static final long serialVersionUID = 1L;          protected BooleanDiff(final String fieldName) {             super(fieldName);         }          @Override         public Boolean getLeft() {             return Boolean.TRUE;         }          @Override         public Boolean getRight() {             return Boolean.FALSE;         }     }      @Test     public void testCannotModify() {         assertThrows(UnsupportedOperationException.class, () -> booleanDiff.setValue(Boolean.FALSE));     }      @Test     public void testGetFieldName() {         assertEquals(FIELD_NAME, booleanDiff.getFieldName());     }      @Test     public void testGetType() {         assertEquals(Boolean.class, booleanDiff.getType());     }      @Test     public void testToString() {         assertEquals(String.format("[%s: %s, %s]", FIELD_NAME, booleanDiff.getLeft(),                 booleanDiff.getRight()), booleanDiff.toString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Date; import java.util.HashMap; import java.util.List;  import java.util.LinkedHashMap; import java.util.Map; import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.JsonToStringStyleTest}.  */ public class JsonToStringStyleTest {      private final Integer base = Integer.valueOf(5);      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.JSON_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      // ----------------------------------------------------------------      @Test     public void testNull() {         assertEquals("null", new ToStringBuilder(null).toString());     }      @Test     public void testBlank() {         assertEquals("{}", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(                 "{}",                 new ToStringBuilder(base).appendSuper(                         "Integer@8888[" + System.lineSeparator() + "]")                         .toString());         assertEquals(                 "{}",                 new ToStringBuilder(base).appendSuper(                         "Integer@8888[" + System.lineSeparator() + "  null"                                 + System.lineSeparator() + "]").toString());         assertEquals(                 "{\"a\":\"hello\"}",                 new ToStringBuilder(base)                         .appendSuper(                                 "Integer@8888[" + System.lineSeparator()                                         + "]").append("a", "hello").toString());         assertEquals(                 "{\"a\":\"hello\"}",                 new ToStringBuilder(base)                         .appendSuper(                                 "Integer@8888[" + System.lineSeparator()                                         + "  null" + System.lineSeparator()                                         + "]").append("a", "hello").toString());         assertEquals("{\"a\":\"hello\"}", new ToStringBuilder(base)                 .appendSuper(null).append("a", "hello").toString());          assertEquals("{\"a\":\"hello\",\"b\":\"world\"}", new ToStringBuilder(base)                 .appendSuper("{\"a\":\"hello\"}").append("b", "world").toString());     }      @Test     public void testChar() {         assertThrows(UnsupportedOperationException.class, () -> new ToStringBuilder(base).append('A').toString());          assertEquals("{\"a\":\"A\"}", new ToStringBuilder(base).append("a", 'A')                 .toString());         assertEquals("{\"a\":\"A\",\"b\":\"B\"}", new ToStringBuilder(base).append("a", 'A').append("b", 'B')                 .toString());     }      @Test     public void testDate() {         final Date now = new Date();         final Date afterNow = new Date(System.currentTimeMillis() + 1);          assertThrows(UnsupportedOperationException.class, () -> new ToStringBuilder(base).append(now).toString());          assertEquals("{\"now\":\"" + now.toString() +"\"}", new ToStringBuilder(base).append("now", now)                 .toString());         assertEquals("{\"now\":\"" + now.toString() +"\",\"after\":\"" + afterNow.toString() + "\"}", new ToStringBuilder(base).append("now", now).append("after", afterNow)                 .toString());     }      @Test     public void testObject() {          final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);          assertThrows(                 UnsupportedOperationException.class, () -> new ToStringBuilder(base).append((Object) null).toString());          assertThrows(UnsupportedOperationException.class, () -> new ToStringBuilder(base).append(i3).toString());          assertEquals("{\"a\":null}",                 new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals("{\"a\":3}", new ToStringBuilder(base).append("a", i3)                 .toString());         assertEquals("{\"a\":3,\"b\":4}",                 new ToStringBuilder(base).append("a", i3).append("b", i4)                         .toString());          assertThrows(                 UnsupportedOperationException.class, () -> new ToStringBuilder(base).append("a", i3, false).toString());          assertThrows(                 UnsupportedOperationException.class,                 () -> new ToStringBuilder(base).append("a", new ArrayList<>(), false).toString());          assertEquals(                 "{\"a\":[]}",                 new ToStringBuilder(base).append("a", new ArrayList<>(),                         true).toString());          assertThrows(                 UnsupportedOperationException.class,                 () -> new ToStringBuilder(base).append("a", new HashMap<>(), false).toString());          assertEquals(                 "{\"a\":{}}",                 new ToStringBuilder(base).append("a",                         new HashMap<>(), true).toString());          assertThrows(                 UnsupportedOperationException.class,                 () -> new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());          assertEquals(                 "{\"a\":[]}",                 new ToStringBuilder(base).append("a", (Object) new String[0],                         true).toString());          assertThrows(                 UnsupportedOperationException.class,                 () -> new ToStringBuilder(base).append("a", (Object) new int[]{1, 2, 3}, false).toString());          assertEquals(                 "{\"a\":[1,2,3]}",                 new ToStringBuilder(base).append("a",                         (Object) new int[]{1, 2, 3}, true).toString());          assertThrows(                 UnsupportedOperationException.class,                 () -> new ToStringBuilder(base).append("a", (Object) new String[]{"v", "x", "y", "z"}, false).toString());          assertEquals(                 "{\"a\":[\"v\",\"x\",\"y\",\"z\"]}",                 new ToStringBuilder(base).append("a",                         (Object) new String[]{"v", "x", "y", "z"}, true)                         .toString());     }      @Test     public void testList() {         final Student student = new Student();         final ArrayList<Hobby> objects = new ArrayList<>();          objects.add(Hobby.BOOK);         objects.add(Hobby.SPORT);         objects.add(Hobby.MUSIC);          student.setHobbies(objects);          assertEquals(student.toString(), "{\"hobbies\":[\"BOOK\",\"SPORT\",\"MUSIC\"]}");         student.setHobbies(new ArrayList<>());         assertEquals(student.toString(), "{\"hobbies\":[]}");         student.setHobbies(null);         assertEquals(student.toString(), "{\"hobbies\":null}");     }      @Test     public void testArrayEnum() {         final Teacher teacher = new Teacher();         final Hobby[] hobbies = new Hobby[3];         hobbies[0] = Hobby.BOOK;         hobbies[1] = Hobby.SPORT;         hobbies[2] = Hobby.MUSIC;          teacher.setHobbies(hobbies);          assertEquals(teacher.toString(), "{\"hobbies\":[\"BOOK\",\"SPORT\",\"MUSIC\"]}");         teacher.setHobbies(new Hobby[0]);         assertEquals(teacher.toString(), "{\"hobbies\":[]}");         teacher.setHobbies(null);         assertEquals(teacher.toString(), "{\"hobbies\":null}");     }      @Test     public void testCombineListAndEnum() {         final Teacher teacher = new Teacher();          final Hobby[] teacherHobbies = new Hobby[3];         teacherHobbies[0] = Hobby.BOOK;         teacherHobbies[1] = Hobby.SPORT;         teacherHobbies[2] = Hobby.MUSIC;          teacher.setHobbies(teacherHobbies);          final Student john = new Student();         john.setHobbies(Arrays.asList(Hobby.BOOK, Hobby.MUSIC));          final Student alice = new Student();         alice.setHobbies(new ArrayList<>());          final Student bob = new Student();         bob.setHobbies(Collections.singletonList(Hobby.BOOK));          final ArrayList<Student> students = new ArrayList<>();         students.add(john);         students.add(alice);         students.add(bob);          final AcademyClass academyClass = new AcademyClass();         academyClass.setStudents(students);         academyClass.setTeacher(teacher);          assertEquals(academyClass.toString(), "{\"students\":[{\"hobbies\":[\"BOOK\",\"MUSIC\"]},{\"hobbies\":[]},{\"hobbies\":[\"BOOK\"]}],\"teacher\":{\"hobbies\":[\"BOOK\",\"SPORT\",\"MUSIC\"]}}");     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "Jane Doe";         p.age = 25;         p.smoker = true;          assertEquals(                 "{\"name\":\"Jane Doe\",\"age\":25,\"smoker\":true}",                 new ToStringBuilder(p).append("name", p.name)                         .append("age", p.age).append("smoker", p.smoker)                         .toString());     }      @Test     public void testNestingPerson() {         final Person p = new Person() {             @Override             public String toString() {                 return new ToStringBuilder(this).append("name", this.name)                     .append("age", this.age).append("smoker", this.smoker)                     .toString();             }         };         p.name = "Jane Doe";         p.age = 25;         p.smoker = true;          final NestingPerson nestP = new NestingPerson();         nestP.pid="#1@Jane";         nestP.person = p;          assertEquals(                 "{\"pid\":\"#1@Jane\",\"person\":{\"name\":\"Jane Doe\",\"age\":25,\"smoker\":true}}",                 new ToStringBuilder(nestP).append("pid", nestP.pid)                         .append("person", nestP.person)                         .toString());     }      @Test     public void testLong() {         assertThrows(UnsupportedOperationException.class, () -> new ToStringBuilder(base).append(3L).toString());          assertEquals("{\"a\":3}", new ToStringBuilder(base).append("a", 3L)                 .toString());         assertEquals("{\"a\":3,\"b\":4}",                 new ToStringBuilder(base).append("a", 3L).append("b", 4L)                         .toString());     }      @Test     public void testObjectArray() {         final Object[] array = new Object[]{null, base, new int[]{3, 6}};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"objectArray\":[null,5,[3,6]]}", toStringBuilder.append("objectArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testLongArray() {         final long[] array = new long[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"longArray\":[1,2,-3,4]}", toStringBuilder.append("longArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testIntArray() {         final int[] array = new int[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"intArray\":[1,2,-3,4]}", toStringBuilder.append("intArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testByteArray() {         final byte[] array = new byte[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"byteArray\":[1,2,-3,4]}", toStringBuilder.append("byteArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testShortArray() {         final short[] array = new short[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"shortArray\":[1,2,-3,4]}", toStringBuilder.append("shortArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testDoubleArray() {         final double[] array = new double[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"doubleArray\":[1.0,2.0,-3.0,4.0]}", toStringBuilder.append("doubleArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testFloatArray() {         final float[] array = new float[]{1, 2, -3, 4};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"floatArray\":[1.0,2.0,-3.0,4.0]}", toStringBuilder.append("floatArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testCharArray() {         final char[] array = new char[]{'1', '2', '3', '4'};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"charArray\":[\"1\",\"2\",\"3\",\"4\"]}", toStringBuilder.append("charArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testBooleanArray() {         final boolean[] array = new boolean[]{true, false};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertEquals("{\"booleanArray\":[true,false]}", toStringBuilder.append("booleanArray", array)                 .toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         final long[][] array = new long[][]{{1, 2}, null, {5}};          final ToStringBuilder toStringBuilder = new ToStringBuilder(base);         assertThrows(UnsupportedOperationException.class, () -> toStringBuilder.append(array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((long[][]) null).toString());          assertThrows(                 UnsupportedOperationException.class, () -> toStringBuilder.append((Object) array).toString());     }      @Test     public void testArray() {         final Person p = new Person();         p.name = "Jane Doe";         p.age = 25;         p.smoker = true;          assertEquals(                 "{\"name\":\"Jane Doe\",\"age\":25,\"smoker\":true,\"groups\":['admin', 'manager', 'user']}",                 new ToStringBuilder(p).append("name", p.name)                         .append("age", p.age).append("smoker", p.smoker)                         .append("groups", new Object() {                             @Override                             public String toString() {                                 return "['admin', 'manager', 'user']";                             }                         })                         .toString());     }      @Test     public void testLANG1395() {         assertEquals("{\"name\":\"value\"}", new ToStringBuilder(base).append("name", "value").toString());         assertEquals("{\"name\":\"\"}", new ToStringBuilder(base).append("name", "").toString());         assertEquals("{\"name\":\"\\\"\"}", new ToStringBuilder(base).append("name", '"').toString());         assertEquals("{\"name\":\"\\\\\"}", new ToStringBuilder(base).append("name", '\\').toString());         assertEquals("{\"name\":\"Let's \\\"quote\\\" this\"}", new ToStringBuilder(base).append("name", "Let's \"quote\" this").toString());     }      @Test     public void testLANG1396() {         assertEquals("{\"Let's \\\"quote\\\" this\":\"value\"}", new ToStringBuilder(base).append("Let's \"quote\" this", "value").toString());     }      @Test     public void testRootMap() {         final Map<String, Object> map = new LinkedHashMap<>();         map.put("k1", "v1");         map.put("k2", 2);          assertEquals("{\"map\":{\"k1\":\"v1\",\"k2\":2}}",                 new ToStringBuilder(base).append("map", map).toString());     }      @Test     public void testObjectWithInnerMap() {         final Map<String, Object> map = new LinkedHashMap<>();         map.put("k1", "value1");         map.put("k2", 2);          final InnerMapObject object = new InnerMapObject(){             @Override             public String toString() {                 return new ToStringBuilder(this).append("pid", this.pid)                         .append("map", this.map).toString();             }         };         object.pid = "dummy-text";         object.map = map;          assertEquals("{\"object\":{\"pid\":\"dummy-text\",\"map\":{\"k1\":\"value1\",\"k2\":2}}}",                 new ToStringBuilder(base).append("object", object).toString());     }      @Test     public void testNestedMaps() {         final Map<String, Object> innerMap = new LinkedHashMap<>();         innerMap.put("k2.1", "v2.1");         innerMap.put("k2.2", "v2.2");         final Map<String, Object> baseMap = new LinkedHashMap<>();         baseMap.put("k1", "v1");         baseMap.put("k2", innerMap);          final InnerMapObject object = new InnerMapObject(){             @Override             public String toString() {                 return new ToStringBuilder(this).append("pid", this.pid)                         .append("map", this.map).toString();             }         };         object.pid = "dummy-text";         object.map = baseMap;          assertEquals("{\"object\":{\"pid\":\"dummy-text\",\"map\":{\"k1\":\"v1\"," +                         "\"k2\":{\"k2.1\":\"v2.1\",\"k2.2\":\"v2.2\"}}}}",                 new ToStringBuilder(base).append("object", object).toString());     }      @Test     public void testMapSkipNullKey() {         final Map<String, Object> map = new LinkedHashMap<>();         map.put("k1", "v1");         map.put(null, "v2");          assertEquals("{\"map\":{\"k1\":\"v1\"}}",                 new ToStringBuilder(base).append("map", map).toString());     }      /**      * An object with nested object structures used to test {@code ToStringStyle.JsonToStringStyle}.      */     static class NestingPerson {         /**          * Test String field.          */         String pid;          /**          * Test nested object field.          */         Person person;     }      enum Hobby {         SPORT,         BOOK,         MUSIC     }      enum EmptyEnum {     }      static class Student {         List<Hobby> hobbies;          public List<Hobby> getHobbies() {             return hobbies;         }          public void setHobbies(final List<Hobby> hobbies) {             this.hobbies = hobbies;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      static class Teacher {         Hobby[] hobbies;          public Hobby[] getHobbies() {             return hobbies;         }          public void setHobbies(final Hobby[] hobbies) {             this.hobbies = hobbies;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      static class AcademyClass {         Teacher teacher;         List<Student> students;          public void setTeacher(final Teacher teacher) {             this.teacher = teacher;         }          public void setStudents(final List<Student> students) {             this.students = students;         }          public Teacher getTeacher() {             return teacher;         }          public List<Student> getStudents() {             return students;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      /**      * An object with a Map field used to test {@code ToStringStyle.JsonToStringStyle}.      */     static class InnerMapObject {         /**          * Test String field.          */         String pid;          /**          * Test inner map field.          */         Map<String, Object> map;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.math.BigInteger;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.CompareToBuilder}.  */ public class CompareToBuilderTest {      //-----------------------------------------------------------------------      static class TestObject implements Comparable<TestObject> {         private int a;         TestObject(final int a) {             this.a = a;         }         @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (!(o instanceof TestObject)) {                 return false;             }             final TestObject rhs = (TestObject) o;             return a == rhs.a;         }          @Override         public int hashCode() {             return a;         }          public void setA(final int a) {             this.a = a;         }          public int getA() {             return a;         }         @Override         public int compareTo(final TestObject rhs) {             return Integer.compare(a, rhs.a);         }     }      static class TestSubObject extends TestObject {         private int b;         TestSubObject() {             super(0);         }         TestSubObject(final int a, final int b) {             super(a);             this.b = b;         }         @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (!(o instanceof TestSubObject)) {                 return false;             }             final TestSubObject rhs = (TestSubObject) o;             return super.equals(o) && b == rhs.b;         }     }      static class TestTransientSubObject extends TestObject {         @SuppressWarnings("unused")         private transient int t;         TestTransientSubObject(final int a, final int t) {             super(a);             this.t = t;         }     }      @Test     public void testReflectionCompare() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(4);         assertEquals(0, CompareToBuilder.reflectionCompare(o1, o1));         assertEquals(0, CompareToBuilder.reflectionCompare(o1, o2));         o2.setA(5);         assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0);         assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0);     }      @Test     public void testReflectionCompareEx1() {         final TestObject o1 = new TestObject(4);         assertThrows(NullPointerException.class, () -> CompareToBuilder.reflectionCompare(o1, null));     }      @Test     public void testReflectionCompareEx2() {         final TestObject o1 = new TestObject(4);         final Object o2 = new Object();         assertThrows(ClassCastException.class, () -> CompareToBuilder.reflectionCompare(o1, o2));     }      @Test     public void testReflectionHierarchyCompare() {         testReflectionHierarchyCompare(false, null);     }      @Test     public void testReflectionHierarchyCompareExcludeFields() {         final String[] excludeFields = new String[] { "b" };         testReflectionHierarchyCompare(true, excludeFields);          TestSubObject x;         TestSubObject y;         TestSubObject z;          x = new TestSubObject(1, 1);         y = new TestSubObject(2, 1);         z = new TestSubObject(3, 1);         assertXYZCompareOrder(x, y, z, true, excludeFields);          x = new TestSubObject(1, 3);         y = new TestSubObject(2, 2);         z = new TestSubObject(3, 1);         assertXYZCompareOrder(x, y, z, true, excludeFields);     }      @Test     public void testReflectionHierarchyCompareTransients() {         testReflectionHierarchyCompare(true, null);          TestTransientSubObject x;         TestTransientSubObject y;         TestTransientSubObject z;          x = new TestTransientSubObject(1, 1);         y = new TestTransientSubObject(2, 2);         z = new TestTransientSubObject(3, 3);         assertXYZCompareOrder(x, y, z, true, null);          x = new TestTransientSubObject(1, 1);         y = new TestTransientSubObject(1, 2);         z = new TestTransientSubObject(1, 3);         assertXYZCompareOrder(x, y, z, true, null);     }      private void assertXYZCompareOrder(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) {         assertEquals(0, CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields));         assertEquals(0, CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields));         assertEquals(0, CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields));          assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields));         assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields));         assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields));          assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients, null, excludeFields));         assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients, null, excludeFields));         assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields));     }      private void testReflectionHierarchyCompare(final boolean testTransients, final String[] excludeFields) {         final TestObject to1 = new TestObject(1);         final TestObject to2 = new TestObject(2);         final TestObject to3 = new TestObject(3);         final TestSubObject tso1 = new TestSubObject(1, 1);         final TestSubObject tso2 = new TestSubObject(2, 2);         final TestSubObject tso3 = new TestSubObject(3, 3);          assertReflectionCompareContract(to1, to1, to1, false, excludeFields);         assertReflectionCompareContract(to1, to2, to3, false, excludeFields);         assertReflectionCompareContract(tso1, tso1, tso1, false, excludeFields);         assertReflectionCompareContract(tso1, tso2, tso3, false, excludeFields);         assertReflectionCompareContract("1", "2", "3", false, excludeFields);          assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));         assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));          // root class         assertXYZCompareOrder(to1, to2, to3, true, null);         // subclass         assertXYZCompareOrder(tso1, tso2, tso3, true, null);     }      /**      * See "Effective Java" under "Consider Implementing Comparable".      *      * @param x an object to compare      * @param y an object to compare      * @param z an object to compare      * @param testTransients Whether to include transients in the comparison      * @param excludeFields fields to exclude      */     private void assertReflectionCompareContract(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) {          // signum         assertEquals(reflectionCompareSignum(x, y, testTransients, excludeFields), -reflectionCompareSignum(y, x, testTransients, excludeFields));          // transitive         if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0                 && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0) {             assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0);         }          // un-named         if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) {             assertEquals(reflectionCompareSignum(x, z, testTransients, excludeFields), -reflectionCompareSignum(y, z, testTransients, excludeFields));         }          // strongly recommended but not strictly required         assertTrue(CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 == EqualsBuilder.reflectionEquals(x, y, testTransients));     }      /**      * Returns the signum of the result of comparing x and y with      * {@code CompareToBuilder.reflectionCompare}      *      * @param lhs The "left-hand-side" of the comparison.      * @param rhs The "right-hand-side" of the comparison.      * @param testTransients Whether to include transients in the comparison      * @param excludeFields fields to exclude      * @return int The signum      */     private int reflectionCompareSignum(final Object lhs, final Object rhs, final boolean testTransients, final String[] excludeFields) {         return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();     }      @Test     public void testAppendSuper() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertEquals(0, new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);          assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);         assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);          assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);     }      @Test     public void testObject() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(4);         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertEquals(0, new CompareToBuilder().append(o1, o2).toComparison());         o2.setA(5);         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);          assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((Object) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0);     }      @Test     public void testObjectBuild() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(4);         assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o1).build());         assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o2).build());         o2.setA(5);         assertTrue(new CompareToBuilder().append(o1, o2).build().intValue() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).build().intValue() > 0);          assertTrue(new CompareToBuilder().append(o1, null).build().intValue() > 0);         assertEquals(Integer.valueOf(0), new CompareToBuilder().append((Object) null, null).build());         assertTrue(new CompareToBuilder().append(null, o1).build().intValue() < 0);     }      @Test     public void testObjectEx2() {         final TestObject o1 = new TestObject(4);         final Object o2 = new Object();         assertThrows(ClassCastException.class, () -> new CompareToBuilder().append(o1, o2));     }      @Test     public void testObjectComparator() {         final String o1 = "Fred";         String o2 = "Fred";         assertEquals(0, new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison());         assertEquals(0, new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison());         o2 = "FRED";         assertEquals(0, new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison());         assertEquals(0, new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison());         o2 = "FREDA";         assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);          assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append(null, null, String.CASE_INSENSITIVE_ORDER).toComparison());         assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);     }      @Test     public void testObjectComparatorNull() {         final String o1 = "Fred";         String o2 = "Fred";         assertEquals(0, new CompareToBuilder().append(o1, o1, null).toComparison());         assertEquals(0, new CompareToBuilder().append(o1, o2, null).toComparison());         o2 = "Zebra";         assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0);          assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append(null, null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0);     }      @Test     public void testLong() {         final long o1 = 1L;         final long o2 = 2L;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0);     }      @Test     public void testInt() {         final int o1 = 1;         final int o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0);     }      @Test     public void testShort() {         final short o1 = 1;         final short o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0);     }      @Test     public void testChar() {         final char o1 = 1;         final char o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0);     }      @Test     public void testByte() {         final byte o1 = 1;         final byte o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0);     }      @Test     public void testDouble() {         final double o1 = 1;         final double o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0);         assertEquals(0, new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison());         assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);         assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);     }      @Test     public void testFloat() {         final float o1 = 1;         final float o2 = 2;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0);         assertEquals(0, new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison());         assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0);         assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0);         assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0);         assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0);         assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);         assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);     }      @Test     public void testBoolean() {         final boolean o1 = true;         final boolean o2 = false;         assertEquals(0, new CompareToBuilder().append(o1, o1).toComparison());         assertEquals(0, new CompareToBuilder().append(o2, o2).toComparison());         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0);     }      @Test     public void testObjectArray() {         final TestObject[] obj1 = new TestObject[2];         obj1[0] = new TestObject(4);         obj1[1] = new TestObject(5);         final TestObject[] obj2 = new TestObject[2];         obj2[0] = new TestObject(4);         obj2[1] = new TestObject(5);         final TestObject[] obj3 = new TestObject[3];         obj3[0] = new TestObject(4);         obj3[1] = new TestObject(5);         obj3[2] = new TestObject(6);          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = new TestObject(7);         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((Object[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testLongArray() {         final long[] obj1 = new long[2];         obj1[0] = 5L;         obj1[1] = 6L;         final long[] obj2 = new long[2];         obj2[0] = 5L;         obj2[1] = 6L;         final long[] obj3 = new long[3];         obj3[0] = 5L;         obj3[1] = 6L;         obj3[2] = 7L;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((long[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testIntArray() {         final int[] obj1 = new int[2];         obj1[0] = 5;         obj1[1] = 6;         final int[] obj2 = new int[2];         obj2[0] = 5;         obj2[1] = 6;         final int[] obj3 = new int[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((int[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testShortArray() {         final short[] obj1 = new short[2];         obj1[0] = 5;         obj1[1] = 6;         final short[] obj2 = new short[2];         obj2[0] = 5;         obj2[1] = 6;         final short[] obj3 = new short[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((short[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testCharArray() {         final char[] obj1 = new char[2];         obj1[0] = 5;         obj1[1] = 6;         final char[] obj2 = new char[2];         obj2[0] = 5;         obj2[1] = 6;         final char[] obj3 = new char[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((char[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testByteArray() {         final byte[] obj1 = new byte[2];         obj1[0] = 5;         obj1[1] = 6;         final byte[] obj2 = new byte[2];         obj2[0] = 5;         obj2[1] = 6;         final byte[] obj3 = new byte[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((byte[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testDoubleArray() {         final double[] obj1 = new double[2];         obj1[0] = 5;         obj1[1] = 6;         final double[] obj2 = new double[2];         obj2[0] = 5;         obj2[1] = 6;         final double[] obj3 = new double[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((double[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testFloatArray() {         final float[] obj1 = new float[2];         obj1[0] = 5;         obj1[1] = 6;         final float[] obj2 = new float[2];         obj2[0] = 5;         obj2[1] = 6;         final float[] obj3 = new float[3];         obj3[0] = 5;         obj3[1] = 6;         obj3[2] = 7;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((float[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testBooleanArray() {         final boolean[] obj1 = new boolean[2];         obj1[0] = true;         obj1[1] = false;         final boolean[] obj2 = new boolean[2];         obj2[0] = true;         obj2[1] = false;         final boolean[] obj3 = new boolean[3];         obj3[0] = true;         obj3[1] = false;         obj3[2] = true;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          obj1[1] = true;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);          assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);         assertEquals(0, new CompareToBuilder().append((boolean[]) null, null).toComparison());         assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);     }      @Test     public void testMultiLongArray() {         final long[][] array1 = new long[2][2];         final long[][] array2 = new long[2][2];         final long[][] array3 = new long[2][3];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);                 array3[i][j] = (i + 1) * (j + 1);             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiIntArray() {         final int[][] array1 = new int[2][2];         final int[][] array2 = new int[2][2];         final int[][] array3 = new int[2][3];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);                 array3[i][j] = (i + 1) * (j + 1);             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiShortArray() {         final short[][] array1 = new short[2][2];         final short[][] array2 = new short[2][2];         final short[][] array3 = new short[2][3];         for (short i = 0; i < array1.length; ++i) {             for (short j = 0; j < array1[0].length; j++) {                 array1[i][j] = (short) ((i + 1) * (j + 1));                 array2[i][j] = (short) ((i + 1) * (j + 1));                 array3[i][j] = (short) ((i + 1) * (j + 1));             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiCharArray() {         final char[][] array1 = new char[2][2];         final char[][] array2 = new char[2][2];         final char[][] array3 = new char[2][3];         for (short i = 0; i < array1.length; ++i) {             for (short j = 0; j < array1[0].length; j++) {                 array1[i][j] = (char) ((i + 1) * (j + 1));                 array2[i][j] = (char) ((i + 1) * (j + 1));                 array3[i][j] = (char) ((i + 1) * (j + 1));             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiByteArray() {         final byte[][] array1 = new byte[2][2];         final byte[][] array2 = new byte[2][2];         final byte[][] array3 = new byte[2][3];         for (byte i = 0; i < array1.length; ++i) {             for (byte j = 0; j < array1[0].length; j++) {                 array1[i][j] = (byte) ((i + 1) * (j + 1));                 array2[i][j] = (byte) ((i + 1) * (j + 1));                 array3[i][j] = (byte) ((i + 1) * (j + 1));             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 127;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiFloatArray() {         final float[][] array1 = new float[2][2];         final float[][] array2 = new float[2][2];         final float[][] array3 = new float[2][3];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);                 array3[i][j] = (i + 1) * (j + 1);             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 127;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiDoubleArray() {         final double[][] array1 = new double[2][2];         final double[][] array2 = new double[2][2];         final double[][] array3 = new double[2][3];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);                 array3[i][j] = (i + 1) * (j + 1);             }         }         array3[1][2] = 100;         array3[1][2] = 100;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 127;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMultiBooleanArray() {         final boolean[][] array1 = new boolean[2][2];         final boolean[][] array2 = new boolean[2][2];         final boolean[][] array3 = new boolean[2][3];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = i == 1 ^ j == 1;                 array2[i][j] = i == 1 ^ j == 1;                 array3[i][j] = i == 1 ^ j == 1;             }         }         array3[1][2] = false;         array3[1][2] = false;          assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = true;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testRaggedArray() {         final long[][] array1 = new long[2][];         final long[][] array2 = new long[2][];         final long[][] array3 = new long[3][];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             array3[i] = new long[3];             for (int j = 0; j < array1[i].length; ++j) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);                 array3[i][j] = (i + 1) * (j + 1);             }         }         array3[1][2] = 100;         array3[1][2] = 100;           assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         array1[1][1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testMixedArray() {         final Object[] array1 = new Object[2];         final Object[] array2 = new Object[2];         final Object[] array3 = new Object[2];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             array3[i] = new long[3];             for (int j = 0; j < 2; ++j) {                 ((long[]) array1[i])[j] = (i + 1) * (j + 1);                 ((long[]) array2[i])[j] = (i + 1) * (j + 1);                 ((long[]) array3[i])[j] = (i + 1) * (j + 1);             }         }         ((long[]) array3[0])[2] = 1;         ((long[]) array3[1])[2] = 1;         assertEquals(0, new CompareToBuilder().append(array1, array1).toComparison());         assertEquals(0, new CompareToBuilder().append(array1, array2).toComparison());         assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);         ((long[]) array1[1])[1] = 200;         assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);     }      @Test     public void testObjectArrayHiddenByObject() {         final TestObject[] array1 = new TestObject[2];         array1[0] = new TestObject(4);         array1[1] = new TestObject(5);         final TestObject[] array2 = new TestObject[2];         array2[0] = new TestObject(4);         array2[1] = new TestObject(5);         final TestObject[] array3 = new TestObject[3];         array3[0] = new TestObject(4);         array3[1] = new TestObject(5);         array3[2] = new TestObject(6);          final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;          assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = new TestObject(7);         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testLongArrayHiddenByObject() {         final long[] array1 = new long[2];         array1[0] = 5L;         array1[1] = 6L;         final long[] array2 = new long[2];         array2[0] = 5L;         array2[1] = 6L;         final long[] array3 = new long[3];         array3[0] = 5L;         array3[1] = 6L;         array3[2] = 7L;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testIntArrayHiddenByObject() {         final int[] array1 = new int[2];         array1[0] = 5;         array1[1] = 6;         final int[] array2 = new int[2];         array2[0] = 5;         array2[1] = 6;         final int[] array3 = new int[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testShortArrayHiddenByObject() {         final short[] array1 = new short[2];         array1[0] = 5;         array1[1] = 6;         final short[] array2 = new short[2];         array2[0] = 5;         array2[1] = 6;         final short[] array3 = new short[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testCharArrayHiddenByObject() {         final char[] array1 = new char[2];         array1[0] = 5;         array1[1] = 6;         final char[] array2 = new char[2];         array2[0] = 5;         array2[1] = 6;         final char[] array3 = new char[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testByteArrayHiddenByObject() {         final byte[] array1 = new byte[2];         array1[0] = 5;         array1[1] = 6;         final byte[] array2 = new byte[2];         array2[0] = 5;         array2[1] = 6;         final byte[] array3 = new byte[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testDoubleArrayHiddenByObject() {         final double[] array1 = new double[2];         array1[0] = 5;         array1[1] = 6;         final double[] array2 = new double[2];         array2[0] = 5;         array2[1] = 6;         final double[] array3 = new double[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testFloatArrayHiddenByObject() {         final float[] array1 = new float[2];         array1[0] = 5;         array1[1] = 6;         final float[] array2 = new float[2];         array2[0] = 5;         array2[1] = 6;         final float[] array3 = new float[3];         array3[0] = 5;         array3[1] = 6;         array3[2] = 7;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = 7;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }      @Test     public void testBooleanArrayHiddenByObject() {         final boolean[] array1 = new boolean[2];         array1[0] = true;         array1[1] = false;         final boolean[] array2 = new boolean[2];         array2[0] = true;         array2[1] = false;         final boolean[] array3 = new boolean[3];         array3[0] = true;         array3[1] = false;         array3[2] = true;         final Object obj1 = array1;         final Object obj2 = array2;         final Object obj3 = array3;         assertEquals(0, new CompareToBuilder().append(obj1, obj1).toComparison());         assertEquals(0, new CompareToBuilder().append(obj1, obj2).toComparison());         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);          array1[1] = true;         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.MultiLineToStringStyleTest}.  */ public class MultiLineToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[" + System.lineSeparator() + "]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[" + System.lineSeparator() + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + System.lineSeparator() + "]").toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]").toString());          assertEquals(baseStr + "[" + System.lineSeparator() + "  a=hello" + System.lineSeparator() + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + System.lineSeparator() + "]").append("a", "hello").toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "  a=hello" + System.lineSeparator() + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]").append("a", "hello").toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=hello" + System.lineSeparator() + "]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  3" + System.lineSeparator() + "]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=3" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=3" + System.lineSeparator() + "  b=4" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<Integer>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=0>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=[]" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=1>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=[3]" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=2>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=[3, 4]" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=0>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a={}" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=1>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a={k=v}" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=0>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a={}" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=1>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a={3}" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=<size=2>" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a={3,4}" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "Jane Doe";         p.age = 25;         p.smoker = true;         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p));         assertEquals(pBaseStr + "[" + System.lineSeparator() + "  name=Jane Doe" + System.lineSeparator() + "  age=25" + System.lineSeparator() + "  smoker=true" + System.lineSeparator() + "]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[" + System.lineSeparator() + "  3" + System.lineSeparator() + "]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=3" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  a=3" + System.lineSeparator() + "  b=4" + System.lineSeparator() + "]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[" + System.lineSeparator() + "  {<null>,5,{3,6}}" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  {<null>,5,{3,6}}" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[" + System.lineSeparator() + "  {1,2,-3,4}" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  {1,2,-3,4}" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[" + System.lineSeparator() + "  {{1,2},<null>,{5}}" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  {{1,2},<null>,{5}}" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[" + System.lineSeparator() + "  <null>" + System.lineSeparator() + "]", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.core.IsEqual.equalTo; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.apache.commons.lang3.ArrayUtils; import org.hamcrest.Matcher; import org.junit.jupiter.api.Test;   /**  * Unit tests {@link DiffBuilder}.  */ public class DiffBuilderTest {      private static class TypeTestClass implements Diffable<TypeTestClass> {         private ToStringStyle style = SHORT_STYLE;         private boolean booleanField = true;         private boolean[] booleanArrayField = {true};         private byte byteField = (byte) 0xFF;         private byte[] byteArrayField = {(byte) 0xFF};         private char charField = 'a';         private char[] charArrayField = {'a'};         private double doubleField = 1.0;         private double[] doubleArrayField = {1.0};         private float floatField = 1.0f;         private float[] floatArrayField = {1.0f};         private int intField = 1;         private int[] intArrayField = {1};         private long longField = 1L;         private long[] longArrayField = {1L};         private short shortField = 1;         private short[] shortArrayField = {1};         private Object objectField = null;         private Object[] objectArrayField = {null};          @Override         public DiffResult<TypeTestClass> diff(final TypeTestClass obj) {             return new DiffBuilder<>(this, obj, style)                 .append("boolean", booleanField, obj.booleanField)                 .append("booleanArray", booleanArrayField, obj.booleanArrayField)                 .append("byte", byteField, obj.byteField)                 .append("byteArray", byteArrayField, obj.byteArrayField)                 .append("char", charField, obj.charField)                 .append("charArray", charArrayField, obj.charArrayField)                 .append("double", doubleField, obj.doubleField)                 .append("doubleArray", doubleArrayField, obj.doubleArrayField)                 .append("float", floatField, obj.floatField)                 .append("floatArray", floatArrayField, obj.floatArrayField)                 .append("int", intField, obj.intField)                 .append("intArray", intArrayField, obj.intArrayField)                 .append("long", longField, obj.longField)                 .append("longArray", longArrayField, obj.longArrayField)                 .append("short", shortField, obj.shortField)                 .append("shortArray", shortArrayField, obj.shortArrayField)                 .append("objectField", objectField, obj.objectField)                 .append("objectArrayField", objectArrayField, obj.objectArrayField)                 .build();         }          @Override         public boolean equals(final Object obj) {             return EqualsBuilder.reflectionEquals(this, obj, false);         }          @Override         public int hashCode() {             return HashCodeBuilder.reflectionHashCode(this, false);         }     }      private static final ToStringStyle SHORT_STYLE = ToStringStyle.SHORT_PREFIX_STYLE;      @Test     public void testBoolean() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.booleanField = false;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Boolean.class, diff.getType());         assertEquals(Boolean.TRUE, diff.getLeft());         assertEquals(Boolean.FALSE, diff.getRight());     }      @Test     public void testBooleanArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.booleanArrayField = new boolean[] {false, false};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.booleanArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.booleanArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testByte() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.byteField = 0x01;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Byte.valueOf(class1.byteField), diff.getLeft());         assertEquals(Byte.valueOf(class2.byteField), diff.getRight());     }      @Test     public void testByteArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.byteArrayField= new byte[] {0x01, 0x02};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.byteArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.byteArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testByteArrayEqualAsObject() {         final DiffResult<String> list = new DiffBuilder<>("String1", "String2", SHORT_STYLE)             .append("foo", new boolean[] {false}, new boolean[] {false})             .append("foo", new byte[] {0x01}, new byte[] {0x01})             .append("foo", new char[] {'a'}, new char[] {'a'})             .append("foo", new double[] {1.0}, new double[] {1.0})             .append("foo", new float[] {1.0F}, new float[] {1.0F})             .append("foo", new int[] {1}, new int[] {1})             .append("foo", new long[] {1L}, new long[] {1L})             .append("foo", new short[] {1}, new short[] {1})             .append("foo", new Object[] {1, "two"}, new Object[] {1, "two"})             .build();          assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void testChar() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.charField = 'z';         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Character.valueOf(class1.charField), diff.getLeft());         assertEquals(Character.valueOf(class2.charField), diff.getRight());     }      @Test     public void testCharArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.charArrayField = new char[] {'f', 'o', 'o'};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.charArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.charArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testDiffResult() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.intField = 2;          final DiffResult<TypeTestClass> list = new DiffBuilder<>(class1, class2, SHORT_STYLE)             .append("prop1", class1.diff(class2))             .build();         assertEquals(1, list.getNumberOfDiffs());         assertEquals("prop1.int", list.getDiffs().get(0).getFieldName());     }      @Test     public void testDouble() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.doubleField = 99.99;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Double.valueOf(class1.doubleField), diff.getLeft());         assertEquals(Double.valueOf(class2.doubleField), diff.getRight());     }      @Test     public void testDoubleArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.doubleArrayField = new double[] {3.0, 2.9, 2.8};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.doubleArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.doubleArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testFloat() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.floatField = 99.99F;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Float.valueOf(class1.floatField), diff.getLeft());         assertEquals(Float.valueOf(class2.floatField), diff.getRight());     }      @Test     public void testFloatArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.floatArrayField = new float[] {3.0F, 2.9F, 2.8F};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.floatArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.floatArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testInt() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.intField = 42;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Integer.valueOf(class1.intField), diff.getLeft());         assertEquals(Integer.valueOf(class2.intField), diff.getRight());     }      @Test     public void testIntArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.intArrayField = new int[] {3, 2, 1};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.intArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.intArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testLong() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.longField = 42L;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Long.valueOf(class1.longField), diff.getLeft());         assertEquals(Long.valueOf(class2.longField), diff.getRight());     }      @Test     public void testLongArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.longArrayField = new long[] {3L, 2L, 1L};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.longArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.longArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testNullLhs() {         assertThrows(NullPointerException.class, () -> new DiffBuilder<>(null, this, ToStringStyle.DEFAULT_STYLE));     }      @Test     public void testNullRhs() {         assertThrows(NullPointerException.class, () -> new DiffBuilder<>(this, null, ToStringStyle.DEFAULT_STYLE));     }      @Test     public void testObject() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.objectField = "Some string";         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(class1.objectField, diff.getLeft());         assertEquals(class2.objectField, diff.getRight());     }      @Test     public void testObjectArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.objectArrayField = new Object[] {"string", 1, 2};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(class1.objectArrayField, (Object[]) diff.getLeft());         assertArrayEquals(class2.objectArrayField, (Object[]) diff.getRight());     }      @Test     public void testObjectArrayEqual() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class1.objectArrayField = new Object[] {"string", 1, 2};         class2.objectArrayField = new Object[] {"string", 1, 2};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(0, list.getNumberOfDiffs());     }      /**      * Test that "left" and "right" are the same instance but are equal.      */     @Test     public void testObjectsNotSameButEqual() {         final TypeTestClass left = new TypeTestClass();         left.objectField = new Integer(1);         final TypeTestClass right = new TypeTestClass();         right.objectField = new Integer(1);         assertNotSame(left.objectField, right.objectField);         assertEquals(left.objectField, right.objectField);          final DiffResult<TypeTestClass> list = left.diff(right);         assertEquals(0, list.getNumberOfDiffs());     }      /**      * Test that "left" and "right" are not the same instance and are not equal.      */     @Test     public void testObjectsNotSameNorEqual() {         final TypeTestClass left = new TypeTestClass();         left.objectField = 4;         final TypeTestClass right = new TypeTestClass();         right.objectField = 100;         assertNotSame(left.objectField, right.objectField);         assertNotEquals(left.objectField, right.objectField);          final DiffResult<TypeTestClass> list = left.diff(right);         assertEquals(1, list.getNumberOfDiffs());     }      /**      * Test that "left" and "right" are the same instance and are equal.      */     @Test     public void testObjectsSameAndEqual() {         final Integer sameObject = 1;         final TypeTestClass left = new TypeTestClass();         left.objectField = sameObject;         final TypeTestClass right = new TypeTestClass();         right.objectField = sameObject;         assertSame(left.objectField, right.objectField);         assertEquals(left.objectField, right.objectField);          final DiffResult<TypeTestClass> list = left.diff(right);         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void testSameObjectIgnoresAppends() {         final TypeTestClass testClass = new TypeTestClass();         final DiffResult<TypeTestClass> list = new DiffBuilder<>(testClass, testClass, SHORT_STYLE)             .append("ignored", false, true)             .build();         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void testShort() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.shortField = 42;         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertEquals(Short.valueOf(class1.shortField), diff.getLeft());         assertEquals(Short.valueOf(class2.shortField), diff.getRight());     }      @Test     public void testShortArray() {         final TypeTestClass class1 = new TypeTestClass();         final TypeTestClass class2 = new TypeTestClass();         class2.shortArrayField = new short[] {3, 2, 1};         final DiffResult<TypeTestClass> list = class1.diff(class2);         assertEquals(1, list.getNumberOfDiffs());         final Diff<?> diff = list.getDiffs().get(0);         assertArrayEquals(ArrayUtils.toObject(class1.shortArrayField),                 (Object[]) diff.getLeft());         assertArrayEquals(ArrayUtils.toObject(class2.shortArrayField),                 (Object[]) diff.getRight());     }      @Test     public void testSimilarObjectIgnoresAppends() {         final TypeTestClass testClass1 = new TypeTestClass();         final TypeTestClass testClass2 = new TypeTestClass();         final DiffResult<TypeTestClass> list = new DiffBuilder<>(testClass1, testClass2, SHORT_STYLE)             .append("ignored", false, true)             .build();         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void testStylePassedToDiffResult() {         final TypeTestClass class1 = new TypeTestClass();         DiffResult<TypeTestClass> list = class1.diff(class1);         assertEquals(SHORT_STYLE, list.getToStringStyle());          class1.style = ToStringStyle.MULTI_LINE_STYLE;         list = class1.diff(class1);         assertEquals(ToStringStyle.MULTI_LINE_STYLE, list.getToStringStyle());     }      @Test     public void testTriviallyEqualTestDisabled() {         final Matcher<Integer> equalToOne = equalTo(1);          // Constructor's arguments are not trivially equal, but not testing for that.         final DiffBuilder<Integer> explicitTestAndNotEqual1 = new DiffBuilder<>(1, 2, null, false);         explicitTestAndNotEqual1.append("letter", "X", "Y");         assertThat(explicitTestAndNotEqual1.build().getNumberOfDiffs(), equalToOne);          // Constructor's arguments are trivially equal, but not testing for that.         final DiffBuilder<Integer> explicitTestAndNotEqual2 = new DiffBuilder<>(1, 1, null, false);         // This append(f, l, r) will not abort early.         explicitTestAndNotEqual2.append("letter", "X", "Y");         assertThat(explicitTestAndNotEqual2.build().getNumberOfDiffs(), equalToOne);     }      @Test     public void testTriviallyEqualTestEnabled() {         final Matcher<Integer> equalToZero = equalTo(0);         final Matcher<Integer> equalToOne = equalTo(1);          // The option to test if trivially equal is enabled by default.         final DiffBuilder<Integer> implicitTestAndEqual = new DiffBuilder<>(1, 1, null);         // This append(f, l, r) will abort without creating a Diff for letter.         implicitTestAndEqual.append("letter", "X", "Y");         assertThat(implicitTestAndEqual.build().getNumberOfDiffs(), equalToZero);          final DiffBuilder<Integer> implicitTestAndNotEqual = new DiffBuilder<>(1, 2, null);         // This append(f, l, r) will not abort early         // because the constructor's arguments were not trivially equal.         implicitTestAndNotEqual.append("letter", "X", "Y");         assertThat(implicitTestAndNotEqual.build().getNumberOfDiffs(), equalToOne);          // This is explicitly enabling the trivially equal test.         final DiffBuilder<Integer> explicitTestAndEqual = new DiffBuilder<>(1, 1, null, true);         explicitTestAndEqual.append("letter", "X", "Y");         assertThat(explicitTestAndEqual.build().getNumberOfDiffs(), equalToZero);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  import java.util.ArrayList; import java.util.Collection; import java.util.LinkedList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test;  /**  * Tests concurrent access for {@link ReflectionToStringBuilder}.  * <p>  * The {@link ToStringStyle} class includes a registry to avoid infinite loops for objects with circular references. We  * want to make sure that we do not get concurrency exceptions accessing this registry.  * </p>  * <p>  * The tests on the non-thread-safe collections do not pass.  * </p>  *  * @see <a href="https://issues.apache.org/jira/browse/LANG-762">[LANG-762] Handle or document ReflectionToStringBuilder  *      and ToStringBuilder for collections that are not thread safe</a>  * @since 3.1  */ public class ReflectionToStringBuilderConcurrencyTest {      static class CollectionHolder<T extends Collection<?>> {         T collection;          CollectionHolder(final T collection) {             this.collection = collection;         }     }      private static final int DATA_SIZE = 100000;     private static final int REPEAT = 100;      @Test     @Disabled     public void testLinkedList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new LinkedList<>()));     }      @Test     @Disabled     public void testArrayList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new ArrayList<>()));     }      @Test     @Disabled     public void testCopyOnWriteArrayList() throws InterruptedException, ExecutionException {         this.testConcurrency(new CollectionHolder<>(new CopyOnWriteArrayList<>()));     }      private void testConcurrency(final CollectionHolder<List<Integer>> holder) throws InterruptedException,         ExecutionException {         final List<Integer> list = holder.collection;         // make a big array that takes a long time to toString()         for (int i = 0; i < DATA_SIZE; i++) {             list.add(Integer.valueOf(i));         }         // Create a thread pool with two threads to cause the most contention on the underlying resource.         final ExecutorService threadPool = Executors.newFixedThreadPool(2);         try {             // Consumes toStrings             final Callable<Integer> consumer = () -> {                 for (int i = 0; i < REPEAT; i++) {                     final String s = ReflectionToStringBuilder.toString(holder);                     assertNotNull(s);                 }                 return Integer.valueOf(REPEAT);             };             // Produces changes in the list             final Callable<Integer> producer = () -> {                 for (int i = 0; i < DATA_SIZE; i++) {                     list.remove(list.get(0));                 }                 return Integer.valueOf(REPEAT);             };             final Collection<Callable<Integer>> tasks = new ArrayList<>();             tasks.add(consumer);             tasks.add(producer);             final List<Future<Integer>> futures = threadPool.invokeAll(tasks);             for (final Future<Integer> future : futures) {                 assertEquals(REPEAT, future.get().intValue());             }         } finally {             threadPool.shutdown();             threadPool.awaitTermination(1, TimeUnit.SECONDS);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  /**  * Test case for ToStringStyle.  */ public class ToStringStyleTest {      private static class ToStringStyleImpl extends ToStringStyle {         private static final long serialVersionUID = 1L;      }      //-----------------------------------------------------------------------     @Test     public void testSetArrayStart() {         final ToStringStyle style = new ToStringStyleImpl();         style.setArrayStart(null);         assertEquals("", style.getArrayStart());     }      @Test     public void testSetArrayEnd() {         final ToStringStyle style = new ToStringStyleImpl();         style.setArrayEnd(null);         assertEquals("", style.getArrayEnd());     }      @Test     public void testSetArraySeparator() {         final ToStringStyle style = new ToStringStyleImpl();         style.setArraySeparator(null);         assertEquals("", style.getArraySeparator());     }      @Test     public void testSetContentStart() {         final ToStringStyle style = new ToStringStyleImpl();         style.setContentStart(null);         assertEquals("", style.getContentStart());     }      @Test     public void testSetContentEnd() {         final ToStringStyle style = new ToStringStyleImpl();         style.setContentEnd(null);         assertEquals("", style.getContentEnd());     }      @Test     public void testSetFieldNameValueSeparator() {         final ToStringStyle style = new ToStringStyleImpl();         style.setFieldNameValueSeparator(null);         assertEquals("", style.getFieldNameValueSeparator());     }      @Test     public void testSetFieldSeparator() {         final ToStringStyle style = new ToStringStyleImpl();         style.setFieldSeparator(null);         assertEquals("", style.getFieldSeparator());     }      @Test     public void testSetNullText() {         final ToStringStyle style = new ToStringStyleImpl();         style.setNullText(null);         assertEquals("", style.getNullText());     }      @Test     public void testSetSizeStartText() {         final ToStringStyle style = new ToStringStyleImpl();         style.setSizeStartText(null);         assertEquals("", style.getSizeStartText());     }      @Test     public void testSetSizeEndText() {         final ToStringStyle style = new ToStringStyleImpl();         style.setSizeEndText(null);         assertEquals("", style.getSizeEndText());     }      @Test     public void testSetSummaryObjectStartText() {         final ToStringStyle style = new ToStringStyleImpl();         style.setSummaryObjectStartText(null);         assertEquals("", style.getSummaryObjectStartText());     }      @Test     public void testSetSummaryObjectEndText() {         final ToStringStyle style = new ToStringStyleImpl();         style.setSummaryObjectEndText(null);         assertEquals("", style.getSummaryObjectEndText());     }      /**      * An object used to test {@link ToStringStyle}.      *      */     static class Person {         /**          * Test String field.          */         String name;          /**          * Test integer field.          */         int age;          /**          * Test boolean field.          */         boolean smoker;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Arrays; import java.util.Collections;  import org.apache.commons.lang3.builder.ToStringStyleTest.Person; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link ToStringStyle#NO_CLASS_NAME_STYLE}.  */ public class NoClassNameToStringStyleTest {      private final Integer base = Integer.valueOf(5);      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(ToStringStyle.NO_CLASS_NAME_STYLE);     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals("[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals("[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals("[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals("[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals("[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals("[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals("[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals("[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals("[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals("[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals("[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());     }      @Test     public void testCollection() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyList(), false).toString());         assertEquals("[a=[]]", new ToStringBuilder(base).append("a", Collections.emptyList(), true).toString());         assertEquals("[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), false).toString());         assertEquals("[a=[3]]", new ToStringBuilder(base).append("a", Collections.singletonList(i3), true).toString());         assertEquals("[a=<size=2>]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), false).toString());         assertEquals("[a=[3, 4]]", new ToStringBuilder(base).append("a", Arrays.asList(i3, i4), true).toString());     }      @Test     public void testMap() {         assertEquals("[a=<size=0>]", new ToStringBuilder(base).append("a", Collections.emptyMap(), false).toString());         assertEquals("[a={}]", new ToStringBuilder(base).append("a", Collections.emptyMap(), true).toString());         assertEquals("[a=<size=1>]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), false).toString());         assertEquals("[a={k=v}]", new ToStringBuilder(base).append("a", Collections.singletonMap("k", "v"), true).toString());     }      @Test     public void testArray() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals("[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new Integer[0], false).toString());         assertEquals("[a={}]", new ToStringBuilder(base).append("a", (Object) new Integer[0], true).toString());         assertEquals("[a=<size=1>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, false).toString());         assertEquals("[a={3}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3}, true).toString());         assertEquals("[a=<size=2>]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, false).toString());         assertEquals("[a={3,4}]", new ToStringBuilder(base).append("a", (Object) new Integer[] {i3, i4}, true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "John Q. Public";         p.age = 45;         p.smoker = true;         assertEquals("[name=John Q. Public,age=45,smoker=true]", new ToStringBuilder(p).append("name", p.name).append("age", p.age).append("smoker", p.smoker).toString());     }      @Test     public void testLong() {         assertEquals("[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals("[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals("[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals("[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals("[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals("[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals("[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals("[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals("[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals("[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals("[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals("[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals("[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.HashCodeBuilder}.  */ public class HashCodeBuilderTest {      /**      * A reflection test fixture.      */     static class ReflectionTestCycleA {         ReflectionTestCycleB b;          @Override         public int hashCode() {             return HashCodeBuilder.reflectionHashCode(this);         }     }      /**      * A reflection test fixture.      */     static class ReflectionTestCycleB {         ReflectionTestCycleA a;          @Override         public int hashCode() {             return HashCodeBuilder.reflectionHashCode(this);         }     }      // -----------------------------------------------------------------------      @Test     public void testConstructorExZero() {         assertThrows(IllegalArgumentException.class, () -> new HashCodeBuilder(0, 0));     }      @Test     public void testConstructorExEvenFirst() {         assertThrows(IllegalArgumentException.class, () -> new HashCodeBuilder(2, 3));     }      @Test     public void testConstructorExEvenSecond() {         assertThrows(IllegalArgumentException.class, () -> new HashCodeBuilder(3, 2));     }      @Test     public void testConstructorExEvenNegative() {         assertThrows(IllegalArgumentException.class, () -> new HashCodeBuilder(-2, -2));     }      static class TestObject {         private int a;          TestObject(final int a) {             this.a = a;         }          @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (!(o instanceof TestObject)) {                 return false;             }             final TestObject rhs = (TestObject) o;             return a == rhs.a;         }          @Override         public int hashCode() {             return a;         }          public void setA(final int a) {             this.a = a;         }          public int getA() {             return a;         }     }      static class TestSubObject extends TestObject {         private int b;          @SuppressWarnings("unused")         private transient int t;          TestSubObject() {             super(0);         }          TestSubObject(final int a, final int b, final int t) {             super(a);             this.b = b;             this.t = t;         }          @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (!(o instanceof TestSubObject)) {                 return false;             }             final TestSubObject rhs = (TestSubObject) o;             return super.equals(o) && b == rhs.b;         }          @Override         public int hashCode() {             return b*17 + super.hashCode();         }      }      @Test     public void testReflectionHashCode() {         assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));         assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));     }      @Test     public void testReflectionHierarchyHashCode() {         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));         assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));         assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890,                 0)));         assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(                 123456, 7890, 0), true));     }      @Test     public void testReflectionHierarchyHashCodeEx1() {         assertThrows(IllegalArgumentException.class, () -> HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true));     }      @Test     public void testReflectionHierarchyHashCodeEx2() {         assertThrows(IllegalArgumentException.class, () -> HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true));     }      @Test     public void testReflectionHashCodeEx1() {         assertThrows(IllegalArgumentException.class, () -> HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true));     }      @Test     public void testReflectionHashCodeEx2() {         assertThrows(IllegalArgumentException.class, () -> HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true));     }      @Test     public void testReflectionHashCodeEx3() {         assertThrows(NullPointerException.class, () -> HashCodeBuilder.reflectionHashCode(13, 19, null, true));     }      @Test     public void testSuper() {         final Object obj = new Object();         assertEquals(17 * 37 + 19 * 41 + obj.hashCode(), new HashCodeBuilder(17, 37).appendSuper(                 new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode());     }      @Test     public void testObject() {         Object obj = null;         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj = new Object();         assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testObjectBuild() {         Object obj = null;         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).build().intValue());         obj = new Object();         assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).build().intValue());     }      @Test     @SuppressWarnings("cast") // cast is not really needed, keep for consistency     public void testLong() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(0L).toHashCode());         assertEquals(17 * 37 + (int) (123456789L ^ 123456789L >> 32), new HashCodeBuilder(17, 37).append(                 123456789L).toHashCode());     }      @Test     @SuppressWarnings("cast") // cast is not really needed, keep for consistency     public void testInt() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(0).toHashCode());         assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append(123456).toHashCode());     }      @Test     public void testShort() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());         assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());     }      @Test     public void testChar() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());         assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());     }      @Test     public void testByte() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());         assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());     }      @Test     @SuppressWarnings("cast") // cast is not really needed, keep for consistency     public void testDouble() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(0d).toHashCode());         final double d = 1234567.89;         final long l = Double.doubleToLongBits(d);         assertEquals(17 * 37 + (int) (l ^ l >> 32), new HashCodeBuilder(17, 37).append(d).toHashCode());     }      @Test     @SuppressWarnings("cast") // cast is not really needed, keep for consistency     public void testFloat() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(0f).toHashCode());         final float f = 1234.89f;         final int i = Float.floatToIntBits(f);         assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());     }      @Test     public void testBoolean() {         assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());         assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());     }      @Test     public void testObjectArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());         final Object[] obj = new Object[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = new Object();         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = new Object();         assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj)                 .toHashCode());     }      @Test     public void testObjectArrayAsObject() {         final Object[] obj = new Object[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = new Object();         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = new Object();         assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(                 (Object) obj).toHashCode());     }      @Test     public void testLongArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());         final long[] obj = new long[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = 5L;         final int h1 = (int) (5L ^ 5L >> 32);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = 6L;         final int h2 = (int) (6L ^ 6L >> 32);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testLongArrayAsObject() {         final long[] obj = new long[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = 5L;         final int h1 = (int) (5L ^ 5L >> 32);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = 6L;         final int h2 = (int) (6L ^ 6L >> 32);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testIntArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());         final int[] obj = new int[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testIntArrayAsObject() {         final int[] obj = new int[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testShortArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());         final short[] obj = new short[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = (short) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = (short) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testShortArrayAsObject() {         final short[] obj = new short[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = (short) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = (short) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testCharArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());         final char[] obj = new char[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = (char) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = (char) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testCharArrayAsObject() {         final char[] obj = new char[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = (char) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = (char) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testByteArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());         final byte[] obj = new byte[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = (byte) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = (byte) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testByteArrayAsObject() {         final byte[] obj = new byte[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = (byte) 5;         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = (byte) 6;         assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testDoubleArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());         final double[] obj = new double[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = 5.4d;         final long l1 = Double.doubleToLongBits(5.4d);         final int h1 = (int) (l1 ^ l1 >> 32);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = 6.3d;         final long l2 = Double.doubleToLongBits(6.3d);         final int h2 = (int) (l2 ^ l2 >> 32);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testDoubleArrayAsObject() {         final double[] obj = new double[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = 5.4d;         final long l1 = Double.doubleToLongBits(5.4d);         final int h1 = (int) (l1 ^ l1 >> 32);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = 6.3d;         final long l2 = Double.doubleToLongBits(6.3d);         final int h2 = (int) (l2 ^ l2 >> 32);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testFloatArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());         final float[] obj = new float[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = 5.4f;         final int h1 = Float.floatToIntBits(5.4f);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = 6.3f;         final int h2 = Float.floatToIntBits(6.3f);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testFloatArrayAsObject() {         final float[] obj = new float[2];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = 5.4f;         final int h1 = Float.floatToIntBits(5.4f);         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = 6.3f;         final int h2 = Float.floatToIntBits(6.3f);         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testBooleanArray() {         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());         final boolean[] obj = new boolean[2];         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = true;         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = false;         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testBooleanArrayAsObject() {         final boolean[] obj = new boolean[2];         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[0] = true;         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());         obj[1] = false;         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());     }      @Test     public void testBooleanMultiArray() {         final boolean[][] obj = new boolean[2][];         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = new boolean[0];         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = new boolean[1];         assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0] = new boolean[2];         assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[0][0] = true;         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());         obj[1] = new boolean[1];         assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());     }      @Test     public void testReflectionHashCodeExcludeFields() {         final TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);          assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2, HashCodeBuilder.reflectionHashCode(x));          assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2, HashCodeBuilder.reflectionHashCode(x, (String[]) null));         assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2, HashCodeBuilder.reflectionHashCode(x));         assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2, HashCodeBuilder.reflectionHashCode(x, "xxx"));          assertEquals((17 * 37 + 1) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, "two"));         assertEquals((17 * 37 + 1) * 37 + 2, HashCodeBuilder.reflectionHashCode(x, "three"));          assertEquals(17 * 37 + 1, HashCodeBuilder.reflectionHashCode(x, "two", "three"));          assertEquals(17, HashCodeBuilder.reflectionHashCode(x, "one", "two", "three"));         assertEquals(17, HashCodeBuilder.reflectionHashCode(x, "one", "two", "three", "xxx"));     }      static class TestObjectWithMultipleFields {         @SuppressWarnings("unused")         private int one = 0;          @SuppressWarnings("unused")         private int two = 0;          @SuppressWarnings("unused")         private int three = 0;          TestObjectWithMultipleFields(final int one, final int two, final int three) {             this.one = one;             this.two = two;             this.three = three;         }     }      /**      * Test Objects pointing to each other.      */     @Test     public void testReflectionObjectCycle() {         final ReflectionTestCycleA a = new ReflectionTestCycleA();         final ReflectionTestCycleB b = new ReflectionTestCycleB();         a.b = b;         b.a = a;          // Used to caused:         // java.lang.StackOverflowError         // at java.lang.ClassLoader.getCallerClassLoader(Native Method)         // at java.lang.Class.getDeclaredFields(Class.java:992)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)         // at         // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)         // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)         // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)         // at         // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)         // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)          a.hashCode();         assertNull(HashCodeBuilder.getRegistry());         b.hashCode();         assertNull(HashCodeBuilder.getRegistry());     }      /**      * Ensures LANG-520 remains true      */     @Test     public void testToHashCodeEqualsHashCode() {         final HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a');         assertEquals(hcb.toHashCode(), hcb.hashCode(),             "hashCode() is no longer returning the same value as toHashCode() - see LANG-520");     }      static class TestObjectHashCodeExclude {         @HashCodeExclude         private final int a;         private final int b;          TestObjectHashCodeExclude(final int a, final int b) {             this.a = a;             this.b = b;         }          public int getA() {             return a;         }          public int getB() {             return b;         }     }      static class TestObjectHashCodeExclude2 {         @HashCodeExclude         private final int a;         @HashCodeExclude         private final int b;          TestObjectHashCodeExclude2(final int a, final int b) {             this.a = a;             this.b = b;         }          public int getA() {             return a;         }          public int getB() {             return b;         }     }      @Test     public void testToHashCodeExclude() {         final TestObjectHashCodeExclude one = new TestObjectHashCodeExclude(1, 2);         final TestObjectHashCodeExclude2 two = new TestObjectHashCodeExclude2(1, 2);         assertEquals(17 * 37 + 2, HashCodeBuilder.reflectionHashCode(one));         assertEquals(17, HashCodeBuilder.reflectionHashCode(two));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Iterator; import java.util.List;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link DiffResult}.  */ public class DiffResultTest {      private static final SimpleClass SIMPLE_FALSE = new SimpleClass(false);     private static final SimpleClass SIMPLE_TRUE = new SimpleClass(true);     private static final ToStringStyle SHORT_STYLE = ToStringStyle.SHORT_PREFIX_STYLE;      private static class SimpleClass implements Diffable<SimpleClass> {         private final boolean booleanField;          SimpleClass(final boolean booleanField) {             this.booleanField = booleanField;         }          static String getFieldName() {             return "booleanField";         }          @Override         public DiffResult diff(final SimpleClass obj) {             return new DiffBuilder(this, obj, ToStringStyle.SHORT_PREFIX_STYLE)                     .append(getFieldName(), booleanField, obj.booleanField)                     .build();         }     }      private static class EmptyClass {     }      @Test     public void testListIsNonModifiable() {         final SimpleClass lhs = new SimpleClass(true);         final SimpleClass rhs = new SimpleClass(false);          final List<Diff<?>> diffs = lhs.diff(rhs).getDiffs();          final DiffResult list = new DiffResult(lhs, rhs, diffs, SHORT_STYLE);         assertEquals(diffs, list.getDiffs());         assertEquals(1, list.getNumberOfDiffs());         assertThrows(UnsupportedOperationException.class, () -> list.getDiffs().remove(0));     }      @Test     public void testIterator() {         final SimpleClass lhs = new SimpleClass(true);         final SimpleClass rhs = new SimpleClass(false);          final List<Diff<?>> diffs = lhs.diff(rhs).getDiffs();         final Iterator<Diff<?>> expectedIterator = diffs.iterator();          final DiffResult list = new DiffResult(lhs, rhs, diffs, SHORT_STYLE);         final Iterator<Diff<?>> iterator = list.iterator();          while (iterator.hasNext()) {             assertTrue(expectedIterator.hasNext());             assertEquals(expectedIterator.next(), iterator.next());         }     }      @Test     public void testToStringOutput() {         final DiffResult list = new DiffBuilder(new EmptyClass(), new EmptyClass(),                 ToStringStyle.SHORT_PREFIX_STYLE).append("test", false, true)                 .build();         assertEquals(                 "DiffResultTest.EmptyClass[test=false] differs from DiffResultTest.EmptyClass[test=true]",                 list.toString());     }      @Test     public void testToStringSpecifyStyleOutput() {         final DiffResult list = SIMPLE_FALSE.diff(SIMPLE_TRUE);         assertEquals(list.getToStringStyle(), SHORT_STYLE);          final String lhsString = new ToStringBuilder(SIMPLE_FALSE,                 ToStringStyle.MULTI_LINE_STYLE).append(                 SimpleClass.getFieldName(), SIMPLE_FALSE.booleanField).build();          final String rhsString = new ToStringBuilder(SIMPLE_TRUE,                 ToStringStyle.MULTI_LINE_STYLE).append(                 SimpleClass.getFieldName(), SIMPLE_TRUE.booleanField).build();          final String expectedOutput = String.format("%s differs from %s", lhsString,                 rhsString);         assertEquals(expectedOutput,                 list.toString(ToStringStyle.MULTI_LINE_STYLE));     }      @Test     public void testNullLhs() {         assertThrows(NullPointerException.class,             () -> new DiffResult(null, SIMPLE_FALSE, SIMPLE_TRUE.diff(SIMPLE_FALSE).getDiffs(), SHORT_STYLE));     }      @Test     public void testNullRhs() {         assertThrows(NullPointerException.class,             () -> new DiffResult(SIMPLE_TRUE, null, SIMPLE_TRUE.diff(SIMPLE_FALSE).getDiffs(), SHORT_STYLE));     }      @Test     public void testNullList() {         assertThrows(NullPointerException.class,             () -> new DiffResult(SIMPLE_TRUE, SIMPLE_FALSE, null, SHORT_STYLE));     }      @Test     public void testNullStyle() {         final DiffResult diffResult = new DiffResult(SIMPLE_TRUE, SIMPLE_FALSE, SIMPLE_TRUE                 .diff(SIMPLE_FALSE).getDiffs(), null);         assertEquals(ToStringStyle.DEFAULT_STYLE, diffResult.getToStringStyle());     }      @Test     public void testNoDifferencesString() {         final DiffResult diffResult = new DiffBuilder(SIMPLE_TRUE, SIMPLE_TRUE,                 SHORT_STYLE).build();         assertEquals(DiffResult.OBJECTS_SAME_STRING, diffResult.toString());     }      @Test     public void testLeftAndRightGetters() {         final SimpleClass left = new SimpleClass(true);         final SimpleClass right = new SimpleClass(false);          final List<Diff<?>> diffs = left.diff(right).getDiffs();         final DiffResult diffResult = new DiffResult(left, right, diffs, SHORT_STYLE);          assertEquals(left, diffResult.getLeft());         assertEquals(right, diffResult.getRight());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;   public class ReflectionDiffBuilderTest {      private static final ToStringStyle SHORT_STYLE = ToStringStyle.SHORT_PREFIX_STYLE;      @SuppressWarnings("unused")     private static class TypeTestClass implements Diffable<TypeTestClass> {         private final ToStringStyle style = SHORT_STYLE;         private final boolean booleanField = true;         private final boolean[] booleanArrayField = {true};         private final byte byteField = (byte) 0xFF;         private final byte[] byteArrayField = {(byte) 0xFF};         private char charField = 'a';         private char[] charArrayField = {'a'};         private final double doubleField = 1.0;         private final double[] doubleArrayField = {1.0};         private final float floatField = 1.0f;         private final float[] floatArrayField = {1.0f};         int intField = 1;         private final int[] intArrayField = {1};         private final long longField = 1L;         private final long[] longArrayField = {1L};         private final short shortField = 1;         private final short[] shortArrayField = {1};         private final Object objectField = null;         private final Object[] objectArrayField = {null};         private static int staticField;         private transient String transientField;          @Override         public DiffResult diff(final TypeTestClass obj) {             return new ReflectionDiffBuilder(this, obj, style).build();         }          @Override         public int hashCode() {             return HashCodeBuilder.reflectionHashCode(this, false);         }          @Override         public boolean equals(final Object obj) {             return EqualsBuilder.reflectionEquals(this, obj, false);         }     }      @SuppressWarnings("unused")     private static class TypeTestChildClass extends TypeTestClass {         String field = "a";     }      @Test     public void test_no_differences() {         final TypeTestClass firstObject = new TypeTestClass();         final TypeTestClass secondObject = new TypeTestClass();          final DiffResult list = firstObject.diff(secondObject);         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void test_primitive_difference() {         final TypeTestClass firstObject = new TypeTestClass();         firstObject.charField = 'c';         final TypeTestClass secondObject = new TypeTestClass();          final DiffResult list = firstObject.diff(secondObject);         assertEquals(1, list.getNumberOfDiffs());     }      @Test     public void test_array_difference() {         final TypeTestClass firstObject = new TypeTestClass();         firstObject.charArrayField = new char[] { 'c' };         final TypeTestClass secondObject = new TypeTestClass();          final DiffResult list = firstObject.diff(secondObject);         assertEquals(1, list.getNumberOfDiffs());     }      @Test     public void test_transient_field_difference() {         final TypeTestClass firstObject = new TypeTestClass();         firstObject.transientField = "a";         final TypeTestClass secondObject = new TypeTestClass();         firstObject.transientField = "b";          final DiffResult list = firstObject.diff(secondObject);         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void test_no_differences_inheritance() {         final TypeTestChildClass firstObject = new TypeTestChildClass();         final TypeTestChildClass secondObject = new TypeTestChildClass();          final DiffResult list = firstObject.diff(secondObject);         assertEquals(0, list.getNumberOfDiffs());     }      @Test     public void test_difference_in_inherited_field() {         final TypeTestChildClass firstObject = new TypeTestChildClass();         firstObject.intField = 99;         final TypeTestChildClass secondObject = new TypeTestChildClass();          final DiffResult list = firstObject.diff(secondObject);         assertEquals(1, list.getNumberOfDiffs());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.ArrayList; import java.util.HashMap;  import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.RecursiveToStringStyleTest}.  */ public class RecursiveToStringStyleTest {      private final Integer base = Integer.valueOf(5);     private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));      @BeforeEach     public void setUp() {         ToStringBuilder.setDefaultStyle(new RecursiveToStringStyle());     }      @AfterEach     public void tearDown() {         ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);     }      //----------------------------------------------------------------      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         final ArrayList<Object> emptyList = new ArrayList<>();          assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", emptyList, false).toString());         assertEquals(baseStr + "[a=java.util.ArrayList@" + Integer.toHexString(System.identityHashCode(emptyList)) + "{}]",                 new ToStringBuilder(base).append("a", emptyList, true).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<>(), false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<>(), true).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());     }      @Test     public void testPerson() {         final Person p = new Person();         p.name = "John Doe";         p.age = 33;         p.smoker = false;         p.job = new Job();         p.job.title = "Manager";         final String pBaseStr = p.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p));         final String pJobStr  = p.job.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(p.job));         assertEquals(pBaseStr + "[age=33,job=" + pJobStr + "[title=Manager],name=John Doe,smoker=false]",                      new ReflectionToStringBuilder(p, new RecursiveToStringStyle()).toString());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      static class Person {         /**          * Test String field.          */         String name;          /**          * Test integer field.          */         int age;          /**          * Test boolean field.          */         boolean smoker;          /**          * Test Object field.          */         Job job;     }      static class Job {         /**          * Test String field.          */         String title;     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.builder.ToStringBuilder}.  */ public class ToStringBuilderTest {      // See LANG-1337 for more.     private static final int ARRAYLIST_INITIAL_CAPACITY = 10;     private final Integer base = Integer.valueOf(5);     private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));      /*      * All tests should leave the registry empty.      */     @AfterEach     public void after() {         validateNullToStringStyleRegistry();     }      //-----------------------------------------------------------------------      @Test     public void testConstructorEx1() {         assertEquals("<null>", new ToStringBuilder(null).toString());     }      @Test     public void testConstructorEx2() {         assertEquals("<null>", new ToStringBuilder(null, null).toString());         new ToStringBuilder(this.base, null).toString();     }      @Test     public void testConstructorEx3() {         assertEquals("<null>", new ToStringBuilder(null, null, null).toString());         new ToStringBuilder(this.base, null, null).toString();         new ToStringBuilder(this.base, ToStringStyle.DEFAULT_STYLE, null).toString();     }      @Test     public void testGetSetDefault() {         try {             ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);             assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());         } finally {             // reset for other tests             ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);         }     }      @Test     public void testSetDefaultEx() {         assertThrows(NullPointerException.class, () -> ToStringBuilder.setDefaultStyle(null));     }      @Test     public void testBlank() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());     }      /**      * Test wrapper for int primitive.      */     @Test     public void testReflectionInteger() {         assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));     }      /**      * Test wrapper for char primitive.      */     @Test     public void testReflectionCharacter() {         final Character c = 'A';         assertEquals(this.toBaseString(c) + "[value=A]", ToStringBuilder.reflectionToString(c));     }      /**      * Test wrapper for char boolean.      */     @Test     public void testReflectionBoolean() {         Boolean b;         b = Boolean.TRUE;         assertEquals(this.toBaseString(b) + "[value=true]", ToStringBuilder.reflectionToString(b));         b = Boolean.FALSE;         assertEquals(this.toBaseString(b) + "[value=false]", ToStringBuilder.reflectionToString(b));     }      /**      * Create the same toString() as Object.toString().      * @param o the object to create the string for.      * @return a String in the Object.toString format.      */     private String toBaseString(final Object o) {         return o.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(o));     }      // Reflection Array tests      //     // Note on the following line of code repeated in the reflection array tests.     //     // assertReflectionArray("<null>", array);     //     // The expected value is not baseStr + "[<null>]" since array==null and is typed as Object.     // The null array does not carry array type information.     // If we added a primitive array type constructor and pile of associated methods,     // then type declaring type information could be carried forward. IMHO, null is null.     //     // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com     //      public void assertReflectionArray(final String expected, final Object actual) {         if (actual == null) {             // Until ToStringBuilder supports null objects.             return;         }         assertEquals(expected, ToStringBuilder.reflectionToString(actual));         assertEquals(expected, ToStringBuilder.reflectionToString(actual, null));         assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true));         assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false));     }      @Test     public void testReflectionObjectArray() {         Object[] array = new Object[] { null, base, new int[] { 3, 6 } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{<null>,5,{3,6}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionLongArray() {         long[] array = new long[] { 1, 2, -3, 4 };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionIntArray() {         int[] array = new int[] { 1, 2, -3, 4 };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionShortArray() {         short[] array = new short[] { 1, 2, -3, 4 };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionyteArray() {         byte[] array = new byte[] { 1, 2, -3, 4 };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionCharArray() {         char[] array = new char[] { 'A', '2', '_', 'D' };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{A,2,_,D}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionDoubleArray() {         double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionFloatArray() {         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionBooleanArray() {         boolean[] array = new boolean[] { true, false, false };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{true,false,false}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      // Reflection Array Array tests      @Test     public void testReflectionFloatArrayArray() {         float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }       @Test     public void testReflectionLongArrayArray() {         long[][] array = new long[][] { { 1, 2 }, null, { 5 } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionIntArrayArray() {         int[][] array = new int[][] { { 1, 2 }, null, { 5 } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionhortArrayArray() {         short[][] array = new short[][] { { 1, 2 }, null, { 5 } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionByteArrayArray() {         byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionCharArrayArray() {         char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{A,B},<null>,{p}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionDoubleArrayArray() {         double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      @Test     public void testReflectionBooleanArrayArray() {         boolean[][] array = new boolean[][] { { true, false }, null, { false } };         final String baseString = this.toBaseString(array);         assertEquals(baseString + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));         assertEquals(baseString + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));         array = null;         assertReflectionArray("<null>", array);     }      // Reflection hierarchy tests     @Test     public void testReflectionHierarchyArrayList() {         // LANG-1337 without this, the generated string can differ depending on the JVM version/vendor         final List<Object> list = new ArrayList<>(ARRAYLIST_INITIAL_CAPACITY);         final String baseString = this.toBaseString(list);         final String expectedWithTransients = baseString + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]";         final String toStringWithTransients = ToStringBuilder.reflectionToString(list, null, true);         if (!expectedWithTransients.equals(toStringWithTransients)) {             assertEquals(expectedWithTransients, toStringWithTransients);         }         final String expectedWithoutTransients = baseString + "[size=0]";         final String toStringWithoutTransients = ToStringBuilder.reflectionToString(list, null, false);         if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {             assertEquals(expectedWithoutTransients, toStringWithoutTransients);         }     }      @Test     public void testReflectionHierarchy() {         final ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();         String baseString = this.toBaseString(baseA);         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA));         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA, null));         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false));         assertEquals(baseString + "[a=a,transientA=t]", ToStringBuilder.reflectionToString(baseA, null, true));         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, null));         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));         assertEquals(baseString + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));          final ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();         baseString = this.toBaseString(baseB);         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false));         assertEquals(baseString + "[b=b,transientB=t,a=a,transientA=t]", ToStringBuilder.reflectionToString(baseB, null, true));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, null));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));         assertEquals(baseString + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));         assertEquals(baseString + "[b=b]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));     }      static class ReflectionTestFixtureA {         @SuppressWarnings("unused")         private final char a='a';         @SuppressWarnings("unused")         private transient char transientA='t';     }      static class ReflectionTestFixtureB extends ReflectionTestFixtureA {         @SuppressWarnings("unused")         private final char b='b';         @SuppressWarnings("unused")         private transient char transientB='t';     }      @Test     public void testInnerClassReflection() {         final Outer outer = new Outer();         assertEquals(toBaseString(outer) + "[inner=" + toBaseString(outer.inner) + "[]]", outer.toString());     }      static class Outer {         Inner inner = new Inner();         class Inner {             @Override             public String toString() {                 return ToStringBuilder.reflectionToString(this);             }         }         @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      // Reflection cycle tests      /**      * Test an array element pointing to its container.      */     @Test     public void testReflectionArrayCycle() {         final Object[] objects = new Object[1];         objects[0] = objects;         assertEquals(             this.toBaseString(objects) + "[{" + this.toBaseString(objects) + "}]",             ToStringBuilder.reflectionToString(objects));     }      /**      * Test an array element pointing to its container.      */     @Test     public void testReflectionArrayCycleLevel2() {         final Object[] objects = new Object[1];         final Object[] objectsLevel2 = new Object[1];         objects[0] = objectsLevel2;         objectsLevel2[0] = objects;         assertEquals(             this.toBaseString(objects) + "[{{" + this.toBaseString(objects) + "}}]",             ToStringBuilder.reflectionToString(objects));         assertEquals(             this.toBaseString(objectsLevel2) + "[{{" + this.toBaseString(objectsLevel2) + "}}]",             ToStringBuilder.reflectionToString(objectsLevel2));     }      @Test     public void testReflectionArrayArrayCycle() {         final Object[][] objects = new Object[2][2];         objects[0][0] = objects;         objects[0][1] = objects;         objects[1][0] = objects;         objects[1][1] = objects;         final String basicToString = this.toBaseString(objects);         assertEquals(             basicToString                 + "[{{"                 + basicToString                 + ","                 + basicToString                 + "},{"                 + basicToString                 + ","                 + basicToString                 + "}}]",             ToStringBuilder.reflectionToString(objects));     }      /**      * A reflection test fixture.      */     static class ReflectionTestCycleA {         ReflectionTestCycleB b;          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      /**      * A reflection test fixture.      */     static class ReflectionTestCycleB {         ReflectionTestCycleA a;          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      /**      * A reflection test fixture.      */     static class SimpleReflectionTestFixture {         Object o;          SimpleReflectionTestFixture() {         }          SimpleReflectionTestFixture(final Object o) {             this.o = o;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      private static class SelfInstanceVarReflectionTestFixture {         @SuppressWarnings("unused")         private final SelfInstanceVarReflectionTestFixture typeIsSelf;          SelfInstanceVarReflectionTestFixture() {             this.typeIsSelf = this;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }       }      private static class SelfInstanceTwoVarsReflectionTestFixture {         @SuppressWarnings("unused")         private final SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;         private final String otherType = "The Other Type";          SelfInstanceTwoVarsReflectionTestFixture() {             this.typeIsSelf = this;         }          public String getOtherType() {             return this.otherType;         }          @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }       }       /**      * Test an Object pointing to itself, the simplest test.      */     @Test     public void testSimpleReflectionObjectCycle() {         final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();         simple.o = simple;         assertEquals(this.toBaseString(simple) + "[o=" + this.toBaseString(simple) + "]", simple.toString());     }      /**      * Test a class that defines an ivar pointing to itself.      */     @Test     public void testSelfInstanceVarReflectionObjectCycle() {         final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();         assertEquals(this.toBaseString(test) + "[typeIsSelf=" + this.toBaseString(test) + "]", test.toString());     }      /**      * Test a class that defines an ivar pointing to itself.  This test was      * created to show that handling cyclical object resulted in a missing endFieldSeparator call.      */     @Test     public void testSelfInstanceTwoVarsReflectionObjectCycle() {         final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();         assertEquals(this.toBaseString(test) + "[otherType=" + test.getOtherType().toString() + ",typeIsSelf=" + this.toBaseString(test)  + "]", test.toString());     }       /**      * Test Objects pointing to each other.      */     @Test     public void testReflectionObjectCycle() {         final ReflectionTestCycleA a = new ReflectionTestCycleA();         final ReflectionTestCycleB b = new ReflectionTestCycleB();         a.b = b;         b.a = a;         assertEquals(             this.toBaseString(a) + "[b=" + this.toBaseString(b) + "[a=" + this.toBaseString(a) + "]]",             a.toString());     }      /**      * Test a nasty combination of arrays and Objects pointing to each other.      * objects[0] -&gt; SimpleReflectionTestFixture[ o -&gt; objects ]      */     @Test     public void testReflectionArrayAndObjectCycle() {         final Object[] objects = new Object[1];         final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);         objects[0] = simple;         assertEquals(             this.toBaseString(objects)                 + "[{"                 + this.toBaseString(simple)                 + "[o="                 + this.toBaseString(objects)                 + "]"                 + "}]",             ToStringBuilder.reflectionToString(objects));         assertEquals(             this.toBaseString(simple)                 + "[o={"                 + this.toBaseString(simple)                 + "}]",             ToStringBuilder.reflectionToString(simple));     }      void validateNullToStringStyleRegistry() {         final Map<Object, Object> registry = ToStringStyle.getRegistry();         assertNull(registry, "Expected null, actual: " + registry);     }     //  End: Reflection cycle tests      @Test     public void testAppendSuper() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());     }      @Test     public void testAppendToString() {         assertEquals(baseStr + "[]", new ToStringBuilder(base).appendToString("Integer@8888[]").toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").toString());          assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[]").append("a", "hello").toString());         assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").append("a", "hello").toString());         assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString(null).append("a", "hello").toString());     }      @Test     public void testAppendAsObjectToString() {         final String objectToAppend1 = "";         final Boolean objectToAppend2 = Boolean.TRUE;         final Object objectToAppend3 = new Object();          assertEquals(baseStr + "[" + toBaseString(objectToAppend1) + "]",                 new ToStringBuilder(base).appendAsObjectToString(objectToAppend1).toString());         assertEquals(baseStr + "[" + toBaseString(objectToAppend2) + "]",                 new ToStringBuilder(base).appendAsObjectToString(objectToAppend2).toString());         assertEquals(baseStr + "[" + toBaseString(objectToAppend3) + "]",                 new ToStringBuilder(base).appendAsObjectToString(objectToAppend3).toString());     }      @Test     public void testAppendBooleanArrayWithFieldName() {         final boolean[] array = new boolean[] { true, false, false };         assertEquals(baseStr + "[flags={true,false,false}]",                 new ToStringBuilder(base).append("flags", array).toString());         assertEquals(baseStr + "[flags=<null>]",                 new ToStringBuilder(base).append("flags", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendBooleanArrayWithFieldNameAndFullDetatil() {         final boolean[] array = new boolean[] { true, false, false };         assertEquals(baseStr + "[flags={true,false,false}]",                 new ToStringBuilder(base).append("flags", array, true).toString());         assertEquals(baseStr + "[length=<size=3>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[flags=<null>]",                 new ToStringBuilder(base).append("flags", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=3>]", new ToStringBuilder(base).append(null, array, false).toString());      }      @Test     public void testAppendCharArrayWithFieldName() {         final char[] array = new char[] { 'A', '2', '_', 'D' };         assertEquals(baseStr + "[chars={A,2,_,D}]", new ToStringBuilder(base).append("chars", array).toString());         assertEquals(baseStr + "[letters={A,2,_,D}]", new ToStringBuilder(base).append("letters", array).toString());         assertEquals(baseStr + "[flags=<null>]",                 new ToStringBuilder(base).append("flags", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendCharArrayWithFieldNameAndFullDetatil() {         final char[] array = new char[] { 'A', '2', '_', 'D' };         assertEquals(baseStr + "[chars={A,2,_,D}]", new ToStringBuilder(base).append("chars", array, true).toString());         assertEquals(baseStr + "[letters=<size=4>]",                 new ToStringBuilder(base).append("letters", array, false).toString());         assertEquals(baseStr + "[flags=<null>]",                 new ToStringBuilder(base).append("flags", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendDoubleArrayWithFieldName() {         final double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };         assertEquals(baseStr + "[values={1.0,2.9876,-3.00001,4.3}]",                 new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendDoubleArrayWithFieldNameAndFullDetatil() {         final double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };         assertEquals(baseStr + "[values={1.0,2.9876,-3.00001,4.3}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendObjectArrayWithFieldName() {         final Object[] array = new Object[] { null, base, new int[] { 3, 6 } };         assertEquals(baseStr + "[values={<null>,5,{3,6}}]",                 new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendObjectArrayWithFieldNameAndFullDetatil() {        final Object[] array = new Object[] { null, base, new int[] { 3, 6 } };        assertEquals(baseStr + "[values={<null>,5,{3,6}}]",                new ToStringBuilder(base).append("values", array, true).toString());        assertEquals(baseStr + "[length=<size=3>]",                new ToStringBuilder(base).append("length", array, false).toString());        assertEquals(baseStr + "[values=<null>]",                new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());        assertEquals(baseStr + "[<size=3>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendLongArrayWithFieldName() {        final long[] array = new long[] { 1, 2, -3, 4 };        assertEquals(baseStr + "[values={1,2,-3,4}]", new ToStringBuilder(base).append("values", array).toString());        assertEquals(baseStr + "[values=<null>]",                new ToStringBuilder(base).append("values", (boolean[]) null).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendLongArrayWithFieldNameAndFullDetatil() {         final long[] array = new long[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendIntArrayWithFieldName() {         final int[] array = new int[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]", new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendIntArrayWithFieldNameAndFullDetatil() {         final int[] array = new int[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendShortArrayWithFieldName() {         final short[] array = new short[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]", new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendShortArrayWithFieldNameAndFullDetatil() {         final short[] array = new short[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendByteArrayWithFieldName() {         final byte[] array = new byte[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]", new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendByteArrayWithFieldNameAndFullDetatil() {         final byte[] array = new byte[] { 1, 2, -3, 4 };         assertEquals(baseStr + "[values={1,2,-3,4}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testAppendFloatArrayWithFieldName() {         final float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };         assertEquals(baseStr + "[values={1.0,2.9876,-3.00001,4.3}]",                 new ToStringBuilder(base).append("values", array).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null).toString());         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(null, array).toString());     }      @Test     public void testAppendFloatArrayWithFieldNameAndFullDetatil() {         final float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };         assertEquals(baseStr + "[values={1.0,2.9876,-3.00001,4.3}]",                 new ToStringBuilder(base).append("values", array, true).toString());         assertEquals(baseStr + "[length=<size=4>]",                 new ToStringBuilder(base).append("length", array, false).toString());         assertEquals(baseStr + "[values=<null>]",                 new ToStringBuilder(base).append("values", (boolean[]) null, true).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(null, (boolean[]) null, false).toString());         assertEquals(baseStr + "[<size=4>]", new ToStringBuilder(base).append(null, array, false).toString());     }      @Test     public void testConstructToStringBuilder() {         final ToStringBuilder stringBuilder1 = new ToStringBuilder(base, null, null);         final ToStringBuilder stringBuilder2 = new ToStringBuilder(base, ToStringStyle.DEFAULT_STYLE, new StringBuffer(1024));         assertEquals(ToStringStyle.DEFAULT_STYLE, stringBuilder1.getStyle());         assertNotNull(stringBuilder1.getStringBuffer());         assertNotNull(stringBuilder1.toString());         assertEquals(ToStringStyle.DEFAULT_STYLE, stringBuilder2.getStyle());         assertNotNull(stringBuilder2.getStringBuffer());         assertNotNull(stringBuilder2.toString());     }       @Test     public void testObject() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<>(), false).toString());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<>(), true).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<>(), false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<>(), true).toString());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());     }      @Test     public void testObjectBuild() {         final Integer i3 = Integer.valueOf(3);         final Integer i4 = Integer.valueOf(4);         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).build());         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).build());         assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).build());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).build());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).build());         assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).build());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<>(), false).build());         assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<>(), true).build());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<>(), false).build());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<>(), true).build());         assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).build());         assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).build());     }      @Test     public void testLong() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());     }      @SuppressWarnings("cast") // cast is not really needed, keep for consistency     @Test     public void testInt() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3).append("b", 4).toString());     }      @Test     public void testShort() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString());     }      @Test     public void testChar() {         assertEquals(baseStr + "[A]", new ToStringBuilder(base).append((char) 65).toString());         assertEquals(baseStr + "[a=A]", new ToStringBuilder(base).append("a", (char) 65).toString());         assertEquals(baseStr + "[a=A,b=B]", new ToStringBuilder(base).append("a", (char) 65).append("b", (char) 66).toString());     }      @Test     public void testByte() {         assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString());         assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString());         assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString());     }      @SuppressWarnings("cast")     @Test     public void testDouble() {         assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append(3.2).toString());         assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", 3.2).toString());         assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", 3.2).append("b", 4.3).toString());     }      @Test     public void testFloat() {         assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString());         assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString());         assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString());     }      @Test     public void testBoolean() {         assertEquals(baseStr + "[true]", new ToStringBuilder(base).append(true).toString());         assertEquals(baseStr + "[a=true]", new ToStringBuilder(base).append("a", true).toString());         assertEquals(baseStr + "[a=true,b=false]", new ToStringBuilder(base).append("a", true).append("b", false).toString());     }       @Test     public void testObjectArray() {         Object[] array = new Object[] {null, base, new int[] {3, 6}};         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArray() {         long[] array = new long[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testIntArray() {         int[] array = new int[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testShortArray() {         short[] array = new short[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testByteArray() {         byte[] array = new byte[] {1, 2, -3, 4};         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testCharArray() {         char[] array = new char[] {'A', '2', '_', 'D'};         assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testDoubleArray() {         double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testFloatArray() {         float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testBooleanArray() {         boolean[] array = new boolean[] {true, false, false};         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testLongArrayArray() {         long[][] array = new long[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testIntArrayArray() {         int[][] array = new int[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testShortArrayArray() {         short[][] array = new short[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testByteArrayArray() {         byte[][] array = new byte[][] {{1, 2}, null, {5}};         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testCharArrayArray() {         char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};         assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testDoubleArrayArray() {         double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testFloatArrayArray() {         float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testBooleanArrayArray() {         boolean[][] array = new boolean[][] {{true, false}, null, {false}};         assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append((Object) array).toString());         array = null;         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());         assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());     }      @Test     public void testObjectCycle() {         final ObjectCycle a = new ObjectCycle();         final ObjectCycle b = new ObjectCycle();         a.obj = b;         b.obj = a;          final String expected = toBaseString(a) + "[" + toBaseString(b) + "[" + toBaseString(a) + "]]";         assertEquals(expected, a.toString());     }      static class ObjectCycle {         Object obj;          @Override         public String toString() {             return new ToStringBuilder(this).append(obj).toString();         }     }      @Test     public void testSimpleReflectionStatics() {         final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();         assertEquals(             this.toBaseString(instance1) + "[staticInt=12345,staticString=staticString]",             ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt=12345,staticString=staticString]",             ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));     }      /**      * Tests ReflectionToStringBuilder.toString() for statics.      */     @Test     public void testReflectionStatics() {         final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();         assertEquals(             this.toBaseString(instance1) + "[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]",             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString,staticTransientInt=54321,staticTransientString=staticTransientString,transientInt=98765,transientString=transientString]",             ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));     }      /**      * Tests ReflectionToStringBuilder.toString() for statics.      */     @Test     public void testInheritedReflectionStatics() {         final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();         assertEquals(             this.toBaseString(instance1) + "[staticInt2=67890,staticString2=staticString2]",             ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]",             ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));         assertEquals(             this.toBaseString(instance1) + "[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]",             this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));     }      /**      * <p>This method uses reflection to build a suitable      * {@code toString} value which includes static fields.</p>      *      * <p>It uses {@code AccessibleObject.setAccessible} to gain access to private      * fields. This means that it will throw a security exception if run      * under a security manager, if the permissions are not set up correctly.      * It is also not as efficient as testing explicitly. </p>      *      * <p>Transient fields are not output.</p>      *      * <p>Superclass fields will be appended up to and including the specified superclass.      * A null superclass is treated as {@code java.lang.Object}.</p>      *      * <p>If the style is {@code null}, the default      * {@code ToStringStyle} is used.</p>      *      * @param <T> the type of the output object      * @param object  the Object to be output      * @param style  the style of the {@code toString} to create,      *  may be {@code null}      * @param reflectUpToClass  the superclass to reflect up to (inclusive),      *  may be {@code null}      * @return the String result      * @throws IllegalArgumentException if the Object is {@code null}      */     public <T> String toStringWithStatics(final T object, final ToStringStyle style, final Class<? super T> reflectUpToClass) {         return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass);     }      /**      * Tests ReflectionToStringBuilder setUpToClass().      */     @Test     public void test_setUpToClass_valid() {         final Integer val = Integer.valueOf(5);         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);         test.setUpToClass(Number.class);         test.toString();     }      /**      * Tests ReflectionToStringBuilder setUpToClass().      */     @Test     public void test_setUpToClass_invalid() {         final Integer val = Integer.valueOf(5);         final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);         assertThrows(IllegalArgumentException.class, () -> test.setUpToClass(String.class));         test.toString();     }      /**      * Tests ReflectionToStringBuilder.toString() for statics.      */     class ReflectionStaticFieldsFixture {         static final String staticString = "staticString";         static final int staticInt = 12345;         static final transient String staticTransientString = "staticTransientString";         static final transient int staticTransientInt = 54321;         String instanceString = "instanceString";         int instanceInt = 67890;         transient String transientString = "transientString";         transient int transientInt = 98765;     }      /**      * Test fixture for ReflectionToStringBuilder.toString() for statics.      */     class SimpleReflectionStaticFieldsFixture {         static final String staticString = "staticString";         static final int staticInt = 12345;     }      /**      * Test fixture for ReflectionToStringBuilder.toString() for statics.      */     @SuppressWarnings("unused")     class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture {         static final String staticString2 = "staticString2";         static final int staticInt2 = 67890;     }      @Test     public void testReflectionNull() {         assertThrows(NullPointerException.class, () -> ReflectionToStringBuilder.toString(null));     }      /**      * Points out failure to print anything from appendToString methods using MULTI_LINE_STYLE.      * See issue LANG-372.      */     class MultiLineTestObject {         Integer i = Integer.valueOf(31337);         @Override         public String toString() {             return new ToStringBuilder(this).append("testInt", i).toString();         }     }      @Test     public void testAppendToStringUsingMultiLineStyle() {         final MultiLineTestObject obj = new MultiLineTestObject();         final ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)                                           .appendToString(obj.toString());         assertEquals(-1, testBuilder.toString().indexOf("testInt=31337"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.builder;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Method;  import org.apache.commons.lang3.reflect.MethodUtils; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.builder.EqualsBuilder}.  */ public class EqualsBuilderTest {      //-----------------------------------------------------------------------      static class TestObject {         private int a;          TestObject() {         }          TestObject(final int a) {             this.a = a;         }          @Override         public boolean equals(final Object o) {             if (o == null) {                 return false;             }             if (o == this) {                 return true;             }             if (o.getClass() != getClass()) {                 return false;             }              final TestObject rhs = (TestObject) o;             return a == rhs.a;         }          @Override         public int hashCode() {             return a;         }          public void setA(final int a) {             this.a = a;         }          public int getA() {             return a;         }     }      static class TestSubObject extends TestObject {         private int b;          TestSubObject() {             super(0);         }          TestSubObject(final int a, final int b) {             super(a);             this.b = b;         }          @Override         public boolean equals(final Object o) {             if (o == null) {                 return false;             }             if (o == this) {                 return true;             }             if (o.getClass() != getClass()) {                 return false;             }              final TestSubObject rhs = (TestSubObject) o;             return super.equals(o) && b == rhs.b;         }          @Override         public int hashCode() {             return b * 17 + super.hashCode();         }          public void setB(final int b) {             this.b = b;         }          public int getB() {             return b;         }     }      static class TestEmptySubObject extends TestObject {         TestEmptySubObject(final int a) {             super(a);         }     }      static class TestTSubObject extends TestObject {         @SuppressWarnings("unused")         private transient int t;          TestTSubObject(final int a, final int t) {             super(a);             this.t = t;         }     }      static class TestTTSubObject extends TestTSubObject {         @SuppressWarnings("unused")         private transient int tt;          TestTTSubObject(final int a, final int t, final int tt) {             super(a, t);             this.tt = tt;         }     }      static class TestTTLeafObject extends TestTTSubObject {         @SuppressWarnings("unused")         private final int leafValue;          TestTTLeafObject(final int a, final int t, final int tt, final int leafValue) {             super(a, t, tt);             this.leafValue = leafValue;         }     }      static class TestTSubObject2 extends TestObject {         private transient int t;          TestTSubObject2(final int a, final int t) {             super(a);         }          public int getT() {             return t;         }          public void setT(final int t) {             this.t = t;         }     }      static class TestRecursiveGenericObject<T> {          private final T a;          TestRecursiveGenericObject(final T a) {             this.a = a;         }          public T getA() {             return a;         }     }      static class TestRecursiveObject {         private final TestRecursiveInnerObject a;         private final TestRecursiveInnerObject b;         private int z;          TestRecursiveObject(final TestRecursiveInnerObject a,                             final TestRecursiveInnerObject b, final int z) {             this.a = a;             this.b = b;         }          public TestRecursiveInnerObject getA() {             return a;         }          public TestRecursiveInnerObject getB() {             return b;         }          public int getZ() {             return z;         }      }      static class TestRecursiveInnerObject {         private final int n;          TestRecursiveInnerObject(final int n) {             this.n = n;         }          public int getN() {             return n;         }     }      static class TestRecursiveCycleObject {         private TestRecursiveCycleObject cycle;         private final int n;          TestRecursiveCycleObject(final int n) {             this.n = n;             this.cycle = this;         }          TestRecursiveCycleObject(final TestRecursiveCycleObject cycle, final int n) {             this.n = n;             this.cycle = cycle;         }          public int getN() {             return n;         }          public TestRecursiveCycleObject getCycle() {             return cycle;         }          public void setCycle(final TestRecursiveCycleObject cycle) {             this.cycle = cycle;         }     }      @Test     public void testReflectionEquals() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertTrue(EqualsBuilder.reflectionEquals(o1, o1));         assertFalse(EqualsBuilder.reflectionEquals(o1, o2));         o2.setA(4);         assertTrue(EqualsBuilder.reflectionEquals(o1, o2));          assertFalse(EqualsBuilder.reflectionEquals(o1, this));          assertFalse(EqualsBuilder.reflectionEquals(o1, null));         assertFalse(EqualsBuilder.reflectionEquals(null, o2));         assertTrue(EqualsBuilder.reflectionEquals(null, null));     }      @Test     public void testReflectionHierarchyEquals() {         testReflectionHierarchyEquals(false);         testReflectionHierarchyEquals(true);         // Transients         assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));         assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));         assertFalse(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));         assertFalse(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));         assertFalse(EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));     }      private void testReflectionHierarchyEquals(final boolean testTransients) {         final TestObject to1 = new TestObject(4);         final TestObject to1Bis = new TestObject(4);         final TestObject to1Ter = new TestObject(4);         final TestObject to2 = new TestObject(5);         final TestEmptySubObject teso = new TestEmptySubObject(4);         final TestTSubObject ttso = new TestTSubObject(4, 1);         final TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);         final TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);         final TestSubObject tso1 = new TestSubObject(1, 4);         final TestSubObject tso1bis = new TestSubObject(1, 4);         final TestSubObject tso1ter = new TestSubObject(1, 4);         final TestSubObject tso2 = new TestSubObject(2, 5);          testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);         testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);          // More sanity checks:          // same values         assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));         // same super values, diff sub values         assertFalse(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));         assertFalse(EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));         // diff super values, same sub values         assertFalse(EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));         assertFalse(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));          // mix super and sub types: equals         assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));          assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert          assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert          assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert          // mix super and sub types: NOT equals         assertFalse(EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));         assertFalse(EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));          assertFalse(EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));         assertFalse(EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));          assertFalse(EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));         assertFalse(EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));          assertFalse(EqualsBuilder.reflectionEquals(to1, ttlo));         assertFalse(EqualsBuilder.reflectionEquals(tso1, this));     }      /**      * Equivalence relationship tests inspired by "Effective Java":      * <ul>      * <li>reflection</li>      * <li>symmetry</li>      * <li>transitive</li>      * <li>consistency</li>      * <li>non-null reference</li>      * </ul>      *      * @param to             a TestObject      * @param toBis          a TestObject, equal to to and toTer      * @param toTer          Left hand side, equal to to and toBis      * @param to2            a different TestObject      * @param oToChange      a TestObject that will be changed      * @param testTransients whether to test transient instance variables      */     private void testReflectionEqualsEquivalenceRelationship(             final TestObject to,             final TestObject toBis,             final TestObject toTer,             final TestObject to2,             final TestObject oToChange,             final boolean testTransients) {          // reflection test         assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));          // symmetry test         assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));          // transitive test         assertTrue(                 EqualsBuilder.reflectionEquals(to, toBis, testTransients)                         && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)                         && EqualsBuilder.reflectionEquals(to, toTer, testTransients));          // consistency test         oToChange.setA(to.getA());         if (oToChange instanceof TestSubObject) {             ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());         }         assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         oToChange.setA(to.getA() + 1);         if (oToChange instanceof TestSubObject) {             ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);         }         assertFalse(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         assertFalse(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));          // non-null reference test         assertFalse(EqualsBuilder.reflectionEquals(to, null, testTransients));         assertFalse(EqualsBuilder.reflectionEquals(to2, null, testTransients));         assertFalse(EqualsBuilder.reflectionEquals(null, to, testTransients));         assertFalse(EqualsBuilder.reflectionEquals(null, to2, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(null, null, testTransients));     }      @Test     public void testSuper() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertTrue(new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());         assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());     }      @Test     public void testObject() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());         o2.setA(4);         assertTrue(new EqualsBuilder().append(o1, o2).isEquals());          assertFalse(new EqualsBuilder().append(o1, this).isEquals());          assertFalse(new EqualsBuilder().append(o1, null).isEquals());         assertFalse(new EqualsBuilder().append(null, o2).isEquals());         assertTrue(new EqualsBuilder().append((Object) null, null).isEquals());     }      @Test     public void testObjectBuild() {         final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertEquals(Boolean.TRUE, new EqualsBuilder().append(o1, o1).build());         assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, o2).build());         o2.setA(4);         assertEquals(Boolean.TRUE, new EqualsBuilder().append(o1, o2).build());          assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, this).build());          assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, null).build());         assertEquals(Boolean.FALSE, new EqualsBuilder().append(null, o2).build());         assertEquals(Boolean.TRUE, new EqualsBuilder().append((Object) null, null).build());     }      @Test     public void testObjectRecursiveGenericInteger() {         final TestRecursiveGenericObject<Integer> o1_a = new TestRecursiveGenericObject<>(1);         final TestRecursiveGenericObject<Integer> o1_b = new TestRecursiveGenericObject<>(1);         final TestRecursiveGenericObject<Integer> o2 = new TestRecursiveGenericObject<>(2);          assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_b).isEquals());         assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_b, o1_a).isEquals());          assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_b, o2).isEquals());     }      @Test     public void testObjectRecursiveGenericString() {         // Note: Do not use literals, because string literals are always mapped by same object (internal() of String))!         final String s1_a = String.valueOf(1);         final TestRecursiveGenericObject<String> o1_a = new TestRecursiveGenericObject<>(s1_a);         final TestRecursiveGenericObject<String> o1_b = new TestRecursiveGenericObject<>(String.valueOf(1));         final TestRecursiveGenericObject<String> o2 = new TestRecursiveGenericObject<>(String.valueOf(2));          // To trigger bug reported in LANG-1356, call hashCode only on string in instance o1_a         s1_a.hashCode();          assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_b).isEquals());         assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_b, o1_a).isEquals());          assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_b, o2).isEquals());     }      @Test     public void testObjectRecursive() {         final TestRecursiveInnerObject i1_1 = new TestRecursiveInnerObject(1);         final TestRecursiveInnerObject i1_2 = new TestRecursiveInnerObject(1);         final TestRecursiveInnerObject i2_1 = new TestRecursiveInnerObject(2);         final TestRecursiveInnerObject i2_2 = new TestRecursiveInnerObject(2);         final TestRecursiveInnerObject i3 = new TestRecursiveInnerObject(3);         final TestRecursiveInnerObject i4 = new TestRecursiveInnerObject(4);          final TestRecursiveObject o1_a = new TestRecursiveObject(i1_1, i2_1, 1);         final TestRecursiveObject o1_b = new TestRecursiveObject(i1_2, i2_2, 1);         final TestRecursiveObject o2 = new TestRecursiveObject(i3, i4, 2);         final TestRecursiveObject oNull = new TestRecursiveObject(null, null, 2);          assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_a).isEquals());         assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_b).isEquals());          assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_a, o2).isEquals());          assertTrue(new EqualsBuilder().setTestRecursive(true).append(oNull, oNull).isEquals());         assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_a, oNull).isEquals());     }      @Test     public void testObjectRecursiveCycleSelfreference() {         final TestRecursiveCycleObject o1_a = new TestRecursiveCycleObject(1);         final TestRecursiveCycleObject o1_b = new TestRecursiveCycleObject(1);         final TestRecursiveCycleObject o2 = new TestRecursiveCycleObject(2);          assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_a).isEquals());         assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_b).isEquals());         assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_a, o2).isEquals());     }      @Test     public void testObjectRecursiveCycle() {         final TestRecursiveCycleObject o1_a = new TestRecursiveCycleObject(1);         final TestRecursiveCycleObject i1_a = new TestRecursiveCycleObject(o1_a, 100);         o1_a.setCycle(i1_a);          final TestRecursiveCycleObject o1_b = new TestRecursiveCycleObject(1);         final TestRecursiveCycleObject i1_b = new TestRecursiveCycleObject(o1_b, 100);         o1_b.setCycle(i1_b);          final TestRecursiveCycleObject o2 = new TestRecursiveCycleObject(2);         final TestRecursiveCycleObject i2 = new TestRecursiveCycleObject(o1_b, 200);         o2.setCycle(i2);          assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_a).isEquals());         assertTrue(new EqualsBuilder().setTestRecursive(true).append(o1_a, o1_b).isEquals());         assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_a, o2).isEquals());          assertTrue(EqualsBuilder.reflectionEquals(o1_a, o1_b, false, null, true));         assertFalse(EqualsBuilder.reflectionEquals(o1_a, o2, false, null, true));     }      @Test     public void testLong() {         final long o1 = 1L;         final long o2 = 2L;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testInt() {         final int o1 = 1;         final int o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testShort() {         final short o1 = 1;         final short o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testChar() {         final char o1 = 1;         final char o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testByte() {         final byte o1 = 1;         final byte o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testDouble() {         final double o1 = 1;         final double o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());         assertFalse(new EqualsBuilder().append(o1, Double.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());     }      @Test     public void testFloat() {         final float o1 = 1;         final float o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());         assertFalse(new EqualsBuilder().append(o1, Float.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());     }      @Test     public void testAccessors() {         final EqualsBuilder equalsBuilder = new EqualsBuilder();         assertTrue(equalsBuilder.isEquals());         equalsBuilder.setEquals(true);         assertTrue(equalsBuilder.isEquals());         equalsBuilder.setEquals(false);         assertFalse(equalsBuilder.isEquals());     }      @Test     public void testReset() {         final EqualsBuilder equalsBuilder = new EqualsBuilder();         assertTrue(equalsBuilder.isEquals());         equalsBuilder.setEquals(false);         assertFalse(equalsBuilder.isEquals());         equalsBuilder.reset();         assertTrue(equalsBuilder.isEquals());     }      @Test     public void testBoolean() {         final boolean o1 = true;         final boolean o2 = false;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertFalse(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test     public void testObjectArray() {         TestObject[] obj1 = new TestObject[3];         obj1[0] = new TestObject(4);         obj1[1] = new TestObject(5);         obj1[2] = null;         TestObject[] obj2 = new TestObject[3];         obj2[0] = new TestObject(4);         obj2[1] = new TestObject(5);         obj2[2] = null;          assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1].setA(6);         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1].setA(5);         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[2] = obj1[1];         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[2] = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testLongArray() {         long[] obj1 = new long[2];         obj1[0] = 5L;         obj1[1] = 6L;         long[] obj2 = new long[2];         obj2[0] = 5L;         obj2[1] = 6L;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testIntArray() {         int[] obj1 = new int[2];         obj1[0] = 5;         obj1[1] = 6;         int[] obj2 = new int[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testShortArray() {         short[] obj1 = new short[2];         obj1[0] = 5;         obj1[1] = 6;         short[] obj2 = new short[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testCharArray() {         char[] obj1 = new char[2];         obj1[0] = 5;         obj1[1] = 6;         char[] obj2 = new char[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testByteArray() {         byte[] obj1 = new byte[2];         obj1[0] = 5;         obj1[1] = 6;         byte[] obj2 = new byte[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testDoubleArray() {         double[] obj1 = new double[2];         obj1[0] = 5;         obj1[1] = 6;         double[] obj2 = new double[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testFloatArray() {         float[] obj1 = new float[2];         obj1[0] = 5;         obj1[1] = 6;         float[] obj2 = new float[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testBooleanArray() {         boolean[] obj1 = new boolean[2];         obj1[0] = true;         obj1[1] = false;         boolean[] obj2 = new boolean[2];         obj2[0] = true;         obj2[1] = false;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = true;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testMultiLongArray() {         final long[][] array1 = new long[2][2];         final long[][] array2 = new long[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiIntArray() {         final int[][] array1 = new int[2][2];         final int[][] array2 = new int[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiShortArray() {         final short[][] array1 = new short[2][2];         final short[][] array2 = new short[2][2];         for (short i = 0; i < array1.length; ++i) {             for (short j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiCharArray() {         final char[][] array1 = new char[2][2];         final char[][] array2 = new char[2][2];         for (char i = 0; i < array1.length; ++i) {             for (char j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiByteArray() {         final byte[][] array1 = new byte[2][2];         final byte[][] array2 = new byte[2][2];         for (byte i = 0; i < array1.length; ++i) {             for (byte j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiFloatArray() {         final float[][] array1 = new float[2][2];         final float[][] array2 = new float[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiDoubleArray() {         final double[][] array1 = new double[2][2];         final double[][] array2 = new double[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMultiBooleanArray() {         final boolean[][] array1 = new boolean[2][2];         final boolean[][] array2 = new boolean[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = i == 1 || j == 1;                 array2[i][j] = i == 1 || j == 1;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = false;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());          // compare 1 dim to 2.         final boolean[] array3 = new boolean[]{true, true};         assertFalse(new EqualsBuilder().append(array1, array3).isEquals());         assertFalse(new EqualsBuilder().append(array3, array1).isEquals());         assertFalse(new EqualsBuilder().append(array2, array3).isEquals());         assertFalse(new EqualsBuilder().append(array3, array2).isEquals());     }      @Test     public void testRaggedArray() {         final long[][] array1 = new long[2][];         final long[][] array2 = new long[2][];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             for (int j = 0; j < array1[i].length; ++j) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testMixedArray() {         final Object[] array1 = new Object[2];         final Object[] array2 = new Object[2];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             for (int j = 0; j < 2; ++j) {                 ((long[]) array1[i])[j] = (i + 1) * (j + 1);                 ((long[]) array2[i])[j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         ((long[]) array1[1])[1] = 0;         assertFalse(new EqualsBuilder().append(array1, array2).isEquals());     }      @Test     public void testObjectArrayHiddenByObject() {         final TestObject[] array1 = new TestObject[2];         array1[0] = new TestObject(4);         array1[1] = new TestObject(5);         final TestObject[] array2 = new TestObject[2];         array2[0] = new TestObject(4);         array2[1] = new TestObject(5);         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1].setA(6);         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testLongArrayHiddenByObject() {         final long[] array1 = new long[2];         array1[0] = 5L;         array1[1] = 6L;         final long[] array2 = new long[2];         array2[0] = 5L;         array2[1] = 6L;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testIntArrayHiddenByObject() {         final int[] array1 = new int[2];         array1[0] = 5;         array1[1] = 6;         final int[] array2 = new int[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testShortArrayHiddenByObject() {         final short[] array1 = new short[2];         array1[0] = 5;         array1[1] = 6;         final short[] array2 = new short[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testCharArrayHiddenByObject() {         final char[] array1 = new char[2];         array1[0] = 5;         array1[1] = 6;         final char[] array2 = new char[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testByteArrayHiddenByObject() {         final byte[] array1 = new byte[2];         array1[0] = 5;         array1[1] = 6;         final byte[] array2 = new byte[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testDoubleArrayHiddenByObject() {         final double[] array1 = new double[2];         array1[0] = 5;         array1[1] = 6;         final double[] array2 = new double[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testFloatArrayHiddenByObject() {         final float[] array1 = new float[2];         array1[0] = 5;         array1[1] = 6;         final float[] array2 = new float[2];         array2[0] = 5;         array2[1] = 6;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test     public void testBooleanArrayHiddenByObject() {         final boolean[] array1 = new boolean[2];         array1[0] = true;         array1[1] = false;         final boolean[] array2 = new boolean[2];         array2[0] = true;         array2[1] = false;         final Object obj1 = array1;         final Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = true;         assertFalse(new EqualsBuilder().append(obj1, obj2).isEquals());     }      public static class TestACanEqualB {         private final int a;          public TestACanEqualB(final int a) {             this.a = a;         }          @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (o instanceof TestACanEqualB) {                 return this.a == ((TestACanEqualB) o).getA();             }             if (o instanceof TestBCanEqualA) {                 return this.a == ((TestBCanEqualA) o).getB();             }             return false;         }          @Override         public int hashCode() {             return a;         }          public int getA() {             return this.a;         }     }      public static class TestBCanEqualA {         private final int b;          public TestBCanEqualA(final int b) {             this.b = b;         }          @Override         public boolean equals(final Object o) {             if (o == this) {                 return true;             }             if (o instanceof TestACanEqualB) {                 return this.b == ((TestACanEqualB) o).getA();             }             if (o instanceof TestBCanEqualA) {                 return this.b == ((TestBCanEqualA) o).getB();             }             return false;         }          @Override         public int hashCode() {             return b;         }          public int getB() {             return this.b;         }     }      /**      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses      * of each other and do not share a parent aside from Object.      * See https://issues.apache.org/bugzilla/show_bug.cgi?id=33069      */     @Test     public void testUnrelatedClasses() {         final Object[] x = new Object[]{new TestACanEqualB(1)};         final Object[] y = new Object[]{new TestBCanEqualA(1)};          // sanity checks:         assertArrayEquals(x, x);         assertArrayEquals(y, y);         assertArrayEquals(x, y);         assertArrayEquals(y, x);         // real tests:         assertEquals(x[0], x[0]);         assertEquals(y[0], y[0]);         assertEquals(x[0], y[0]);         assertEquals(y[0], x[0]);         assertTrue(new EqualsBuilder().append(x, x).isEquals());         assertTrue(new EqualsBuilder().append(y, y).isEquals());         assertTrue(new EqualsBuilder().append(x, y).isEquals());         assertTrue(new EqualsBuilder().append(y, x).isEquals());     }      /**      * Test from https://issues.apache.org/bugzilla/show_bug.cgi?id=33067      */     @Test     public void testNpeForNullElement() {         final Object[] x1 = new Object[]{Integer.valueOf(1), null, Integer.valueOf(3)};         final Object[] x2 = new Object[]{Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)};          // causes an NPE in 2.0 according to:         // https://issues.apache.org/bugzilla/show_bug.cgi?id=33067         new EqualsBuilder().append(x1, x2);     }      @Test     public void testReflectionEqualsExcludeFields() {         final TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);         final TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);          // not equal when including all fields         assertFalse(EqualsBuilder.reflectionEquals(x1, x2));          // doesn't barf on null, empty array, or non-existent field, but still tests as not equal         assertFalse(EqualsBuilder.reflectionEquals(x1, x2, (String[]) null));         assertFalse(EqualsBuilder.reflectionEquals(x1, x2));         assertFalse(EqualsBuilder.reflectionEquals(x1, x2, "xxx"));          // not equal if only one of the differing fields excluded         assertFalse(EqualsBuilder.reflectionEquals(x1, x2, "two"));         assertFalse(EqualsBuilder.reflectionEquals(x1, x2, "three"));          // equal if both differing fields excluded         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, "two", "three"));          // still equal as long as both differing fields are among excluded         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, "one", "two", "three"));         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, "one", "two", "three", "xxx"));     }      static class TestObjectWithMultipleFields {         @SuppressWarnings("unused")         private final TestObject one;         @SuppressWarnings("unused")         private final TestObject two;         @SuppressWarnings("unused")         private final TestObject three;          TestObjectWithMultipleFields(final int one, final int two, final int three) {             this.one = new TestObject(one);             this.two = new TestObject(two);             this.three = new TestObject(three);         }     }      /**      * Test cyclical object references which cause a StackOverflowException if      * not handled properly. s. LANG-606      */     @Test     public void testCyclicalObjectReferences() {         final TestObjectReference refX1 = new TestObjectReference(1);         final TestObjectReference x1 = new TestObjectReference(1);         x1.setObjectReference(refX1);         refX1.setObjectReference(x1);          final TestObjectReference refX2 = new TestObjectReference(1);         final TestObjectReference x2 = new TestObjectReference(1);         x2.setObjectReference(refX2);         refX2.setObjectReference(x2);          final TestObjectReference refX3 = new TestObjectReference(2);         final TestObjectReference x3 = new TestObjectReference(2);         x3.setObjectReference(refX3);         refX3.setObjectReference(x3);          assertEquals(x1, x2);         assertNull(EqualsBuilder.getRegistry());         assertNotEquals(x1, x3);         assertNull(EqualsBuilder.getRegistry());         assertNotEquals(x2, x3);         assertNull(EqualsBuilder.getRegistry());     }      static class TestObjectReference {         @SuppressWarnings("unused")         private TestObjectReference reference;         @SuppressWarnings("unused")         private final TestObject one;          TestObjectReference(final int one) {             this.one = new TestObject(one);         }          public void setObjectReference(final TestObjectReference reference) {             this.reference = reference;         }          @Override         public boolean equals(final Object obj) {             return EqualsBuilder.reflectionEquals(this, obj);         }     }      @Test     public void testReflectionArrays() {          final TestObject one = new TestObject(1);         final TestObject two = new TestObject(2);          final Object[] o1 = new Object[]{one};         final Object[] o2 = new Object[]{two};         final Object[] o3 = new Object[]{one};          assertFalse(EqualsBuilder.reflectionEquals(o1, o2));         assertTrue(EqualsBuilder.reflectionEquals(o1, o1));         assertTrue(EqualsBuilder.reflectionEquals(o1, o3));          final double[] d1 = {0, 1};         final double[] d2 = {2, 3};         final double[] d3 = {0, 1};          assertFalse(EqualsBuilder.reflectionEquals(d1, d2));         assertTrue(EqualsBuilder.reflectionEquals(d1, d1));         assertTrue(EqualsBuilder.reflectionEquals(d1, d3));     }      static class TestObjectEqualsExclude {         @EqualsExclude         private final int a;         private final int b;          TestObjectEqualsExclude(final int a, final int b) {             this.a = a;             this.b = b;         }          public int getA() {             return a;         }          public int getB() {             return b;         }     }      @Test     public void testToEqualsExclude() {         TestObjectEqualsExclude one = new TestObjectEqualsExclude(1, 2);         TestObjectEqualsExclude two = new TestObjectEqualsExclude(1, 3);          assertFalse(EqualsBuilder.reflectionEquals(one, two));          one = new TestObjectEqualsExclude(1, 2);         two = new TestObjectEqualsExclude(2, 2);          assertTrue(EqualsBuilder.reflectionEquals(one, two));     }      @Test     public void testReflectionAppend() {         assertTrue(EqualsBuilder.reflectionEquals(null, null));          final TestObject o1 = new TestObject(4);         final TestObject o2 = new TestObject(5);         assertTrue(new EqualsBuilder().reflectionAppend(o1, o1).build());         assertFalse(new EqualsBuilder().reflectionAppend(o1, o2).build());          o2.setA(4);         assertTrue(new EqualsBuilder().reflectionAppend(o1, o2).build());          assertFalse(new EqualsBuilder().reflectionAppend(o1, this).build());          assertFalse(new EqualsBuilder().reflectionAppend(o1, null).build());         assertFalse(new EqualsBuilder().reflectionAppend(null, o2).build());     }      @Test     public void testIsRegistered() throws Exception {         final Object firstObject = new Object();         final Object secondObject = new Object();          try {             final Method registerMethod = MethodUtils.getMatchingMethod(EqualsBuilder.class, "register", Object.class, Object.class);             registerMethod.setAccessible(true);             registerMethod.invoke(null, firstObject, secondObject);              assertTrue(EqualsBuilder.isRegistered(firstObject, secondObject));             assertTrue(EqualsBuilder.isRegistered(secondObject, firstObject)); // LANG-1349         } finally {             final Method unregisterMethod = MethodUtils.getMatchingMethod(EqualsBuilder.class, "unregister", Object.class, Object.class);             unregisterMethod.setAccessible(true);             unregisterMethod.invoke(null, firstObject, secondObject);         }     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import java.nio.charset.Charset; import java.nio.charset.StandardCharsets;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  /**  * Tests {@link Charsets}.  */ public class CharsetsTestCase {      @Test     public void testToCharset_Charset() {         Assertions.assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null));         Assertions.assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset()));         Assertions.assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8));     }      @Test     public void testToCharset_String() {         Assertions.assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null));         Assertions.assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset().name()));         Assertions.assertEquals(StandardCharsets.UTF_8, Charsets.toCharset("UTF-8"));     }      @Test     public void testToCharsetName() {         Assertions.assertEquals(Charset.defaultCharset().name(), Charsets.toCharsetName((String) null));         Assertions.assertEquals("UTF-8", Charsets.toCharsetName("UTF-8"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.ArrayList; import java.util.Arrays; import java.util.EnumSet; import java.util.List; import java.util.Map;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  /**  *  */ public class EnumUtilsTest {      @Test     public void testConstructable() {         // enforce public constructor         new EnumUtils();     }      @Test     public void test_getEnumMap() {         final Map<String, Traffic> test = EnumUtils.getEnumMap(Traffic.class);         assertEquals("{RED=RED, AMBER=AMBER, GREEN=GREEN}", test.toString(), "getEnumMap not created correctly");         assertEquals(3, test.size());         assertTrue(test.containsKey("RED"));         assertEquals(Traffic.RED, test.get("RED"));         assertTrue(test.containsKey("AMBER"));         assertEquals(Traffic.AMBER, test.get("AMBER"));         assertTrue(test.containsKey("GREEN"));         assertEquals(Traffic.GREEN, test.get("GREEN"));         assertFalse(test.containsKey("PURPLE"));     }      @Test     public void test_getEnumList() {         final List<Traffic> test = EnumUtils.getEnumList(Traffic.class);         assertEquals(3, test.size());         assertEquals(Traffic.RED, test.get(0));         assertEquals(Traffic.AMBER, test.get(1));         assertEquals(Traffic.GREEN, test.get(2));     }      @Test     public void test_isValidEnum() {         assertTrue(EnumUtils.isValidEnum(Traffic.class, "RED"));         assertTrue(EnumUtils.isValidEnum(Traffic.class, "AMBER"));         assertTrue(EnumUtils.isValidEnum(Traffic.class, "GREEN"));         assertFalse(EnumUtils.isValidEnum(Traffic.class, "PURPLE"));         assertFalse(EnumUtils.isValidEnum(Traffic.class, null));     }      @Test     public void test_isValidEnum_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.isValidEnum(null, "PURPLE"));     }      @Test     public void test_isValidEnumIgnoreCase() {         assertTrue(EnumUtils.isValidEnumIgnoreCase(Traffic.class, "red"));         assertTrue(EnumUtils.isValidEnumIgnoreCase(Traffic.class, "Amber"));         assertTrue(EnumUtils.isValidEnumIgnoreCase(Traffic.class, "grEEn"));         assertFalse(EnumUtils.isValidEnumIgnoreCase(Traffic.class, "purple"));         assertFalse(EnumUtils.isValidEnumIgnoreCase(Traffic.class, null));     }      @Test     public void test_isValidEnumIgnoreCase_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.isValidEnumIgnoreCase(null, "PURPLE"));     }      @Test     public void test_getEnum() {         assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, "RED"));         assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, "AMBER"));         assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, "GREEN"));         assertNull(EnumUtils.getEnum(Traffic.class, "PURPLE"));         assertNull(EnumUtils.getEnum(Traffic.class, null));     }      @Test     public void test_getEnum_nonEnumClass() {         final Class rawType = Object.class;         assertNull(EnumUtils.getEnum(rawType, "rawType"));     }      @Test     public void test_getEnum_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.getEnum((Class<Traffic>) null, "PURPLE"));     }      @Test     public void test_getEnum_defaultEnum() {         assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, "RED", Traffic.AMBER));         assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, "AMBER", Traffic.GREEN));         assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, "GREEN", Traffic.RED));         assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, "PURPLE", Traffic.AMBER));         assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, "PURPLE", Traffic.GREEN));         assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, "PURPLE", Traffic.RED));         assertEquals(Traffic.AMBER, EnumUtils.getEnum(Traffic.class, null, Traffic.AMBER));         assertEquals(Traffic.GREEN, EnumUtils.getEnum(Traffic.class, null, Traffic.GREEN));         assertEquals(Traffic.RED, EnumUtils.getEnum(Traffic.class, null, Traffic.RED));         assertNull(EnumUtils.getEnum(Traffic.class, "PURPLE", null));     }      @Test     public void test_getEnumIgnoreCase() {         assertEquals(Traffic.RED, EnumUtils.getEnumIgnoreCase(Traffic.class, "red"));         assertEquals(Traffic.AMBER, EnumUtils.getEnumIgnoreCase(Traffic.class, "Amber"));         assertEquals(Traffic.GREEN, EnumUtils.getEnumIgnoreCase(Traffic.class, "grEEn"));         assertNull(EnumUtils.getEnumIgnoreCase(Traffic.class, "purple"));         assertNull(EnumUtils.getEnumIgnoreCase(Traffic.class, null));     }      @Test     public void test_getEnumIgnoreCase_nonEnumClass() {         final Class rawType = Object.class;         assertNull(EnumUtils.getEnumIgnoreCase(rawType, "rawType"));     }      @Test     public void test_getEnumIgnoreCase_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.getEnumIgnoreCase((Class<Traffic>) null, "PURPLE"));     }      @Test     public void test_getEnumIgnoreCase_defaultEnum() {         assertEquals(Traffic.RED, EnumUtils.getEnumIgnoreCase(Traffic.class, "red", Traffic.AMBER));         assertEquals(Traffic.AMBER, EnumUtils.getEnumIgnoreCase(Traffic.class, "Amber", Traffic.GREEN));         assertEquals(Traffic.GREEN, EnumUtils.getEnumIgnoreCase(Traffic.class, "grEEn", Traffic.RED));         assertEquals(Traffic.AMBER, EnumUtils.getEnumIgnoreCase(Traffic.class, "PURPLE", Traffic.AMBER));         assertEquals(Traffic.GREEN, EnumUtils.getEnumIgnoreCase(Traffic.class, "purple", Traffic.GREEN));         assertEquals(Traffic.RED, EnumUtils.getEnumIgnoreCase(Traffic.class, "pUrPlE", Traffic.RED));         assertEquals(Traffic.AMBER, EnumUtils.getEnumIgnoreCase(Traffic.class, null, Traffic.AMBER));         assertEquals(Traffic.GREEN, EnumUtils.getEnumIgnoreCase(Traffic.class, null, Traffic.GREEN));         assertEquals(Traffic.RED, EnumUtils.getEnumIgnoreCase(Traffic.class, null, Traffic.RED));         assertNull(EnumUtils.getEnumIgnoreCase(Traffic.class, "PURPLE", null));     }      @Test     public void test_generateBitVector_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVector(null, EnumSet.of(Traffic.RED)));     }      @Test     public void test_generateBitVectors_nullClass() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVectors(null, EnumSet.of(Traffic.RED)));     }      @Test     public void test_generateBitVector_nullIterable() {         assertThrows(NullPointerException.class,                 () -> EnumUtils.generateBitVector(Traffic.class, (Iterable<Traffic>) null));     }      @Test     public void test_generateBitVectors_nullIterable() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVectors(null, (Iterable<Traffic>) null));     }      @Test     public void test_generateBitVector_nullElement() {         assertThrows(NullPointerException.class,                 () -> EnumUtils.generateBitVector(Traffic.class, Arrays.asList(Traffic.RED, null)));     }      @Test     public void test_generateBitVectors_nullElement() {         assertThrows(NullPointerException.class,                 () -> EnumUtils.generateBitVectors(Traffic.class, Arrays.asList(Traffic.RED, null)));     }      @Test     public void test_generateBitVector_nullClassWithArray() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVector(null, Traffic.RED));     }      @Test     public void test_generateBitVectors_nullClassWithArray() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVectors(null, Traffic.RED));     }      @Test     public void test_generateBitVector_nullArray() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVector(Traffic.class, (Traffic[]) null));     }      @Test     public void test_generateBitVectors_nullArray() {         assertThrows(NullPointerException.class, () -> EnumUtils.generateBitVectors(Traffic.class, (Traffic[]) null));     }      @Test     public void test_generateBitVector_nullArrayElement() {         assertThrows(IllegalArgumentException.class,                 () -> EnumUtils.generateBitVector(Traffic.class, Traffic.RED, null));     }      @Test     public void test_generateBitVectors_nullArrayElement() {         assertThrows(IllegalArgumentException.class,                 () -> EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, null));     }      @Test     public void test_generateBitVector_longClass() {         assertThrows(IllegalArgumentException.class,                 () -> EnumUtils.generateBitVector(TooMany.class, EnumSet.of(TooMany.A1)));     }      @Test     public void test_generateBitVector_longClassWithArray() {         assertThrows(IllegalArgumentException.class, () -> EnumUtils.generateBitVector(TooMany.class, TooMany.A1));     }      @SuppressWarnings("unchecked")     @Test     public void test_generateBitVector_nonEnumClass() {         @SuppressWarnings("rawtypes")         final         Class rawType = Object.class;         @SuppressWarnings("rawtypes")         final         List rawList = new ArrayList();         assertThrows(IllegalArgumentException.class, () -> EnumUtils.generateBitVector(rawType, rawList));     }      @SuppressWarnings("unchecked")     @Test     public void test_generateBitVectors_nonEnumClass() {         @SuppressWarnings("rawtypes")         final         Class rawType = Object.class;         @SuppressWarnings("rawtypes")         final         List rawList = new ArrayList();         assertThrows(IllegalArgumentException.class, () -> EnumUtils.generateBitVectors(rawType, rawList));     }      @SuppressWarnings("unchecked")     @Test     public void test_generateBitVector_nonEnumClassWithArray() {         @SuppressWarnings("rawtypes")         final         Class rawType = Object.class;         assertThrows(IllegalArgumentException.class, () -> EnumUtils.generateBitVector(rawType));     }      @SuppressWarnings("unchecked")     @Test     public void test_generateBitVectors_nonEnumClassWithArray() {         @SuppressWarnings("rawtypes")         final         Class rawType = Object.class;         assertThrows(IllegalArgumentException.class, () -> EnumUtils.generateBitVectors(rawType));     }      @Test     public void test_generateBitVector() {         assertEquals(0L, EnumUtils.generateBitVector(Traffic.class, EnumSet.noneOf(Traffic.class)));         assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED)));         assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER)));         assertEquals(4L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.GREEN)));         assertEquals(3L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)));         assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)));         assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)));         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)));          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertEquals((1L << 31), EnumUtils.generateBitVector(Enum64.class, EnumSet.of(Enum64.A31)));         assertEquals((1L << 32), EnumUtils.generateBitVector(Enum64.class, EnumSet.of(Enum64.A32)));         assertEquals((1L << 63), EnumUtils.generateBitVector(Enum64.class, EnumSet.of(Enum64.A63)));         assertEquals(Long.MIN_VALUE, EnumUtils.generateBitVector(Enum64.class, EnumSet.of(Enum64.A63)));     }      @Test     public void test_generateBitVectors() {         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED)), 1L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L);          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, EnumSet.of(Enum64.A31)), (1L << 31));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, EnumSet.of(Enum64.A32)), (1L << 32));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, EnumSet.of(Enum64.A63)), (1L << 63));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, EnumSet.of(Enum64.A63)), Long.MIN_VALUE);          // More than 64 values Enum         assertArrayEquals(EnumUtils.generateBitVectors(TooMany.class, EnumSet.of(TooMany.M2)), 1L, 0L);         assertArrayEquals(EnumUtils.generateBitVectors(TooMany.class, EnumSet.of(TooMany.L2, TooMany.M2)), 1L, (1L << 63));     }      @Test     public void test_generateBitVectorFromArray() {         assertEquals(0L, EnumUtils.generateBitVector(Traffic.class));         assertEquals(1L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED));         assertEquals(2L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER));         assertEquals(4L, EnumUtils.generateBitVector(Traffic.class, Traffic.GREEN));         assertEquals(3L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER));         assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.GREEN));         assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, Traffic.AMBER, Traffic.GREEN));         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN));         //gracefully handles duplicates:         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN));          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertEquals((1L << 31), EnumUtils.generateBitVector(Enum64.class, Enum64.A31));         assertEquals((1L << 32), EnumUtils.generateBitVector(Enum64.class, Enum64.A32));         assertEquals((1L << 63), EnumUtils.generateBitVector(Enum64.class, Enum64.A63));         assertEquals(Long.MIN_VALUE, EnumUtils.generateBitVector(Enum64.class, Enum64.A63));     }      @Test     public void test_generateBitVectorsFromArray() {         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L);         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN), 7L);         //gracefully handles duplicates:         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L);          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, Enum64.A31), (1L << 31));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, Enum64.A32), (1L << 32));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, Enum64.A63), (1L << 63));         assertArrayEquals(EnumUtils.generateBitVectors(Enum64.class, Enum64.A63), Long.MIN_VALUE);          // More than 64 values Enum         assertArrayEquals(EnumUtils.generateBitVectors(TooMany.class, TooMany.M2), 1L, 0L);         assertArrayEquals(EnumUtils.generateBitVectors(TooMany.class, TooMany.L2, TooMany.M2), 1L, (1L << 63));      }      private void assertArrayEquals(final long[] actual, final long... expected) {         Assertions.assertArrayEquals(expected, actual);     }      @Test     public void test_processBitVector_nullClass() {         final Class<Traffic> empty = null;         assertThrows(NullPointerException.class, () -> EnumUtils.processBitVector(empty, 0L));     }      @Test     public void test_processBitVectors_nullClass() {         final Class<Traffic> empty = null;         assertThrows(NullPointerException.class, () -> EnumUtils.processBitVectors(empty, 0L));     }      @Test     public void test_processBitVector() {         assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVector(Traffic.class, 0L));         assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVector(Traffic.class, 1L));         assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVector(Traffic.class, 2L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVector(Traffic.class, 3L));         assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 4L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 5L));         assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 6L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 7L));          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertEquals(EnumSet.of(Enum64.A31), EnumUtils.processBitVector(Enum64.class, (1L << 31)));         assertEquals(EnumSet.of(Enum64.A32), EnumUtils.processBitVector(Enum64.class, (1L << 32)));         assertEquals(EnumSet.of(Enum64.A63), EnumUtils.processBitVector(Enum64.class, (1L << 63)));         assertEquals(EnumSet.of(Enum64.A63), EnumUtils.processBitVector(Enum64.class, Long.MIN_VALUE));     }      @Test     public void test_processBitVectors() {         assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L));         assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 1L));         assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 2L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 3L));         assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 4L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 5L));         assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 6L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 7L));          assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L, 0L));         assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 0L, 1L));         assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 2L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 3L));         assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 4L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 5L));         assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 6L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 7L));          // demonstrate tolerance of irrelevant high-order digits:         assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 666L, 0L));         assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 666L, 1L));         assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 2L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 3L));         assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 4L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 5L));         assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 6L));         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 7L));          // 64 values Enum (to test whether no int<->long jdk conversion issue exists)         assertEquals(EnumSet.of(Enum64.A31), EnumUtils.processBitVectors(Enum64.class, (1L << 31)));         assertEquals(EnumSet.of(Enum64.A32), EnumUtils.processBitVectors(Enum64.class, (1L << 32)));         assertEquals(EnumSet.of(Enum64.A63), EnumUtils.processBitVectors(Enum64.class, (1L << 63)));         assertEquals(EnumSet.of(Enum64.A63), EnumUtils.processBitVectors(Enum64.class, Long.MIN_VALUE));     }      @Test     public void test_processBitVector_longClass() {         assertThrows(IllegalArgumentException.class, () -> EnumUtils.processBitVector(TooMany.class, 0L));     }      @Test     public void test_processBitVectors_longClass() {         assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L));         assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 1L));         assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 2L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 3L));         assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 4L));         assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 5L));         assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 6L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 7L));          assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L, 0L));         assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 0L, 1L));         assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 2L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 3L));         assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 4L));         assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 5L));         assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 6L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L));          assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 0L));         assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 1L));         assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 2L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 3L));         assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 4L));         assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 5L));         assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 6L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L));          // demonstrate tolerance of irrelevant high-order digits:         assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 0L));         assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 1L));         assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 2L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 3L));         assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 4L));         assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 5L));         assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 6L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L));         assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L));     }  }  enum Traffic {     RED, AMBER, GREEN }  enum Enum64 {     A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15,     A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31,     A32, A33, A34, A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45, A46, A47,     A48, A49, A50, A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, A61, A62, A63 }  enum TooMany {     A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,     A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1, O1, P1, Q1, R1, S1, T1,     U1, V1, W1, X1, Y1, Z1, A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, K2, L2, M2 } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Tests ArrayUtils insert methods.  */ public class ArrayUtilsInsertTest {      @Test     public void testInsertBooleans() {         final boolean[] array = {true, false, true};         final boolean[] values = {false, true, false};          final boolean[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new boolean[0], ArrayUtils.insert(0, new boolean[0], null));         assertNull(ArrayUtils.insert(42, (boolean[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new boolean[]{false, true, false, true}, ArrayUtils.insert(0, array, false));         assertArrayEquals(new boolean[]{true, false, false, true}, ArrayUtils.insert(1, array, false));         assertArrayEquals(new boolean[]{true, false, true, false}, ArrayUtils.insert(array.length, array, false));         assertArrayEquals(new boolean[]{false, true, false, true, false, true}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new boolean[]{true, false, true, false, false, true}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new boolean[]{true, false, true, false, true, false}, ArrayUtils.insert(array.length, array, values));     }       @Test     public void testInsertBytes() {         final byte[] array = {1, 2, 3};         final byte[] values = {4, 5, 6};          final byte[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new byte[0], ArrayUtils.insert(0, new byte[0], null));         assertNull(ArrayUtils.insert(42, (byte[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new byte[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, (byte) 0));         assertArrayEquals(new byte[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, (byte) 0));         assertArrayEquals(new byte[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, (byte) 0));         assertArrayEquals(new byte[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new byte[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values));     }      @Test     public void testInsertChars() {         final char[] array = {'a', 'b', 'c'};         final char[] values = {'d', 'e', 'f'};          final char[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new char[0], ArrayUtils.insert(0, new char[0], null));         assertNull(ArrayUtils.insert(42, (char[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new char[]{'z', 'a', 'b', 'c'}, ArrayUtils.insert(0, array, 'z'));         assertArrayEquals(new char[]{'a', 'z', 'b', 'c'}, ArrayUtils.insert(1, array, 'z'));         assertArrayEquals(new char[]{'a', 'b', 'c', 'z'}, ArrayUtils.insert(array.length, array, 'z'));         assertArrayEquals(new char[]{'d', 'e', 'f', 'a', 'b', 'c'}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new char[]{'a', 'd', 'e', 'f', 'b', 'c'}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new char[]{'a', 'b', 'c', 'd', 'e', 'f'}, ArrayUtils.insert(array.length, array, values));     }      @Test     public void testInsertDoubles() {         final double[] array = {1, 2, 3};         final double[] values = {4, 5, 6};         final double delta = 0.000001;          final double[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result, delta);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new double[0], ArrayUtils.insert(0, new double[0], null), delta);         assertNull(ArrayUtils.insert(42, (double[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new double[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, 0), delta);         assertArrayEquals(new double[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, 0), delta);         assertArrayEquals(new double[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, 0), delta);         assertArrayEquals(new double[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values), delta);         assertArrayEquals(new double[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values), delta);         assertArrayEquals(new double[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values), delta);     }      @Test     public void testInsertFloats() {         final float[] array = {1, 2, 3};         final float[] values = {4, 5, 6};         final float delta = 0.000001f;          final float[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result, delta);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new float[0], ArrayUtils.insert(0, new float[0], null), delta);         assertNull(ArrayUtils.insert(42, (float[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new float[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, 0), delta);         assertArrayEquals(new float[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, 0), delta);         assertArrayEquals(new float[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, 0), delta);         assertArrayEquals(new float[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values), delta);         assertArrayEquals(new float[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values), delta);         assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values), delta);     }      @Test     public void testInsertGenericArray() {         final String[] array = {"a", "b", "c"};         final String[] values = {"d", "e", "f"};          final String[] result = ArrayUtils.insert(42, array, (String[]) null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new String[0], ArrayUtils.insert(0, new String[0], (String[]) null));         assertNull(ArrayUtils.insert(42, null, (String[]) null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new String[]{"z", "a", "b", "c"}, ArrayUtils.insert(0, array, "z"));         assertArrayEquals(new String[]{"a", "z", "b", "c"}, ArrayUtils.insert(1, array, "z"));         assertArrayEquals(new String[]{"a", "b", "c", "z"}, ArrayUtils.insert(array.length, array, "z"));         assertArrayEquals(new String[]{"d", "e", "f", "a", "b", "c"}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new String[]{"a", "d", "e", "f", "b", "c"}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new String[]{"a", "b", "c", "d", "e", "f"}, ArrayUtils.insert(array.length, array, values));     }       @Test     public void testInsertInts() {         final int[] array = {1, 2, 3};         final int[] values = {4, 5, 6};          final int[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new int[0], ArrayUtils.insert(0, new int[0], null));         assertNull(ArrayUtils.insert(42, (int[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new int[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, 0));         assertArrayEquals(new int[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, 0));         assertArrayEquals(new int[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, 0));         assertArrayEquals(new int[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new int[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values));     }       @Test     public void testInsertLongs() {         final long[] array = {1, 2, 3};         final long[] values = {4, 5, 6};          final long[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new long[0], ArrayUtils.insert(0, new long[0], null));         assertNull(ArrayUtils.insert(42, (long[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new long[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, 0));         assertArrayEquals(new long[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, 0));         assertArrayEquals(new long[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, 0));         assertArrayEquals(new long[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new long[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new long[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values));     }       @Test     public void testInsertShorts() {         final short[] array = {1, 2, 3};         final short[] values = {4, 5, 6};          final short[] result = ArrayUtils.insert(42, array, null);         assertArrayEquals(array, result);         assertNotSame(array, result);          assertNull(ArrayUtils.insert(42, null, array));         assertArrayEquals(new short[0], ArrayUtils.insert(0, new short[0], null));         assertNull(ArrayUtils.insert(42, (short[]) null, null));          assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(-1, array, array));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.insert(array.length + 1, array, array));          assertArrayEquals(new short[]{0, 1, 2, 3}, ArrayUtils.insert(0, array, (short) 0));         assertArrayEquals(new short[]{1, 0, 2, 3}, ArrayUtils.insert(1, array, (short) 0));         assertArrayEquals(new short[]{1, 2, 3, 0}, ArrayUtils.insert(array.length, array, (short) 0));         assertArrayEquals(new short[]{4, 5, 6, 1, 2, 3}, ArrayUtils.insert(0, array, values));         assertArrayEquals(new short[]{1, 4, 5, 6, 2, 3}, ArrayUtils.insert(1, array, values));         assertArrayEquals(new short[]{1, 2, 3, 4, 5, 6}, ArrayUtils.insert(array.length, array, values));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Substring methods  */ public class StringUtilsSubstringTest  {     private static final String FOO = "foo";     private static final String BAR = "bar";     private static final String BAZ = "baz";     private static final String FOOBAR = "foobar";     private static final String SENTENCE = "foo bar baz";      //-----------------------------------------------------------------------      @Test     public void testSubstring_StringInt() {         assertNull(StringUtils.substring(null, 0));         assertEquals("", StringUtils.substring("", 0));         assertEquals("", StringUtils.substring("", 2));          assertEquals("", StringUtils.substring(SENTENCE, 80));         assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));         assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));         assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));         assertEquals("abc", StringUtils.substring("abc", -4));         assertEquals("abc", StringUtils.substring("abc", -3));         assertEquals("bc", StringUtils.substring("abc", -2));         assertEquals("c", StringUtils.substring("abc", -1));         assertEquals("abc", StringUtils.substring("abc", 0));         assertEquals("bc", StringUtils.substring("abc", 1));         assertEquals("c", StringUtils.substring("abc", 2));         assertEquals("", StringUtils.substring("abc", 3));         assertEquals("", StringUtils.substring("abc", 4));     }      @Test     public void testSubstring_StringIntInt() {         assertNull(StringUtils.substring(null, 0, 0));         assertNull(StringUtils.substring(null, 1, 2));         assertEquals("", StringUtils.substring("", 0, 0));         assertEquals("", StringUtils.substring("", 1, 2));         assertEquals("", StringUtils.substring("", -2, -1));          assertEquals("", StringUtils.substring(SENTENCE, 8, 6));         assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));         assertEquals("o", StringUtils.substring(SENTENCE, -9, 3));         assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));         assertEquals("o", StringUtils.substring(SENTENCE, -9, -8));         assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));         assertEquals("", StringUtils.substring(SENTENCE, 2, 2));         assertEquals("b", StringUtils.substring("abc", -2, -1));     }      @Test     public void testLeft_String() {         assertSame(null, StringUtils.left(null, -1));         assertSame(null, StringUtils.left(null, 0));         assertSame(null, StringUtils.left(null, 2));          assertEquals("", StringUtils.left("", -1));         assertEquals("", StringUtils.left("", 0));         assertEquals("", StringUtils.left("", 2));          assertEquals("", StringUtils.left(FOOBAR, -1));         assertEquals("", StringUtils.left(FOOBAR, 0));         assertEquals(FOO, StringUtils.left(FOOBAR, 3));         assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));     }      @Test     public void testRight_String() {         assertSame(null, StringUtils.right(null, -1));         assertSame(null, StringUtils.right(null, 0));         assertSame(null, StringUtils.right(null, 2));          assertEquals("", StringUtils.right("", -1));         assertEquals("", StringUtils.right("", 0));         assertEquals("", StringUtils.right("", 2));          assertEquals("", StringUtils.right(FOOBAR, -1));         assertEquals("", StringUtils.right(FOOBAR, 0));         assertEquals(BAR, StringUtils.right(FOOBAR, 3));         assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));     }      @Test     public void testMid_String() {         assertSame(null, StringUtils.mid(null, -1, 0));         assertSame(null, StringUtils.mid(null, 0, -1));         assertSame(null, StringUtils.mid(null, 3, 0));         assertSame(null, StringUtils.mid(null, 3, 2));          assertEquals("", StringUtils.mid("", 0, -1));         assertEquals("", StringUtils.mid("", 0, 0));         assertEquals("", StringUtils.mid("", 0, 2));          assertEquals("", StringUtils.mid(FOOBAR, 3, -1));         assertEquals("", StringUtils.mid(FOOBAR, 3, 0));         assertEquals("b", StringUtils.mid(FOOBAR, 3, 1));         assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));         assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));         assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));         assertEquals("", StringUtils.mid(FOOBAR, 9, 3));         assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3));     }      //-----------------------------------------------------------------------     @Test     public void testSubstringBefore_StringString() {         assertEquals("foo", StringUtils.substringBefore("fooXXbarXXbaz", "XX"));          assertNull(StringUtils.substringBefore(null, null));         assertNull(StringUtils.substringBefore(null, ""));         assertNull(StringUtils.substringBefore(null, "XX"));         assertEquals("", StringUtils.substringBefore("", null));         assertEquals("", StringUtils.substringBefore("", ""));         assertEquals("", StringUtils.substringBefore("", "XX"));          assertEquals("foo", StringUtils.substringBefore("foo", null));         assertEquals("foo", StringUtils.substringBefore("foo", "b"));         assertEquals("f", StringUtils.substringBefore("foot", "o"));         assertEquals("", StringUtils.substringBefore("abc", "a"));         assertEquals("a", StringUtils.substringBefore("abcba", "b"));         assertEquals("ab", StringUtils.substringBefore("abc", "c"));         assertEquals("", StringUtils.substringBefore("abc", ""));     }      @Test     public void testSubstringAfter_StringString() {         assertEquals("barXXbaz", StringUtils.substringAfter("fooXXbarXXbaz", "XX"));          assertNull(StringUtils.substringAfter(null, null));         assertNull(StringUtils.substringAfter(null, ""));         assertNull(StringUtils.substringAfter(null, "XX"));         assertEquals("", StringUtils.substringAfter("", null));         assertEquals("", StringUtils.substringAfter("", ""));         assertEquals("", StringUtils.substringAfter("", "XX"));          assertEquals("", StringUtils.substringAfter("foo", null));         assertEquals("ot", StringUtils.substringAfter("foot", "o"));         assertEquals("bc", StringUtils.substringAfter("abc", "a"));         assertEquals("cba", StringUtils.substringAfter("abcba", "b"));         assertEquals("", StringUtils.substringAfter("abc", "c"));         assertEquals("abc", StringUtils.substringAfter("abc", ""));         assertEquals("", StringUtils.substringAfter("abc", "d"));     }      @Test     public void testSubstringAfter_StringInt() {         assertNull(StringUtils.substringAfter(null, 0));         assertNull(StringUtils.substringAfter(null, 'X'));         assertEquals("", StringUtils.substringAfter("", 0));         assertEquals("", StringUtils.substringAfter("", 'X'));          assertEquals("", StringUtils.substringAfter("foo", 0));         assertEquals("ot", StringUtils.substringAfter("foot", 'o'));         assertEquals("bc", StringUtils.substringAfter("abc", 'a'));         assertEquals("cba", StringUtils.substringAfter("abcba", 'b'));         assertEquals("", StringUtils.substringAfter("abc", 'c'));         assertEquals("", StringUtils.substringAfter("abc", 'd'));     }      @Test     public void testSubstringBeforeLast_StringString() {         assertEquals("fooXXbar", StringUtils.substringBeforeLast("fooXXbarXXbaz", "XX"));          assertNull(StringUtils.substringBeforeLast(null, null));         assertNull(StringUtils.substringBeforeLast(null, ""));         assertNull(StringUtils.substringBeforeLast(null, "XX"));         assertEquals("", StringUtils.substringBeforeLast("", null));         assertEquals("", StringUtils.substringBeforeLast("", ""));         assertEquals("", StringUtils.substringBeforeLast("", "XX"));          assertEquals("foo", StringUtils.substringBeforeLast("foo", null));         assertEquals("foo", StringUtils.substringBeforeLast("foo", "b"));         assertEquals("fo", StringUtils.substringBeforeLast("foo", "o"));         assertEquals("abc\r\n", StringUtils.substringBeforeLast("abc\r\n", "d"));         assertEquals("abc", StringUtils.substringBeforeLast("abcdabc", "d"));         assertEquals("abcdabc", StringUtils.substringBeforeLast("abcdabcd", "d"));         assertEquals("a", StringUtils.substringBeforeLast("abc", "b"));         assertEquals("abc ", StringUtils.substringBeforeLast("abc \n", "\n"));         assertEquals("a", StringUtils.substringBeforeLast("a", null));         assertEquals("a", StringUtils.substringBeforeLast("a", ""));         assertEquals("", StringUtils.substringBeforeLast("a", "a"));     }      @Test     public void testSubstringAfterLast_StringString() {         assertEquals("baz", StringUtils.substringAfterLast("fooXXbarXXbaz", "XX"));          assertNull(StringUtils.substringAfterLast(null, null));         assertNull(StringUtils.substringAfterLast(null, ""));         assertNull(StringUtils.substringAfterLast(null, "XX"));         assertEquals("", StringUtils.substringAfterLast("", null));         assertEquals("", StringUtils.substringAfterLast("", ""));         assertEquals("", StringUtils.substringAfterLast("", "a"));          assertEquals("", StringUtils.substringAfterLast("foo", null));         assertEquals("", StringUtils.substringAfterLast("foo", "b"));         assertEquals("t", StringUtils.substringAfterLast("foot", "o"));         assertEquals("bc", StringUtils.substringAfterLast("abc", "a"));         assertEquals("a", StringUtils.substringAfterLast("abcba", "b"));         assertEquals("", StringUtils.substringAfterLast("abc", "c"));         assertEquals("", StringUtils.substringAfterLast("", "d"));         assertEquals("", StringUtils.substringAfterLast("abc", ""));     }      @Test     public void testSubstringAfterLast_StringInt() {         assertNull(StringUtils.substringAfterLast(null, 0));         assertNull(StringUtils.substringAfterLast(null, 'X'));         assertEquals("", StringUtils.substringAfterLast("", 0));         assertEquals("", StringUtils.substringAfterLast("", 'a'));          assertEquals("", StringUtils.substringAfterLast("foo", 0));         assertEquals("", StringUtils.substringAfterLast("foo", 'b'));         assertEquals("t", StringUtils.substringAfterLast("foot", 'o'));         assertEquals("bc", StringUtils.substringAfterLast("abc", 'a'));         assertEquals("a", StringUtils.substringAfterLast("abcba", 'b'));         assertEquals("", StringUtils.substringAfterLast("abc", 'c'));         assertEquals("", StringUtils.substringAfterLast("", 'd'));     }      //-----------------------------------------------------------------------     @Test     public void testSubstringBetween_StringString() {         assertNull(StringUtils.substringBetween(null, "tag"));         assertEquals("", StringUtils.substringBetween("", ""));         assertNull(StringUtils.substringBetween("", "abc"));         assertEquals("", StringUtils.substringBetween("    ", " "));         assertNull(StringUtils.substringBetween("abc", null));         assertEquals("", StringUtils.substringBetween("abc", ""));         assertNull(StringUtils.substringBetween("abc", "a"));         assertEquals("bc", StringUtils.substringBetween("abca", "a"));         assertEquals("bc", StringUtils.substringBetween("abcabca", "a"));         assertEquals("bar", StringUtils.substringBetween("\nbar\n", "\n"));     }      @Test     public void testSubstringBetween_StringStringString() {         assertNull(StringUtils.substringBetween(null, "", ""));         assertNull(StringUtils.substringBetween("", null, ""));         assertNull(StringUtils.substringBetween("", "", null));         assertEquals("", StringUtils.substringBetween("", "", ""));         assertEquals("", StringUtils.substringBetween("foo", "", ""));         assertNull(StringUtils.substringBetween("foo", "", "]"));         assertNull(StringUtils.substringBetween("foo", "[", "]"));         assertEquals("", StringUtils.substringBetween("    ", " ", "  "));         assertEquals("bar", StringUtils.substringBetween("<foo>bar</foo>", "<foo>", "</foo>") );     }     /**      * Tests the substringsBetween method that returns an String Array of substrings.      */     @Test     public void testSubstringsBetween_StringStringString() {          String[] results = StringUtils.substringsBetween("[one], [two], [three]", "[", "]");         assertEquals(3, results.length);         assertEquals("one", results[0]);         assertEquals("two", results[1]);         assertEquals("three", results[2]);          results = StringUtils.substringsBetween("[one], [two], three", "[", "]");         assertEquals(2, results.length);         assertEquals("one", results[0]);         assertEquals("two", results[1]);          results = StringUtils.substringsBetween("[one], [two], three]", "[", "]");         assertEquals(2, results.length);         assertEquals("one", results[0]);         assertEquals("two", results[1]);          results = StringUtils.substringsBetween("[one], two], three]", "[", "]");         assertEquals(1, results.length);         assertEquals("one", results[0]);          results = StringUtils.substringsBetween("one], two], [three]", "[", "]");         assertEquals(1, results.length);         assertEquals("three", results[0]);          // 'ab hello ba' will match, but 'ab non ba' won't         // this is because the 'a' is shared between the two and can't be matched twice         results = StringUtils.substringsBetween("aabhellobabnonba", "ab", "ba");         assertEquals(1, results.length);         assertEquals("hello", results[0]);          results = StringUtils.substringsBetween("one, two, three", "[", "]");         assertNull(results);          results = StringUtils.substringsBetween("[one, two, three", "[", "]");         assertNull(results);          results = StringUtils.substringsBetween("one, two, three]", "[", "]");         assertNull(results);          results = StringUtils.substringsBetween("[one], [two], [three]", "[", null);         assertNull(results);          results = StringUtils.substringsBetween("[one], [two], [three]", null, "]");         assertNull(results);          results = StringUtils.substringsBetween("[one], [two], [three]", "", "");         assertNull(results);          results = StringUtils.substringsBetween(null, "[", "]");         assertNull(results);          results = StringUtils.substringsBetween("", "[", "]");         assertEquals(0, results.length);     }      //-----------------------------------------------------------------------     @Test     public void testCountMatches_String() {         assertEquals(0, StringUtils.countMatches(null, null));         assertEquals(0, StringUtils.countMatches("blah", null));         assertEquals(0, StringUtils.countMatches(null, "DD"));          assertEquals(0, StringUtils.countMatches("x", ""));         assertEquals(0, StringUtils.countMatches("", ""));          assertEquals(3,              StringUtils.countMatches("one long someone sentence of one", "one"));         assertEquals(0,              StringUtils.countMatches("one long someone sentence of one", "two"));         assertEquals(4,              StringUtils.countMatches("oooooooooooo", "ooo"));         assertEquals(0, StringUtils.countMatches(null, "?"));         assertEquals(0, StringUtils.countMatches("", "?"));         assertEquals(0, StringUtils.countMatches("abba", null));         assertEquals(0, StringUtils.countMatches("abba", ""));         assertEquals(2, StringUtils.countMatches("abba", "a"));         assertEquals(1, StringUtils.countMatches("abba", "ab"));         assertEquals(0, StringUtils.countMatches("abba", "xxx"));         assertEquals(1, StringUtils.countMatches("ababa", "aba"));     }      @Test     public void testCountMatches_char() {         assertEquals(0, StringUtils.countMatches(null, 'D'));         assertEquals(5, StringUtils.countMatches("one long someone sentence of one", ' '));         assertEquals(6, StringUtils.countMatches("one long someone sentence of one", 'o'));         assertEquals(4, StringUtils.countMatches("oooooooooooo", "ooo"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.Set;  import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.Validate}.  */ class ValidateTest {      @Nested     class IsTrue {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowForTrueExpression() {                 Validate.isTrue(true);             }              @Test             void shouldThrowExceptionWithDefaultMessageForFalseExpression() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isTrue(false));                  assertEquals("The validated expression is false", ex.getMessage());             }          }          @Nested         class WithMessage {              @Test             void shouldNotThrowForTrueExpression() {                 Validate.isTrue(true, "MSG");             }              @Test             void shouldThrowExceptionWithGivenMessageForFalseExpression() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isTrue(false, "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }          @Nested         class WithLongTemplate {              @Test             void shouldNotThrowForTrueExpression() {                 Validate.isTrue(true, "MSG", 6);             }              @Test             void shouldThrowExceptionWithLongInsertedIntoTemplateMessageForFalseExpression() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isTrue(false, "MSG %s", 6));                  assertEquals("MSG 6", ex.getMessage());             }         }          @Nested         class WithDoubleTemplate {              @Test             void shouldNotThrowForTrueExpression() {                 Validate.isTrue(true, "MSG", 7.4d);             }              @Test             void shouldThrowExceptionWithDoubleInsertedIntoTemplateMessageForFalseExpression() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isTrue(false, "MSG %s", 7.4d));                  assertEquals("MSG 7.4", ex.getMessage());             }         }          @Nested         class WithObjectTemplate {              @Test             void shouldNotThrowForTrueExpression() {                 Validate.isTrue(true, "MSG", "Object 1", "Object 2");             }              @Test             void shouldThrowExceptionWithDoubleInsertedIntoTemplateMessageForFalseExpression() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isTrue(false, "MSG %s %s", "Object 1", "Object 2"));                  assertEquals("MSG Object 1 Object 2", ex.getMessage());             }         }     }      @Nested     class NotNull {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowForNonNullReference() {                 Validate.notNull(new Object());             }              @Test             void shouldReturnTheSameInstance() {                 final String str = "Hi";                 final String result = Validate.notNull(str);                  assertSame(str, result);             }              @Test             void shouldThrowExceptionWithDefaultMessageForNullReference() {                 final NullPointerException ex = assertThrows(                         NullPointerException.class,                         () -> Validate.notNull(null));                  assertEquals("The validated object is null", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowForNonNullReference() {                 Validate.notNull(new Object(), "MSG");             }              @Test             void shouldReturnTheSameInstance() {                 final String str = "Hi";                 final String result = Validate.notNull(str, "MSG");                  assertSame(str, result);             }              @Test             void shouldThrowExceptionWithGivenMessageForNullReference() {                 final NullPointerException ex = assertThrows(                         NullPointerException.class,                         () -> Validate.notNull(null, "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class NotEmpty {          @Nested         class WithArray {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForArrayContainingNullReference() {                     Validate.notEmpty(new Object[]{null});                 }                  @Test                 void shouldReturnTheSameInstance() {                     final String[] array = new String[]{"hi"};                     final String[] result = Validate.notEmpty(array);                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Object[]) null));                      assertEquals("The validated array is empty", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyArray() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(new Object[0]));                      assertEquals("The validated array is empty", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForArrayContainingNullReference() {                     Validate.notEmpty(new Object[]{null}, "MSG");                 }                  @Test                 void shouldReturnTheSameInstance() {                     final String[] array = new String[]{"hi"};                     final String[] result = Validate.notEmpty(array, "MSG");                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithGivenMessageForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Object[]) null, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyArray() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(new Object[0], "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithCollection {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForCollectionContainingNullReference() {                     Validate.notEmpty(Collections.singleton(null));                 }                  @Test                 void shouldReturnTheSameInstance() {                     final Set<String> col = Collections.singleton("Hi");                     final Set<String> result = Validate.notEmpty(col);                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Collection<?>) null));                      assertEquals("The validated collection is empty", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyCollection() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(Collections.emptySet()));                      assertEquals("The validated collection is empty", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForCollectionContainingNullReference() {                     Validate.notEmpty(Collections.singleton(null), "MSG");                 }                  @Test                 void shouldReturnTheSameInstance() {                     final Set<String> col = Collections.singleton("Hi");                     final Set<String> result = Validate.notEmpty(col, "MSG");                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithGivenMessageForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Collection<?>) null, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageForEmptyCollection() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(Collections.emptySet(), "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithMap {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForMapContainingNullMapping() {                     Validate.notEmpty(Collections.singletonMap("key", null));                 }                  @Test                 void shouldReturnTheSameInstance() {                     final Map<String, String> map = Collections.singletonMap("key", "value");                     final Map<String, String> result = Validate.notEmpty(map);                      assertSame(map, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullMap() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Map<?, ?>) null));                      assertEquals("The validated map is empty", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyMap() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(Collections.emptyMap()));                      assertEquals("The validated map is empty", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForMapContainingNullMapping() {                     Validate.notEmpty(Collections.singletonMap("key", null), "MSG");                 }                  @Test                 void shouldReturnTheSameInstance() {                     final Map<String, String> map = Collections.singletonMap("key", "value");                     final Map<String, String> result = Validate.notEmpty(map, "MSG");                      assertSame(map, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithGivenMessageForNullMap() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((Map<?, ?>) null, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageForEmptyMap() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(Collections.emptyMap(), "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithCharSequence {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyString() {                     Validate.notEmpty("Hi");                 }                  @Test                 void shouldReturnTheSameInstance() {                     final String str = "Hi";                     final String result = Validate.notEmpty(str);                      assertSame(str, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullCharSequence() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((CharSequence) null));                      assertEquals("The validated character sequence is empty", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyString() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty(""));                      assertEquals("The validated character sequence is empty", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyString() {                     Validate.notEmpty("Hi", "MSG");                 }                  @Test                 void shouldReturnTheSameInstance() {                     final String str = "Hi";                     final String result = Validate.notEmpty(str, "MSG");                      assertSame(str, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithGivenMessageForNullCharSequence() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.notEmpty((CharSequence) null, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageForEmptyString() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.notEmpty("", "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }     }      @Nested     class NotBlank {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionForNonEmptyString() {                 Validate.notBlank("abc");             }              @Test             void shouldNotThrowExceptionForNonEmptyStringContainingSpaces() {                 Validate.notBlank("  abc   ");             }              @Test             void shouldNotThrowExceptionForNonEmptyStringContainingWhitespaceChars() {                 Validate.notBlank(" \n \t abc \r \n ");             }              @Test             void shouldReturnNonBlankValue() {                 final String str = "abc";                 final String result = Validate.notBlank(str);                  assertSame(str, result);             }              @Test             void shouldThrowNullPointerExceptionWithDefaultMessageForNullString() {                 final NullPointerException ex = assertThrows(                         NullPointerException.class,                         () -> Validate.notBlank(null));                  assertEquals("The validated character sequence is blank", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForEmptyString() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank(""));                  assertEquals("The validated character sequence is blank", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForBlankString() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank("   "));                  assertEquals("The validated character sequence is blank", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForStringContainingOnlyWhitespaceChars() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank(" \n \t \r \n "));                  assertEquals("The validated character sequence is blank", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionForNonEmptyString() {                 Validate.notBlank("abc", "MSG");             }              @Test             void shouldNotThrowExceptionForNonEmptyStringContainingSpaces() {                 Validate.notBlank("  abc   ", "MSG");             }              @Test             void shouldNotThrowExceptionForNonEmptyStringContainingWhitespaceChars() {                 Validate.notBlank(" \n \t abc \r \n ", "MSG");             }              @Test             void shouldReturnNonBlankValue() {                 final String str = "abc";                 final String result = Validate.notBlank(str, "MSG");                  assertSame(str, result);             }              @Test             void shouldThrowNullPointerExceptionWithGivenMessageForNullString() {                 final NullPointerException ex = assertThrows(                         NullPointerException.class,                         () -> Validate.notBlank(null, "MSG"));                  assertEquals("MSG", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageForEmptyString() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank("", "MSG"));                  assertEquals("MSG", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageForBlankString() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank("   ", "MSG"));                  assertEquals("MSG", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageForStringContainingOnlyWhitespaceChars() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notBlank(" \n \t \r \n ", "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class NoNullElements {          @Nested         class WithArray {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyArray() {                     Validate.noNullElements(new String[]{"a", "b"});                 }                  @Test                 void shouldReturnSameInstance() {                     final String[] array = {"a", "b"};                     final String[] result = Validate.noNullElements(array);                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.noNullElements((Object[]) null));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForArrayWithNullElement() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.noNullElements(new String[]{"a", null}));                      assertEquals("The validated array contains null element at index: 1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyArray() {                     Validate.noNullElements(new String[]{"a", "b"}, "MSG");                 }                  @Test                 void shouldReturnSameInstance() {                     final String[] array = {"a", "b"};                     final String[] result = Validate.noNullElements(array, "MSG");                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.noNullElements((Object[]) null, "MSG"));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageForArrayWithNullElement() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.noNullElements(new String[]{"a", null}, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithCollection {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyCollection() {                     Validate.noNullElements(Collections.singleton("a"));                 }                  @Test                 void shouldReturnSameInstance() {                     final Set<String> col = Collections.singleton("a");                     final Set<String> result = Validate.noNullElements(col);                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.noNullElements((Collection<?>) null));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageForCollectionWithNullElement() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.noNullElements(Collections.singleton(null)));                      assertEquals("The validated collection contains null element at index: 0", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForNonEmptyCollection() {                     Validate.noNullElements(Collections.singleton("a"), "MSG");                 }                  @Test                 void shouldReturnSameInstance() {                     final Set<String> col = Collections.singleton("a");                     final Set<String> result = Validate.noNullElements(col, "MSG");                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.noNullElements((Collection<?>) null, "MSG"));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageForCollectionWithNullElement() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.noNullElements(Collections.singleton(null), "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }     }      @Nested     class ValidIndex {          @Nested         class WithArray {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex(new String[]{"a"}, 0);                 }                  @Test                 void shouldReturnSameInstance() {                     final String[] array = {"a"};                     final String[] result = Validate.validIndex(array, 0);                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((Object[]) null, 1));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(new String[]{"a"}, -1));                      assertEquals("The validated array index is invalid: -1", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(new String[]{"a"}, 1));                      assertEquals("The validated array index is invalid: 1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex(new String[]{"a"}, 0, "MSG");                 }                  @Test                 void shouldReturnSameInstance() {                     final String[] array = {"a"};                     final String[] result = Validate.validIndex(array, 0, "MSG");                      assertSame(array, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullArray() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((Object[]) null, 1, "MSG"));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(new String[]{"a"}, -1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(new String[]{"a"}, 1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithCollection {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex(Collections.singleton("a"), 0);                 }                  @Test                 void shouldReturnSameInstance() {                     final Set<String> col = Collections.singleton("a");                     final Set<String> result = Validate.validIndex(col, 0);                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((Collection<?>) null, 1));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(Collections.singleton("a"), -1));                      assertEquals("The validated collection index is invalid: -1", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(Collections.singleton("a"), 1));                      assertEquals("The validated collection index is invalid: 1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex(Collections.singleton("a"), 0, "MSG");                 }                  @Test                 void shouldReturnSameInstance() {                     final Set<String> col = Collections.singleton("a");                     final Set<String> result = Validate.validIndex(col, 0, "MSG");                      assertSame(col, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullCollection() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((Collection<?>) null, 1, "MSG"));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(Collections.singleton("a"), -1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex(Collections.singleton("a"), 1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithCharSequence {              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex("a", 0);                 }                  @Test                 void shouldReturnSameInstance() {                     final String str = "a";                     final String result = Validate.validIndex(str, 0);                      assertSame(str, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultForNullString() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((String) null, 1));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex("a", -1));                      assertEquals("The validated character sequence index is invalid: -1", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithDefaultMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex("a", 1));                      assertEquals("The validated character sequence index is invalid: 1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionForValidIndex() {                     Validate.validIndex("a", 0, "MSG");                 }                  @Test                 void shouldReturnSameInstance() {                     final String str = "a";                     final String result = Validate.validIndex(str, 0, "MSG");                      assertSame(str, result);                 }                  @Test                 void shouldThrowNullPointerExceptionWithDefaultMessageForNullStr() {                     final NullPointerException ex = assertThrows(                             NullPointerException.class,                             () -> Validate.validIndex((String) null, 1, "MSG"));                      assertEquals("The validated object is null", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForNegativeIndex() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex("a", -1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIndexOutOfBoundsExceptionWithGivenMessageForIndexOutOfBounds() {                     final IndexOutOfBoundsException ex = assertThrows(                             IndexOutOfBoundsException.class,                             () -> Validate.validIndex("a", 1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }     }      @Nested     class MatchesPattern {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionWhenStringMatchesPattern() {                 Validate.matchesPattern("hi", "[a-z]*");             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenStringDoesNotMatchPattern() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.matchesPattern("hi", "[0-9]*"));                  assertEquals("The string hi does not match the pattern [0-9]*", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionWhenStringMatchesPattern() {                 Validate.matchesPattern("hi", "[a-z]*", "MSG");             }              @Test             void shouldThrowIllegalArgumentExceptionWhenStringDoesNotMatchPattern() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.matchesPattern("hi", "[0-9]*", "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class NotNaN {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionForNumber() {                 Validate.notNaN(0.0);             }              @Test             void shouldNotThrowExceptionForPositiveInfinity() {                 Validate.notNaN(Double.POSITIVE_INFINITY);             }              @Test             void shouldNotThrowExceptionForNegativeInfinity() {                 Validate.notNaN(Double.NEGATIVE_INFINITY);             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForNaN() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notNaN(Double.NaN));                  assertEquals("The validated value is not a number", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionForNumber() {                 Validate.notNaN(0.0, "MSG");             }              @Test             void shouldNotThrowExceptionForPositiveInfinity() {                 Validate.notNaN(Double.POSITIVE_INFINITY, "MSG");             }              @Test             void shouldNotThrowExceptionForNegativeInfinity() {                 Validate.notNaN(Double.NEGATIVE_INFINITY, "MSG");             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageForNaN() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.notNaN(Double.NaN, "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class Finite {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionForFiniteValue() {                 Validate.finite(0.0);             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForPositiveInfinity() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.POSITIVE_INFINITY));                  assertEquals("The value is invalid: Infinity", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForNegativeInfinity() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.NEGATIVE_INFINITY));                  assertEquals("The value is invalid: -Infinity", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForNaN() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.NaN));                  assertEquals("The value is invalid: NaN", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionForFiniteValue() {                 Validate.finite(0.0, "MSG");             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForPositiveInfinity() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.POSITIVE_INFINITY, "MSG"));                  assertEquals("MSG", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForNegativeInfinity() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.NEGATIVE_INFINITY, "MSG"));                  assertEquals("MSG", ex.getMessage());             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageForNaN() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.finite(Double.NaN, "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class InclusiveBetween {          @Nested         class WithComparable {              private static final String LOWER_BOUND = "1";             private static final String UPPER_BOUND = "3";              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "2");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND);                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND);                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "0"));                      assertEquals("The value 0 is not in the specified inclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "4"));                      assertEquals("The value 4 is not in the specified inclusive range of 1 to 3", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "2", "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "0", "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, "4", "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithLong {              private static final long LOWER_BOUND = 1;             private static final long UPPER_BOUND = 3;              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2);                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND);                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND);                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0));                      assertEquals("The value 0 is not in the specified inclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4));                      assertEquals("The value 4 is not in the specified inclusive range of 1 to 3", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2, "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithDouble {              private static final double LOWER_BOUND = 0.1;             private static final double UPPER_BOUND = 3.1;              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2.1);                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND);                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND);                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0.01));                      assertEquals("The value 0.01 is not in the specified inclusive range of 0.1 to 3.1", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4.1));                      assertEquals("The value 4.1 is not in the specified inclusive range of 0.1 to 3.1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2.1, "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsLowerBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG");                 }                  @Test                 void shouldNotThrowExceptionWhenValueIsUpperBound() {                     Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0.01, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.inclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4.1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }     }      @Nested     class ExclusiveBetween {          @Nested         class WithComparable {              private static final String LOWER_BOUND = "1";             private static final String UPPER_BOUND = "3";              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "2");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND));                      assertEquals("The value 1 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND));                      assertEquals("The value 3 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "0"));                      assertEquals("The value 0 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "4"));                      assertEquals("The value 4 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "2", "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "0", "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, "4", "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithLong {              private static final long LOWER_BOUND = 1;             private static final long UPPER_BOUND = 3;              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2);                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND));                      assertEquals("The value 1 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND));                      assertEquals("The value 3 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0));                      assertEquals("The value 0 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4));                      assertEquals("The value 4 is not in the specified exclusive range of 1 to 3", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2, "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }          @Nested         class WithDouble {              private static final double LOWER_BOUND = 0.1;             private static final double UPPER_BOUND = 3.1;              @Nested             class WithoutMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2.1);                 }                  @Test                 void shouldThrowIllegalArgumentExcdeptionWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND));                      assertEquals("The value 0.1 is not in the specified exclusive range of 0.1 to 3.1", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExcdeptionWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND));                      assertEquals("The value 3.1 is not in the specified exclusive range of 0.1 to 3.1", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0.01));                      assertEquals("The value 0.01 is not in the specified exclusive range of 0.1 to 3.1", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4.1));                      assertEquals("The value 4.1 is not in the specified exclusive range of 0.1 to 3.1", ex.getMessage());                 }             }              @Nested             class WithMessage {                  @Test                 void shouldNotThrowExceptionWhenValueIsBetweenBounds() {                     Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2.1, "MSG");                 }                  @Test                 void shouldThrowIllegalArgumentExcdeptionWhenValueIsLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, LOWER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExcdeptionWhenValueIsUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, UPPER_BOUND, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsBelowLowerBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 0.01, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }                  @Test                 void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsAboveUpperBound() {                     final IllegalArgumentException ex = assertThrows(                             IllegalArgumentException.class,                             () -> Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 4.1, "MSG"));                      assertEquals("MSG", ex.getMessage());                 }             }         }     }      @Nested     class IsInstanceOf {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionWhenValueIsInstanceOfClass() {                 Validate.isInstanceOf(String.class, "hi");             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenValueIsNotInstanceOfClass() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isInstanceOf(List.class, "hi"));                  assertEquals("Expected type: java.util.List, actual: java.lang.String", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionWhenValueIsInstanceOfClass() {                 Validate.isInstanceOf(String.class, "hi", "MSG");             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsNotInstanceOfClass() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isInstanceOf(List.class, "hi", "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }          @Nested         class WithMessageTemplate {              @Test             void shouldNotThrowExceptionWhenValueIsInstanceOfClass() {                 Validate.isInstanceOf(String.class, "hi", "Error %s=%s", "Name", "Value");             }              @Test             void shouldThrowIllegalArgumentExceptionWithGivenMessageWhenValueIsNotInstanceOfClass() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isInstanceOf(List.class, "hi", "Error %s=%s", "Name", "Value"));                  assertEquals("Error Name=Value", ex.getMessage());             }         }     }      @Nested     class IsAssignable {          @Nested         class WithoutMessage {              @Test             void shouldNotThrowExceptionWhenClassIsAssignable() {                 Validate.isAssignableFrom(CharSequence.class, String.class);             }              @Test             void shouldThrowIllegalArgumentExceptionWithDefaultMessageWhenClassIsNotAssignable() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isAssignableFrom(List.class, String.class));                  assertEquals("Cannot assign a java.lang.String to a java.util.List", ex.getMessage());             }         }          @Nested         class WithMessage {              @Test             void shouldNotThrowExceptionWhenClassIsAssignable() {                 Validate.isAssignableFrom(CharSequence.class, String.class, "MSG");             }              @Test             void shouldThrowIllegalArgumentExceptionWithGiventMessageWhenClassIsNotAssignable() {                 final IllegalArgumentException ex = assertThrows(                         IllegalArgumentException.class,                         () -> Validate.isAssignableFrom(List.class, String.class, "MSG"));                  assertEquals("MSG", ex.getMessage());             }         }     }      @Nested     class UtilClassConventions {          @Test         void instancesCanBeConstrcuted() {             assertNotNull(new Validate());         }          @Test         void hasOnlyOnePublicConstructor() {             final Constructor<?>[] cons = Validate.class.getDeclaredConstructors();             assertEquals(1, cons.length);         }          @Test         void isPublicClass() {             assertTrue(Modifier.isPublic(Validate.class.getModifiers()));         }          @Test         void isNonFinalClass() {             assertFalse(Modifier.isFinal(Validate.class.getModifiers()));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.IOException; import java.io.StringWriter; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths;  import org.apache.commons.lang3.text.translate.CharSequenceTranslator; import org.apache.commons.lang3.text.translate.NumericEntityEscaper; import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link StringEscapeUtils}.  */ @Deprecated public class StringEscapeUtilsTest {     private static final String FOO = "foo";      @Test     public void testConstructor() {         assertNotNull(new StringEscapeUtils());         final Constructor<?>[] cons = StringEscapeUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(StringEscapeUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(StringEscapeUtils.class.getModifiers()));     }      @Test     public void testEscapeJava() throws IOException {         assertNull(StringEscapeUtils.escapeJava(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_JAVA.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_JAVA.translate("", null));          assertEscapeJava("empty string", "", "");         assertEscapeJava(FOO, FOO);         assertEscapeJava("tab", "\\t", "\t");         assertEscapeJava("backslash", "\\\\", "\\");         assertEscapeJava("single quote should not be escaped", "'", "'");         assertEscapeJava("\\\\\\b\\t\\r", "\\\b\t\r");         assertEscapeJava("\\u1234", "\u1234");         assertEscapeJava("\\u0234", "\u0234");         assertEscapeJava("\\u00EF", "\u00ef");         assertEscapeJava("\\u0001", "\u0001");         assertEscapeJava("Should use capitalized Unicode hex", "\\uABCD", "\uabcd");          assertEscapeJava("He didn't say, \\\"stop!\\\"",                 "He didn't say, \"stop!\"");         assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00A0",                 "This space is non-breaking:\u00a0");         assertEscapeJava("\\uABCD\\u1234\\u012C",                 "\uABCD\u1234\u012C");     }      /**      * Tests https://issues.apache.org/jira/browse/LANG-421      */     @Test     public void testEscapeJavaWithSlash() {         final String input = "String with a slash (/) in it";          final String expected = input;         final String actual = StringEscapeUtils.escapeJava(input);          /*          * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape          * in a Java string.          */         assertEquals(expected, actual);     }      private void assertEscapeJava(final String escaped, final String original) throws IOException {         assertEscapeJava(null, escaped, original);     }      private void assertEscapeJava(String message, final String expected, final String original) throws IOException {         final String converted = StringEscapeUtils.escapeJava(original);         message = "escapeJava(String) failed" + (message == null ? "" : (": " + message));         assertEquals(expected, converted, message);          final StringWriter writer = new StringWriter();         StringEscapeUtils.ESCAPE_JAVA.translate(original, writer);         assertEquals(expected, writer.toString());     }      @Test     public void testUnescapeJava() throws IOException {         assertNull(StringEscapeUtils.unescapeJava(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_JAVA.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_JAVA.translate("", null));         assertThrows(RuntimeException.class, () -> StringEscapeUtils.unescapeJava("\\u02-3"));          assertUnescapeJava("", "");         assertUnescapeJava("test", "test");         assertUnescapeJava("\ntest\b", "\\ntest\\b");         assertUnescapeJava("\u123425foo\ntest\b", "\\u123425foo\\ntest\\b");         assertUnescapeJava("'\foo\teste\r", "\\'\\foo\\teste\\r");         assertUnescapeJava("", "\\");         //foo         assertUnescapeJava("lowercase Unicode", "\uABCDx", "\\uabcdx");         assertUnescapeJava("uppercase Unicode", "\uABCDx", "\\uABCDx");         assertUnescapeJava("Unicode as final character", "\uABCD", "\\uabcd");     }      private void assertUnescapeJava(final String unescaped, final String original) throws IOException {         assertUnescapeJava(null, unescaped, original);     }      private void assertUnescapeJava(final String message, final String unescaped, final String original) throws IOException {         final String expected = unescaped;         final String actual = StringEscapeUtils.unescapeJava(original);          assertEquals(expected, actual,                 "unescape(String) failed" +                 (message == null ? "" : (": " + message)) +                 ": expected '" + StringEscapeUtils.escapeJava(expected) +                 // we escape this so we can see it in the error message                 "' actual '" + StringEscapeUtils.escapeJava(actual) + "'");          final StringWriter writer = new StringWriter();         StringEscapeUtils.UNESCAPE_JAVA.translate(original, writer);         assertEquals(unescaped, writer.toString());      }      @Test     public void testEscapeEcmaScript() {         assertNull(StringEscapeUtils.escapeEcmaScript(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_ECMASCRIPT.translate("", null));          assertEquals("He didn\\'t say, \\\"stop!\\\"", StringEscapeUtils.escapeEcmaScript("He didn't say, \"stop!\""));         assertEquals("document.getElementById(\\\"test\\\").value = \\'<script>alert(\\'aaa\\');<\\/script>\\';",                 StringEscapeUtils.escapeEcmaScript("document.getElementById(\"test\").value = '<script>alert('aaa');</script>';"));     }      @Test     public void testUnescapeEcmaScript() {         assertNull(StringEscapeUtils.escapeEcmaScript(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_ECMASCRIPT.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_ECMASCRIPT.translate("", null));          assertEquals("He didn't say, \"stop!\"", StringEscapeUtils.unescapeEcmaScript("He didn\\'t say, \\\"stop!\\\""));         assertEquals("document.getElementById(\"test\").value = '<script>alert('aaa');</script>';",                 StringEscapeUtils.unescapeEcmaScript("document.getElementById(\\\"test\\\").value = \\'<script>alert(\\'aaa\\');<\\/script>\\';"));     }       // HTML and XML     //--------------------------------------------------------------      private static final String[][] HTML_ESCAPES = {         {"no escaping", "plain text", "plain text"},         {"no escaping", "plain text", "plain text"},         {"empty string", "", ""},         {"null", null, null},         {"ampersand", "bread &amp; butter", "bread & butter"},         {"quotes", "&quot;bread&quot; &amp; butter", "\"bread\" & butter"},         {"final character only", "greater than &gt;", "greater than >"},         {"first character only", "&lt; less than", "< less than"},         {"apostrophe", "Huntington's chorea", "Huntington's chorea"},         {"languages", "English,Fran&ccedil;ais,\u65E5\u672C\u8A9E (nihongo)", "English,Fran\u00E7ais,\u65E5\u672C\u8A9E (nihongo)"},         {"8-bit ascii shouldn't number-escape", "\u0080\u009F", "\u0080\u009F"},     };      @Test     public void testEscapeHtml() throws IOException {         for (final String[] element : HTML_ESCAPES) {             final String message = element[0];             final String expected = element[1];             final String original = element[2];             assertEquals(expected, StringEscapeUtils.escapeHtml4(original), message);             final StringWriter sw = new StringWriter();             StringEscapeUtils.ESCAPE_HTML4.translate(original, sw);             final String actual = original == null ? null : sw.toString();             assertEquals(expected, actual, message);         }     }      @Test     public void testUnescapeHtml4() throws IOException {         for (final String[] element : HTML_ESCAPES) {             final String message = element[0];             final String expected = element[2];             final String original = element[1];             assertEquals(expected, StringEscapeUtils.unescapeHtml4(original), message);              final StringWriter sw = new StringWriter();             StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw);             final String actual = original == null ? null : sw.toString();             assertEquals(expected, actual, message);         }         // \u00E7 is a cedilla (c with wiggle under)         // note that the test string must be 7-bit-clean (Unicode escaped) or else it will compile incorrectly         // on some locales         assertEquals("Fran\u00E7ais", StringEscapeUtils.unescapeHtml4("Fran\u00E7ais"), "funny chars pass through OK");          assertEquals("Hello&;World", StringEscapeUtils.unescapeHtml4("Hello&;World"));         assertEquals("Hello&#;World", StringEscapeUtils.unescapeHtml4("Hello&#;World"));         assertEquals("Hello&# ;World", StringEscapeUtils.unescapeHtml4("Hello&# ;World"));         assertEquals("Hello&##;World", StringEscapeUtils.unescapeHtml4("Hello&##;World"));     }      @Test     public void testUnescapeHexCharsHtml() {         // Simple easy to grok test         assertEquals("\u0080\u009F", StringEscapeUtils.unescapeHtml4("&#x80;&#x9F;"), "hex number unescape");         assertEquals("\u0080\u009F", StringEscapeUtils.unescapeHtml4("&#X80;&#X9F;"), "hex number unescape");         // Test all Character values:         for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {             final Character c1 = Character.valueOf(i);             final Character c2 = Character.valueOf((char) (i+1));             final String expected = c1.toString() + c2.toString();             final String escapedC1 = "&#x" + Integer.toHexString((c1.charValue())) + ";";             final String escapedC2 = "&#x" + Integer.toHexString((c2.charValue())) + ";";             assertEquals(expected, StringEscapeUtils.unescapeHtml4(escapedC1 + escapedC2), "hex number unescape index " + (int) i);         }     }      @Test     public void testUnescapeUnknownEntity() {         assertEquals("&zzzz;", StringEscapeUtils.unescapeHtml4("&zzzz;"));     }      @Test     public void testEscapeHtmlVersions() {         assertEquals("&Beta;", StringEscapeUtils.escapeHtml4("\u0392"));         assertEquals("\u0392", StringEscapeUtils.unescapeHtml4("&Beta;"));          // TODO: refine API for escaping/unescaping specific HTML versions     }      @Test     public void testEscapeXml() throws Exception {         assertEquals("&lt;abc&gt;", StringEscapeUtils.escapeXml("<abc>"));         assertEquals("<abc>", StringEscapeUtils.unescapeXml("&lt;abc&gt;"));          assertEquals("\u00A1", StringEscapeUtils.escapeXml("\u00A1"), "XML should not escape >0x7f values");         assertEquals("\u00A0", StringEscapeUtils.unescapeXml("&#160;"), "XML should be able to unescape >0x7f values");         assertEquals("\u00A0", StringEscapeUtils.unescapeXml("&#0160;"),                 "XML should be able to unescape >0x7f values with one leading 0");         assertEquals("\u00A0", StringEscapeUtils.unescapeXml("&#00160;"),                 "XML should be able to unescape >0x7f values with two leading 0s");         assertEquals("\u00A0", StringEscapeUtils.unescapeXml("&#000160;"),                 "XML should be able to unescape >0x7f values with three leading 0s");          assertEquals("ain't", StringEscapeUtils.unescapeXml("ain&apos;t"));         assertEquals("ain&apos;t", StringEscapeUtils.escapeXml("ain't"));         assertEquals("", StringEscapeUtils.escapeXml(""));         assertNull(StringEscapeUtils.escapeXml(null));         assertNull(StringEscapeUtils.unescapeXml(null));          StringWriter sw = new StringWriter();         StringEscapeUtils.ESCAPE_XML.translate("<abc>", sw);         assertEquals("&lt;abc&gt;", sw.toString(), "XML was escaped incorrectly");          sw = new StringWriter();         StringEscapeUtils.UNESCAPE_XML.translate("&lt;abc&gt;", sw);         assertEquals("<abc>", sw.toString(), "XML was unescaped incorrectly");     }      @Test     public void testEscapeXml10() {         assertEquals("a&lt;b&gt;c&quot;d&apos;e&amp;f", StringEscapeUtils.escapeXml10("a<b>c\"d'e&f"));         assertEquals("a\tb\rc\nd", StringEscapeUtils.escapeXml10("a\tb\rc\nd"), "XML 1.0 should not escape \t \n \r");         assertEquals("ab", StringEscapeUtils.escapeXml10("a\u0000\u0001\u0008\u000b\u000c\u000e\u001fb"),                 "XML 1.0 should omit most #x0-x8 | #xb | #xc | #xe-#x19");         assertEquals("a\ud7ff  \ue000b", StringEscapeUtils.escapeXml10("a\ud7ff\ud800 \udfff \ue000b"),                 "XML 1.0 should omit #xd800-#xdfff");         assertEquals("a\ufffdb", StringEscapeUtils.escapeXml10("a\ufffd\ufffe\uffffb"),                 "XML 1.0 should omit #xfffe | #xffff");         assertEquals("a\u007e&#127;&#132;\u0085&#134;&#159;\u00a0b",                 StringEscapeUtils.escapeXml10("a\u007e\u007f\u0084\u0085\u0086\u009f\u00a0b"),                 "XML 1.0 should escape #x7f-#x84 | #x86 - #x9f, for XML 1.1 compatibility");     }      @Test     public void testEscapeXml11() {         assertEquals("a&lt;b&gt;c&quot;d&apos;e&amp;f", StringEscapeUtils.escapeXml11("a<b>c\"d'e&f"));         assertEquals("a\tb\rc\nd", StringEscapeUtils.escapeXml11("a\tb\rc\nd"), "XML 1.1 should not escape \t \n \r");         assertEquals("ab", StringEscapeUtils.escapeXml11("a\u0000b"), "XML 1.1 should omit #x0");         assertEquals("a&#1;&#8;&#11;&#12;&#14;&#31;b",                 StringEscapeUtils.escapeXml11("a\u0001\u0008\u000b\u000c\u000e\u001fb"),                 "XML 1.1 should escape #x1-x8 | #xb | #xc | #xe-#x19");         assertEquals("a\u007e&#127;&#132;\u0085&#134;&#159;\u00a0b",                 StringEscapeUtils.escapeXml11("a\u007e\u007f\u0084\u0085\u0086\u009f\u00a0b"),                 "XML 1.1 should escape #x7F-#x84 | #x86-#x9F");         assertEquals("a\ud7ff  \ue000b", StringEscapeUtils.escapeXml11("a\ud7ff\ud800 \udfff \ue000b"),                 "XML 1.1 should omit #xd800-#xdfff");         assertEquals("a\ufffdb", StringEscapeUtils.escapeXml11("a\ufffd\ufffe\uffffb"),                 "XML 1.1 should omit #xfffe | #xffff");     }      /**      * Tests Supplementary characters.      * <p>      * From http://www.w3.org/International/questions/qa-escapes      * </p>      * <blockquote>      * Supplementary characters are those Unicode characters that have code points higher than the characters in      * the Basic Multilingual Plane (BMP). In UTF-16 a supplementary character is encoded using two 16-bit surrogate code points from the      * BMP. Because of this, some people think that supplementary characters need to be represented using two escapes, but this is incorrect      * - you must use the single, code point value for that character. For example, use &amp;&#35;x233B4&#59; rather than      * &amp;&#35;xD84C&#59;&amp;&#35;xDFB4&#59;.      * </blockquote>      * @see <a href="http://www.w3.org/International/questions/qa-escapes">Using character escapes in markup and CSS</a>      * @see <a href="https://issues.apache.org/jira/browse/LANG-728">LANG-728</a>      */     @Test     public void testEscapeXmlSupplementaryCharacters() {         final CharSequenceTranslator escapeXml =             StringEscapeUtils.ESCAPE_XML.with( NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE) );          assertEquals("&#144308;", escapeXml.translate("\uD84C\uDFB4"),                 "Supplementary character must be represented using a single escape");          assertEquals("a b c &#144308;", escapeXml.translate("a b c \uD84C\uDFB4"),                 "Supplementary characters mixed with basic characters should be encoded correctly");     }      @Test     public void testEscapeXmlAllCharacters() {         // http://www.w3.org/TR/xml/#charsets says:         // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character,         // excluding the surrogate blocks, FFFE, and FFFF. */         final CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML                 .with(NumericEntityEscaper.below(9), NumericEntityEscaper.between(0xB, 0xC), NumericEntityEscaper.between(0xE, 0x19),                         NumericEntityEscaper.between(0xD800, 0xDFFF), NumericEntityEscaper.between(0xFFFE, 0xFFFF), NumericEntityEscaper.above(0x110000));          assertEquals("&#0;&#1;&#2;&#3;&#4;&#5;&#6;&#7;&#8;", escapeXml.translate("\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0008"));         assertEquals("\t", escapeXml.translate("\t")); // 0x9         assertEquals("\n", escapeXml.translate("\n")); // 0xA         assertEquals("&#11;&#12;", escapeXml.translate("\u000B\u000C"));         assertEquals("\r", escapeXml.translate("\r")); // 0xD         assertEquals("Hello World! Ain&apos;t this great?", escapeXml.translate("Hello World! Ain't this great?"));         assertEquals("&#14;&#15;&#24;&#25;", escapeXml.translate("\u000E\u000F\u0018\u0019"));     }      /**      * Reverse of the above.      *      * @see <a href="https://issues.apache.org/jira/browse/LANG-729">LANG-729</a>      */     @Test     public void testUnescapeXmlSupplementaryCharacters() {         assertEquals("\uD84C\uDFB4", StringEscapeUtils.unescapeXml("&#144308;"),                 "Supplementary character must be represented using a single escape");          assertEquals("a b c \uD84C\uDFB4", StringEscapeUtils.unescapeXml("a b c &#144308;"),                 "Supplementary characters mixed with basic characters should be decoded correctly");     }      // Tests issue #38569     // https://issues.apache.org/bugzilla/show_bug.cgi?id=38569     @Test     public void testStandaloneAmphersand() {         assertEquals("<P&O>", StringEscapeUtils.unescapeHtml4("&lt;P&O&gt;"));         assertEquals("test & <", StringEscapeUtils.unescapeHtml4("test & &lt;"));         assertEquals("<P&O>", StringEscapeUtils.unescapeXml("&lt;P&O&gt;"));         assertEquals("test & <", StringEscapeUtils.unescapeXml("test & &lt;"));     }      @Test     public void testLang313() {         assertEquals("& &", StringEscapeUtils.unescapeHtml4("& &amp;"));     }      @Test     public void testEscapeCsvString() {         assertEquals("foo.bar",            StringEscapeUtils.escapeCsv("foo.bar"));         assertEquals("\"foo,bar\"",        StringEscapeUtils.escapeCsv("foo,bar"));         assertEquals("\"foo\nbar\"",       StringEscapeUtils.escapeCsv("foo\nbar"));         assertEquals("\"foo\rbar\"",       StringEscapeUtils.escapeCsv("foo\rbar"));         assertEquals("\"foo\"\"bar\"",     StringEscapeUtils.escapeCsv("foo\"bar"));         assertEquals("foo\uD84C\uDFB4bar", StringEscapeUtils.escapeCsv("foo\uD84C\uDFB4bar"));         assertEquals("",   StringEscapeUtils.escapeCsv(""));         assertNull(StringEscapeUtils.escapeCsv(null));     }      @Test     public void testEscapeCsvWriter() throws Exception {         checkCsvEscapeWriter("foo.bar",            "foo.bar");         checkCsvEscapeWriter("\"foo,bar\"",        "foo,bar");         checkCsvEscapeWriter("\"foo\nbar\"",       "foo\nbar");         checkCsvEscapeWriter("\"foo\rbar\"",       "foo\rbar");         checkCsvEscapeWriter("\"foo\"\"bar\"",     "foo\"bar");         checkCsvEscapeWriter("foo\uD84C\uDFB4bar", "foo\uD84C\uDFB4bar");         checkCsvEscapeWriter("", null);         checkCsvEscapeWriter("", "");     }      private void checkCsvEscapeWriter(final String expected, final String value) throws IOException {         final StringWriter writer = new StringWriter();         StringEscapeUtils.ESCAPE_CSV.translate(value, writer);         assertEquals(expected, writer.toString());     }      @Test     public void testEscapeCsvIllegalStateException() {         final StringWriter writer = new StringWriter();         assertThrows(IllegalStateException.class, () -> StringEscapeUtils.ESCAPE_CSV.translate("foo", -1, writer));     }      @Test     public void testUnescapeCsvString() {         assertEquals("foo.bar",              StringEscapeUtils.unescapeCsv("foo.bar"));         assertEquals("foo,bar",              StringEscapeUtils.unescapeCsv("\"foo,bar\""));         assertEquals("foo\nbar",             StringEscapeUtils.unescapeCsv("\"foo\nbar\""));         assertEquals("foo\rbar",             StringEscapeUtils.unescapeCsv("\"foo\rbar\""));         assertEquals("foo\"bar",             StringEscapeUtils.unescapeCsv("\"foo\"\"bar\""));         assertEquals("foo\uD84C\uDFB4bar",   StringEscapeUtils.unescapeCsv("foo\uD84C\uDFB4bar"));         assertEquals("",   StringEscapeUtils.unescapeCsv(""));         assertNull(StringEscapeUtils.unescapeCsv(null));          assertEquals("\"foo.bar\"",          StringEscapeUtils.unescapeCsv("\"foo.bar\""));     }      @Test     public void testUnescapeCsvWriter() throws Exception {         checkCsvUnescapeWriter("foo.bar",            "foo.bar");         checkCsvUnescapeWriter("foo,bar",            "\"foo,bar\"");         checkCsvUnescapeWriter("foo\nbar",           "\"foo\nbar\"");         checkCsvUnescapeWriter("foo\rbar",           "\"foo\rbar\"");         checkCsvUnescapeWriter("foo\"bar",           "\"foo\"\"bar\"");         checkCsvUnescapeWriter("foo\uD84C\uDFB4bar", "foo\uD84C\uDFB4bar");         checkCsvUnescapeWriter("", null);         checkCsvUnescapeWriter("", "");          checkCsvUnescapeWriter("\"foo.bar\"",        "\"foo.bar\"");     }      private void checkCsvUnescapeWriter(final String expected, final String value) throws IOException {         final StringWriter writer = new StringWriter();         StringEscapeUtils.UNESCAPE_CSV.translate(value, writer);         assertEquals(expected, writer.toString());     }      @Test     public void testUnescapeCsvIllegalStateException() {         final StringWriter writer = new StringWriter();         assertThrows(IllegalStateException.class, () -> StringEscapeUtils.UNESCAPE_CSV.translate("foo", -1, writer));     }      /**      * Tests // https://issues.apache.org/jira/browse/LANG-480      */     @Test     public void testEscapeHtmlHighUnicode() {         // this is the utf8 representation of the character:         // COUNTING ROD UNIT DIGIT THREE         // in Unicode         // codepoint: U+1D362         final byte[] data = new byte[] { (byte) 0xF0, (byte) 0x9D, (byte) 0x8D, (byte) 0xA2 };          final String original = new String(data, StandardCharsets.UTF_8);          final String escaped = StringEscapeUtils.escapeHtml4( original );         assertEquals(original, escaped, "High Unicode should not have been escaped");          final String unescaped = StringEscapeUtils.unescapeHtml4( escaped );         assertEquals(original, unescaped, "High Unicode should have been unchanged");  // TODO: I think this should hold, needs further investigation //        String unescapedFromEntity = StringEscapeUtils.unescapeHtml4( "&#119650;" ); //        assertEquals( "High Unicode should have been unescaped", original, unescapedFromEntity);     }      /**      * Tests https://issues.apache.org/jira/browse/LANG-339      */     @Test     public void testEscapeHiragana() {         // Some random Japanese Unicode characters         final String original = "\u304B\u304C\u3068";         final String escaped = StringEscapeUtils.escapeHtml4(original);         assertEquals(original, escaped,                 "Hiragana character Unicode behavior should not be being escaped by escapeHtml4");          final String unescaped = StringEscapeUtils.unescapeHtml4( escaped );          assertEquals(escaped, unescaped, "Hiragana character Unicode behavior has changed - expected no unescaping");     }      /**      * Tests https://issues.apache.org/jira/browse/LANG-708      *      * @throws IOException      *             if an I/O error occurs      */     @Test     public void testLang708() throws IOException {         final byte[] inputBytes = Files.readAllBytes(Paths.get("src/test/resources/lang-708-input.txt"));         final String input = new String(inputBytes, StandardCharsets.UTF_8);         final String escaped = StringEscapeUtils.escapeEcmaScript(input);         // just the end:         assertTrue(escaped.endsWith("}]"), escaped);         // a little more:         assertTrue(escaped.endsWith("\"valueCode\\\":\\\"\\\"}]"), escaped);     }      /**      * Tests https://issues.apache.org/jira/browse/LANG-720      */     @Test     public void testLang720() {         final String input = "\ud842\udfb7" + "A";         final String escaped = StringEscapeUtils.escapeXml(input);         assertEquals(input, escaped);     }      /**      * Tests https://issues.apache.org/jira/browse/LANG-911      */     @Test     public void testLang911() {         final String bellsTest = "\ud83d\udc80\ud83d\udd14";         final String value = StringEscapeUtils.escapeJava(bellsTest);         final String valueTest = StringEscapeUtils.unescapeJava(value);         assertEquals(bellsTest, valueTest);     }      @Test     public void testEscapeJson() {         assertNull(StringEscapeUtils.escapeJson(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_JSON.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.ESCAPE_JSON.translate("", null));          assertEquals("He didn't say, \\\"stop!\\\"", StringEscapeUtils.escapeJson("He didn't say, \"stop!\""));          final String expected = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/";         final String input ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/";          assertEquals(expected, StringEscapeUtils.escapeJson(input));     }      @Test     public void testUnescapeJson() {         assertNull(StringEscapeUtils.unescapeJson(null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_JSON.translate(null, null));         assertThrows(IllegalArgumentException.class, () -> StringEscapeUtils.UNESCAPE_JSON.translate("", null));          assertEquals("He didn't say, \"stop!\"", StringEscapeUtils.unescapeJson("He didn't say, \\\"stop!\\\""));          final String expected ="\"foo\" isn't \"bar\". specials: \b\r\n\f\t\\/";         final String input = "\\\"foo\\\" isn't \\\"bar\\\". specials: \\b\\r\\n\\f\\t\\\\\\/";          assertEquals(expected, StringEscapeUtils.unescapeJson(input));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - IsX methods  */ public class StringUtilsIsTest  {      @Test     public void testIsAlpha() {         assertFalse(StringUtils.isAlpha(null));         assertFalse(StringUtils.isAlpha(""));         assertFalse(StringUtils.isAlpha(" "));         assertTrue(StringUtils.isAlpha("a"));         assertTrue(StringUtils.isAlpha("A"));         assertTrue(StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertFalse(StringUtils.isAlpha("ham kso"));         assertFalse(StringUtils.isAlpha("1"));         assertFalse(StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isAlpha("_"));         assertFalse(StringUtils.isAlpha("hkHKHik*khbkuh"));     }      @Test     public void testIsAlphanumeric() {         assertFalse(StringUtils.isAlphanumeric(null));         assertFalse(StringUtils.isAlphanumeric(""));         assertFalse(StringUtils.isAlphanumeric(" "));         assertTrue(StringUtils.isAlphanumeric("a"));         assertTrue(StringUtils.isAlphanumeric("A"));         assertTrue(StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertFalse(StringUtils.isAlphanumeric("ham kso"));         assertTrue(StringUtils.isAlphanumeric("1"));         assertTrue(StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isAlphanumeric("_"));         assertFalse(StringUtils.isAlphanumeric("hkHKHik*khbkuh"));     }      @Test     public void testIsAlphanumericSpace() {         assertFalse(StringUtils.isAlphanumericSpace(null));         assertTrue(StringUtils.isAlphanumericSpace(""));         assertTrue(StringUtils.isAlphanumericSpace(" "));         assertTrue(StringUtils.isAlphanumericSpace("a"));         assertTrue(StringUtils.isAlphanumericSpace("A"));         assertTrue(StringUtils.isAlphanumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertTrue(StringUtils.isAlphanumericSpace("ham kso"));         assertTrue(StringUtils.isAlphanumericSpace("1"));         assertTrue(StringUtils.isAlphanumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isAlphanumericSpace("_"));         assertFalse(StringUtils.isAlphanumericSpace("hkHKHik*khbkuh"));     }      @Test     public void testIsAlphaspace() {         assertFalse(StringUtils.isAlphaSpace(null));         assertTrue(StringUtils.isAlphaSpace(""));         assertTrue(StringUtils.isAlphaSpace(" "));         assertTrue(StringUtils.isAlphaSpace("a"));         assertTrue(StringUtils.isAlphaSpace("A"));         assertTrue(StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertTrue(StringUtils.isAlphaSpace("ham kso"));         assertFalse(StringUtils.isAlphaSpace("1"));         assertFalse(StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isAlphaSpace("_"));         assertFalse(StringUtils.isAlphaSpace("hkHKHik*khbkuh"));     }      @Test     public void testIsAsciiPrintable_String() {         assertFalse(StringUtils.isAsciiPrintable(null));         assertTrue(StringUtils.isAsciiPrintable(""));         assertTrue(StringUtils.isAsciiPrintable(" "));         assertTrue(StringUtils.isAsciiPrintable("a"));         assertTrue(StringUtils.isAsciiPrintable("A"));         assertTrue(StringUtils.isAsciiPrintable("1"));         assertTrue(StringUtils.isAsciiPrintable("Ceki"));         assertTrue(StringUtils.isAsciiPrintable("!ab2c~"));         assertTrue(StringUtils.isAsciiPrintable("1000"));         assertTrue(StringUtils.isAsciiPrintable("10 00"));         assertFalse(StringUtils.isAsciiPrintable("10\t00"));         assertTrue(StringUtils.isAsciiPrintable("10.00"));         assertTrue(StringUtils.isAsciiPrintable("10,00"));         assertTrue(StringUtils.isAsciiPrintable("!ab-c~"));         assertTrue(StringUtils.isAsciiPrintable("hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,kug"));         assertTrue(StringUtils.isAsciiPrintable("\u0020"));         assertTrue(StringUtils.isAsciiPrintable("\u0021"));         assertTrue(StringUtils.isAsciiPrintable("\u007e"));         assertFalse(StringUtils.isAsciiPrintable("\u007f"));         assertTrue(StringUtils.isAsciiPrintable("G?lc?"));         assertTrue(StringUtils.isAsciiPrintable("=?iso-8859-1?Q?G=FClc=FC?="));         assertFalse(StringUtils.isAsciiPrintable("G\u00fclc\u00fc"));     }      @Test     public void testIsNumeric() {         assertFalse(StringUtils.isNumeric(null));         assertFalse(StringUtils.isNumeric(""));         assertFalse(StringUtils.isNumeric(" "));         assertFalse(StringUtils.isNumeric("a"));         assertFalse(StringUtils.isNumeric("A"));         assertFalse(StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertFalse(StringUtils.isNumeric("ham kso"));         assertTrue(StringUtils.isNumeric("1"));         assertTrue(StringUtils.isNumeric("1000"));         assertTrue(StringUtils.isNumeric("\u0967\u0968\u0969"));         assertFalse(StringUtils.isNumeric("\u0967\u0968 \u0969"));         assertFalse(StringUtils.isNumeric("2.3"));         assertFalse(StringUtils.isNumeric("10 00"));         assertFalse(StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isNumeric("_"));         assertFalse(StringUtils.isNumeric("hkHKHik*khbkuh"));         assertFalse(StringUtils.isNumeric("+123"));         assertFalse(StringUtils.isNumeric("-123"));     }      @Test     public void testIsNumericSpace() {         assertFalse(StringUtils.isNumericSpace(null));         assertTrue(StringUtils.isNumericSpace(""));         assertTrue(StringUtils.isNumericSpace(" "));         assertFalse(StringUtils.isNumericSpace("a"));         assertFalse(StringUtils.isNumericSpace("A"));         assertFalse(StringUtils.isNumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));         assertFalse(StringUtils.isNumericSpace("ham kso"));         assertTrue(StringUtils.isNumericSpace("1"));         assertTrue(StringUtils.isNumericSpace("1000"));         assertFalse(StringUtils.isNumericSpace("2.3"));         assertTrue(StringUtils.isNumericSpace("10 00"));         assertTrue(StringUtils.isNumericSpace("\u0967\u0968\u0969"));         assertTrue(StringUtils.isNumericSpace("\u0967\u0968 \u0969"));         assertFalse(StringUtils.isNumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));         assertFalse(StringUtils.isNumericSpace("_"));         assertFalse(StringUtils.isNumericSpace("hkHKHik*khbkuh"));     }      @Test     public void testIsWhitespace() {         assertFalse(StringUtils.isWhitespace(null));         assertTrue(StringUtils.isWhitespace(""));         assertTrue(StringUtils.isWhitespace(" "));         assertTrue(StringUtils.isWhitespace("\t \n \t"));         assertFalse(StringUtils.isWhitespace("\t aa\n \t"));         assertTrue(StringUtils.isWhitespace(" "));         assertFalse(StringUtils.isWhitespace(" a "));         assertFalse(StringUtils.isWhitespace("a  "));         assertFalse(StringUtils.isWhitespace("  a"));         assertFalse(StringUtils.isWhitespace("aba"));         assertTrue(StringUtils.isWhitespace(StringUtilsTest.WHITESPACE));         assertFalse(StringUtils.isWhitespace(StringUtilsTest.NON_WHITESPACE));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Collections; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  import org.apache.commons.lang3.ClassUtils.Interfaces; import org.apache.commons.lang3.reflect.testbed.GenericConsumer; import org.apache.commons.lang3.reflect.testbed.GenericParent; import org.apache.commons.lang3.reflect.testbed.StringParameterizedChild; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.ClassUtils}.  */ @SuppressWarnings("boxing") // JUnit4 does not support primitive equality testing apart from long public class ClassUtilsTest  {      private static class CX implements IB, IA, IE {         // empty     }      private static class CY extends CX implements IB, IC {         // empty     }      private interface IA {         // empty     }      private interface IB {         // empty     }      private interface IC extends ID, IE {         // empty     }      private interface ID {         // empty     }      private interface IE extends IF {         // empty     }      private interface IF {         // empty     }      private static class Inner {         private class DeeplyNested {             // empty         }     }      private void assertGetClassReturnsClass( final Class<?> c ) throws Exception {         assertEquals( c, ClassUtils.getClass( c.getName() ) );     }      private void assertGetClassThrowsClassNotFound( final String className ) {         assertGetClassThrowsException( className, ClassNotFoundException.class );     }      private void assertGetClassThrowsException(final String className, final Class<? extends Exception> exceptionType) {         assertThrows(exceptionType,                 () -> ClassUtils.getClass(className),                 "ClassUtils.getClass() should fail with an exception of type " + exceptionType.getName() + " when given class name \"" + className + "\"." );     }      private void assertGetClassThrowsNullPointerException( final String className ) {         assertGetClassThrowsException( className, NullPointerException.class );     }      @Test     public void test_convertClassesToClassNames_List() {         final List<Class<?>> list = new ArrayList<>();         List<String> result = ClassUtils.convertClassesToClassNames(list);         assertEquals(0, result.size());          list.add(String.class);         list.add(null);         list.add(Object.class);         result = ClassUtils.convertClassesToClassNames(list);         assertEquals(3, result.size());         assertEquals("java.lang.String", result.get(0));         assertNull(result.get(1));         assertEquals("java.lang.Object", result.get(2));          @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element         final List<Object> olist = (List<Object>) (List<?>) list;         olist.add(new Object());         assertThrows(ClassCastException.class,                 () -> ClassUtils.convertClassesToClassNames(list),                 "Should not have been able to convert list");         assertNull(ClassUtils.convertClassesToClassNames(null));     }      // -------------------------------------------------------------------------     @Test     public void test_convertClassNamesToClasses_List() {         final List<String> list = new ArrayList<>();         List<Class<?>> result = ClassUtils.convertClassNamesToClasses(list);         assertEquals(0, result.size());          list.add("java.lang.String");         list.add("java.lang.xxx");         list.add("java.lang.Object");         result = ClassUtils.convertClassNamesToClasses(list);         assertEquals(3, result.size());         assertEquals(String.class, result.get(0));         assertNull(result.get(1));         assertEquals(Object.class, result.get(2));          @SuppressWarnings("unchecked") // test what happens when non-generic code adds wrong type of element         final List<Object> olist = (List<Object>) (List<?>) list;         olist.add(new Object());         assertThrows(ClassCastException.class,                 () -> ClassUtils.convertClassNamesToClasses(list),                 "Should not have been able to convert list");         assertNull(ClassUtils.convertClassNamesToClasses(null));     }      // -------------------------------------------------------------------------     @Test     public void test_getAbbreviatedName_Class() {         assertEquals("", ClassUtils.getAbbreviatedName((Class<?>) null, 1));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName(String.class, 1));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName(String.class, 5));         assertEquals("o.a.c.l.ClassUtils", ClassUtils.getAbbreviatedName(ClassUtils.class, 18));         assertEquals("j.lang.String", ClassUtils.getAbbreviatedName(String.class, 13));         assertEquals("j.lang.String", ClassUtils.getAbbreviatedName(String.class, 15));         assertEquals("java.lang.String", ClassUtils.getAbbreviatedName(String.class, 20));     }      /**      * Test that in case the required length is larger than the name and thus there is no need for any shortening      * then the returned string object is the same as the one passed as argument. Note, however, that this is      * tested as an internal implementation detail, but it is not a guaranteed feature of the implementation.      */     @Test     @DisplayName("When the length hint is longer than the actual length then the same String object is returned")     public void test_getAbbreviatedName_TooLongHint(){         final String className = "java.lang.String";         Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()+1));         Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()));     }      @Test     @DisplayName("When the desired length is negative then exception is thrown")     public void test_getAbbreviatedName_Class_NegativeLen() {         assertThrows(IllegalArgumentException.class, () -> ClassUtils.getAbbreviatedName(String.class, -10));     }      @Test     @DisplayName("When the desired length is zero then exception is thrown")     public void test_getAbbreviatedName_Class_ZeroLen() {         assertThrows(IllegalArgumentException.class, () -> ClassUtils.getAbbreviatedName(String.class, 0));     }      @Test     public void test_getAbbreviatedName_String() {         assertEquals("", ClassUtils.getAbbreviatedName((String) null, 1));         assertEquals("", ClassUtils.getAbbreviatedName("", 1));         assertEquals("WithoutPackage", ClassUtils.getAbbreviatedName("WithoutPackage", 1));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName("java.lang.String", 1));         assertEquals("o.a.c.l.ClassUtils", ClassUtils.getAbbreviatedName("org.apache.commons.lang3.ClassUtils", 18));         assertEquals("org.apache.commons.lang3.ClassUtils",                               ClassUtils.getAbbreviatedName("org.apache.commons.lang3.ClassUtils",                               "org.apache.commons.lang3.ClassUtils".length()));         assertEquals("o.a.c.l.ClassUtils", ClassUtils.getAbbreviatedName("o.a.c.l.ClassUtils", 18));         assertEquals("o..c.l.ClassUtils", ClassUtils.getAbbreviatedName("o..c.l.ClassUtils", 18));         assertEquals(".", ClassUtils.getAbbreviatedName(".", 18));         assertEquals(".", ClassUtils.getAbbreviatedName(".", 1));         assertEquals("..", ClassUtils.getAbbreviatedName("..", 1));         assertEquals("...", ClassUtils.getAbbreviatedName("...", 2));         assertEquals("...", ClassUtils.getAbbreviatedName("...", 3));         assertEquals("java.lang.String", ClassUtils.getAbbreviatedName("java.lang.String", Integer.MAX_VALUE));         assertEquals("j.lang.String", ClassUtils.getAbbreviatedName("java.lang.String", "j.lang.String".length()));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName("java.lang.String", "j.lang.String".length() - 1));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName("java.lang.String", "j.l.String".length()));         assertEquals("j.l.String", ClassUtils.getAbbreviatedName("java.lang.String", "j.l.String".length() - 1));     }      @Test     public void test_getAllInterfaces_Class() {         final List<?> list = ClassUtils.getAllInterfaces(CY.class);         assertEquals(6, list.size());         assertEquals(IB.class, list.get(0));         assertEquals(IC.class, list.get(1));         assertEquals(ID.class, list.get(2));         assertEquals(IE.class, list.get(3));         assertEquals(IF.class, list.get(4));         assertEquals(IA.class, list.get(5));          assertNull(ClassUtils.getAllInterfaces(null));     }      // -------------------------------------------------------------------------     @Test     public void test_getAllSuperclasses_Class() {         final List<?> list = ClassUtils.getAllSuperclasses(CY.class);         assertEquals(2, list.size());         assertEquals(CX.class, list.get(0));         assertEquals(Object.class, list.get(1));          assertNull(ClassUtils.getAllSuperclasses(null));     }      @Test     public void test_getCanonicalName_Class() {         assertEquals("org.apache.commons.lang3.ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class));         assertEquals("java.util.Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class));         assertEquals("", ClassUtils.getCanonicalName((Class<?>) null));          assertEquals("java.lang.String[]", ClassUtils.getCanonicalName(String[].class));         assertEquals("java.util.Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class));          // Primitives         assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class));         assertEquals("byte", ClassUtils.getCanonicalName(byte.class));         assertEquals("char", ClassUtils.getCanonicalName(char.class));         assertEquals("short", ClassUtils.getCanonicalName(short.class));         assertEquals("int", ClassUtils.getCanonicalName(int.class));         assertEquals("long", ClassUtils.getCanonicalName(long.class));         assertEquals("float", ClassUtils.getCanonicalName(float.class));         assertEquals("double", ClassUtils.getCanonicalName(double.class));          // Primitive Arrays         assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class));         assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class));         assertEquals("char[]", ClassUtils.getCanonicalName(char[].class));         assertEquals("short[]", ClassUtils.getCanonicalName(short[].class));         assertEquals("int[]", ClassUtils.getCanonicalName(int[].class));         assertEquals("long[]", ClassUtils.getCanonicalName(long[].class));         assertEquals("float[]", ClassUtils.getCanonicalName(float[].class));         assertEquals("double[]", ClassUtils.getCanonicalName(double[].class));          // Arrays of arrays of ...         assertEquals("java.lang.String[][]", ClassUtils.getCanonicalName(String[][].class));         assertEquals("java.lang.String[][][]", ClassUtils.getCanonicalName(String[][][].class));         assertEquals("java.lang.String[][][][]", ClassUtils.getCanonicalName(String[][][][].class));          // Inner types         class Named {             // empty         }         assertEquals(StringUtils.EMPTY, ClassUtils.getCanonicalName(new Object() {             // empty         }.getClass()));         assertEquals(StringUtils.EMPTY, ClassUtils.getCanonicalName(Named.class));         assertEquals("org.apache.commons.lang3.ClassUtilsTest.Inner", ClassUtils.getCanonicalName(Inner.class));     }      @Test     public void test_getCanonicalName_Class_String() {         assertEquals("org.apache.commons.lang3.ClassUtils", ClassUtils.getCanonicalName(ClassUtils.class, "X"));         assertEquals("java.util.Map.Entry", ClassUtils.getCanonicalName(Map.Entry.class, "X"));         assertEquals("X", ClassUtils.getCanonicalName((Class<?>) null, "X"));          assertEquals("java.lang.String[]", ClassUtils.getCanonicalName(String[].class, "X"));         assertEquals("java.util.Map.Entry[]", ClassUtils.getCanonicalName(Map.Entry[].class, "X"));          // Primitives         assertEquals("boolean", ClassUtils.getCanonicalName(boolean.class, "X"));         assertEquals("byte", ClassUtils.getCanonicalName(byte.class, "X"));         assertEquals("char", ClassUtils.getCanonicalName(char.class, "X"));         assertEquals("short", ClassUtils.getCanonicalName(short.class, "X"));         assertEquals("int", ClassUtils.getCanonicalName(int.class, "X"));         assertEquals("long", ClassUtils.getCanonicalName(long.class, "X"));         assertEquals("float", ClassUtils.getCanonicalName(float.class, "X"));         assertEquals("double", ClassUtils.getCanonicalName(double.class, "X"));          // Primitive Arrays         assertEquals("boolean[]", ClassUtils.getCanonicalName(boolean[].class, "X"));         assertEquals("byte[]", ClassUtils.getCanonicalName(byte[].class, "X"));         assertEquals("char[]", ClassUtils.getCanonicalName(char[].class, "X"));         assertEquals("short[]", ClassUtils.getCanonicalName(short[].class, "X"));         assertEquals("int[]", ClassUtils.getCanonicalName(int[].class, "X"));         assertEquals("long[]", ClassUtils.getCanonicalName(long[].class, "X"));         assertEquals("float[]", ClassUtils.getCanonicalName(float[].class, "X"));         assertEquals("double[]", ClassUtils.getCanonicalName(double[].class, "X"));          // Arrays of arrays of ...         assertEquals("java.lang.String[][]", ClassUtils.getCanonicalName(String[][].class, "X"));         assertEquals("java.lang.String[][][]", ClassUtils.getCanonicalName(String[][][].class, "X"));         assertEquals("java.lang.String[][][][]", ClassUtils.getCanonicalName(String[][][][].class, "X"));          // Inner types         class Named {             // empty         }         assertEquals("X", ClassUtils.getCanonicalName(new Object() {             // empty         }.getClass(), "X"));         assertEquals("X", ClassUtils.getCanonicalName(Named.class, "X"));         assertEquals("org.apache.commons.lang3.ClassUtilsTest.Inner", ClassUtils.getCanonicalName(Inner.class, "X"));     }      @Test     public void test_getName_Class() {         assertEquals("org.apache.commons.lang3.ClassUtils", ClassUtils.getName(ClassUtils.class));         assertEquals("java.util.Map$Entry", ClassUtils.getName(Map.Entry.class));         assertEquals("", ClassUtils.getName((Class<?>) null));          assertEquals("[Ljava.lang.String;", ClassUtils.getName(String[].class));         assertEquals("[Ljava.util.Map$Entry;", ClassUtils.getName(Map.Entry[].class));          // Primitives         assertEquals("boolean", ClassUtils.getName(boolean.class));         assertEquals("byte", ClassUtils.getName(byte.class));         assertEquals("char", ClassUtils.getName(char.class));         assertEquals("short", ClassUtils.getName(short.class));         assertEquals("int", ClassUtils.getName(int.class));         assertEquals("long", ClassUtils.getName(long.class));         assertEquals("float", ClassUtils.getName(float.class));         assertEquals("double", ClassUtils.getName(double.class));          // Primitive Arrays         assertEquals("[Z", ClassUtils.getName(boolean[].class));         assertEquals("[B", ClassUtils.getName(byte[].class));         assertEquals("[C", ClassUtils.getName(char[].class));         assertEquals("[S", ClassUtils.getName(short[].class));         assertEquals("[I", ClassUtils.getName(int[].class));         assertEquals("[J", ClassUtils.getName(long[].class));         assertEquals("[F", ClassUtils.getName(float[].class));         assertEquals("[D", ClassUtils.getName(double[].class));          // Arrays of arrays of ...         assertEquals("[[Ljava.lang.String;", ClassUtils.getName(String[][].class));         assertEquals("[[[Ljava.lang.String;", ClassUtils.getName(String[][][].class));         assertEquals("[[[[Ljava.lang.String;", ClassUtils.getName(String[][][][].class));          // Inner types         class Named {             // empty         }         assertEquals("org.apache.commons.lang3.ClassUtilsTest$3", ClassUtils.getName(new Object() {             // empty         }.getClass()));         assertEquals("org.apache.commons.lang3.ClassUtilsTest$3Named", ClassUtils.getName(Named.class));         assertEquals("org.apache.commons.lang3.ClassUtilsTest$Inner", ClassUtils.getName(Inner.class));     }      @Test     public void test_getName_Object() {         assertEquals("org.apache.commons.lang3.ClassUtils", ClassUtils.getName(new ClassUtils(), "<null>"));         assertEquals("org.apache.commons.lang3.ClassUtilsTest$Inner", ClassUtils.getName(new Inner(), "<null>"));         assertEquals("java.lang.String", ClassUtils.getName("hello", "<null>"));         assertEquals("<null>", ClassUtils.getName(null, "<null>"));          // Inner types         class Named {             // empty         }         assertEquals("org.apache.commons.lang3.ClassUtilsTest$4", ClassUtils.getName(new Object() {             // empty         }, "<null>"));         assertEquals("org.apache.commons.lang3.ClassUtilsTest$4Named", ClassUtils.getName(new Named(), "<null>"));         assertEquals("org.apache.commons.lang3.ClassUtilsTest$Inner", ClassUtils.getName(new Inner(), "<null>"));     }      @Test     public void test_getPackageCanonicalName_Class() {         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils.class));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils[].class));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(ClassUtils[][].class));         assertEquals("", ClassUtils.getPackageCanonicalName(int[].class));         assertEquals("", ClassUtils.getPackageCanonicalName(int[][].class));          // Inner types         class Named {             // empty         }         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Object() {             // empty         }.getClass()));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(Named.class));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(Inner.class));     }      @Test     public void test_getPackageCanonicalName_Object() {         assertEquals("<null>", ClassUtils.getPackageCanonicalName(null, "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils(), "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils[0], "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new ClassUtils[0][0], "<null>"));         assertEquals("", ClassUtils.getPackageCanonicalName(new int[0], "<null>"));         assertEquals("", ClassUtils.getPackageCanonicalName(new int[0][0], "<null>"));          // Inner types         class Named {             // empty         }         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Object() {             // empty         }, "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Named(), "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName(new Inner(), "<null>"));     }      @Test     public void test_getPackageCanonicalName_String() {         assertEquals("org.apache.commons.lang3",             ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils"));         assertEquals("org.apache.commons.lang3",             ClassUtils.getPackageCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;"));         assertEquals("org.apache.commons.lang3",             ClassUtils.getPackageCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;"));         assertEquals("org.apache.commons.lang3",             ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils[]"));         assertEquals("org.apache.commons.lang3",             ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtils[][]"));         assertEquals("", ClassUtils.getPackageCanonicalName("[I"));         assertEquals("", ClassUtils.getPackageCanonicalName("[[I"));         assertEquals("", ClassUtils.getPackageCanonicalName("int[]"));         assertEquals("", ClassUtils.getPackageCanonicalName("int[][]"));          // Inner types         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner"));     }      @Test     public void test_getPackageName_Class() {         assertEquals("java.lang", ClassUtils.getPackageName(String.class));         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class));         assertEquals("", ClassUtils.getPackageName((Class<?>) null));          // LANG-535         assertEquals("java.lang", ClassUtils.getPackageName(String[].class));          // Primitive Arrays         assertEquals("", ClassUtils.getPackageName(boolean[].class));         assertEquals("", ClassUtils.getPackageName(byte[].class));         assertEquals("", ClassUtils.getPackageName(char[].class));         assertEquals("", ClassUtils.getPackageName(short[].class));         assertEquals("", ClassUtils.getPackageName(int[].class));         assertEquals("", ClassUtils.getPackageName(long[].class));         assertEquals("", ClassUtils.getPackageName(float[].class));         assertEquals("", ClassUtils.getPackageName(double[].class));          // Arrays of arrays of ...         assertEquals("java.lang", ClassUtils.getPackageName(String[][].class));         assertEquals("java.lang", ClassUtils.getPackageName(String[][][].class));         assertEquals("java.lang", ClassUtils.getPackageName(String[][][][].class));          // On-the-fly types         class Named {             // empty         }         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Object() {             // empty         }.getClass()));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(Named.class));     }      // -------------------------------------------------------------------------     @Test     public void test_getPackageName_Object() {         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new ClassUtils(), "<null>"));         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(new Inner(), "<null>"));         assertEquals("<null>", ClassUtils.getPackageName(null, "<null>"));     }      @Test     public void test_getPackageName_String() {         assertEquals("org.apache.commons.lang3", ClassUtils.getPackageName(ClassUtils.class.getName()));         assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName()));         assertEquals("", ClassUtils.getPackageName((String) null));         assertEquals("", ClassUtils.getPackageName(""));     }      @Test     public void test_getShortCanonicalName_Class() {         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(ClassUtils.class));         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(ClassUtils[].class));         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(ClassUtils[][].class));         assertEquals("int[]", ClassUtils.getShortCanonicalName(int[].class));         assertEquals("int[][]", ClassUtils.getShortCanonicalName(int[][].class));          // Inner types         class Named {             // empty         }         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.8", ClassUtils.getShortCanonicalName(new Object() {             // empty         }.getClass()));         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.8Named", ClassUtils.getShortCanonicalName(Named.class));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(Inner.class));     }      @Test     public void test_getShortCanonicalName_Object() {         assertEquals("<null>", ClassUtils.getShortCanonicalName(null, "<null>"));         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName(new ClassUtils(), "<null>"));         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName(new ClassUtils[0], "<null>"));         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName(new ClassUtils[0][0], "<null>"));         assertEquals("int[]", ClassUtils.getShortCanonicalName(new int[0], "<null>"));         assertEquals("int[][]", ClassUtils.getShortCanonicalName(new int[0][0], "<null>"));          // Inner types         class Named {             // empty         }         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.9", ClassUtils.getShortCanonicalName(new Object() {             // empty         }, "<null>"));         assertEquals("ClassUtilsTest.9Named", ClassUtils.getShortCanonicalName(new Named(), "<null>"));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName(new Inner(), "<null>"));     }      @Test     public void test_getShortCanonicalName_String() {         assertEquals("", ClassUtils.getShortCanonicalName((String) null));         assertEquals("Map.Entry", ClassUtils.getShortCanonicalName(java.util.Map.Entry.class.getName()));         assertEquals("Entry", ClassUtils.getShortCanonicalName(java.util.Map.Entry.class.getCanonicalName()));         assertEquals("ClassUtils", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils"));         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("[Lorg.apache.commons.lang3.ClassUtils;"));         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("[[Lorg.apache.commons.lang3.ClassUtils;"));         assertEquals("ClassUtils[]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[]"));         assertEquals("ClassUtils[][]", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtils[][]"));         assertEquals("int[]", ClassUtils.getShortCanonicalName("[I"));         assertEquals("int[]", ClassUtils.getShortCanonicalName(int[].class.getCanonicalName()));         assertEquals("int[]", ClassUtils.getShortCanonicalName(int[].class.getName()));         assertEquals("int[][]", ClassUtils.getShortCanonicalName("[[I"));         assertEquals("int[]", ClassUtils.getShortCanonicalName("int[]"));         assertEquals("int[][]", ClassUtils.getShortCanonicalName("int[][]"));          // this is to demonstrate that the documentation and the naming of the methods         // uses the class name and canonical name totally mixed up, which cannot be         // fixed without backward compatibility break         assertEquals("int[]", int[].class.getCanonicalName());         assertEquals("[I", int[].class.getName());          // Inner types... the problem is that these are not canonical names, classes with this name do not even have canonical name         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.6", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$6"));       // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.5Named", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$5Named"));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortCanonicalName("org.apache.commons.lang3.ClassUtilsTest$Inner"));         // demonstrating what a canonical name is... it is a bigger issue to clean this up         assertEquals("org.apache.commons.lang3.ClassUtilsTest$10", new org.apache.commons.lang3.ClassUtilsTest(){}.getClass().getName());         assertNull(new org.apache.commons.lang3.ClassUtilsTest(){}.getClass().getCanonicalName());     }      @Test     public void test_getShortClassName_Class() {         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class));         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class));         assertEquals("", ClassUtils.getShortClassName((Class<?>) null));          // LANG-535         assertEquals("String[]", ClassUtils.getShortClassName(String[].class));         assertEquals("Map.Entry[]", ClassUtils.getShortClassName(Map.Entry[].class));          // Primitives         assertEquals("boolean", ClassUtils.getShortClassName(boolean.class));         assertEquals("byte", ClassUtils.getShortClassName(byte.class));         assertEquals("char", ClassUtils.getShortClassName(char.class));         assertEquals("short", ClassUtils.getShortClassName(short.class));         assertEquals("int", ClassUtils.getShortClassName(int.class));         assertEquals("long", ClassUtils.getShortClassName(long.class));         assertEquals("float", ClassUtils.getShortClassName(float.class));         assertEquals("double", ClassUtils.getShortClassName(double.class));          // Primitive Arrays         assertEquals("boolean[]", ClassUtils.getShortClassName(boolean[].class));         assertEquals("byte[]", ClassUtils.getShortClassName(byte[].class));         assertEquals("char[]", ClassUtils.getShortClassName(char[].class));         assertEquals("short[]", ClassUtils.getShortClassName(short[].class));         assertEquals("int[]", ClassUtils.getShortClassName(int[].class));         assertEquals("long[]", ClassUtils.getShortClassName(long[].class));         assertEquals("float[]", ClassUtils.getShortClassName(float[].class));         assertEquals("double[]", ClassUtils.getShortClassName(double[].class));          // Arrays of arrays of ...         assertEquals("String[][]", ClassUtils.getShortClassName(String[][].class));         assertEquals("String[][][]", ClassUtils.getShortClassName(String[][][].class));         assertEquals("String[][][][]", ClassUtils.getShortClassName(String[][][][].class));          // Inner types         class Named {             // empty         }       // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.12", ClassUtils.getShortClassName(new Object() {             // empty         }.getClass()));         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.10Named", ClassUtils.getShortClassName(Named.class));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(Inner.class));     }      // -------------------------------------------------------------------------     @Test     public void test_getShortClassName_Object() {         assertEquals("ClassUtils", ClassUtils.getShortClassName(new ClassUtils(), "<null>"));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(new Inner(), "<null>"));         assertEquals("String", ClassUtils.getShortClassName("hello", "<null>"));         assertEquals("<null>", ClassUtils.getShortClassName(null, "<null>"));          // Inner types         class Named {             // empty         }       // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.13", ClassUtils.getShortClassName(new Object() {             // empty         }, "<null>"));         // WARNING: this is fragile, implementation may change, naming is not guaranteed         assertEquals("ClassUtilsTest.11Named", ClassUtils.getShortClassName(new Named(), "<null>"));         assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(new Inner(), "<null>"));     }      @Test     public void test_getShortClassName_String() {         assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class.getName()));         assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class.getName()));         assertEquals("", ClassUtils.getShortClassName((String) null));         assertEquals("", ClassUtils.getShortClassName(""));     }      @Test     public void test_getSimpleName_Class() {         assertEquals("ClassUtils", ClassUtils.getSimpleName(ClassUtils.class));         assertEquals("Entry", ClassUtils.getSimpleName(Map.Entry.class));         assertEquals("", ClassUtils.getSimpleName(null));          // LANG-535         assertEquals("String[]", ClassUtils.getSimpleName(String[].class));         assertEquals("Entry[]", ClassUtils.getSimpleName(Map.Entry[].class));          // Primitives         assertEquals("boolean", ClassUtils.getSimpleName(boolean.class));         assertEquals("byte", ClassUtils.getSimpleName(byte.class));         assertEquals("char", ClassUtils.getSimpleName(char.class));         assertEquals("short", ClassUtils.getSimpleName(short.class));         assertEquals("int", ClassUtils.getSimpleName(int.class));         assertEquals("long", ClassUtils.getSimpleName(long.class));         assertEquals("float", ClassUtils.getSimpleName(float.class));         assertEquals("double", ClassUtils.getSimpleName(double.class));          // Primitive Arrays         assertEquals("boolean[]", ClassUtils.getSimpleName(boolean[].class));         assertEquals("byte[]", ClassUtils.getSimpleName(byte[].class));         assertEquals("char[]", ClassUtils.getSimpleName(char[].class));         assertEquals("short[]", ClassUtils.getSimpleName(short[].class));         assertEquals("int[]", ClassUtils.getSimpleName(int[].class));         assertEquals("long[]", ClassUtils.getSimpleName(long[].class));         assertEquals("float[]", ClassUtils.getSimpleName(float[].class));         assertEquals("double[]", ClassUtils.getSimpleName(double[].class));          // Arrays of arrays of ...         assertEquals("String[][]", ClassUtils.getSimpleName(String[][].class));         assertEquals("String[][][]", ClassUtils.getSimpleName(String[][][].class));         assertEquals("String[][][][]", ClassUtils.getSimpleName(String[][][][].class));          // On-the-fly types         class Named {             // empty         }         assertEquals("", ClassUtils.getSimpleName(new Object() {             // empty         }.getClass()));         assertEquals("Named", ClassUtils.getSimpleName(Named.class));     }      @Test     public void test_getSimpleName_Object() {         assertEquals("ClassUtils", ClassUtils.getSimpleName(new ClassUtils()));         assertEquals("Inner", ClassUtils.getSimpleName(new Inner()));         assertEquals("String", ClassUtils.getSimpleName("hello"));         assertEquals(StringUtils.EMPTY, ClassUtils.getSimpleName(null));         assertEquals(StringUtils.EMPTY, ClassUtils.getSimpleName(null));     }      @Test     public void test_getSimpleName_Object_String() {         assertEquals("ClassUtils", ClassUtils.getSimpleName(new ClassUtils(), "<null>"));         assertEquals("Inner", ClassUtils.getSimpleName(new Inner(), "<null>"));         assertEquals("String", ClassUtils.getSimpleName("hello", "<null>"));         assertEquals("<null>", ClassUtils.getSimpleName(null, "<null>"));         assertNull(ClassUtils.getSimpleName(null, null));     }      @Test     public void test_isAssignable() {         assertFalse(ClassUtils.isAssignable((Class<?>) null, null));         assertFalse(ClassUtils.isAssignable(String.class, null));          assertTrue(ClassUtils.isAssignable(null, Object.class));         assertTrue(ClassUtils.isAssignable(null, Integer.class));         assertFalse(ClassUtils.isAssignable(null, Integer.TYPE));         assertTrue(ClassUtils.isAssignable(String.class, Object.class));         assertTrue(ClassUtils.isAssignable(String.class, String.class));         assertFalse(ClassUtils.isAssignable(Object.class, String.class));          assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.class));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Object.class));         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE));         assertTrue(ClassUtils.isAssignable(Integer.class, Object.class));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Object.class));         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE));         assertTrue(ClassUtils.isAssignable(Boolean.class, Object.class));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class));     }      @Test     public void test_isAssignable_Autoboxing() {         assertFalse(ClassUtils.isAssignable((Class<?>) null, null, true));         assertFalse(ClassUtils.isAssignable(String.class, null, true));          assertTrue(ClassUtils.isAssignable(null, Object.class, true));         assertTrue(ClassUtils.isAssignable(null, Integer.class, true));         assertFalse(ClassUtils.isAssignable(null, Integer.TYPE, true));         assertTrue(ClassUtils.isAssignable(String.class, Object.class, true));         assertTrue(ClassUtils.isAssignable(String.class, String.class, true));         assertFalse(ClassUtils.isAssignable(Object.class, String.class, true));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.class, true));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Object.class, true));         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE, true));         assertTrue(ClassUtils.isAssignable(Integer.class, Object.class, true));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE, true));         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class, true));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class, true));         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true));         assertTrue(ClassUtils.isAssignable(Boolean.class, Object.class, true));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE, true));         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class, true));     }      // -------------------------------------------------------------------------     @Test     public void test_isAssignable_ClassArray_ClassArray() {         final Class<?>[] array2 = new Class[] {Object.class, Object.class};         final Class<?>[] array1 = new Class[] {Object.class};         final Class<?>[] array1s = new Class[] {String.class};         final Class<?>[] array0 = new Class[] {};         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };          assertFalse(ClassUtils.isAssignable(array1, array2));         assertFalse(ClassUtils.isAssignable(null, array2));         assertTrue(ClassUtils.isAssignable(null, array0));         assertTrue(ClassUtils.isAssignable(array0, array0));         assertTrue(ClassUtils.isAssignable(array0, (Class<?>[]) null)); // explicit cast to avoid warning         assertTrue(ClassUtils.isAssignable(null, (Class<?>[]) null)); // explicit cast to avoid warning          assertFalse(ClassUtils.isAssignable(array1, array1s));         assertTrue(ClassUtils.isAssignable(array1s, array1s));         assertTrue(ClassUtils.isAssignable(array1s, array1));          assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers));         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives));         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1));         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1));         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array2));         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2));     }      @Test     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() {         final Class<?>[] array2 = new Class[] {Object.class, Object.class};         final Class<?>[] array1 = new Class[] {Object.class};         final Class<?>[] array1s = new Class[] {String.class};         final Class<?>[] array0 = new Class[] {};         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };          assertFalse(ClassUtils.isAssignable(array1, array2, true));         assertFalse(ClassUtils.isAssignable(null, array2, true));         assertTrue(ClassUtils.isAssignable(null, array0, true));         assertTrue(ClassUtils.isAssignable(array0, array0, true));         assertTrue(ClassUtils.isAssignable(array0, null, true));         assertTrue(ClassUtils.isAssignable((Class[]) null, null, true));          assertFalse(ClassUtils.isAssignable(array1, array1s, true));         assertTrue(ClassUtils.isAssignable(array1s, array1s, true));         assertTrue(ClassUtils.isAssignable(array1s, array1, true));          assertTrue(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, true));         assertTrue(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, true));         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, true));         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, true));         assertTrue(ClassUtils.isAssignable(arrayPrimitives, array2, true));         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, true));     }      @Test     public void test_isAssignable_ClassArray_ClassArray_NoAutoboxing() {         final Class<?>[] array2 = new Class[] {Object.class, Object.class};         final Class<?>[] array1 = new Class[] {Object.class};         final Class<?>[] array1s = new Class[] {String.class};         final Class<?>[] array0 = new Class[] {};         final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };         final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };          assertFalse(ClassUtils.isAssignable(array1, array2, false));         assertFalse(ClassUtils.isAssignable(null, array2, false));         assertTrue(ClassUtils.isAssignable(null, array0, false));         assertTrue(ClassUtils.isAssignable(array0, array0, false));         assertTrue(ClassUtils.isAssignable(array0, null, false));         assertTrue(ClassUtils.isAssignable((Class[]) null, null, false));          assertFalse(ClassUtils.isAssignable(array1, array1s, false));         assertTrue(ClassUtils.isAssignable(array1s, array1s, false));         assertTrue(ClassUtils.isAssignable(array1s, array1, false));          assertFalse(ClassUtils.isAssignable(arrayPrimitives, arrayWrappers, false));         assertFalse(ClassUtils.isAssignable(arrayWrappers, arrayPrimitives, false));         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array1, false));         assertFalse(ClassUtils.isAssignable(arrayWrappers, array1, false));         assertTrue(ClassUtils.isAssignable(arrayWrappers, array2, false));         assertFalse(ClassUtils.isAssignable(arrayPrimitives, array2, false));     }      @Test     public void test_isAssignable_DefaultUnboxing_Widening() {         // test byte conversions         assertFalse(ClassUtils.isAssignable(Byte.class, Character.TYPE), "byte -> char");         assertTrue(ClassUtils.isAssignable(Byte.class, Byte.TYPE), "byte -> byte");         assertTrue(ClassUtils.isAssignable(Byte.class, Short.TYPE), "byte -> short");         assertTrue(ClassUtils.isAssignable(Byte.class, Integer.TYPE), "byte -> int");         assertTrue(ClassUtils.isAssignable(Byte.class, Long.TYPE), "byte -> long");         assertTrue(ClassUtils.isAssignable(Byte.class, Float.TYPE), "byte -> float");         assertTrue(ClassUtils.isAssignable(Byte.class, Double.TYPE), "byte -> double");         assertFalse(ClassUtils.isAssignable(Byte.class, Boolean.TYPE), "byte -> boolean");          // test short conversions         assertFalse(ClassUtils.isAssignable(Short.class, Character.TYPE), "short -> char");         assertFalse(ClassUtils.isAssignable(Short.class, Byte.TYPE), "short -> byte");         assertTrue(ClassUtils.isAssignable(Short.class, Short.TYPE), "short -> short");         assertTrue(ClassUtils.isAssignable(Short.class, Integer.TYPE), "short -> int");         assertTrue(ClassUtils.isAssignable(Short.class, Long.TYPE), "short -> long");         assertTrue(ClassUtils.isAssignable(Short.class, Float.TYPE), "short -> float");         assertTrue(ClassUtils.isAssignable(Short.class, Double.TYPE), "short -> double");         assertFalse(ClassUtils.isAssignable(Short.class, Boolean.TYPE), "short -> boolean");          // test char conversions         assertTrue(ClassUtils.isAssignable(Character.class, Character.TYPE), "char -> char");         assertFalse(ClassUtils.isAssignable(Character.class, Byte.TYPE), "char -> byte");         assertFalse(ClassUtils.isAssignable(Character.class, Short.TYPE), "char -> short");         assertTrue(ClassUtils.isAssignable(Character.class, Integer.TYPE), "char -> int");         assertTrue(ClassUtils.isAssignable(Character.class, Long.TYPE), "char -> long");         assertTrue(ClassUtils.isAssignable(Character.class, Float.TYPE), "char -> float");         assertTrue(ClassUtils.isAssignable(Character.class, Double.TYPE), "char -> double");         assertFalse(ClassUtils.isAssignable(Character.class, Boolean.TYPE), "char -> boolean");          // test int conversions         assertFalse(ClassUtils.isAssignable(Integer.class, Character.TYPE), "int -> char");         assertFalse(ClassUtils.isAssignable(Integer.class, Byte.TYPE), "int -> byte");         assertFalse(ClassUtils.isAssignable(Integer.class, Short.TYPE), "int -> short");         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE), "int -> int");         assertTrue(ClassUtils.isAssignable(Integer.class, Long.TYPE), "int -> long");         assertTrue(ClassUtils.isAssignable(Integer.class, Float.TYPE), "int -> float");         assertTrue(ClassUtils.isAssignable(Integer.class, Double.TYPE), "int -> double");         assertFalse(ClassUtils.isAssignable(Integer.class, Boolean.TYPE), "int -> boolean");          // test long conversions         assertFalse(ClassUtils.isAssignable(Long.class, Character.TYPE), "long -> char");         assertFalse(ClassUtils.isAssignable(Long.class, Byte.TYPE), "long -> byte");         assertFalse(ClassUtils.isAssignable(Long.class, Short.TYPE), "long -> short");         assertFalse(ClassUtils.isAssignable(Long.class, Integer.TYPE), "long -> int");         assertTrue(ClassUtils.isAssignable(Long.class, Long.TYPE), "long -> long");         assertTrue(ClassUtils.isAssignable(Long.class, Float.TYPE), "long -> float");         assertTrue(ClassUtils.isAssignable(Long.class, Double.TYPE), "long -> double");         assertFalse(ClassUtils.isAssignable(Long.class, Boolean.TYPE), "long -> boolean");          // test float conversions         assertFalse(ClassUtils.isAssignable(Float.class, Character.TYPE), "float -> char");         assertFalse(ClassUtils.isAssignable(Float.class, Byte.TYPE), "float -> byte");         assertFalse(ClassUtils.isAssignable(Float.class, Short.TYPE), "float -> short");         assertFalse(ClassUtils.isAssignable(Float.class, Integer.TYPE), "float -> int");         assertFalse(ClassUtils.isAssignable(Float.class, Long.TYPE), "float -> long");         assertTrue(ClassUtils.isAssignable(Float.class, Float.TYPE), "float -> float");         assertTrue(ClassUtils.isAssignable(Float.class, Double.TYPE), "float -> double");         assertFalse(ClassUtils.isAssignable(Float.class, Boolean.TYPE), "float -> boolean");          // test double conversions         assertFalse(ClassUtils.isAssignable(Double.class, Character.TYPE), "double -> char");         assertFalse(ClassUtils.isAssignable(Double.class, Byte.TYPE), "double -> byte");         assertFalse(ClassUtils.isAssignable(Double.class, Short.TYPE), "double -> short");         assertFalse(ClassUtils.isAssignable(Double.class, Integer.TYPE), "double -> int");         assertFalse(ClassUtils.isAssignable(Double.class, Long.TYPE), "double -> long");         assertFalse(ClassUtils.isAssignable(Double.class, Float.TYPE), "double -> float");         assertTrue(ClassUtils.isAssignable(Double.class, Double.TYPE), "double -> double");         assertFalse(ClassUtils.isAssignable(Double.class, Boolean.TYPE), "double -> boolean");          // test boolean conversions         assertFalse(ClassUtils.isAssignable(Boolean.class, Character.TYPE), "boolean -> char");         assertFalse(ClassUtils.isAssignable(Boolean.class, Byte.TYPE), "boolean -> byte");         assertFalse(ClassUtils.isAssignable(Boolean.class, Short.TYPE), "boolean -> short");         assertFalse(ClassUtils.isAssignable(Boolean.class, Integer.TYPE), "boolean -> int");         assertFalse(ClassUtils.isAssignable(Boolean.class, Long.TYPE), "boolean -> long");         assertFalse(ClassUtils.isAssignable(Boolean.class, Float.TYPE), "boolean -> float");         assertFalse(ClassUtils.isAssignable(Boolean.class, Double.TYPE), "boolean -> double");         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE), "boolean -> boolean");     }      @Test     public void test_isAssignable_NoAutoboxing() {         assertFalse(ClassUtils.isAssignable((Class<?>) null, null, false));         assertFalse(ClassUtils.isAssignable(String.class, null, false));          assertTrue(ClassUtils.isAssignable(null, Object.class, false));         assertTrue(ClassUtils.isAssignable(null, Integer.class, false));         assertFalse(ClassUtils.isAssignable(null, Integer.TYPE, false));         assertTrue(ClassUtils.isAssignable(String.class, Object.class, false));         assertTrue(ClassUtils.isAssignable(String.class, String.class, false));         assertFalse(ClassUtils.isAssignable(Object.class, String.class, false));         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Integer.class, false));         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Object.class, false));         assertFalse(ClassUtils.isAssignable(Integer.class, Integer.TYPE, false));         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE, false));         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.class, false));         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Boolean.class, false));         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Object.class, false));         assertFalse(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, false));         assertTrue(ClassUtils.isAssignable(Boolean.class, Object.class, false));         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE, false));         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.class, false));     }      @Test     public void test_isAssignable_Unboxing_Widening() {         // test byte conversions         assertFalse(ClassUtils.isAssignable(Byte.class, Character.TYPE, true), "byte -> char");         assertTrue(ClassUtils.isAssignable(Byte.class, Byte.TYPE, true), "byte -> byte");         assertTrue(ClassUtils.isAssignable(Byte.class, Short.TYPE, true), "byte -> short");         assertTrue(ClassUtils.isAssignable(Byte.class, Integer.TYPE, true), "byte -> int");         assertTrue(ClassUtils.isAssignable(Byte.class, Long.TYPE, true), "byte -> long");         assertTrue(ClassUtils.isAssignable(Byte.class, Float.TYPE, true), "byte -> float");         assertTrue(ClassUtils.isAssignable(Byte.class, Double.TYPE, true), "byte -> double");         assertFalse(ClassUtils.isAssignable(Byte.class, Boolean.TYPE, true), "byte -> boolean");          // test short conversions         assertFalse(ClassUtils.isAssignable(Short.class, Character.TYPE, true), "short -> char");         assertFalse(ClassUtils.isAssignable(Short.class, Byte.TYPE, true), "short -> byte");         assertTrue(ClassUtils.isAssignable(Short.class, Short.TYPE, true), "short -> short");         assertTrue(ClassUtils.isAssignable(Short.class, Integer.TYPE, true), "short -> int");         assertTrue(ClassUtils.isAssignable(Short.class, Long.TYPE, true), "short -> long");         assertTrue(ClassUtils.isAssignable(Short.class, Float.TYPE, true), "short -> float");         assertTrue(ClassUtils.isAssignable(Short.class, Double.TYPE, true), "short -> double");         assertFalse(ClassUtils.isAssignable(Short.class, Boolean.TYPE, true), "short -> boolean");          // test char conversions         assertTrue(ClassUtils.isAssignable(Character.class, Character.TYPE, true), "char -> char");         assertFalse(ClassUtils.isAssignable(Character.class, Byte.TYPE, true), "char -> byte");         assertFalse(ClassUtils.isAssignable(Character.class, Short.TYPE, true), "char -> short");         assertTrue(ClassUtils.isAssignable(Character.class, Integer.TYPE, true), "char -> int");         assertTrue(ClassUtils.isAssignable(Character.class, Long.TYPE, true), "char -> long");         assertTrue(ClassUtils.isAssignable(Character.class, Float.TYPE, true), "char -> float");         assertTrue(ClassUtils.isAssignable(Character.class, Double.TYPE, true), "char -> double");         assertFalse(ClassUtils.isAssignable(Character.class, Boolean.TYPE, true), "char -> boolean");          // test int conversions         assertFalse(ClassUtils.isAssignable(Integer.class, Character.TYPE, true), "int -> char");         assertFalse(ClassUtils.isAssignable(Integer.class, Byte.TYPE, true), "int -> byte");         assertFalse(ClassUtils.isAssignable(Integer.class, Short.TYPE, true), "int -> short");         assertTrue(ClassUtils.isAssignable(Integer.class, Integer.TYPE, true), "int -> int");         assertTrue(ClassUtils.isAssignable(Integer.class, Long.TYPE, true), "int -> long");         assertTrue(ClassUtils.isAssignable(Integer.class, Float.TYPE, true), "int -> float");         assertTrue(ClassUtils.isAssignable(Integer.class, Double.TYPE, true), "int -> double");         assertFalse(ClassUtils.isAssignable(Integer.class, Boolean.TYPE, true), "int -> boolean");          // test long conversions         assertFalse(ClassUtils.isAssignable(Long.class, Character.TYPE, true), "long -> char");         assertFalse(ClassUtils.isAssignable(Long.class, Byte.TYPE, true), "long -> byte");         assertFalse(ClassUtils.isAssignable(Long.class, Short.TYPE, true), "long -> short");         assertFalse(ClassUtils.isAssignable(Long.class, Integer.TYPE, true), "long -> int");         assertTrue(ClassUtils.isAssignable(Long.class, Long.TYPE, true), "long -> long");         assertTrue(ClassUtils.isAssignable(Long.class, Float.TYPE, true), "long -> float");         assertTrue(ClassUtils.isAssignable(Long.class, Double.TYPE, true), "long -> double");         assertFalse(ClassUtils.isAssignable(Long.class, Boolean.TYPE, true), "long -> boolean");          // test float conversions         assertFalse(ClassUtils.isAssignable(Float.class, Character.TYPE, true), "float -> char");         assertFalse(ClassUtils.isAssignable(Float.class, Byte.TYPE, true), "float -> byte");         assertFalse(ClassUtils.isAssignable(Float.class, Short.TYPE, true), "float -> short");         assertFalse(ClassUtils.isAssignable(Float.class, Integer.TYPE, true), "float -> int");         assertFalse(ClassUtils.isAssignable(Float.class, Long.TYPE, true), "float -> long");         assertTrue(ClassUtils.isAssignable(Float.class, Float.TYPE, true), "float -> float");         assertTrue(ClassUtils.isAssignable(Float.class, Double.TYPE, true), "float -> double");         assertFalse(ClassUtils.isAssignable(Float.class, Boolean.TYPE, true), "float -> boolean");          // test double conversions         assertFalse(ClassUtils.isAssignable(Double.class, Character.TYPE, true), "double -> char");         assertFalse(ClassUtils.isAssignable(Double.class, Byte.TYPE, true), "double -> byte");         assertFalse(ClassUtils.isAssignable(Double.class, Short.TYPE, true), "double -> short");         assertFalse(ClassUtils.isAssignable(Double.class, Integer.TYPE, true), "double -> int");         assertFalse(ClassUtils.isAssignable(Double.class, Long.TYPE, true), "double -> long");         assertFalse(ClassUtils.isAssignable(Double.class, Float.TYPE, true), "double -> float");         assertTrue(ClassUtils.isAssignable(Double.class, Double.TYPE, true), "double -> double");         assertFalse(ClassUtils.isAssignable(Double.class, Boolean.TYPE, true), "double -> boolean");          // test boolean conversions         assertFalse(ClassUtils.isAssignable(Boolean.class, Character.TYPE, true), "boolean -> char");         assertFalse(ClassUtils.isAssignable(Boolean.class, Byte.TYPE, true), "boolean -> byte");         assertFalse(ClassUtils.isAssignable(Boolean.class, Short.TYPE, true), "boolean -> short");         assertFalse(ClassUtils.isAssignable(Boolean.class, Integer.TYPE, true), "boolean -> int");         assertFalse(ClassUtils.isAssignable(Boolean.class, Long.TYPE, true), "boolean -> long");         assertFalse(ClassUtils.isAssignable(Boolean.class, Float.TYPE, true), "boolean -> float");         assertFalse(ClassUtils.isAssignable(Boolean.class, Double.TYPE, true), "boolean -> double");         assertTrue(ClassUtils.isAssignable(Boolean.class, Boolean.TYPE, true), "boolean -> boolean");     }      @Test     public void test_isAssignable_Widening() {         // test byte conversions         assertFalse(ClassUtils.isAssignable(Byte.TYPE, Character.TYPE), "byte -> char");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE), "byte -> byte");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Short.TYPE), "byte -> short");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE), "byte -> int");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Long.TYPE), "byte -> long");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Float.TYPE), "byte -> float");         assertTrue(ClassUtils.isAssignable(Byte.TYPE, Double.TYPE), "byte -> double");         assertFalse(ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE), "byte -> boolean");          // test short conversions         assertFalse(ClassUtils.isAssignable(Short.TYPE, Character.TYPE), "short -> char");         assertFalse(ClassUtils.isAssignable(Short.TYPE, Byte.TYPE), "short -> byte");         assertTrue(ClassUtils.isAssignable(Short.TYPE, Short.TYPE), "short -> short");         assertTrue(ClassUtils.isAssignable(Short.TYPE, Integer.TYPE), "short -> int");         assertTrue(ClassUtils.isAssignable(Short.TYPE, Long.TYPE), "short -> long");         assertTrue(ClassUtils.isAssignable(Short.TYPE, Float.TYPE), "short -> float");         assertTrue(ClassUtils.isAssignable(Short.TYPE, Double.TYPE), "short -> double");         assertFalse(ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE), "short -> boolean");          // test char conversions         assertTrue(ClassUtils.isAssignable(Character.TYPE, Character.TYPE), "char -> char");         assertFalse(ClassUtils.isAssignable(Character.TYPE, Byte.TYPE), "char -> byte");         assertFalse(ClassUtils.isAssignable(Character.TYPE, Short.TYPE), "char -> short");         assertTrue(ClassUtils.isAssignable(Character.TYPE, Integer.TYPE), "char -> int");         assertTrue(ClassUtils.isAssignable(Character.TYPE, Long.TYPE), "char -> long");         assertTrue(ClassUtils.isAssignable(Character.TYPE, Float.TYPE), "char -> float");         assertTrue(ClassUtils.isAssignable(Character.TYPE, Double.TYPE), "char -> double");         assertFalse(ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE), "char -> boolean");          // test int conversions         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Character.TYPE), "int -> char");         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE), "int -> byte");         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Short.TYPE), "int -> short");         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE), "int -> int");         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Long.TYPE), "int -> long");         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Float.TYPE), "int -> float");         assertTrue(ClassUtils.isAssignable(Integer.TYPE, Double.TYPE), "int -> double");         assertFalse(ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE), "int -> boolean");          // test long conversions         assertFalse(ClassUtils.isAssignable(Long.TYPE, Character.TYPE), "long -> char");         assertFalse(ClassUtils.isAssignable(Long.TYPE, Byte.TYPE), "long -> byte");         assertFalse(ClassUtils.isAssignable(Long.TYPE, Short.TYPE), "long -> short");         assertFalse(ClassUtils.isAssignable(Long.TYPE, Integer.TYPE), "long -> int");         assertTrue(ClassUtils.isAssignable(Long.TYPE, Long.TYPE), "long -> long");         assertTrue(ClassUtils.isAssignable(Long.TYPE, Float.TYPE), "long -> float");         assertTrue(ClassUtils.isAssignable(Long.TYPE, Double.TYPE), "long -> double");         assertFalse(ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE), "long -> boolean");          // test float conversions         assertFalse(ClassUtils.isAssignable(Float.TYPE, Character.TYPE), "float -> char");         assertFalse(ClassUtils.isAssignable(Float.TYPE, Byte.TYPE), "float -> byte");         assertFalse(ClassUtils.isAssignable(Float.TYPE, Short.TYPE), "float -> short");         assertFalse(ClassUtils.isAssignable(Float.TYPE, Integer.TYPE), "float -> int");         assertFalse(ClassUtils.isAssignable(Float.TYPE, Long.TYPE), "float -> long");         assertTrue(ClassUtils.isAssignable(Float.TYPE, Float.TYPE), "float -> float");         assertTrue(ClassUtils.isAssignable(Float.TYPE, Double.TYPE), "float -> double");         assertFalse(ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE), "float -> boolean");          // test double conversions         assertFalse(ClassUtils.isAssignable(Double.TYPE, Character.TYPE), "double -> char");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Byte.TYPE), "double -> byte");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Short.TYPE), "double -> short");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Integer.TYPE), "double -> int");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Long.TYPE), "double -> long");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Float.TYPE), "double -> float");         assertTrue(ClassUtils.isAssignable(Double.TYPE, Double.TYPE), "double -> double");         assertFalse(ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE), "double -> boolean");          // test boolean conversions         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE), "boolean -> char");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE), "boolean -> byte");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE), "boolean -> short");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE), "boolean -> int");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE), "boolean -> long");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE), "boolean -> float");         assertFalse(ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE), "boolean -> double");         assertTrue(ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE), "boolean -> boolean");     }      // -------------------------------------------------------------------------     @Test     public void test_isInnerClass_Class() {         assertTrue(ClassUtils.isInnerClass(Inner.class));         assertTrue(ClassUtils.isInnerClass(Map.Entry.class));         assertTrue(ClassUtils.isInnerClass(new Cloneable() {             // empty         }.getClass()));         assertFalse(ClassUtils.isInnerClass(this.getClass()));         assertFalse(ClassUtils.isInnerClass(String.class));         assertFalse(ClassUtils.isInnerClass(null));     }      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new ClassUtils());         final Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ClassUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ClassUtils.class.getModifiers()));     }      @Test     public void testGetClassByNormalNameArrays() throws ClassNotFoundException {         assertEquals( int[].class, ClassUtils.getClass( "int[]" ) );         assertEquals( long[].class, ClassUtils.getClass( "long[]" ) );         assertEquals( short[].class, ClassUtils.getClass( "short[]" ) );         assertEquals( byte[].class, ClassUtils.getClass( "byte[]" ) );         assertEquals( char[].class, ClassUtils.getClass( "char[]" ) );         assertEquals( float[].class, ClassUtils.getClass( "float[]" ) );         assertEquals( double[].class, ClassUtils.getClass( "double[]" ) );         assertEquals( boolean[].class, ClassUtils.getClass( "boolean[]" ) );         assertEquals( String[].class, ClassUtils.getClass( "java.lang.String[]" ) );         assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "java.util.Map.Entry[]" ) );         assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "java.util.Map$Entry[]" ) );         assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "[Ljava.util.Map.Entry;" ) );         assertEquals( java.util.Map.Entry[].class, ClassUtils.getClass( "[Ljava.util.Map$Entry;" ) );     }      @Test     public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException {         assertEquals( int[][].class, ClassUtils.getClass( "int[][]" ) );         assertEquals( long[][].class, ClassUtils.getClass( "long[][]" ) );         assertEquals( short[][].class, ClassUtils.getClass( "short[][]" ) );         assertEquals( byte[][].class, ClassUtils.getClass( "byte[][]" ) );         assertEquals( char[][].class, ClassUtils.getClass( "char[][]" ) );         assertEquals( float[][].class, ClassUtils.getClass( "float[][]" ) );         assertEquals( double[][].class, ClassUtils.getClass( "double[][]" ) );         assertEquals( boolean[][].class, ClassUtils.getClass( "boolean[][]" ) );         assertEquals( String[][].class, ClassUtils.getClass( "java.lang.String[][]" ) );     }      @Test     public void testGetClassClassNotFound() throws Exception {         assertGetClassThrowsClassNotFound( "bool" );         assertGetClassThrowsClassNotFound( "bool[]" );         assertGetClassThrowsClassNotFound( "integer[]" );     }      @Test     public void testGetClassInvalidArguments() throws Exception {         assertGetClassThrowsNullPointerException( null );         assertGetClassThrowsClassNotFound( "[][][]" );         assertGetClassThrowsClassNotFound( "[[]" );         assertGetClassThrowsClassNotFound( "[" );         assertGetClassThrowsClassNotFound( "java.lang.String][" );         assertGetClassThrowsClassNotFound( ".hello.world" );         assertGetClassThrowsClassNotFound( "hello..world" );     }      @Test     public void testGetClassRawPrimitives() throws ClassNotFoundException {         assertEquals( int.class, ClassUtils.getClass( "int" ) );         assertEquals( long.class, ClassUtils.getClass( "long" ) );         assertEquals( short.class, ClassUtils.getClass( "short" ) );         assertEquals( byte.class, ClassUtils.getClass( "byte" ) );         assertEquals( char.class, ClassUtils.getClass( "char" ) );         assertEquals( float.class, ClassUtils.getClass( "float" ) );         assertEquals( double.class, ClassUtils.getClass( "double" ) );         assertEquals( boolean.class, ClassUtils.getClass( "boolean" ) );         assertEquals( void.class, ClassUtils.getClass( "void" ) );     }      @Test     public void testGetClassWithArrayClasses() throws Exception {         assertGetClassReturnsClass( String[].class );         assertGetClassReturnsClass( int[].class );         assertGetClassReturnsClass( long[].class );         assertGetClassReturnsClass( short[].class );         assertGetClassReturnsClass( byte[].class );         assertGetClassReturnsClass( char[].class );         assertGetClassReturnsClass( float[].class );         assertGetClassReturnsClass( double[].class );         assertGetClassReturnsClass( boolean[].class );     }      @Test     public void testGetClassWithArrayClasses2D() throws Exception {         assertGetClassReturnsClass( String[][].class );         assertGetClassReturnsClass( int[][].class );         assertGetClassReturnsClass( long[][].class );         assertGetClassReturnsClass( short[][].class );         assertGetClassReturnsClass( byte[][].class );         assertGetClassReturnsClass( char[][].class );         assertGetClassReturnsClass( float[][].class );         assertGetClassReturnsClass( double[][].class );         assertGetClassReturnsClass( boolean[][].class );     }      @Test     public void testGetInnerClass() throws ClassNotFoundException {         assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested" ) );         assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested" ) );         assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested" ) );         assertEquals( Inner.DeeplyNested.class, ClassUtils.getClass( "org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested" ) );     }      @Test     public void testGetPublicMethod() throws Exception {         // Tests with Collections$UnmodifiableSet         final Set<?> set = Collections.unmodifiableSet(new HashSet<>());         final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), "isEmpty");         assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers()));         assertTrue((Boolean) isEmptyMethod.invoke(set));          // Tests with a public Class         final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, "toString");         assertEquals(Object.class.getMethod("toString"), toStringMethod);     }      @Test     public void testHierarchyExcludingInterfaces() {         final Iterator<Class<?>> iter = ClassUtils.hierarchy(StringParameterizedChild.class).iterator();         assertEquals(StringParameterizedChild.class, iter.next());         assertEquals(GenericParent.class, iter.next());         assertEquals(Object.class, iter.next());         assertFalse(iter.hasNext());     }      @Test     public void testHierarchyIncludingInterfaces() {         final Iterator<Class<?>> iter =             ClassUtils.hierarchy(StringParameterizedChild.class, Interfaces.INCLUDE).iterator();         assertEquals(StringParameterizedChild.class, iter.next());         assertEquals(GenericParent.class, iter.next());         assertEquals(GenericConsumer.class, iter.next());         assertEquals(Object.class, iter.next());         assertFalse(iter.hasNext());     }      @Test     public void testIsPrimitiveOrWrapper() {          // test primitive wrapper classes         assertTrue(ClassUtils.isPrimitiveOrWrapper(Boolean.class), "Boolean.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Byte.class), "Byte.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Character.class), "Character.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Short.class), "Short.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Integer.class), "Integer.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Long.class), "Long.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Double.class), "Double.class");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Float.class), "Float.class");          // test primitive classes         assertTrue(ClassUtils.isPrimitiveOrWrapper(Boolean.TYPE), "boolean");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Byte.TYPE), "byte");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Character.TYPE), "char");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Short.TYPE), "short");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Integer.TYPE), "int");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Long.TYPE), "long");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Double.TYPE), "double");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Float.TYPE), "float");         assertTrue(ClassUtils.isPrimitiveOrWrapper(Void.TYPE), "Void.TYPE");          // others         assertFalse(ClassUtils.isPrimitiveOrWrapper(null), "null");         assertFalse(ClassUtils.isPrimitiveOrWrapper(Void.class), "Void.class");         assertFalse(ClassUtils.isPrimitiveOrWrapper(String.class), "String.class");         assertFalse(ClassUtils.isPrimitiveOrWrapper(this.getClass()), "this.getClass()");     }      @Test     public void testIsPrimitiveWrapper() {          // test primitive wrapper classes         assertTrue(ClassUtils.isPrimitiveWrapper(Boolean.class), "Boolean.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Byte.class), "Byte.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Character.class), "Character.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Short.class), "Short.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Integer.class), "Integer.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Long.class), "Long.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Double.class), "Double.class");         assertTrue(ClassUtils.isPrimitiveWrapper(Float.class), "Float.class");          // test primitive classes         assertFalse(ClassUtils.isPrimitiveWrapper(Boolean.TYPE), "boolean");         assertFalse(ClassUtils.isPrimitiveWrapper(Byte.TYPE), "byte");         assertFalse(ClassUtils.isPrimitiveWrapper(Character.TYPE), "char");         assertFalse(ClassUtils.isPrimitiveWrapper(Short.TYPE), "short");         assertFalse(ClassUtils.isPrimitiveWrapper(Integer.TYPE), "int");         assertFalse(ClassUtils.isPrimitiveWrapper(Long.TYPE), "long");         assertFalse(ClassUtils.isPrimitiveWrapper(Double.TYPE), "double");         assertFalse(ClassUtils.isPrimitiveWrapper(Float.TYPE), "float");          // others         assertFalse(ClassUtils.isPrimitiveWrapper(null), "null");         assertFalse(ClassUtils.isPrimitiveWrapper(Void.class), "Void.class");         assertFalse(ClassUtils.isPrimitiveWrapper(Void.TYPE), "Void.TYPE");         assertFalse(ClassUtils.isPrimitiveWrapper(String.class), "String.class");         assertFalse(ClassUtils.isPrimitiveWrapper(this.getClass()), "this.getClass()");     }      @Test     public void testPrimitivesToWrappers() {         // test null //        assertNull("null -> null", ClassUtils.primitivesToWrappers(null)); // generates warning         assertNull(ClassUtils.primitivesToWrappers((Class<?>[]) null), "null -> null"); // equivalent cast to avoid warning         // Other possible casts for null         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers(), "empty -> empty");         final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>) null); // == new Class<?>[]{null}         assertArrayEquals(new Class<?>[]{null}, castNull, "(Class<?>) null -> [null]");         // test empty array is returned unchanged         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers(ArrayUtils.EMPTY_CLASS_ARRAY),                 "empty -> empty");          // test an array of various classes         final Class<?>[] primitives = new Class[] {                 Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE,                 Integer.TYPE, Long.TYPE, Double.TYPE, Float.TYPE,                 String.class, ClassUtils.class         };         final Class<?>[] wrappers= ClassUtils.primitivesToWrappers(primitives);          for (int i=0; i < primitives.length; i++) {             // test each returned wrapper             final Class<?> primitive = primitives[i];             final Class<?> expectedWrapper = ClassUtils.primitiveToWrapper(primitive);              assertEquals(expectedWrapper, wrappers[i], primitive + " -> " + expectedWrapper);         }          // test an array of no primitive classes         final Class<?>[] noPrimitives = new Class[] {                 String.class, ClassUtils.class, Void.TYPE         };         // This used to return the exact same array, but no longer does.         assertNotSame(noPrimitives, ClassUtils.primitivesToWrappers(noPrimitives), "unmodified");     }      @Test     public void testPrimitiveToWrapper() {          // test primitive classes         assertEquals(Boolean.class, ClassUtils.primitiveToWrapper(Boolean.TYPE), "boolean -> Boolean.class");         assertEquals(Byte.class, ClassUtils.primitiveToWrapper(Byte.TYPE), "byte -> Byte.class");         assertEquals(Character.class, ClassUtils.primitiveToWrapper(Character.TYPE), "char -> Character.class");         assertEquals(Short.class, ClassUtils.primitiveToWrapper(Short.TYPE), "short -> Short.class");         assertEquals(Integer.class, ClassUtils.primitiveToWrapper(Integer.TYPE), "int -> Integer.class");         assertEquals(Long.class, ClassUtils.primitiveToWrapper(Long.TYPE), "long -> Long.class");         assertEquals(Double.class, ClassUtils.primitiveToWrapper(Double.TYPE), "double -> Double.class");         assertEquals(Float.class, ClassUtils.primitiveToWrapper(Float.TYPE), "float -> Float.class");          // test a few other classes         assertEquals(String.class, ClassUtils.primitiveToWrapper(String.class), "String.class -> String.class");         assertEquals(ClassUtils.class, ClassUtils.primitiveToWrapper(ClassUtils.class),                 "ClassUtils.class -> ClassUtils.class");         assertEquals(Void.TYPE, ClassUtils.primitiveToWrapper(Void.TYPE), "Void.TYPE -> Void.TYPE");          // test null         assertNull(ClassUtils.primitiveToWrapper(null), "null -> null");     }      // Show the Java bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957     // We may have to delete this if a JDK fixes the bug.     @Test     public void testShowJavaBug() throws Exception {         // Tests with Collections$UnmodifiableSet         final Set<?> set = Collections.unmodifiableSet(new HashSet<>());         final Method isEmptyMethod = set.getClass().getMethod("isEmpty");         assertThrows(IllegalAccessException.class, () -> isEmptyMethod.invoke(set));     }      @Test     public void testToClass_object() { //        assertNull(ClassUtils.toClass(null)); // generates warning         assertNull(ClassUtils.toClass((Object[]) null)); // equivalent explicit cast          // Additional varargs tests         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(), "empty -> empty");         final Class<?>[] castNull = ClassUtils.toClass((Object) null); // == new Object[]{null}         assertArrayEquals(new Object[]{null}, castNull, "(Object) null -> [null]");          assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));          assertArrayEquals(new Class[]{String.class, Integer.class, Double.class}, ClassUtils.toClass("Test", Integer.valueOf(1), Double.valueOf(99d)));          assertArrayEquals(new Class[]{String.class, null, Double.class}, ClassUtils.toClass("Test", null, Double.valueOf(99d)));     }      @Test     public void testWithInterleavingWhitespace() throws ClassNotFoundException {         assertEquals( int[].class, ClassUtils.getClass( " int [ ] " ) );         assertEquals( long[].class, ClassUtils.getClass( "\rlong\t[\n]\r" ) );         assertEquals( short[].class, ClassUtils.getClass( "\tshort                \t\t[]" ) );         assertEquals( byte[].class, ClassUtils.getClass( "byte[\t\t\n\r]   " ) );     }      @Test     public void testWrappersToPrimitives() {         // an array with classes to test         final Class<?>[] classes = {                 Boolean.class, Byte.class, Character.class, Short.class,                 Integer.class, Long.class, Float.class, Double.class,                 String.class, ClassUtils.class, null         };          final Class<?>[] primitives = ClassUtils.wrappersToPrimitives(classes);         // now test the result         assertEquals(classes.length, primitives.length, "Wrong length of result array");         for (int i = 0; i < classes.length; i++) {             final Class<?> expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]);             assertEquals(expectedPrimitive, primitives[i], classes[i] + " -> " + expectedPrimitive);         }     }      @Test     public void testWrappersToPrimitivesEmpty() {         final Class<?>[] empty = new Class[0];         assertArrayEquals(empty, ClassUtils.wrappersToPrimitives(empty), "Wrong result for empty input");     }      @Test     public void testWrappersToPrimitivesNull() { //        assertNull("Wrong result for null input", ClassUtils.wrappersToPrimitives(null)); // generates warning         assertNull(ClassUtils.wrappersToPrimitives((Class<?>[]) null), "Wrong result for null input"); // equivalent cast         // Other possible casts for null         assertArrayEquals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.wrappersToPrimitives(), "empty -> empty");         final Class<?>[] castNull = ClassUtils.wrappersToPrimitives((Class<?>) null); // == new Class<?>[]{null}         assertArrayEquals(new Class<?>[]{null}, castNull, "(Class<?>) null -> [null]"); }      @Test     public void testWrapperToPrimitive() {         // an array with classes to convert         final Class<?>[] primitives = {                 Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE,                 Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE         };         for (final Class<?> primitive : primitives) {             final Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitive);             assertFalse(wrapperCls.isPrimitive(), "Still primitive");             assertEquals(primitive, ClassUtils.wrapperToPrimitive(wrapperCls), wrapperCls + " -> " + primitive);         }     }      @Test     public void testWrapperToPrimitiveNoWrapper() {         assertNull(ClassUtils.wrapperToPrimitive(String.class), "Wrong result for non wrapper class");     }      @Test     public void testWrapperToPrimitiveNull() {         assertNull(ClassUtils.wrapperToPrimitive(null), "Wrong result for null class");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.IOException; import java.io.UncheckedIOException; import java.lang.reflect.UndeclaredThrowableException; import java.util.concurrent.Callable; import java.util.function.BiConsumer; import java.util.function.BiFunction; import java.util.function.BiPredicate; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier;  import org.apache.commons.lang3.Functions.FailableBiConsumer; import org.apache.commons.lang3.Functions.FailableBiFunction; import org.apache.commons.lang3.Functions.FailableCallable; import org.apache.commons.lang3.Functions.FailableConsumer; import org.apache.commons.lang3.Functions.FailableFunction; import org.apache.commons.lang3.Functions.FailableSupplier; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test;  public class FunctionsTest {      public static class CloseableObject {         private boolean closed;          public void close() {             closed = true;         }          public boolean isClosed() {             return closed;         }          public void reset() {             closed = false;         }          public void run(final Throwable pTh) throws Throwable {             if (pTh != null) {                 throw pTh;             }         }     }      public static class FailureOnOddInvocations {         private static int invocations;          static boolean failingBool() throws SomeException {             throwOnOdd();             return true;         }          static boolean testDouble(final double value) throws SomeException {             throwOnOdd();             return true;         }          static boolean testInt(final int value) throws SomeException {             throwOnOdd();             return true;         }          static boolean testLong(final long value) throws SomeException {             throwOnOdd();             return true;         }          private static void throwOnOdd() throws SomeException {             final int i = ++invocations;             if (i % 2 == 1) {                 throw new SomeException("Odd Invocation: " + i);             }         }          FailureOnOddInvocations() throws SomeException {             throwOnOdd();         }          boolean getAsBoolean() throws SomeException {             throwOnOdd();             return true;         }     }      public static class SomeException extends Exception {          private static final long serialVersionUID = -4965704778119283411L;          private Throwable t;          SomeException(final String message) {             super(message);         }          public void setThrowable(final Throwable throwable) {             t = throwable;         }          public void test() throws Throwable {             if (t != null) {                 throw t;             }         }     }      public static class Testable<T, P> {         private T acceptedObject;         private P acceptedPrimitiveObject1;         private P acceptedPrimitiveObject2;         private Throwable throwable;          Testable(final Throwable throwable) {             this.throwable = throwable;         }          public T getAcceptedObject() {             return acceptedObject;         }          public P getAcceptedPrimitiveObject1() {             return acceptedPrimitiveObject1;         }          public P getAcceptedPrimitiveObject2() {             return acceptedPrimitiveObject2;         }          public void setThrowable(final Throwable throwable) {             this.throwable = throwable;         }          public void test() throws Throwable {             test(throwable);         }          public Object test(final Object input1, final Object input2) throws Throwable {             test(throwable);             return acceptedObject;         }          public void test(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }         }          public boolean testAsBooleanPrimitive() throws Throwable {             return testAsBooleanPrimitive(throwable);         }          public boolean testAsBooleanPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return false;         }          public double testAsDoublePrimitive() throws Throwable {             return testAsDoublePrimitive(throwable);         }          public double testAsDoublePrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public Integer testAsInteger() throws Throwable {             return testAsInteger(throwable);         }          public Integer testAsInteger(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public int testAsIntPrimitive() throws Throwable {             return testAsIntPrimitive(throwable);         }          public int testAsIntPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public long testAsLongPrimitive() throws Throwable {             return testAsLongPrimitive(throwable);         }          public long testAsLongPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public void testDouble(final double i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Double) i);         }          public double testDoubleDouble(final double i, final double j) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Double) i);             acceptedPrimitiveObject2 = (P) ((Double) j);             return 3d;         }          public void testInt(final int i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Integer) i);         }          public void testLong(final long i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Long) i);         }          public void testObjDouble(final T object, final double i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Double) i);         }          public void testObjInt(final T object, final int i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Integer) i);         }          public void testObjLong(final T object, final long i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Long) i);         }     }      @Test     public void testAcceptBiConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(null);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(Testable::test, testable, ise));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(Testable::test, testable, error));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(Testable::test, testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Functions.accept(Testable::test, testable, (Throwable) null);     }      @Test     public void testAcceptConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(Testable::test, testable));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(Testable::test, testable));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(Testable::test, testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Functions.accept(Testable::test, testable);     }      @Test     public void testAcceptDoubleConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, Double> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(testable::testDouble, 1d));         assertSame(ise, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testDouble, 1d));         assertSame(error, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testDouble, 1d));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testDouble, 1d);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptIntConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, Integer> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(testable::testInt, 1));         assertSame(ise, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testInt, 1));         assertSame(error, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testInt, 1));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testInt, 1);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptLongConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, Long> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(testable::testLong, 1L));         assertSame(ise, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testLong, 1L));         assertSame(error, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testLong, 1L));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testLong, 1L);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjDoubleConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<String, Double> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class,             () -> Functions.accept(testable::testObjDouble, "X", 1d));         assertSame(ise, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testObjDouble, "X", 1d));         assertSame(error, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testObjDouble, "X", 1d));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testObjDouble, "X", 1d);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1d, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjIntConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<String, Integer> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(testable::testObjInt, "X", 1));         assertSame(ise, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testObjInt, "X", 1));         assertSame(error, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testObjInt, "X", 1));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testObjInt, "X", 1);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjLongConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<String, Long> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.accept(testable::testObjLong, "X", 1L));         assertSame(ise, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.accept(testable::testObjLong, "X", 1L));         assertSame(error, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.accept(testable::testObjLong, "X", 1L));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Functions.accept(testable::testObjLong, "X", 1L);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1L, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testApplyBiFunction() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(null);         Throwable e = assertThrows(IllegalStateException.class,             () -> Functions.apply(Testable::testAsInteger, testable, ise));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         e = assertThrows(OutOfMemoryError.class, () -> Functions.apply(Testable::testAsInteger, testable, error));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         e = assertThrows(UncheckedIOException.class, () -> Functions.apply(Testable::testAsInteger, testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          final Integer i = Functions.apply(Testable::testAsInteger, testable, (Throwable) null);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     public void testApplyFunction() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class,             () -> Functions.apply(Testable::testAsInteger, testable));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.apply(Testable::testAsInteger, testable));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.apply(Testable::testAsInteger, testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final Integer i = Functions.apply(Testable::testAsInteger, testable);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     public void testAsCallable() {         FailureOnOddInvocations.invocations = 0;         final FailableCallable<FailureOnOddInvocations, SomeException> failableCallable = FailureOnOddInvocations::new;         final Callable<FailureOnOddInvocations> callable = Functions.asCallable(failableCallable);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, callable::call);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance;         try {             instance = callable.call();         } catch (final Exception ex) {             throw Functions.rethrow(ex);         }         assertNotNull(instance);     }      @Test     public void testAsConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         final Consumer<Testable<?, ?>> consumer = Functions.asConsumer(Testable::test);         Throwable e = assertThrows(IllegalStateException.class, () -> consumer.accept(testable));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> consumer.accept(testable));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> consumer.accept(testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Functions.accept(Testable::test, testable);     }      @Test     public void testAsRunnable() {         FailureOnOddInvocations.invocations = 0;         final Runnable runnable = Functions.asRunnable(FailureOnOddInvocations::new);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, runnable::run);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());          // Even invocations, should not throw an exception         runnable.run();     }      @Test     public void testAsSupplier() {         FailureOnOddInvocations.invocations = 0;         final FailableSupplier<FailureOnOddInvocations, Throwable> failableSupplier = FailureOnOddInvocations::new;         final Supplier<FailureOnOddInvocations> supplier = Functions.asSupplier(failableSupplier);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, supplier::get);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         assertNotNull(supplier.get());     }      @Test     public void testBiConsumer() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(null);         final FailableBiConsumer<Testable<?, ?>, Throwable, Throwable> failableBiConsumer = (t, th) -> {             t.setThrowable(th);             t.test();         };         final BiConsumer<Testable<?, ?>, Throwable> consumer = Functions.asBiConsumer(failableBiConsumer);         Throwable e = assertThrows(IllegalStateException.class, () -> consumer.accept(testable, ise));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         e = assertThrows(OutOfMemoryError.class, () -> consumer.accept(testable, error));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> consumer.accept(testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          consumer.accept(testable, null);     }      @Test     public void testBiFunction() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         final FailableBiFunction<Testable<?, ?>, Throwable, Integer, Throwable> failableBiFunction = (t, th) -> {             t.setThrowable(th);             return Integer.valueOf(t.testAsInteger());         };         final BiFunction<Testable<?, ?>, Throwable, Integer> biFunction = Functions.asBiFunction(failableBiFunction);         Throwable e = assertThrows(IllegalStateException.class, () -> biFunction.apply(testable, ise));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> biFunction.apply(testable, error));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> biFunction.apply(testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          assertEquals(0, biFunction.apply(testable, null).intValue());     }      @Test     @DisplayName("Test that asPredicate(FailableBiPredicate) is converted to -> BiPredicate ")     public void testBiPredicate() {         FailureOnOddInvocations.invocations = 0;         final Functions.FailableBiPredicate<Object, Object, Throwable> failableBiPredicate = (t1,             t2) -> FailureOnOddInvocations.failingBool();         final BiPredicate<?, ?> predicate = Functions.asBiPredicate(failableBiPredicate);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> predicate.test(null, null));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final boolean instance = predicate.test(null, null);         assertNotNull(instance);     }      @Test     public void testCallable() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Functions.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance = Functions.call(FailureOnOddInvocations::new);         assertNotNull(instance);     }      @Test     public void testConstructor() {         // We allow this, which must have been an omission to make the ctor private.         // We could make the ctor private in 4.0.         new Functions();     }      @Test     public void testFunction() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         final FailableFunction<Throwable, Integer, Throwable> failableFunction = th -> {             testable.setThrowable(th);             return Integer.valueOf(testable.testAsInteger());         };         final Function<Throwable, Integer> function = Functions.asFunction(failableFunction);         Throwable e = assertThrows(IllegalStateException.class, () -> function.apply(ise));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> function.apply(error));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> function.apply(ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          assertEquals(0, function.apply(null).intValue());     }      @Test     public void testGetFromSupplier() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Functions.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance = Functions.call(FailureOnOddInvocations::new);         assertNotNull(instance);     }      @Test     public void testGetSupplier() {         final IllegalStateException ise = new IllegalStateException();         final Testable<?, ?> testable = new Testable<>(ise);         Throwable e = assertThrows(IllegalStateException.class, () -> Functions.get(testable::testAsInteger));         assertSame(ise, e);          final Error error = new OutOfMemoryError();         testable.setThrowable(error);         e = assertThrows(OutOfMemoryError.class, () -> Functions.get(testable::testAsInteger));         assertSame(error, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Functions.get(testable::testAsInteger));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final Integer i = Functions.apply(Testable::testAsInteger, testable);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     @DisplayName("Test that asPredicate(FailablePredicate) is converted to -> Predicate ")     public void testPredicate() {         FailureOnOddInvocations.invocations = 0;         final Functions.FailablePredicate<Object, Throwable> failablePredicate = t -> FailureOnOddInvocations             .failingBool();         final Predicate<?> predicate = Functions.asPredicate(failablePredicate);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> predicate.test(null));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final boolean instance = predicate.test(null);         assertNotNull(instance);     }      @Test     public void testRunnable() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Functions.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());          // Even invocations, should not throw an exception         Functions.run(FailureOnOddInvocations::new);     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiConsumer_Object_Throwable() {         new Functions.FailableBiConsumer<Object, Object, Throwable>() {              @Override             public void accept(final Object object1, final Object object2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiConsumer_String_IOException() {         new Functions.FailableBiConsumer<String, String, IOException>() {              @Override             public void accept(final String object1, final String object2) throws IOException {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiFunction_Object_Throwable() {         new Functions.FailableBiFunction<Object, Object, Object, Throwable>() {              @Override             public Object apply(final Object input1, final Object input2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiFunction_String_IOException() {         new Functions.FailableBiFunction<String, String, String, IOException>() {              @Override             public String apply(final String input1, final String input2) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiPredicate_Object_Throwable() {         new Functions.FailableBiPredicate<Object, Object, Throwable>() {              @Override             public boolean test(final Object object1, final Object object2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiPredicate_String_IOException() {         new Functions.FailableBiPredicate<String, String, IOException>() {              @Override             public boolean test(final String object1, final String object2) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableCallable_Object_Throwable() {         new Functions.FailableCallable<Object, Throwable>() {              @Override             public Object call() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableCallable_String_IOException() {         new Functions.FailableCallable<String, IOException>() {              @Override             public String call() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableConsumer_Object_Throwable() {         new Functions.FailableConsumer<Object, Throwable>() {              @Override             public void accept(final Object object) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableConsumer_String_IOException() {         new Functions.FailableConsumer<String, IOException>() {              @Override             public void accept(final String object) throws IOException {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableFunction_Object_Throwable() {         new Functions.FailableFunction<Object, Object, Throwable>() {              @Override             public Object apply(final Object input) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableFunction_String_IOException() {         new Functions.FailableFunction<String, String, IOException>() {              @Override             public String apply(final String input) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailablePredicate_Object_Throwable() {         new Functions.FailablePredicate<Object, Throwable>() {              @Override             public boolean test(final Object object) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailablePredicate_String_IOException() {         new Functions.FailablePredicate<String, IOException>() {              @Override             public boolean test(final String object) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableRunnable_Object_Throwable() {         new Functions.FailableRunnable<Throwable>() {              @Override             public void run() throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableRunnable_String_IOException() {         new Functions.FailableRunnable<IOException>() {              @Override             public void run() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableSupplier_Object_Throwable() {         new Functions.FailableSupplier<Object, Throwable>() {              @Override             public Object get() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableSupplier_String_IOException() {         new Functions.FailableSupplier<String, IOException>() {              @Override             public String get() throws IOException {                 throw new IOException("test");             }         };     }      @Test     public void testTryWithResources() {         final CloseableObject co = new CloseableObject();         final FailableConsumer<Throwable, ? extends Throwable> consumer = co::run;         final IllegalStateException ise = new IllegalStateException();         Throwable e = assertThrows(IllegalStateException.class,             () -> Functions.tryWithResources(() -> consumer.accept(ise), co::close));         assertSame(ise, e);          assertTrue(co.isClosed());         co.reset();         final Error error = new OutOfMemoryError();         e = assertThrows(OutOfMemoryError.class,             () -> Functions.tryWithResources(() -> consumer.accept(error), co::close));         assertSame(error, e);          assertTrue(co.isClosed());         co.reset();         final IOException ioe = new IOException("Unknown I/O error");         final UncheckedIOException uioe = assertThrows(UncheckedIOException.class,             () -> Functions.tryWithResources(() -> consumer.accept(ioe), co::close));         final IOException cause = uioe.getCause();         assertSame(ioe, cause);          assertTrue(co.isClosed());         co.reset();         Functions.tryWithResources(() -> consumer.accept(null), co::close);         assertTrue(co.isClosed());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  * Tests for {@link RandomUtils}  */ public class RandomUtilsTest {      /**      * For comparing doubles and floats      */     private static final double DELTA = 1e-5;      @Test     public void testConstructor() {         assertNotNull(new RandomUtils());         final Constructor<?>[] cons = RandomUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(RandomUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(RandomUtils.class.getModifiers()));     }      @Test     public void testNextBytesNegative() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextBytes(-1));     }      @Test     public void testNextIntNegative() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextInt(-1, 1));     }      @Test     public void testNextLongNegative() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextLong(-1, 1));     }      @Test     public void testNextDoubleNegative() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextDouble(-1, 1));     }      @Test     public void testNextFloatNegative() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextFloat(-1, 1));     }      @Test     public void testNextIntLowerGreaterUpper() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextInt(2, 1));     }      @Test     public void testNextLongLowerGreaterUpper() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextLong(2, 1));     }      @Test     public void testNextDoubleLowerGreaterUpper() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextDouble(2, 1));     }      @Test     public void testNextFloatLowerGreaterUpper() {         assertThrows(IllegalArgumentException.class, () -> RandomUtils.nextFloat(2, 1));     }      /**      * Tests next boolean      */     @Test     public void testBoolean() {         final boolean result = RandomUtils.nextBoolean();         assertTrue(result == true || result == false);     }      /**      * Tests a zero byte array length.      */     @Test     public void testZeroLengthNextBytes() {         assertArrayEquals(new byte[0], RandomUtils.nextBytes(0));     }      /**      * Tests random byte array.      */     @Test     public void testNextBytes() {         final byte[] result = RandomUtils.nextBytes(20);         assertEquals(20, result.length);     }      /**      * Test next int range with minimal range.      */     @Test     public void testNextIntMinimalRange() {         assertEquals(42, RandomUtils.nextInt(42, 42));     }      /**      * Tests next int range.      */     @Test     public void testNextInt() {         final int result = RandomUtils.nextInt(33, 42);         assertTrue(result >= 33 && result < 42);     }      /**      * Tests next int range, random result.      */     @Test     public void testNextIntRandomResult() {         final int randomResult = RandomUtils.nextInt();         assertTrue(randomResult > 0);         assertTrue(randomResult < Integer.MAX_VALUE);     }      /**      * Test next double range with minimal range.      */     @Test     public void testNextDoubleMinimalRange() {         assertEquals(42.1, RandomUtils.nextDouble(42.1, 42.1), DELTA);     }      /**      * Test next float range with minimal range.      */     @Test     public void testNextFloatMinimalRange() {         assertEquals(42.1f, RandomUtils.nextFloat(42.1f, 42.1f), DELTA);     }      /**      * Tests next double range.      */     @Test     public void testNextDouble() {         final double result = RandomUtils.nextDouble(33d, 42d);         assertTrue(result >= 33d && result <= 42d);     }      /**      * Tests next double range, random result.      */     @Test     public void testNextDoubleRandomResult() {         final double randomResult = RandomUtils.nextDouble();         assertTrue(randomResult > 0);         assertTrue(randomResult < Double.MAX_VALUE);     }      /**      * Tests next float range.      */     @Test     public void testNextFloat() {         final double result = RandomUtils.nextFloat(33f, 42f);         assertTrue(result >= 33f && result <= 42f);     }      /**      * Tests next float range, random result.      */     @Test     public void testNextFloatRandomResult() {         final float randomResult = RandomUtils.nextFloat();         assertTrue(randomResult > 0);         assertTrue(randomResult < Float.MAX_VALUE);     }      /**      * Test next long range with minimal range.      */     @Test     public void testNextLongMinimalRange() {         assertEquals(42L, RandomUtils.nextLong(42L, 42L));     }      /**      * Tests next long range.      */     @Test     public void testNextLong() {         final long result = RandomUtils.nextLong(33L, 42L);         assertTrue(result >= 33L && result < 42L);     }      /**      * Tests next long range, random result.      */     @Test     public void testNextLongRandomResult() {         final long randomResult = RandomUtils.nextLong();         assertTrue(randomResult > 0);         assertTrue(randomResult < Long.MAX_VALUE);     }      /**      * Tests extreme range.      */     @Test     public void testExtremeRangeInt() {         final int result = RandomUtils.nextInt(0, Integer.MAX_VALUE);         assertTrue(result >= 0 && result < Integer.MAX_VALUE);     }      /**      * Tests extreme range.      */     @Test     public void testExtremeRangeLong() {         final long result = RandomUtils.nextLong(0, Long.MAX_VALUE);         assertTrue(result >= 0 && result < Long.MAX_VALUE);     }      /**      * Tests extreme range.      */     @Test     public void testExtremeRangeFloat() {         final float result = RandomUtils.nextFloat(0, Float.MAX_VALUE);         assertTrue(result >= 0f && result <= Float.MAX_VALUE);     }      /**      * Tests extreme range.      */     @Test     public void testExtremeRangeDouble() {         final double result = RandomUtils.nextDouble(0, Double.MAX_VALUE);         assertTrue(result >= 0 && result <= Double.MAX_VALUE);     }      /**      * Test a large value for long. A previous implementation using      * {@link RandomUtils#nextDouble(double, double)} could generate a value equal      * to the upper limit.      *      * <pre>      * return (long) nextDouble(startInclusive, endExclusive);      * </pre>      *      * <p>See LANG-1592.</p>      */     @Test     public void testLargeValueRangeLong() {         final long startInclusive = 12900000000001L;         final long endExclusive = 12900000000016L;         // Note: The method using 'return (long) nextDouble(startInclusive, endExclusive)'         // takes thousands of calls to generate an error. This size loop fails most         // of the time with the previous method.         final int n = (int) (endExclusive - startInclusive) * 1000;         for (int i = 0; i < n; i++) {             assertNotEquals(endExclusive, RandomUtils.nextLong(startInclusive, endExclusive));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Tests ArrayUtils remove and removeElement methods.  */ public class ArrayUtilsRemoveTest {      @Test     public void testRemoveAllBooleanOccurences() {         boolean[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, true));          a = new boolean[0];         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurences(a, true));          a = new boolean[] { true };         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurences(a, true));          a = new boolean[] { true, true };         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurences(a, true));          a = new boolean[] { false, true, true, false, true };         assertArrayEquals(new boolean[]{false, false}, ArrayUtils.removeAllOccurences(a, true));          a = new boolean[] { false, true, true, false, true };         assertArrayEquals(new boolean[]{true, true, true}, ArrayUtils.removeAllOccurences(a, false));     }      @Test     public void testRemoveAllBooleanOccurrences() {         boolean[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, true));          a = new boolean[0];         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurrences(a, true));          a = new boolean[] { true };         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurrences(a, true));          a = new boolean[] { true, true };         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.removeAllOccurrences(a, true));          a = new boolean[] { false, true, true, false, true };         assertArrayEquals(new boolean[]{false, false}, ArrayUtils.removeAllOccurrences(a, true));          a = new boolean[] { false, true, true, false, true };         assertArrayEquals(new boolean[]{true, true, true}, ArrayUtils.removeAllOccurrences(a, false));     }      @Test     public void testRemoveAllByteOccurences() {         byte[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, (byte) 2));          a = new byte[0];         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurences(a, (byte) 2));          a = new byte[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurences(a, (byte) 2));          a = new byte[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurences(a, (byte) 2));          a = new byte[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new byte[]{1, 3}, ArrayUtils.removeAllOccurences(a, (byte) 2));          a = new byte[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new byte[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, (byte) 4));     }      @Test     public void testRemoveAllByteOccurrences() {         byte[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, (byte) 2));          a = new byte[0];         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurrences(a, (byte) 2));          a = new byte[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurrences(a, (byte) 2));          a = new byte[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.removeAllOccurrences(a, (byte) 2));          a = new byte[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new byte[]{1, 3}, ArrayUtils.removeAllOccurrences(a, (byte) 2));          a = new byte[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new byte[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, (byte) 4));     }      @Test     public void testRemoveAllCharOccurences() {         char[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, '2'));          a = new char[0];         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurences(a, '2'));          a = new char[] { '2' };         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurences(a, '2'));          a = new char[] { '2', '2' };         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurences(a, '2'));          a = new char[] { '1', '2', '2', '3', '2' };         assertArrayEquals(new char[]{'1', '3'}, ArrayUtils.removeAllOccurences(a, '2'));          a = new char[] { '1', '2', '2', '3', '2' };         assertArrayEquals(new char[]{'1', '2', '2', '3', '2'}, ArrayUtils.removeAllOccurences(a, '4'));     }      @Test     public void testRemoveAllCharOccurrences() {         char[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, '2'));          a = new char[0];         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurrences(a, '2'));          a = new char[] { '2' };         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurrences(a, '2'));          a = new char[] { '2', '2' };         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.removeAllOccurrences(a, '2'));          a = new char[] { '1', '2', '2', '3', '2' };         assertArrayEquals(new char[]{'1', '3'}, ArrayUtils.removeAllOccurrences(a, '2'));          a = new char[] { '1', '2', '2', '3', '2' };         assertArrayEquals(new char[]{'1', '2', '2', '3', '2'}, ArrayUtils.removeAllOccurrences(a, '4'));     }      @Test     public void testRemoveAllDoubleOccurences() {         double[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, 2));          a = new double[0];         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new double[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new double[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new double[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new double[]{1, 3}, ArrayUtils.removeAllOccurences(a, 2));          a = new double[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new double[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, 4));     }      @Test     public void testRemoveAllDoubleOccurrences() {         double[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, 2));          a = new double[0];         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new double[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new double[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new double[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new double[]{1, 3}, ArrayUtils.removeAllOccurrences(a, 2));          a = new double[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new double[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, 4));     }      @Test     public void testRemoveAllFloatOccurences() {         float[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, 2));          a = new float[0];         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new float[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new float[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new float[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new float[]{1, 3}, ArrayUtils.removeAllOccurences(a, 2));          a = new float[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new float[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, 4));     }      @Test     public void testRemoveAllFloatOccurrences() {         float[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, 2));          a = new float[0];         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new float[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new float[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new float[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new float[]{1, 3}, ArrayUtils.removeAllOccurrences(a, 2));          a = new float[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new float[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, 4));     }      @Test     public void testRemoveAllIntOccurences() {         int[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, 2));          a = new int[0];         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new int[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new int[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new int[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new int[]{1, 3}, ArrayUtils.removeAllOccurences(a, 2));          a = new int[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new int[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, 4));     }      @Test     public void testRemoveAllIntOccurrences() {         int[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, 2));          a = new int[0];         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new int[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new int[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new int[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new int[]{1, 3}, ArrayUtils.removeAllOccurrences(a, 2));          a = new int[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new int[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, 4));     }      @Test     public void testRemoveAllLongOccurences() {         long[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, 2));          a = new long[0];         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new long[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new long[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurences(a, 2));          a = new long[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new long[]{1, 3}, ArrayUtils.removeAllOccurences(a, 2));          a = new long[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new long[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, 4));     }      @Test     public void testRemoveAllLongOccurrences() {         long[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, 2));          a = new long[0];         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new long[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new long[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.removeAllOccurrences(a, 2));          a = new long[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new long[]{1, 3}, ArrayUtils.removeAllOccurrences(a, 2));          a = new long[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new long[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, 4));     }      @Test     public void testRemoveAllObjectOccurences() {         String[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, "2"));          a = new String[0];         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurences(a, "2"));          a = new String[] { "2" };         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurences(a, "2"));          a = new String[] { "2", "2" };         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurences(a, "2"));          a = new String[] { "1", "2", "2", "3", "2" };         assertArrayEquals(new String[]{"1", "3"}, ArrayUtils.removeAllOccurences(a, "2"));          a = new String[] { "1", "2", "2", "3", "2" };         assertArrayEquals(new String[]{"1", "2", "2", "3", "2"}, ArrayUtils.removeAllOccurences(a, "4"));     }      @Test     public void testRemoveAllObjectOccurrences() {         String[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, "2"));          a = new String[0];         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurrences(a, "2"));          a = new String[] { "2" };         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurrences(a, "2"));          a = new String[] { "2", "2" };         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.removeAllOccurrences(a, "2"));          a = new String[] { "1", "2", "2", "3", "2" };         assertArrayEquals(new String[]{"1", "3"}, ArrayUtils.removeAllOccurrences(a, "2"));          a = new String[] { "1", "2", "2", "3", "2" };         assertArrayEquals(new String[]{"1", "2", "2", "3", "2"}, ArrayUtils.removeAllOccurrences(a, "4"));     }      @Test     public void testRemoveAllShortOccurences() {         short[] a = null;         assertNull(ArrayUtils.removeAllOccurences(a, (short) 2));          a = new short[0];         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurences(a, (short) 2));          a = new short[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurences(a, (short) 2));          a = new short[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurences(a, (short) 2));          a = new short[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new short[]{1, 3}, ArrayUtils.removeAllOccurences(a, (short) 2));          a = new short[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new short[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurences(a, (short) 4));     }      @Test     public void testRemoveAllShortOccurrences() {         short[] a = null;         assertNull(ArrayUtils.removeAllOccurrences(a, (short) 2));          a = new short[0];         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurrences(a, (short) 2));          a = new short[] { 2 };         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurrences(a, (short) 2));          a = new short[] { 2, 2 };         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.removeAllOccurrences(a, (short) 2));          a = new short[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new short[]{1, 3}, ArrayUtils.removeAllOccurrences(a, (short) 2));          a = new short[] { 1, 2, 2, 3, 2 };         assertArrayEquals(new short[]{1, 2, 2, 3, 2}, ArrayUtils.removeAllOccurrences(a, (short) 4));     }      @Test     public void testRemoveBooleanArray() {         boolean[] array;         array = ArrayUtils.remove(new boolean[] {true}, 0);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new boolean[] {true, false}, 0);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new boolean[] {true, false}, 1);         assertArrayEquals(new boolean[]{true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new boolean[] {true, false, true}, 1);         assertArrayEquals(new boolean[]{true, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new boolean[] {true, false}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new boolean[] {true, false}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((boolean[]) null, 0));     }      @Test     public void testRemoveByteArray() {         byte[] array;         array = ArrayUtils.remove(new byte[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new byte[] {1, 2}, 0);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new byte[] {1, 2}, 1);         assertArrayEquals(new byte[]{1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new byte[] {1, 2, 1}, 1);         assertArrayEquals(new byte[]{1, 1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new byte[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new byte[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((byte[]) null, 0));     }      @Test     public void testRemoveCharArray() {         char[] array;         array = ArrayUtils.remove(new char[] {'a'}, 0);         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new char[] {'a', 'b'}, 0);         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new char[] {'a', 'b'}, 1);         assertArrayEquals(new char[]{'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new char[] {'a', 'b', 'c'}, 1);         assertArrayEquals(new char[]{'a', 'c'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new char[] {'a', 'b'}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new char[] {'a', 'b'}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((char[]) null, 0));     }      @Test     public void testRemoveDoubleArray() {         double[] array;         array = ArrayUtils.remove(new double[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new double[] {1, 2}, 0);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new double[] {1, 2}, 1);         assertArrayEquals(new double[]{1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new double[] {1, 2, 1}, 1);         assertArrayEquals(new double[]{1, 1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new double[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new double[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((double[]) null, 0));     }      @Test     public void testRemoveElementBooleanArray() {         boolean[] array;         array = ArrayUtils.removeElement(null, true);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new boolean[] {true}, true);         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new boolean[] {true, false}, true);         assertArrayEquals(new boolean[]{false}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true);         assertArrayEquals(new boolean[]{false, true}, array);         assertEquals(Boolean.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementByteArray() {         byte[] array;         array = ArrayUtils.removeElement((byte[]) null, (byte) 1);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1);         assertArrayEquals(ArrayUtils.EMPTY_BYTE_ARRAY, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1);         assertArrayEquals(new byte[]{2}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1);         assertArrayEquals(new byte[]{2, 1}, array);         assertEquals(Byte.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementCharArray() {         char[] array;         array = ArrayUtils.removeElement((char[]) null, 'a');         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new char[] {'a'}, 'a');         assertArrayEquals(ArrayUtils.EMPTY_CHAR_ARRAY, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new char[] {'a', 'b'}, 'a');         assertArrayEquals(new char[]{'b'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new char[] {'a', 'b', 'a'}, 'a');         assertArrayEquals(new char[]{'b', 'a'}, array);         assertEquals(Character.TYPE, array.getClass().getComponentType());     }      @Test     @SuppressWarnings("cast")     public void testRemoveElementDoubleArray() {         double[] array;         array = ArrayUtils.removeElement(null, (double) 1);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new double[] {1}, (double) 1);         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new double[] {1, 2}, (double) 1);         assertArrayEquals(new double[]{2}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new double[] {1, 2, 1}, (double) 1);         assertArrayEquals(new double[]{2, 1}, array);         assertEquals(Double.TYPE, array.getClass().getComponentType());     }      @Test     @SuppressWarnings("cast")     public void testRemoveElementFloatArray() {         float[] array;         array = ArrayUtils.removeElement((float[]) null, (float) 1);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new float[] {1}, (float) 1);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new float[] {1, 2}, (float) 1);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new float[] {1, 2, 1}, (float) 1);         assertArrayEquals(new float[]{2, 1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementIntArray() {         int[] array;         array = ArrayUtils.removeElement((int[]) null, 1);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new int[] {1}, 1);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new int[] {1, 2}, 1);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1);         assertArrayEquals(new int[]{2, 1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());     }       @Test     @SuppressWarnings("cast")     public void testRemoveElementLongArray() {         long[] array;         array = ArrayUtils.removeElement((long[]) null, 1L);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_LONG_ARRAY, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new long[] {1}, 1L);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new long[] {1, 2}, 1L);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new long[] {1, 2, 1}, 1L);         assertArrayEquals(new long[]{2, 1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveElementObjectArray() {         Object[] array;         array = ArrayUtils.removeElement(null, "a");         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, "a");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new Object[] {"a"}, "a");         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new Object[] {"a", "b"}, "a");         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new Object[] {"a", "b", "a"}, "a");         assertArrayEquals(new Object[]{"b", "a"}, array);         assertEquals(Object.class, array.getClass().getComponentType());     }      @Test     public void testRemoveElementShortArray() {         short[] array;         array = ArrayUtils.removeElement((short[]) null, (short) 1);         assertNull(array);         array = ArrayUtils.removeElement(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new short[] {1}, (short) 1);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new short[] {1, 2}, (short) 1);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.removeElement(new short[] {1, 2, 1}, (short) 1);         assertArrayEquals(new short[]{2, 1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());     }      @Test     public void testRemoveFloatArray() {         float[] array;         array = ArrayUtils.remove(new float[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new float[] {1, 2}, 0);         assertArrayEquals(new float[]{2}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new float[] {1, 2}, 1);         assertArrayEquals(new float[]{1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new float[] {1, 2, 1}, 1);         assertArrayEquals(new float[]{1, 1}, array);         assertEquals(Float.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new float[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new float[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((float[]) null, 0));     }      @Test     public void testRemoveIntArray() {         int[] array;         array = ArrayUtils.remove(new int[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new int[] {1, 2}, 0);         assertArrayEquals(new int[]{2}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new int[] {1, 2}, 1);         assertArrayEquals(new int[]{1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new int[] {1, 2, 1}, 1);         assertArrayEquals(new int[]{1, 1}, array);         assertEquals(Integer.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new int[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new int[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((int[]) null, 0));     }      @Test     public void testRemoveLongArray() {         long[] array;         array = ArrayUtils.remove(new long[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_LONG_ARRAY, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new long[] {1, 2}, 0);         assertArrayEquals(new long[]{2}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new long[] {1, 2}, 1);         assertArrayEquals(new long[]{1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new long[] {1, 2, 1}, 1);         assertArrayEquals(new long[]{1, 1}, array);         assertEquals(Long.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new long[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new long[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((long[]) null, 0));     }      @Test     public void testRemoveNumberArray() {         final Number[] inarray = {Integer.valueOf(1), Long.valueOf(2), Byte.valueOf((byte) 3)};         assertEquals(3, inarray.length);         Number[] outarray;         outarray = ArrayUtils.remove(inarray, 1);         assertEquals(2, outarray.length);         assertEquals(Number.class, outarray.getClass().getComponentType());         outarray = ArrayUtils.remove(outarray, 1);         assertEquals(1, outarray.length);         assertEquals(Number.class, outarray.getClass().getComponentType());         outarray = ArrayUtils.remove(outarray, 0);         assertEquals(0, outarray.length);         assertEquals(Number.class, outarray.getClass().getComponentType());     }      @Test     public void testRemoveObjectArray() {         Object[] array;         array = ArrayUtils.remove(new Object[] {"a"}, 0);         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.remove(new Object[] {"a", "b"}, 0);         assertArrayEquals(new Object[]{"b"}, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.remove(new Object[] {"a", "b"}, 1);         assertArrayEquals(new Object[]{"a"}, array);         assertEquals(Object.class, array.getClass().getComponentType());         array = ArrayUtils.remove(new Object[] {"a", "b", "c"}, 1);         assertArrayEquals(new Object[]{"a", "c"}, array);         assertEquals(Object.class, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new Object[] {"a", "b"}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new Object[] {"a", "b"}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((Object[]) null, 0));     }      @Test     public void testRemoveShortArray() {         short[] array;         array = ArrayUtils.remove(new short[] {1}, 0);         assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new short[] {1, 2}, 0);         assertArrayEquals(new short[]{2}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new short[] {1, 2}, 1);         assertArrayEquals(new short[]{1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         array = ArrayUtils.remove(new short[] {1, 2, 1}, 1);         assertArrayEquals(new short[]{1, 1}, array);         assertEquals(Short.TYPE, array.getClass().getComponentType());         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new short[] {1, 2}, -1));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove(new short[] {1, 2}, 2));         assertThrows(IndexOutOfBoundsException.class, () -> ArrayUtils.remove((short[]) null, 0));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.CURLY; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.LARRY; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.MOE; import static org.apache.commons.lang3.AnnotationUtilsTest.Stooge.SHEMP; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.time.Duration; import java.util.Collection; import java.util.Map;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  */ public class AnnotationUtilsTest {     @TestAnnotation(             booleanValue = false,             booleanValues = { false },             byteValue = 0,             byteValues = { 0 },             charValue = 0,             charValues = { 0 },             doubleValue = 0,             doubleValues = { 0 },             floatValue = 0,             floatValues = { 0 },             intValue = 0,             intValues = { 0 },             longValue = 0,             longValues = { 0 },             nest = @NestAnnotation(                     booleanValue = false,                     booleanValues = { false },                     byteValue = 0,                     byteValues = { 0 },                     charValue = 0,                     charValues = { 0 },                     doubleValue = 0,                     doubleValues = { 0 },                     floatValue = 0,                     floatValues = { 0 },                     intValue = 0,                     intValues = { 0 },                     longValue = 0,                     longValues = { 0 },                     shortValue = 0,                     shortValues = { 0 },                     stooge = CURLY,                     stooges = { MOE, LARRY, SHEMP },                     string = "",                     strings = { "" },                     type = Object.class,                     types = { Object.class }             ),             nests = {                 @NestAnnotation(                         booleanValue = false,                         booleanValues = { false },                         byteValue = 0,                         byteValues = { 0 },                         charValue = 0,                         charValues = { 0 },                         doubleValue = 0,                         doubleValues = { 0 },                         floatValue = 0,                         floatValues = { 0 },                         intValue = 0,                         intValues = { 0 },                         longValue = 0,                         longValues = { 0 },                         shortValue = 0,                         shortValues = { 0 },                         stooge = CURLY,                         stooges = { MOE, LARRY, SHEMP },                         string = "",                         strings = { "" },                         type = Object[].class,                         types = { Object[].class }                 )             },             shortValue = 0,             shortValues = { 0 },             stooge = SHEMP,             stooges = { MOE, LARRY, CURLY },             string = "",             strings = { "" },             type = Object.class,             types = { Object.class }     )     public Object dummy1;      @TestAnnotation(             booleanValue = false,             booleanValues = { false },             byteValue = 0,             byteValues = { 0 },             charValue = 0,             charValues = { 0 },             doubleValue = 0,             doubleValues = { 0 },             floatValue = 0,             floatValues = { 0 },             intValue = 0,             intValues = { 0 },             longValue = 0,             longValues = { 0 },             nest = @NestAnnotation(                     booleanValue = false,                     booleanValues = { false },                     byteValue = 0,                     byteValues = { 0 },                     charValue = 0,                     charValues = { 0 },                     doubleValue = 0,                     doubleValues = { 0 },                     floatValue = 0,                     floatValues = { 0 },                     intValue = 0,                     intValues = { 0 },                     longValue = 0,                     longValues = { 0 },                     shortValue = 0,                     shortValues = { 0 },                     stooge = CURLY,                     stooges = { MOE, LARRY, SHEMP },                     string = "",                     strings = { "" },                     type = Object.class,                     types = { Object.class }             ),             nests = {                 @NestAnnotation(                         booleanValue = false,                         booleanValues = { false },                         byteValue = 0,                         byteValues = { 0 },                         charValue = 0,                         charValues = { 0 },                         doubleValue = 0,                         doubleValues = { 0 },                         floatValue = 0,                         floatValues = { 0 },                         intValue = 0,                         intValues = { 0 },                         longValue = 0,                         longValues = { 0 },                         shortValue = 0,                         shortValues = { 0 },                         stooge = CURLY,                         stooges = { MOE, LARRY, SHEMP },                         string = "",                         strings = { "" },                         type = Object[].class,                         types = { Object[].class }                 )             },             shortValue = 0,             shortValues = { 0 },             stooge = SHEMP,             stooges = { MOE, LARRY, CURLY },             string = "",             strings = { "" },             type = Object.class,             types = { Object.class }     )     public Object dummy2;      @TestAnnotation(             booleanValue = false,             booleanValues = { false },             byteValue = 0,             byteValues = { 0 },             charValue = 0,             charValues = { 0 },             doubleValue = 0,             doubleValues = { 0 },             floatValue = 0,             floatValues = { 0 },             intValue = 0,             intValues = { 0 },             longValue = 0,             longValues = { 0 },             nest = @NestAnnotation(                     booleanValue = false,                     booleanValues = { false },                     byteValue = 0,                     byteValues = { 0 },                     charValue = 0,                     charValues = { 0 },                     doubleValue = 0,                     doubleValues = { 0 },                     floatValue = 0,                     floatValues = { 0 },                     intValue = 0,                     intValues = { 0 },                     longValue = 0,                     longValues = { 0 },                     shortValue = 0,                     shortValues = { 0 },                     stooge = CURLY,                     stooges = { MOE, LARRY, SHEMP },                     string = "",                     strings = { "" },                     type = Object.class,                     types = { Object.class }             ),             nests = {                 @NestAnnotation(                         booleanValue = false,                         booleanValues = { false },                         byteValue = 0,                         byteValues = { 0 },                         charValue = 0,                         charValues = { 0 },                         doubleValue = 0,                         doubleValues = { 0 },                         floatValue = 0,                         floatValues = { 0 },                         intValue = 0,                         intValues = { 0 },                         longValue = 0,                         longValues = { 0 },                         shortValue = 0,                         shortValues = { 0 },                         stooge = CURLY,                         stooges = { MOE, LARRY, SHEMP },                         string = "",                         strings = { "" },                         type = Object[].class,                         types = { Object[].class }                 ),                 //add a second NestAnnotation to break equality:                 @NestAnnotation(                         booleanValue = false,                         booleanValues = { false },                         byteValue = 0,                         byteValues = { 0 },                         charValue = 0,                         charValues = { 0 },                         doubleValue = 0,                         doubleValues = { 0 },                         floatValue = 0,                         floatValues = { 0 },                         intValue = 0,                         intValues = { 0 },                         longValue = 0,                         longValues = { 0 },                         shortValue = 0,                         shortValues = { 0 },                         stooge = CURLY,                         stooges = { MOE, LARRY, SHEMP },                         string = "",                         strings = { "" },                         type = Object[].class,                         types = { Object[].class }                 )             },             shortValue = 0,             shortValues = { 0 },             stooge = SHEMP,             stooges = { MOE, LARRY, CURLY },             string = "",             strings = { "" },             type = Object.class,             types = { Object.class }     )     public Object dummy3;      @NestAnnotation(             booleanValue = false,             booleanValues = { false },             byteValue = 0,             byteValues = { 0 },             charValue = 0,             charValues = { 0 },             doubleValue = 0,             doubleValues = { 0 },             floatValue = 0,             floatValues = { 0 },             intValue = 0,             intValues = { 0 },             longValue = 0,             longValues = { 0 },             shortValue = 0,             shortValues = { 0 },             stooge = CURLY,             stooges = { MOE, LARRY, SHEMP },             string = "",             strings = { "" },             type = Object[].class,             types = { Object[].class }     )     public Object dummy4;      @Target(FIELD)     @Retention(RUNTIME)     public @interface TestAnnotation {         String string();         String[] strings();         Class<?> type();         Class<?>[] types();         byte byteValue();         byte[] byteValues();         short shortValue();         short[] shortValues();         int intValue();         int[] intValues();         char charValue();         char[] charValues();         long longValue();         long[] longValues();         float floatValue();         float[] floatValues();         double doubleValue();         double[] doubleValues();         boolean booleanValue();         boolean[] booleanValues();         Stooge stooge();         Stooge[] stooges();         NestAnnotation nest();         NestAnnotation[] nests();     }      @Retention(RUNTIME)     public @interface NestAnnotation {         String string();         String[] strings();         Class<?> type();         Class<?>[] types();         byte byteValue();         byte[] byteValues();         short shortValue();         short[] shortValues();         int intValue();         int[] intValues();         char charValue();         char[] charValues();         long longValue();         long[] longValues();         float floatValue();         float[] floatValues();         double doubleValue();         double[] doubleValues();         boolean booleanValue();         boolean[] booleanValues();         Stooge stooge();         Stooge[] stooges();     }      @Retention(RetentionPolicy.RUNTIME)     @Target({ElementType.METHOD})     public @interface TestMethodAnnotation {         Class<? extends Throwable> expected() default None.class;          long timeout() default 0L;          class None extends Throwable {         }     }      public enum Stooge {         MOE, LARRY, CURLY, JOE, SHEMP     }      private Field field1;     private Field field2;     private Field field3;     private Field field4;      @BeforeEach     public void setup() throws Exception {         field1 = getClass().getDeclaredField("dummy1");         field2 = getClass().getDeclaredField("dummy2");         field3 = getClass().getDeclaredField("dummy3");         field4 = getClass().getDeclaredField("dummy4");     }      @Test     public void testEquivalence() {         assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field2.getAnnotation(TestAnnotation.class)));         assertTrue(AnnotationUtils.equals(field2.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class)));     }      @Test     public void testSameInstance() {         assertTrue(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class)));     }      @Test     public void testNonEquivalentAnnotationsOfSameType() {         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field3.getAnnotation(TestAnnotation.class)));         assertFalse(AnnotationUtils.equals(field3.getAnnotation(TestAnnotation.class), field1.getAnnotation(TestAnnotation.class)));     }      @Test     public void testAnnotationsOfDifferingTypes() {         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), field4.getAnnotation(NestAnnotation.class)));         assertFalse(AnnotationUtils.equals(field4.getAnnotation(NestAnnotation.class), field1.getAnnotation(TestAnnotation.class)));     }      @Test     public void testOneArgNull() {         assertFalse(AnnotationUtils.equals(field1.getAnnotation(TestAnnotation.class), null));         assertFalse(AnnotationUtils.equals(null, field1.getAnnotation(TestAnnotation.class)));     }      @Test     public void testBothArgsNull() {         assertTrue(AnnotationUtils.equals(null, null));     }      @Test     public void testIsValidAnnotationMemberType() {         for (final Class<?> type : new Class[] { byte.class, short.class, int.class, char.class,                 long.class, float.class, double.class, boolean.class, String.class, Class.class,                 NestAnnotation.class, TestAnnotation.class, Stooge.class, ElementType.class }) {             assertTrue(AnnotationUtils.isValidAnnotationMemberType(type));             assertTrue(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0)                     .getClass()));         }         for (final Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) {             assertFalse(AnnotationUtils.isValidAnnotationMemberType(type));             assertFalse(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0)                     .getClass()));         }     }      @Test     public void testGeneratedAnnotationEquivalentToRealAnnotation() {         assertTimeoutPreemptively(Duration.ofSeconds(666L), () -> {             final Test real = getClass().getDeclaredMethod(                     "testGeneratedAnnotationEquivalentToRealAnnotation").getAnnotation(Test.class);              final InvocationHandler generatedTestInvocationHandler = (proxy, method, args) -> {                 if ("equals".equals(method.getName()) && method.getParameterTypes().length == 1) {                     return Boolean.valueOf(proxy == args[0]);                 }                 if ("hashCode".equals(method.getName()) && method.getParameterTypes().length == 0) {                     return Integer.valueOf(System.identityHashCode(proxy));                 }                 if ("toString".equals(method.getName()) && method.getParameterTypes().length == 0) {                     return "Test proxy";                 }                 return method.invoke(real, args);             };              final Test generated = (Test) Proxy.newProxyInstance(Thread.currentThread()                             .getContextClassLoader(), new Class[]{Test.class},                     generatedTestInvocationHandler);             assertEquals(real, generated);             assertNotEquals(generated, real);             assertTrue(AnnotationUtils.equals(generated, real));             assertTrue(AnnotationUtils.equals(real, generated));              final Test generated2 = (Test) Proxy.newProxyInstance(Thread.currentThread()                             .getContextClassLoader(), new Class[]{Test.class},                     generatedTestInvocationHandler);             assertNotEquals(generated, generated2);             assertNotEquals(generated2, generated);             assertTrue(AnnotationUtils.equals(generated, generated2));             assertTrue(AnnotationUtils.equals(generated2, generated));         });     }      @Test     public void testHashCode() {         assertTimeoutPreemptively(Duration.ofSeconds(666L), () -> {             final Test test = getClass().getDeclaredMethod("testHashCode").getAnnotation(Test.class);             assertEquals(test.hashCode(), AnnotationUtils.hashCode(test));             final TestAnnotation testAnnotation1 = field1.getAnnotation(TestAnnotation.class);             assertEquals(testAnnotation1.hashCode(), AnnotationUtils.hashCode(testAnnotation1));             final TestAnnotation testAnnotation3 = field3.getAnnotation(TestAnnotation.class);             assertEquals(testAnnotation3.hashCode(), AnnotationUtils.hashCode(testAnnotation3));         });     }      @Test     @TestMethodAnnotation(timeout = 666000)     public void testToString() {         assertTimeoutPreemptively(Duration.ofSeconds(666L), () -> {             final TestMethodAnnotation testAnnotation =                     getClass().getDeclaredMethod("testToString").getAnnotation(TestMethodAnnotation.class);              final String annotationString = AnnotationUtils.toString(testAnnotation);             assertTrue(annotationString.startsWith("@org.apache.commons.lang3.AnnotationUtilsTest$TestMethodAnnotation("));             assertTrue(annotationString.endsWith(")"));             assertTrue(annotationString.contains("expected=class org.apache.commons.lang3.AnnotationUtilsTest$TestMethodAnnotation$None"));             assertTrue(annotationString.contains("timeout=666000"));             assertTrue(annotationString.contains(", "));         });     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.UUID;  import org.junit.jupiter.api.Test;   /**  * Unit tests {@link Conversion}.  */ public class ConversionTest {      /**      * Tests {@link Conversion#hexDigitToInt(char)}.      */     @Test     public void testHexDigitToInt() {         assertEquals(0, Conversion.hexDigitToInt('0'));         assertEquals(1, Conversion.hexDigitToInt('1'));         assertEquals(2, Conversion.hexDigitToInt('2'));         assertEquals(3, Conversion.hexDigitToInt('3'));         assertEquals(4, Conversion.hexDigitToInt('4'));         assertEquals(5, Conversion.hexDigitToInt('5'));         assertEquals(6, Conversion.hexDigitToInt('6'));         assertEquals(7, Conversion.hexDigitToInt('7'));         assertEquals(8, Conversion.hexDigitToInt('8'));         assertEquals(9, Conversion.hexDigitToInt('9'));         assertEquals(10, Conversion.hexDigitToInt('A'));         assertEquals(10, Conversion.hexDigitToInt('a'));         assertEquals(11, Conversion.hexDigitToInt('B'));         assertEquals(11, Conversion.hexDigitToInt('b'));         assertEquals(12, Conversion.hexDigitToInt('C'));         assertEquals(12, Conversion.hexDigitToInt('c'));         assertEquals(13, Conversion.hexDigitToInt('D'));         assertEquals(13, Conversion.hexDigitToInt('d'));         assertEquals(14, Conversion.hexDigitToInt('E'));         assertEquals(14, Conversion.hexDigitToInt('e'));         assertEquals(15, Conversion.hexDigitToInt('F'));         assertEquals(15, Conversion.hexDigitToInt('f'));         assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitToInt('G'));     }      /**      * Tests {@link Conversion#hexDigitMsb0ToInt(char)}.      */     @Test     public void testHexDigitMsb0ToInt() {         assertEquals(0x0, Conversion.hexDigitMsb0ToInt('0'));         assertEquals(0x8, Conversion.hexDigitMsb0ToInt('1'));         assertEquals(0x4, Conversion.hexDigitMsb0ToInt('2'));         assertEquals(0xC, Conversion.hexDigitMsb0ToInt('3'));         assertEquals(0x2, Conversion.hexDigitMsb0ToInt('4'));         assertEquals(0xA, Conversion.hexDigitMsb0ToInt('5'));         assertEquals(0x6, Conversion.hexDigitMsb0ToInt('6'));         assertEquals(0xE, Conversion.hexDigitMsb0ToInt('7'));         assertEquals(0x1, Conversion.hexDigitMsb0ToInt('8'));         assertEquals(0x9, Conversion.hexDigitMsb0ToInt('9'));         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('A'));         assertEquals(0x5, Conversion.hexDigitMsb0ToInt('a'));         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('B'));         assertEquals(0xD, Conversion.hexDigitMsb0ToInt('b'));         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('C'));         assertEquals(0x3, Conversion.hexDigitMsb0ToInt('c'));         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('D'));         assertEquals(0xB, Conversion.hexDigitMsb0ToInt('d'));         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('E'));         assertEquals(0x7, Conversion.hexDigitMsb0ToInt('e'));         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('F'));         assertEquals(0xF, Conversion.hexDigitMsb0ToInt('f'));         assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitMsb0ToInt('G'));     }      /**      * Tests {@link Conversion#hexDigitToBinary(char)}.      */     @Test     public void testHexDigitToBinary() {         assertArrayEquals(             new boolean[]{false, false, false, false}, Conversion.hexDigitToBinary('0'));         assertArrayEquals(             new boolean[]{true, false, false, false}, Conversion.hexDigitToBinary('1'));         assertArrayEquals(             new boolean[]{false, true, false, false}, Conversion.hexDigitToBinary('2'));         assertArrayEquals(             new boolean[]{true, true, false, false}, Conversion.hexDigitToBinary('3'));         assertArrayEquals(             new boolean[]{false, false, true, false}, Conversion.hexDigitToBinary('4'));         assertArrayEquals(             new boolean[]{true, false, true, false}, Conversion.hexDigitToBinary('5'));         assertArrayEquals(             new boolean[]{false, true, true, false}, Conversion.hexDigitToBinary('6'));         assertArrayEquals(             new boolean[]{true, true, true, false}, Conversion.hexDigitToBinary('7'));         assertArrayEquals(             new boolean[]{false, false, false, true}, Conversion.hexDigitToBinary('8'));         assertArrayEquals(             new boolean[]{true, false, false, true}, Conversion.hexDigitToBinary('9'));         assertArrayEquals(             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('A'));         assertArrayEquals(             new boolean[]{false, true, false, true}, Conversion.hexDigitToBinary('a'));         assertArrayEquals(             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('B'));         assertArrayEquals(             new boolean[]{true, true, false, true}, Conversion.hexDigitToBinary('b'));         assertArrayEquals(             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('C'));         assertArrayEquals(             new boolean[]{false, false, true, true}, Conversion.hexDigitToBinary('c'));         assertArrayEquals(             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('D'));         assertArrayEquals(             new boolean[]{true, false, true, true}, Conversion.hexDigitToBinary('d'));         assertArrayEquals(             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('E'));         assertArrayEquals(             new boolean[]{false, true, true, true}, Conversion.hexDigitToBinary('e'));         assertArrayEquals(             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('F'));         assertArrayEquals(             new boolean[]{true, true, true, true}, Conversion.hexDigitToBinary('f'));         assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitToBinary('G'));     }      /**      * Tests {@link Conversion#hexDigitMsb0ToBinary(char)}.      */     @Test     public void testHexDigitMsb0ToBinary() {         assertArrayEquals(             new boolean[]{false, false, false, false}, Conversion.hexDigitMsb0ToBinary('0'));         assertArrayEquals(             new boolean[]{false, false, false, true}, Conversion.hexDigitMsb0ToBinary('1'));         assertArrayEquals(             new boolean[]{false, false, true, false}, Conversion.hexDigitMsb0ToBinary('2'));         assertArrayEquals(             new boolean[]{false, false, true, true}, Conversion.hexDigitMsb0ToBinary('3'));         assertArrayEquals(             new boolean[]{false, true, false, false}, Conversion.hexDigitMsb0ToBinary('4'));         assertArrayEquals(             new boolean[]{false, true, false, true}, Conversion.hexDigitMsb0ToBinary('5'));         assertArrayEquals(             new boolean[]{false, true, true, false}, Conversion.hexDigitMsb0ToBinary('6'));         assertArrayEquals(             new boolean[]{false, true, true, true}, Conversion.hexDigitMsb0ToBinary('7'));         assertArrayEquals(             new boolean[]{true, false, false, false}, Conversion.hexDigitMsb0ToBinary('8'));         assertArrayEquals(             new boolean[]{true, false, false, true}, Conversion.hexDigitMsb0ToBinary('9'));         assertArrayEquals(             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('A'));         assertArrayEquals(             new boolean[]{true, false, true, false}, Conversion.hexDigitMsb0ToBinary('a'));         assertArrayEquals(             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('B'));         assertArrayEquals(             new boolean[]{true, false, true, true}, Conversion.hexDigitMsb0ToBinary('b'));         assertArrayEquals(             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('C'));         assertArrayEquals(             new boolean[]{true, true, false, false}, Conversion.hexDigitMsb0ToBinary('c'));         assertArrayEquals(             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('D'));         assertArrayEquals(             new boolean[]{true, true, false, true}, Conversion.hexDigitMsb0ToBinary('d'));         assertArrayEquals(             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('E'));         assertArrayEquals(             new boolean[]{true, true, true, false}, Conversion.hexDigitMsb0ToBinary('e'));         assertArrayEquals(             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('F'));         assertArrayEquals(             new boolean[]{true, true, true, true}, Conversion.hexDigitMsb0ToBinary('f'));         assertThrows(IllegalArgumentException.class, () -> Conversion.hexDigitMsb0ToBinary('G'));     }      /**      * Tests {@link Conversion#binaryToHexDigit(boolean[])}.      */     @Test     public void testBinaryToHexDigit() {         assertEquals(             '0', Conversion.binaryToHexDigit(new boolean[]{false, false, false, false}));         assertEquals('1', Conversion.binaryToHexDigit(new boolean[]{true, false, false, false}));         assertEquals('2', Conversion.binaryToHexDigit(new boolean[]{false, true, false, false}));         assertEquals('3', Conversion.binaryToHexDigit(new boolean[]{true, true, false, false}));         assertEquals('4', Conversion.binaryToHexDigit(new boolean[]{false, false, true, false}));         assertEquals('5', Conversion.binaryToHexDigit(new boolean[]{true, false, true, false}));         assertEquals('6', Conversion.binaryToHexDigit(new boolean[]{false, true, true, false}));         assertEquals('7', Conversion.binaryToHexDigit(new boolean[]{true, true, true, false}));         assertEquals('8', Conversion.binaryToHexDigit(new boolean[]{false, false, false, true}));         assertEquals('9', Conversion.binaryToHexDigit(new boolean[]{true, false, false, true}));         assertEquals('a', Conversion.binaryToHexDigit(new boolean[]{false, true, false, true}));         assertEquals('b', Conversion.binaryToHexDigit(new boolean[]{true, true, false, true}));         assertEquals('c', Conversion.binaryToHexDigit(new boolean[]{false, false, true, true}));         assertEquals('d', Conversion.binaryToHexDigit(new boolean[]{true, false, true, true}));         assertEquals('e', Conversion.binaryToHexDigit(new boolean[]{false, true, true, true}));         assertEquals('f', Conversion.binaryToHexDigit(new boolean[]{true, true, true, true}));         assertEquals('1', Conversion.binaryToHexDigit(new boolean[]{true}));         assertEquals(             'f', Conversion.binaryToHexDigit(new boolean[]{true, true, true, true, true}));         assertThrows(IllegalArgumentException.class, () -> Conversion.binaryToHexDigit(new boolean[]{}));     }      /**      * Tests {@link Conversion#binaryBeMsb0ToHexDigit(boolean[], int)}.      */     @Test     public void testBinaryToHexDigit_2args() {         final boolean[] shortArray = new boolean[]{false, true, true};         assertEquals('6', Conversion.binaryToHexDigit(shortArray, 0));         assertEquals('3', Conversion.binaryToHexDigit(shortArray, 1));         assertEquals('1', Conversion.binaryToHexDigit(shortArray, 2));         final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};         assertEquals('5', Conversion.binaryToHexDigit(longArray, 0));         assertEquals('2', Conversion.binaryToHexDigit(longArray, 1));         assertEquals('9', Conversion.binaryToHexDigit(longArray, 2));         assertEquals('c', Conversion.binaryToHexDigit(longArray, 3));         assertEquals('6', Conversion.binaryToHexDigit(longArray, 4));         assertEquals('3', Conversion.binaryToHexDigit(longArray, 5));         assertEquals('1', Conversion.binaryToHexDigit(longArray, 6));     }      /**      * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[])}.      */     @Test     public void testBinaryToHexDigitMsb0_bits() {         assertEquals(             '0',             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, false}));         assertEquals(             '1',             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, false, true}));         assertEquals(             '2',             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, false}));         assertEquals(             '3', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, false, true, true}));         assertEquals(             '4',             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, false}));         assertEquals(             '5', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, false, true}));         assertEquals(             '6', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, false}));         assertEquals(             '7', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{false, true, true, true}));         assertEquals(             '8',             Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, false}));         assertEquals(             '9', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, false, true}));         assertEquals(             'a', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, false}));         assertEquals(             'b', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, false, true, true}));         assertEquals(             'c', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, false}));         assertEquals(             'd', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, false, true}));         assertEquals(             'e', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, false}));         assertEquals(             'f', Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{true, true, true, true}));         assertThrows(IllegalArgumentException.class, () -> Conversion.binaryToHexDigitMsb0_4bits(new boolean[]{}));     }      /**      * Tests {@link Conversion#binaryToHexDigitMsb0_4bits(boolean[], int)}.      */     @Test     public void testBinaryToHexDigitMsb0_4bits_2args() {         // boolean[] shortArray = new boolean[]{true, true, false};         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(shortArray, 0));         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(shortArray, 1));         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(shortArray, 2));         final boolean[] shortArray = new boolean[]{true, true, false, true};         assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(shortArray, 0));         final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};         assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(longArray, 0));         assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(longArray, 1));         assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(longArray, 2));         assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(longArray, 3));         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(longArray, 4));         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray, 5));         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray, 6));         final boolean[] maxLengthArray = new boolean[]{             true, false, true, false, false, true, true, true};         assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 0));         assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 1));         assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 2));         assertEquals('3', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 3));         assertEquals('7', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 4));         // assertEquals('7', Conversion.BinaryToHexDigitMsb0(longArray, 5));         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray, 6));         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray, 7));         final boolean[] javaDocCheck = new boolean[]{             true, false, false, true, true, false, true, false};         assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(javaDocCheck, 3));      }      /**      * Tests {@link Conversion#binaryToHexDigit(boolean[])}.      */     @Test     public void testBinaryBeMsb0ToHexDigit() {         assertEquals(             '0', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, false}));         assertEquals(             '1', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, false, true}));         assertEquals(             '2', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, false}));         assertEquals(             '3', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, false, true, true}));         assertEquals(             '4', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, false}));         assertEquals(             '5', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, false, true}));         assertEquals(             '6', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, false}));         assertEquals(             '7', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{false, true, true, true}));         assertEquals(             '8', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, false}));         assertEquals(             '9', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, false, true}));         assertEquals(             'a', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, false}));         assertEquals(             'b', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, false, true, true}));         assertEquals(             'c', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, false}));         assertEquals(             'd', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, false, true}));         assertEquals(             'e', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, false}));         assertEquals(             'f', Conversion.binaryBeMsb0ToHexDigit(new boolean[]{true, true, true, true}));         assertEquals(             '4',             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{                 true, false, false, false, false, false, false, false, false, false, false,                 false, false, true, false, false}));         assertThrows(IllegalArgumentException.class, () -> Conversion.binaryBeMsb0ToHexDigit(new boolean[]{}));     }      /**      * Tests {@link Conversion#binaryToHexDigit(boolean[], int)}.      */     @Test     public void testBinaryBeMsb0ToHexDigit_2args() {         assertEquals(             '5',             Conversion.binaryBeMsb0ToHexDigit(new boolean[]{                 true, false, false, false, false, false, false, false, false, false, false,                 true, false, true, false, false}, 2));          final boolean[] shortArray = new boolean[]{true, true, false};         assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(shortArray, 0));         assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray, 1));         assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray, 2));         final boolean[] shortArray2 = new boolean[]{true, true, true, false, false, true, false, true};         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 0));         assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 1));         assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 2));         assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 3));         assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 4));         assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 5));         assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 6));         assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 7));         final boolean[] multiBytesArray = new boolean[]{             true, true, false, false, true, false, true, false, true, true, true, false, false,             true, false, true};         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 0));         assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 1));         assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 2));         assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 3));         assertEquals('e', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 4));         assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 5));         assertEquals('b', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 6));         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 7));          assertEquals('a', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 8));         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 9));         assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 10));         assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 11));         assertEquals('c', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 12));         assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 13));         assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 14));         assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 15));      }      /**      * Tests {@link Conversion#intToHexDigit(int)}.      */     @Test     public void testIntToHexDigit() {         assertEquals('0', Conversion.intToHexDigit(0));         assertEquals('1', Conversion.intToHexDigit(1));         assertEquals('2', Conversion.intToHexDigit(2));         assertEquals('3', Conversion.intToHexDigit(3));         assertEquals('4', Conversion.intToHexDigit(4));         assertEquals('5', Conversion.intToHexDigit(5));         assertEquals('6', Conversion.intToHexDigit(6));         assertEquals('7', Conversion.intToHexDigit(7));         assertEquals('8', Conversion.intToHexDigit(8));         assertEquals('9', Conversion.intToHexDigit(9));         assertEquals('a', Conversion.intToHexDigit(10));         assertEquals('b', Conversion.intToHexDigit(11));         assertEquals('c', Conversion.intToHexDigit(12));         assertEquals('d', Conversion.intToHexDigit(13));         assertEquals('e', Conversion.intToHexDigit(14));         assertEquals('f', Conversion.intToHexDigit(15));         assertThrows(IllegalArgumentException.class, () -> Conversion.intToHexDigit(16));     }      /**      * Tests {@link Conversion#intToHexDigitMsb0(int)}.      */     @Test     public void testIntToHexDigitMsb0() {         assertEquals('0', Conversion.intToHexDigitMsb0(0));         assertEquals('8', Conversion.intToHexDigitMsb0(1));         assertEquals('4', Conversion.intToHexDigitMsb0(2));         assertEquals('c', Conversion.intToHexDigitMsb0(3));         assertEquals('2', Conversion.intToHexDigitMsb0(4));         assertEquals('a', Conversion.intToHexDigitMsb0(5));         assertEquals('6', Conversion.intToHexDigitMsb0(6));         assertEquals('e', Conversion.intToHexDigitMsb0(7));         assertEquals('1', Conversion.intToHexDigitMsb0(8));         assertEquals('9', Conversion.intToHexDigitMsb0(9));         assertEquals('5', Conversion.intToHexDigitMsb0(10));         assertEquals('d', Conversion.intToHexDigitMsb0(11));         assertEquals('3', Conversion.intToHexDigitMsb0(12));         assertEquals('b', Conversion.intToHexDigitMsb0(13));         assertEquals('7', Conversion.intToHexDigitMsb0(14));         assertEquals('f', Conversion.intToHexDigitMsb0(15));         assertThrows(IllegalArgumentException.class, () -> Conversion.intToHexDigitMsb0(16));     }      static String dbgPrint(final boolean[] src) {         final StringBuilder sb = new StringBuilder();         for (final boolean e : src) {             if (e) {                 sb.append("1, ");             } else {                 sb.append("0, ");             }         }         final String out = sb.toString();         return out.substring(0, out.length() - 1);     }      /**      * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}.      */     @Test     public void testIntArrayToLong() {         final int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000};         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0));         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0));         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1));         assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2));         assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1));         assertEquals(             0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));         assertEquals(             0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1));         // assertEquals(0x0F12345678000000L, Conversion.intsToLong(src, 1, 0x123456789ABCDEF0L, 32, 2));     }      /**      * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}.      */     @Test     public void testShortArrayToLong() {         final short[] src = new short[]{             (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800};         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0));         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1));         assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2));         assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4));         assertEquals(             0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));         assertEquals(             0x123456CDF1BCDEF0L,             Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));         assertEquals(             0x123478003456DEF0L,             Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2));     }      /**      * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}.      */     @Test     public void testByteArrayToLong() {         final byte[] src = new byte[]{             (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34,             (byte) 0x56, (byte) 0x78};         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0));         assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1));         assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4));         assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4));         assertEquals(             0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));         assertEquals(             0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));         assertEquals(             0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2));     }      /**      * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}.      */     @Test     public void testShortArrayToInt() {         final short[] src = new short[]{             (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800};         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0));         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1));         assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2));         assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2));         assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0));         assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1));         // assertEquals(0x34567800, Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2));     }      /**      * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}.      */     @Test     public void testByteArrayToInt() {         final byte[] src = new byte[]{             (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34,             (byte) 0x56, (byte) 0x78};         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));         assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1));         assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4));         assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4));         assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0));         assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1));         // assertEquals(0x56341278, Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4));     }      /**      * Tests {@link Conversion#byteArrayToShort(byte[], int, short, int, int)}.      */     @Test     public void testByteArrayToShort() {         final byte[] src = new byte[]{             (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34,             (byte) 0x56, (byte) 0x78};         assertEquals((short) 0x0000, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 0));         assertEquals((short) 0x00CD, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 1));         assertEquals((short) 0xF1CD, Conversion.byteArrayToShort(src, 0, (short) 0, 0, 2));         assertEquals((short) 0xF0F1, Conversion.byteArrayToShort(src, 1, (short) 0, 0, 2));         assertEquals((short) 0x1234, Conversion.byteArrayToShort(src, 0, (short) 0x1234, 0, 0));         assertEquals((short) 0xCD34, Conversion.byteArrayToShort(src, 0, (short) 0x1234, 8, 1));         // assertEquals((short) 0x5678, Conversion.ByteArrayToShort(src, 7, (short) 0x0123, 8,         // 2));     }      /**      * Tests {@link Conversion#hexToLong(String, int, long, int, int)}.      */     @Test     public void testHexToLong() {         final String src = "CDF1F0C10F12345678";         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0));         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1));         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8));         assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8));         assertEquals(             0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));         assertEquals(             0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3));     }      /**      * Tests {@link Conversion#hexToInt(String, int, int, int, int)}.      */     @Test     public void testHexToInt() {         final String src = "CDF1F0C10F12345678";         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0));         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1));         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8));         assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8));         assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0));         assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3));     }      /**      * Tests {@link Conversion#hexToShort(String, int, short, int, int)}.      */     @Test     public void testHexToShort() {         final String src = "CDF1F0C10F12345678";         assertEquals((short) 0x0000, Conversion.hexToShort(src, 0, (short) 0, 0, 0));         assertEquals((short) 0x000C, Conversion.hexToShort(src, 0, (short) 0, 0, 1));         assertEquals((short) 0x1FDC, Conversion.hexToShort(src, 0, (short) 0, 0, 4));         assertEquals((short) 0xF1FD, Conversion.hexToShort(src, 1, (short) 0, 0, 4));         assertEquals((short) 0x1234, Conversion.hexToShort(src, 0, (short) 0x1234, 0, 0));         assertEquals((short) 0x8764, Conversion.hexToShort(src, 15, (short) 0x1234, 4, 3));     }      /**      * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}.      */     @Test     public void testHexToByte() {         final String src = "CDF1F0C10F12345678";         assertEquals((byte) 0x00, Conversion.hexToByte(src, 0, (byte) 0, 0, 0));         assertEquals((byte) 0x0C, Conversion.hexToByte(src, 0, (byte) 0, 0, 1));         assertEquals((byte) 0xDC, Conversion.hexToByte(src, 0, (byte) 0, 0, 2));         assertEquals((byte) 0xFD, Conversion.hexToByte(src, 1, (byte) 0, 0, 2));         assertEquals((byte) 0x34, Conversion.hexToByte(src, 0, (byte) 0x34, 0, 0));         assertEquals((byte) 0x84, Conversion.hexToByte(src, 17, (byte) 0x34, 4, 1));     }      /**      * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}.      */     @Test     public void testBinaryToLong() {         final boolean[] src = new boolean[]{             false, false, true, true, true, false, true, true, true, true, true, true, true,             false, false, false, true, true, true, true, false, false, false, false, false,             false, true, true, true, false, false, false, false, false, false, false, true,             true, true, true, true, false, false, false, false, true, false, false, true, true,             false, false, false, false, true, false, true, false, true, false, false, true,             true, false, true, true, true, false, false, false, false, true};         // conversion of "CDF1F0C10F12345678" by HexToBinary         assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0));         assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4));         assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4));         assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4));         assertEquals(             0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));         assertEquals(             0x1234567876BCDEF0L,             Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));     }      /**      * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}.      */     @Test     public void testBinaryToInt() {         final boolean[] src = new boolean[]{             false, false, true, true, true, false, true, true, true, true, true, true, true,             false, false, false, true, true, true, true, false, false, false, false, false,             false, true, true, true, false, false, false, false, false, false, false, true,             true, true, true, true, false, false, false, false, true, false, false, true, true,             false, false, false, false, true, false, true, false, true, false, false, true,             true, false, true, true, true, false, false, false, false, true};         // conversion of "CDF1F0C10F12345678" by HexToBinary         assertEquals(0x00000000, Conversion.binaryToInt(src, 0 * 4, 0, 0, 0 * 4));         assertEquals(0x0000000C, Conversion.binaryToInt(src, 0 * 4, 0, 0, 1 * 4));         assertEquals(0x1C0F1FDC, Conversion.binaryToInt(src, 0 * 4, 0, 0, 8 * 4));         assertEquals(0x01C0F1FD, Conversion.binaryToInt(src, 1 * 4, 0, 0, 8 * 4));         assertEquals(0x12345679, Conversion.binaryToInt(src, 0 * 4, 0x12345679, 0, 0 * 4));         assertEquals(0x87645679, Conversion.binaryToInt(src, 15 * 4, 0x12345679, 20, 3 * 4));     }      /**      * Tests {@link Conversion#binaryToShort(boolean[], int, short, int, int)}.      */     @Test     public void testBinaryToShort() {         final boolean[] src = new boolean[]{             false, false, true, true, true, false, true, true, true, true, true, true, true,             false, false, false, true, true, true, true, false, false, false, false, false,             false, true, true, true, false, false, false, false, false, false, false, true,             true, true, true, true, false, false, false, false, true, false, false, true, true,             false, false, false, false, true, false, true, false, true, false, false, true,             true, false, true, true, true, false, false, false, false, true};         // conversion of "CDF1F0C10F12345678" by HexToBinary         assertEquals((short) 0x0000, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 0 * 4));         assertEquals((short) 0x000C, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 1 * 4));         assertEquals((short) 0x1FDC, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 4 * 4));         assertEquals((short) 0xF1FD, Conversion.binaryToShort(src, 1 * 4, (short) 0, 0, 4 * 4));         assertEquals(             (short) 0x1234, Conversion.binaryToShort(src, 0 * 4, (short) 0x1234, 0, 0 * 4));         assertEquals(             (short) 0x8764, Conversion.binaryToShort(src, 15 * 4, (short) 0x1234, 4, 3 * 4));     }      /**      * Tests {@link Conversion#binaryToByte(boolean[], int, byte, int, int)}.      */     @Test     public void testBinaryToByte() {         final boolean[] src = new boolean[]{             false, false, true, true, true, false, true, true, true, true, true, true, true,             false, false, false, true, true, true, true, false, false, false, false, false,             false, true, true, true, false, false, false, false, false, false, false, true,             true, true, true, true, false, false, false, false, true, false, false, true, true,             false, false, false, false, true, false, true, false, true, false, false, true,             true, false, true, true, true, false, false, false, false, true};         // conversion of "CDF1F0C10F12345678" by HexToBinary         assertEquals((byte) 0x00, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 0 * 4));         assertEquals((byte) 0x0C, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 1 * 4));         assertEquals((byte) 0xDC, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 2 * 4));         assertEquals((byte) 0xFD, Conversion.binaryToByte(src, 1 * 4, (byte) 0, 0, 2 * 4));         assertEquals((byte) 0x34, Conversion.binaryToByte(src, 0 * 4, (byte) 0x34, 0, 0 * 4));         assertEquals((byte) 0x84, Conversion.binaryToByte(src, 17 * 4, (byte) 0x34, 4, 1 * 4));     }      /**      * Tests {@link Conversion#longToIntArray(long, int, int[], int, int)}.      */     @Test     public void testLongToIntArray() {         assertArrayEquals(             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 0, 0));         assertArrayEquals(             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[]{}, 0, 0));         assertArrayEquals(             new int[]{}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[]{}, 100, 0));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 2));         // assertArrayEquals(new         // int[]{0x90ABCDEF, 0x12345678, 0x90ABCDEF, 0x12345678}, Conversion.longToIntArray(0x1234567890ABCDEFL,         // 0, new int[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion         // assertArrayEquals(new         // int[]{0xFFFFFFFF, 0x90ABCDEF, 0x12345678, 0x90ABCDEF}, Conversion.longToIntArray(0x1234567890ABCDEFL,         // 0, new int[]{-1, -1, -1, -1}, 1, 3));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 2));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF},             Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[]{-1, -1, -1, -1}, 2, 1));         // assertArrayEquals(new         // int[]{0x4855E6F7, 0x091A2B3C, 0x4855E6F7, 0x091A2B3C}, Conversion.longToIntArray(0x1234567890ABCDEFL,         // 1, new int[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion         assertArrayEquals(             new int[]{0x091A2B3C},             Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[]{0}, 0, 1));     }      /**      * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}.      */     @Test     public void testLongToShortArray() {         assertArrayEquals(             new short[]{},             Conversion.longToShortArray(0x0000000000000000L, 0, new short[]{}, 0, 0));         assertArrayEquals(             new short[]{},             Conversion.longToShortArray(0x0000000000000000L, 100, new short[]{}, 0, 0));         assertArrayEquals(             new short[]{},             Conversion.longToShortArray(0x0000000000000000L, 0, new short[]{}, 100, 0));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new short[]{(short) 0xCDEF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new short[]{(short) 0xCDEF, (short) 0x90AB, (short) 0xFFFF, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 2));         assertArrayEquals(             new short[]{(short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 3));         assertArrayEquals(             new short[]{(short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0x1234},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 4));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB, (short) 0x5678},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 1, 3));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 2));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xE6F7, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xF37B, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 2, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x79BD, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 3, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xBCDE, (short) 0xFFFF},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 4, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A},             Conversion.longToShortArray(                 0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 0, 4));         assertArrayEquals(             new short[]{(short) 0x2B3C},             Conversion.longToShortArray(0x1234567890ABCDEFL, 33, new short[]{0}, 0, 1));     }      /**      * Tests {@link Conversion#intToShortArray(int, int, short[], int, int)}.      */     @Test     public void testIntToShortArray() {         assertArrayEquals(             new short[]{}, Conversion.intToShortArray(0x00000000, 0, new short[]{}, 0, 0));         assertArrayEquals(             new short[]{}, Conversion.intToShortArray(0x00000000, 100, new short[]{}, 0, 0));         assertArrayEquals(             new short[]{}, Conversion.intToShortArray(0x00000000, 0, new short[]{}, 100, 0));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new short[]{(short) 0x5678, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new short[]{(short) 0x5678, (short) 0x1234, (short) 0xFFFF, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 2));         // assertArrayEquals(new         // short[]{(short) 0x5678, (short) 0x1234, (short) 0x5678, (short) 0xFFFF}, Conversion.intToShortArray(0x12345678,         // 0, new short[]{-1, -1, -1, -1}, 0, 3));//rejected by assertion         // assertArrayEquals(new         // short[]{(short) 0x5678, (short) 0x1234, (short) 0x5678, (short) 0x1234}, Conversion.intToShortArray(0x12345678,         // 0, new short[]{-1, -1, -1, -1}, 0, 4));         // assertArrayEquals(new         // short[]{(short) 0xFFFF, (short) 0x5678, (short) 0x1234, (short) 0x5678}, Conversion.intToShortArray(0x12345678,         // 0, new short[]{-1, -1, -1, -1}, 1, 3));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0x1234},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 2));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678},             Conversion.intToShortArray(0x12345678, 0, new short[]{-1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x2B3C, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 1, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x159E, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 2, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x8ACF, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 3, new short[]{-1, -1, -1, -1}, 2, 1));         assertArrayEquals(             new short[]{(short) 0xFFFF, (short) 0xFFFF, (short) 0x4567, (short) 0xFFFF},             Conversion.intToShortArray(0x12345678, 4, new short[]{-1, -1, -1, -1}, 2, 1));         // assertArrayEquals(new         // short[]{(short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A}, Conversion.intToShortArray(0x12345678,         // 1, new short[]{-1, -1, -1, -1}, 0, 4));//rejected by assertion         // assertArrayEquals(new         // short[]{(short) 0x2B3C}, Conversion.intToShortArray(0x12345678, 33, new         // short[]{0}, 0, 1));//rejected by assertion         assertArrayEquals(             new short[]{(short) 0x091A},             Conversion.intToShortArray(0x12345678, 17, new short[]{0}, 0, 1));     }      /**      * Tests {@link Conversion#longToByteArray(long, int, byte[], int, int)}.      */     @Test     public void testLongToByteArray() {         assertArrayEquals(             new byte[]{},             Conversion.longToByteArray(0x0000000000000000L, 0, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{},             Conversion.longToByteArray(0x0000000000000000L, 100, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{},             Conversion.longToByteArray(0x0000000000000000L, 0, new byte[]{}, 100, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56,                 (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 7));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56,                 (byte) 0x34, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 8));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB,                 (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB,                 (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB,                 (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12},             Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));         assertArrayEquals(             new byte[]{                 (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 1, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 2, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85,                 (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00},             Conversion.longToByteArray(0x1234567890ABCDEFL, 5, new byte[]{                 -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));         // assertArrayEquals(new         // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0x00}, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new         // byte[]{-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));//rejected by assertion         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4,                 (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0xFF},             Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new byte[]{                 -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7));     }      /**      * Tests {@link Conversion#intToByteArray(int, int, byte[], int, int)}.      */     @Test     public void testIntToByteArray() {         assertArrayEquals(             new byte[]{}, Conversion.intToByteArray(0x00000000, 0, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{}, Conversion.intToByteArray(0x00000000, 100, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{}, Conversion.intToByteArray(0x00000000, 0, new byte[]{}, 100, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB,                 (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));         assertArrayEquals(             new byte[]{                 (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 1, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 2, new byte[]{                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85,                 (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 5, new byte[]{                 -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));         // assertArrayEquals(new         // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}, Conversion.intToByteArray(0x90ABCDEF, 13, new         // byte[]{-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));//rejected by assertion         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC,                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF},             Conversion.intToByteArray(0x90ABCDEF, 13, new byte[]{                 -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 3));     }      /**      * Tests {@link Conversion#shortToByteArray(short, int, byte[], int, int)}.      */     @Test     public void testShortToByteArray() {         assertArrayEquals(             new byte[]{}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{}, Conversion.shortToByteArray((short) 0x0000, 100, new byte[]{}, 0, 0));         assertArrayEquals(             new byte[]{}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[]{}, 100, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 0, 0));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 0, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 3, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 3, 2));         assertArrayEquals(             new byte[]{                 (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 1, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 2, new byte[]{                 -1, -1, -1, -1, -1, -1, -1}, 0, 1));         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0xFE, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 5, new byte[]{                 -1, 0, -1, -1, -1, -1, -1}, 3, 2));         // assertArrayEquals(new         // byte[]{(byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 13, new         // byte[]{-1, 0, -1, -1, -1, -1, -1}, 3, 2));//rejected by assertion         assertArrayEquals(             new byte[]{                 (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF,                 (byte) 0xFF}, Conversion.shortToByteArray((short) 0xCDEF, 13, new byte[]{                 -1, 0, -1, -1, -1, -1, -1}, 3, 1));     }      /**      * Tests {@link Conversion#longToHex(long, int, String, int, int)}.      */     @Test     public void testLongToHex() {         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 0, 0));         assertEquals("", Conversion.longToHex(0x0000000000000000L, 100, "", 0, 0));         assertEquals("", Conversion.longToHex(0x0000000000000000L, 0, "", 100, 0));         assertEquals(             "ffffffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 0));         assertEquals(             "3fffffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "feffffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 2));         assertEquals(             "fedcffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 4));         assertEquals(             "fedcba098765432fffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 15));         assertEquals(             "fedcba0987654321ffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 0, 16));         assertEquals(             "fff3ffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDE3L, 0, "ffffffffffffffffffffffff", 3, 1));         assertEquals(             "ffffefffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 2));         assertEquals(             "ffffedcfffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 4));         assertEquals(             "ffffedcba098765432ffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 15));         assertEquals(             "ffffedcba0987654321fffff",             Conversion.longToHex(0x1234567890ABCDEFL, 0, "ffffffffffffffffffffffff", 3, 16));         assertEquals(             "7fffffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 1, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "bfffffffffffffffffffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 2, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "fffdb975121fca86420fffff",             Conversion.longToHex(0x1234567890ABCDEFL, 3, "ffffffffffffffffffffffff", 3, 16));         // assertEquals("ffffffffffffffffffffffff", Conversion.longToHex(0x1234567890ABCDEFL, 4, "ffffffffffffffffffffffff", 3, 16));//rejected         // by assertion         assertEquals(             "fffedcba0987654321ffffff",             Conversion.longToHex(0x1234567890ABCDEFL, 4, "ffffffffffffffffffffffff", 3, 15));         assertEquals(             "fedcba0987654321", Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 0, 16));         assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.longToHex(0x1234567890ABCDEFL, 0, "", 1, 8));     }      /**      * Tests {@link Conversion#intToHex(int, int, String, int, int)}.      */     @Test     public void testIntToHex() {         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 0, 0));         assertEquals("", Conversion.intToHex(0x00000000, 100, "", 0, 0));         assertEquals("", Conversion.intToHex(0x00000000, 0, "", 100, 0));         assertEquals(             "ffffffffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 0));         assertEquals(             "3fffffffffffffffffffffff",             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "feffffffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 2));         assertEquals(             "fedcffffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 4));         assertEquals(             "fedcba0fffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 7));         assertEquals(             "fedcba09ffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 0, 8));         assertEquals(             "fff3ffffffffffffffffffff",             Conversion.intToHex(0x90ABCDE3, 0, "ffffffffffffffffffffffff", 3, 1));         assertEquals(             "ffffefffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 2));         assertEquals(             "ffffedcfffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 4));         assertEquals(             "ffffedcba0ffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 7));         assertEquals(             "ffffedcba09fffffffffffff",             Conversion.intToHex(0x90ABCDEF, 0, "ffffffffffffffffffffffff", 3, 8));         assertEquals(             "7fffffffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 1, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "bfffffffffffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 2, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "fffdb97512ffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 3, "ffffffffffffffffffffffff", 3, 8));         // assertEquals("ffffffffffffffffffffffff", Conversion.intToHex(0x90ABCDEF,         // 4, "ffffffffffffffffffffffff", 3, 8));//rejected by assertion         assertEquals(             "fffedcba09ffffffffffffff",             Conversion.intToHex(0x90ABCDEF, 4, "ffffffffffffffffffffffff", 3, 7));         assertEquals("fedcba09", Conversion.intToHex(0x90ABCDEF, 0, "", 0, 8));         assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.intToHex(0x90ABCDEF, 0, "", 1, 8));     }      /**      * Tests {@link Conversion#shortToHex(short, int, String, int, int)}.      */     @Test     public void testShortToHex() {         assertEquals("", Conversion.shortToHex((short) 0x0000, 0, "", 0, 0));         assertEquals("", Conversion.shortToHex((short) 0x0000, 100, "", 0, 0));         assertEquals("", Conversion.shortToHex((short) 0x0000, 0, "", 100, 0));         assertEquals(             "ffffffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 0, "ffffffffffffffffffffffff", 0, 0));         assertEquals(             "3fffffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDE3, 0, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "feffffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 0, "ffffffffffffffffffffffff", 0, 2));         assertEquals(             "fedfffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 0, "ffffffffffffffffffffffff", 0, 3));         assertEquals(             "fedcffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 0, "ffffffffffffffffffffffff", 0, 4));         assertEquals(             "fff3ffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDE3, 0, "ffffffffffffffffffffffff", 3, 1));         assertEquals(             "ffffefffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 0, "ffffffffffffffffffffffff", 3, 2));         assertEquals(             "7fffffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 1, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "bfffffffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 2, "ffffffffffffffffffffffff", 0, 1));         assertEquals(             "fffdb9ffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 3, "ffffffffffffffffffffffff", 3, 4));         // assertEquals("ffffffffffffffffffffffff", Conversion.shortToHex((short) 0xCDEF,         // 4, "ffffffffffffffffffffffff", 3, 4));//rejected by assertion         assertEquals(             "fffedcffffffffffffffffff",             Conversion.shortToHex((short) 0xCDEF, 4, "ffffffffffffffffffffffff", 3, 3));         assertEquals("fedc", Conversion.shortToHex((short) 0xCDEF, 0, "", 0, 4));         assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.shortToHex((short) 0xCDEF, 0, "", 1, 4));     }      /**      * Tests {@link Conversion#byteToHex(byte, int, String, int, int)}.      */     @Test     public void testByteToHex() {         assertEquals("", Conversion.byteToHex((byte) 0x00, 0, "", 0, 0));         assertEquals("", Conversion.byteToHex((byte) 0x00, 100, "", 0, 0));         assertEquals("", Conversion.byteToHex((byte) 0x00, 0, "", 100, 0));         assertEquals("00000", Conversion.byteToHex((byte) 0xEF, 0, "00000", 0, 0));         assertEquals("f0000", Conversion.byteToHex((byte) 0xEF, 0, "00000", 0, 1));         assertEquals("fe000", Conversion.byteToHex((byte) 0xEF, 0, "00000", 0, 2));         assertEquals("000f0", Conversion.byteToHex((byte) 0xEF, 0, "00000", 3, 1));         assertEquals("000fe", Conversion.byteToHex((byte) 0xEF, 0, "00000", 3, 2));         assertEquals("70000", Conversion.byteToHex((byte) 0xEF, 1, "00000", 0, 1));         assertEquals("b0000", Conversion.byteToHex((byte) 0xEF, 2, "00000", 0, 1));         assertEquals("000df", Conversion.byteToHex((byte) 0xEF, 3, "00000", 3, 2));         // assertEquals("00000", Conversion.byteToHex((byte) 0xEF, 4, "00000", 3, 2));//rejected by         // assertion         assertEquals("000e0", Conversion.byteToHex((byte) 0xEF, 4, "00000", 3, 1));         assertEquals("fe", Conversion.byteToHex((byte) 0xEF, 0, "", 0, 2));         assertThrows(StringIndexOutOfBoundsException.class, () -> Conversion.byteToHex((byte) 0xEF, 0, "", 1, 2));     }      /**      * Tests {@link Conversion#longToBinary(long, int, boolean[], int, int)}.      */     @Test     public void testLongToBinary() {         assertArrayEquals(             new boolean[]{},             Conversion.longToBinary(0x0000000000000000L, 0, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{},             Conversion.longToBinary(0x0000000000000000L, 100, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{},             Conversion.longToBinary(0x0000000000000000L, 0, new boolean[]{}, 100, 0));         assertArrayEquals(             new boolean[69],             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 0));          assertArrayEquals(             new boolean[]{                 true, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 1));         assertArrayEquals(             new boolean[]{                 true, true, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 2));         assertArrayEquals(             new boolean[]{                 true, true, true, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 3));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, true, true, true, false, true, false, true, false, true,                 false, false, false, false, true, false, false, true, false, false, false,                 true, true, true, true, false, false, true, true, false, true, false, true,                 false, false, false, true, false, true, true, false, false, false, true, false,                 false, true, false, false, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 63));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, true, true, true, false, true, false, true, false, true,                 false, false, false, false, true, false, false, true, false, false, false,                 true, true, true, true, false, false, true, true, false, true, false, true,                 false, false, false, true, false, true, true, false, false, false, true, false,                 false, true, false, false, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 0, 64));         assertArrayEquals(             new boolean[]{                 false, false, true, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false, false,                 false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 1));         assertArrayEquals(             new boolean[]{                 false, false, true, true, true, true, false, true, true, true, true, false,                 true, true, false, false, true, true, true, true, false, true, false, true,                 false, true, false, false, false, false, true, false, false, true, false,                 false, false, true, true, true, true, false, false, true, true, false, true,                 false, true, false, false, false, true, false, true, true, false, false, false,                 true, false, false, true, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 0, new boolean[69], 2, 64));         assertArrayEquals(             new boolean[]{                 true, true, true, false, true, true, true, true, false, true, true, false,                 false, true, true, true, true, false, true, false, true, false, true, false,                 false, false, false, true, false, false, true, false, false, false, true, true,                 true, true, false, false, true, true, false, true, false, true, false, false,                 false, true, false, true, true, false, false, false, true, false, false, true,                 false, false, false, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 1, new boolean[69], 0, 63));         assertArrayEquals(             new boolean[]{                 true, true, false, true, true, true, true, false, true, true, false, false,                 true, true, true, true, false, true, false, true, false, true, false, false,                 false, false, true, false, false, true, false, false, false, true, true, true,                 true, false, false, true, true, false, true, false, true, false, false, false,                 true, false, true, true, false, false, false, true, false, false, true, false,                 false, false, false, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 0, 62));          // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,         // true, true, false, true, true, false, false, true, true, true, true, false, true,         // false, true, false, true, false, false, false, false, true, false, false, true,         // false, false, false, true, true, true, true, false, false, true, true, false, true,         // false, true, false, false, false, true, false, true, true, false, false, false, true,         // false, false, true, false, false, false         // , false, false, false, false}, Conversion.longToBinary(0x1234567890ABCDEFL, 2, new         // boolean[69], 3, 63));//rejected by assertion         assertArrayEquals(             new boolean[]{                 false, false, false, true, true, false, true, true, true, true, false, true,                 true, false, false, true, true, true, true, false, true, false, true, false,                 true, false, false, false, false, true, false, false, true, false, false,                 false, true, true, true, true, false, false, true, true, false, true, false,                 true, false, false, false, true, false, true, true, false, false, false, true,                 false, false, true, false, false, false, false, false, false, false},             Conversion.longToBinary(0x1234567890ABCDEFL, 2, new boolean[69], 3, 62));     }      /**      * Tests {@link Conversion#intToBinary(int, int, boolean[], int, int)}.      */     @Test     public void testIntToBinary() {         assertArrayEquals(             new boolean[]{}, Conversion.intToBinary(0x00000000, 0, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{}, Conversion.intToBinary(0x00000000, 100, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{}, Conversion.intToBinary(0x00000000, 0, new boolean[]{}, 100, 0));         assertArrayEquals(             new boolean[69], Conversion.intToBinary(0x90ABCDEF, 0, new boolean[69], 0, 0));         assertArrayEquals(new boolean[]{             true, false, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 1));         assertArrayEquals(new boolean[]{             true, true, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 2));         assertArrayEquals(new boolean[]{             true, true, true, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 3));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, true, true, true, false, true, false, true, false, true,                 false, false, false, false, true, false, false, false, false, false, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 31));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, true, true, true, false, true, false, true, false, true,                 false, false, false, false, true, false, false, true, false, false, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 0, 32));         assertArrayEquals(new boolean[]{             false, false, true, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 1));         assertArrayEquals(             new boolean[]{                 false, false, true, true, true, true, false, true, true, true, true, false,                 true, true, false, false, true, true, true, true, false, true, false, true,                 false, true, false, false, false, false, true, false, false, true, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 0, new boolean[37], 2, 32));         assertArrayEquals(             new boolean[]{                 true, true, true, false, true, true, true, true, false, true, true, false,                 false, true, true, true, true, false, true, false, true, false, true, false,                 false, false, false, true, false, false, true, false, false, false, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 1, new boolean[37], 0, 31));         assertArrayEquals(             new boolean[]{                 true, true, false, true, true, true, true, false, true, true, false, false,                 true, true, true, true, false, true, false, true, false, true, false, false,                 false, false, true, false, false, true, false, false, false, false, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 0, 30));         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true,         // true,         // true, true, false, true, true, false, false, true, true, true, true, false, true,         // false, true, false, true, false, false, false, false, true, false, false, false,         // false, false, false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37],         // 3, 31));//rejected by assertion         assertArrayEquals(             new boolean[]{                 false, false, false, true, true, false, true, true, true, true, false, true,                 true, false, false, true, true, true, true, false, true, false, true, false,                 true, false, false, false, false, true, false, false, true, false, false,                 false, false}, Conversion.intToBinary(0x90ABCDEF, 2, new boolean[37], 3, 30));     }      /**      * Tests {@link Conversion#shortToBinary(short, int, boolean[], int, int)}.      */     @Test     public void testShortToBinary() {         assertArrayEquals(             new boolean[]{}, Conversion.shortToBinary((short) 0x0000, 0, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{},             Conversion.shortToBinary((short) 0x0000, 100, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{},             Conversion.shortToBinary((short) 0x0000, 0, new boolean[]{}, 100, 0));         assertArrayEquals(             new boolean[69], Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[69], 0, 0));         assertArrayEquals(             new boolean[]{                 true, false, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 1));         assertArrayEquals(             new boolean[]{                 true, true, false, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 2));         assertArrayEquals(             new boolean[]{                 true, true, true, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 3));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 15));         assertArrayEquals(             new boolean[]{                 true, true, true, true, false, true, true, true, true, false, true, true,                 false, false, true, true, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 0, 16));         assertArrayEquals(             new boolean[]{                 false, false, true, false, false, false, false, false, false, false, false,                 false, false, false, false, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 2, 1));         assertArrayEquals(             new boolean[]{                 false, false, true, true, true, true, false, true, true, true, true, false,                 true, true, false, false, true, true, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 0, new boolean[21], 2, 16));         assertArrayEquals(             new boolean[]{                 true, true, true, false, true, true, true, true, false, true, true, false,                 false, true, true, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 1, new boolean[21], 0, 15));         assertArrayEquals(             new boolean[]{                 true, true, false, true, true, true, true, false, true, true, false, false,                 true, true, false, false, false, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21], 0, 14));         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,         // true, true, false, true, true, false, false, true, false, false, false, false,         // false}, Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21],         // 3, 15));//rejected by         // assertion         assertArrayEquals(             new boolean[]{                 false, false, false, true, true, false, true, true, true, true, false, true,                 true, false, false, true, true, false, false, false, false},             Conversion.shortToBinary((short) 0xCDEF, 2, new boolean[21], 3, 14));     }      /**      * Tests {@link Conversion#byteToBinary(byte, int, boolean[], int, int)}.      */     @Test     public void testByteToBinary() {         assertArrayEquals(             new boolean[]{}, Conversion.byteToBinary((byte) 0x00, 0, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{}, Conversion.byteToBinary((byte) 0x00, 100, new boolean[]{}, 0, 0));         assertArrayEquals(             new boolean[]{}, Conversion.byteToBinary((byte) 0x00, 0, new boolean[]{}, 100, 0));         assertArrayEquals(             new boolean[69], Conversion.byteToBinary((byte) 0xEF, 0, new boolean[69], 0, 0));         assertArrayEquals(new boolean[]{             true, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 1));         assertArrayEquals(new boolean[]{             true, false, false, false, false, false, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 2));         assertArrayEquals(new boolean[]{             true, false, true, false, false, false, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 3));         assertArrayEquals(new boolean[]{             true, false, true, false, true, false, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 7));         assertArrayEquals(new boolean[]{             true, false, true, false, true, false, false, true, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 0, 8));         assertArrayEquals(new boolean[]{             false, false, true, false, false, false, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 2, 1));         assertArrayEquals(new boolean[]{             false, false, true, false, true, false, true, false, false, true, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 0, new boolean[13], 2, 8));         assertArrayEquals(new boolean[]{             false, true, false, true, false, false, true, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 1, new boolean[13], 0, 7));         assertArrayEquals(new boolean[]{             true, false, true, false, false, true, false, false, false, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 2, new boolean[13], 0, 6));         // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,         // false, false, false, false, false}, Conversion.byteToBinary((byte) 0x95, 2, new         // boolean[13], 3, 7));//rejected by assertion         assertArrayEquals(new boolean[]{             false, false, false, true, false, true, false, false, true, false, false, false,             false}, Conversion.byteToBinary((byte) 0x95, 2, new boolean[13], 3, 6));     }      /**      * Tests {@link Conversion#uuidToByteArray(UUID, byte[], int, int)}.      */     @Test     public void testUuidToByteArray() {         assertArrayEquals(new byte[]{             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,             (byte) 0xff, (byte) 0xff}, Conversion.uuidToByteArray(new UUID(             0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16));         assertArrayEquals(new byte[]{             (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee,             (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55,             (byte) 0x66, (byte) 0x77}, Conversion.uuidToByteArray(new UUID(             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16));         assertArrayEquals(new byte[]{             (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x88, (byte) 0x99, (byte) 0xaa,             (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x00,             (byte) 0x00, (byte) 0x00}, Conversion.uuidToByteArray(new UUID(             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 4, 8));         assertArrayEquals(new byte[]{             (byte) 0x00, (byte) 0x00, (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc,             (byte) 0xdd, (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33,             (byte) 0x00, (byte) 0x00}, Conversion.uuidToByteArray(new UUID(             0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 2, 12));     }      /**      * Tests {@link Conversion#byteArrayToUuid(byte[], int)}.      */     @Test     public void testByteArrayToUuid() {         assertEquals(             new UUID(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL),             Conversion.byteArrayToUuid(new byte[]{                 (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,                 (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,                 (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff}, 0));         assertEquals(             new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L),             Conversion.byteArrayToUuid(new byte[]{                 (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd,                 (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33,                 (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77}, 0));         assertEquals(             new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L),             Conversion.byteArrayToUuid(new byte[]{                 0, 0, (byte) 0x88, (byte) 0x99, (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd,                 (byte) 0xee, (byte) 0xff, (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33,                 (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77}, 2));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.function;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.IOException; import java.io.UncheckedIOException; import java.lang.reflect.UndeclaredThrowableException; import java.util.concurrent.Callable; import java.util.function.BiConsumer; import java.util.function.BiFunction; import java.util.function.BiPredicate; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier;  import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test;  /**  * Tests "failable" interfaces defined in this package.  */ public class FailableFunctionsTest {      public static class CloseableObject {         private boolean closed;          public void close() {             closed = true;         }          public boolean isClosed() {             return closed;         }          public void reset() {             closed = false;         }          public void run(final Throwable pTh) throws Throwable {             if (pTh != null) {                 throw pTh;             }         }     }      public static class FailureOnOddInvocations {         private static int invocations;          static boolean failingBool() throws SomeException {             throwOnOdd();             return true;         }          static boolean testDouble(final double value) throws SomeException {             throwOnOdd();             return true;         }          static boolean testInt(final int value) throws SomeException {             throwOnOdd();             return true;         }          static boolean testLong(final long value) throws SomeException {             throwOnOdd();             return true;         }          private static void throwOnOdd() throws SomeException {             final int i = ++invocations;             if (i % 2 == 1) {                 throw new SomeException("Odd Invocation: " + i);             }         }          FailureOnOddInvocations() throws SomeException {             throwOnOdd();         }          boolean getAsBoolean() throws SomeException {             throwOnOdd();             return true;         }     }      public static class SomeException extends Exception {          private static final long serialVersionUID = -4965704778119283411L;          private Throwable t;          SomeException(final String message) {             super(message);         }          public void setThrowable(final Throwable throwable) {             t = throwable;         }          public void test() throws Throwable {             if (t != null) {                 throw t;             }         }     }      public static class Testable<T, P> {         private T acceptedObject;         private P acceptedPrimitiveObject1;         private P acceptedPrimitiveObject2;         private Throwable throwable;          Testable(final Throwable throwable) {             this.throwable = throwable;         }          public T getAcceptedObject() {             return acceptedObject;         }          public P getAcceptedPrimitiveObject1() {             return acceptedPrimitiveObject1;         }          public P getAcceptedPrimitiveObject2() {             return acceptedPrimitiveObject2;         }          public void setThrowable(final Throwable throwable) {             this.throwable = throwable;         }          public void test() throws Throwable {             test(throwable);         }          public Object test(final Object input1, final Object input2) throws Throwable {             test(throwable);             return acceptedObject;         }          public void test(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }         }          public boolean testAsBooleanPrimitive() throws Throwable {             return testAsBooleanPrimitive(throwable);         }          public boolean testAsBooleanPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return false;         }          public double testAsDoublePrimitive() throws Throwable {             return testAsDoublePrimitive(throwable);         }          public double testAsDoublePrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public Integer testAsInteger() throws Throwable {             return testAsInteger(throwable);         }          public Integer testAsInteger(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public int testAsIntPrimitive() throws Throwable {             return testAsIntPrimitive(throwable);         }          public int testAsIntPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public long testAsLongPrimitive() throws Throwable {             return testAsLongPrimitive(throwable);         }          public long testAsLongPrimitive(final Throwable throwable) throws Throwable {             if (throwable != null) {                 throw throwable;             }             return 0;         }          public void testDouble(final double i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Double) i);         }          public double testDoubleDouble(final double i, final double j) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Double) i);             acceptedPrimitiveObject2 = (P) ((Double) j);             return 3d;         }          public void testInt(final int i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Integer) i);         }          public void testLong(final long i) throws Throwable {             test(throwable);             acceptedPrimitiveObject1 = (P) ((Long) i);         }          public void testObjDouble(final T object, final double i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Double) i);         }          public void testObjInt(final T object, final int i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Integer) i);         }          public void testObjLong(final T object, final long i) throws Throwable {             test(throwable);             acceptedObject = object;             acceptedPrimitiveObject1 = (P) ((Long) i);         }     }      private static final OutOfMemoryError ERROR = new OutOfMemoryError();      private static final IllegalStateException ILLEGAL_STATE_EXCEPTION = new IllegalStateException();      @Test     public void testAcceptBiConsumer() {         final Testable<?, ?> testable = new Testable<>(null);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.accept(Testable::test, testable, ILLEGAL_STATE_EXCEPTION));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(Testable::test, testable, ERROR));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(Testable::test, testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Failable.accept(Testable::test, testable, (Throwable) null);     }      @Test     public void testAcceptConsumer() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(Testable::test, testable));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(Testable::test, testable));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(Testable::test, testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Failable.accept(Testable::test, testable);     }      @Test     public void testAcceptDoubleConsumer() {         final Testable<?, Double> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(testable::testDouble, 1d));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testDouble, 1d));         assertSame(ERROR, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testDouble, 1d));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testDouble, 1d);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptIntConsumer() {         final Testable<?, Integer> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(testable::testInt, 1));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testInt, 1));         assertSame(ERROR, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testInt, 1));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testInt, 1);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptLongConsumer() {         final Testable<?, Long> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(testable::testLong, 1L));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testLong, 1L));         assertSame(ERROR, e);         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testLong, 1L));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testLong, 1L);         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjDoubleConsumer() {         final Testable<String, Double> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.accept(testable::testObjDouble, "X", 1d));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testObjDouble, "X", 1d));         assertSame(ERROR, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testObjDouble, "X", 1d));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testObjDouble, "X", 1d);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1d, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjIntConsumer() {         final Testable<String, Integer> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(testable::testObjInt, "X", 1));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testObjInt, "X", 1));         assertSame(ERROR, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testObjInt, "X", 1));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testObjInt, "X", 1);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testAcceptObjLongConsumer() {         final Testable<String, Long> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.accept(testable::testObjLong, "X", 1L));         assertSame(ILLEGAL_STATE_EXCEPTION, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.accept(testable::testObjLong, "X", 1L));         assertSame(ERROR, e);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.accept(testable::testObjLong, "X", 1L));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);         assertNull(testable.getAcceptedObject());         assertNull(testable.getAcceptedPrimitiveObject1());          testable.setThrowable(null);         Failable.accept(testable::testObjLong, "X", 1L);         assertEquals("X", testable.getAcceptedObject());         assertEquals(1L, testable.getAcceptedPrimitiveObject1());     }      @Test     public void testApplyBiFunction() {         final Testable<?, ?> testable = new Testable<>(null);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.apply(Testable::testAsInteger, testable, ILLEGAL_STATE_EXCEPTION));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          e = assertThrows(OutOfMemoryError.class, () -> Failable.apply(Testable::testAsInteger, testable, ERROR));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         e = assertThrows(UncheckedIOException.class, () -> Failable.apply(Testable::testAsInteger, testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          final Integer i = Failable.apply(Testable::testAsInteger, testable, (Throwable) null);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     public void testApplyDoubleBinaryOperator() {         final Testable<?, Double> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         final Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.applyAsDouble(testable::testDoubleDouble, 1d, 2d));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          final Testable<?, Double> testable2 = new Testable<>(null);         final double i = Failable.applyAsDouble(testable2::testDoubleDouble, 1d, 2d);         assertEquals(3d, i);     }      @Test     public void testApplyFunction() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.apply(Testable::testAsInteger, testable));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.apply(Testable::testAsInteger, testable));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.apply(Testable::testAsInteger, testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final Integer i = Failable.apply(Testable::testAsInteger, testable);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     public void testAsCallable() {         FailureOnOddInvocations.invocations = 0;         final FailableCallable<FailureOnOddInvocations, SomeException> failableCallable = FailureOnOddInvocations::new;         final Callable<FailureOnOddInvocations> callable = Failable.asCallable(failableCallable);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, callable::call);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance;         try {             instance = callable.call();         } catch (final Exception ex) {             throw Failable.rethrow(ex);         }         assertNotNull(instance);     }      @Test     public void testAsConsumer() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         final Consumer<Testable<?, ?>> consumer = Failable.asConsumer(Testable::test);         Throwable e = assertThrows(IllegalStateException.class, () -> consumer.accept(testable));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> consumer.accept(testable));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> consumer.accept(testable));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         Failable.accept(Testable::test, testable);     }      @Test     public void testAsRunnable() {         FailureOnOddInvocations.invocations = 0;         final Runnable runnable = Failable.asRunnable(FailureOnOddInvocations::new);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, runnable::run);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());          // Even invocations, should not throw an exception         runnable.run();     }      @Test     public void testAsSupplier() {         FailureOnOddInvocations.invocations = 0;         final FailableSupplier<FailureOnOddInvocations, Throwable> failableSupplier = FailureOnOddInvocations::new;         final Supplier<FailureOnOddInvocations> supplier = Failable.asSupplier(failableSupplier);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class, supplier::get);         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         assertNotNull(supplier.get());     }      @Test     public void testBiConsumer() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableBiConsumer<Testable<?, ?>, Throwable, Throwable> failableBiConsumer = (t, th) -> {             t.setThrowable(th);             t.test();         };         final BiConsumer<Testable<?, ?>, Throwable> consumer = Failable.asBiConsumer(failableBiConsumer);         Throwable e = assertThrows(IllegalStateException.class,             () -> consumer.accept(testable, ILLEGAL_STATE_EXCEPTION));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          e = assertThrows(OutOfMemoryError.class, () -> consumer.accept(testable, ERROR));         assertSame(ERROR, e);          e = assertThrows(OutOfMemoryError.class, () -> failableBiConsumer.accept(testable, ERROR));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> consumer.accept(testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          consumer.accept(testable, null);     }      @Test     public void testBiConsumerAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableBiConsumer<Testable<?, ?>, Throwable, Throwable> failing = (t, th) -> {             t.setThrowable(th);             t.test();         };         final FailableBiConsumer<Testable<?, ?>, Throwable, Throwable> nop = FailableBiConsumer.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).accept(testable, ERROR));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).accept(testable, ERROR));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testBiFunction() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         final FailableBiFunction<Testable<?, ?>, Throwable, Integer, Throwable> failableBiFunction = (t, th) -> {             t.setThrowable(th);             return t.testAsInteger();         };         final BiFunction<Testable<?, ?>, Throwable, Integer> biFunction = Failable.asBiFunction(failableBiFunction);         Throwable e = assertThrows(IllegalStateException.class,             () -> biFunction.apply(testable, ILLEGAL_STATE_EXCEPTION));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> biFunction.apply(testable, ERROR));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> biFunction.apply(testable, ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          assertEquals(0, biFunction.apply(testable, null).intValue());     }      @Test     public void testBiFunctionAndThen() throws IOException {         // Unchecked usage pattern in JRE         final BiFunction<Object, Integer, Integer> nopBiFunction = (t, u) -> null;         final Function<Object, Integer> nopFunction = t -> null;         nopBiFunction.andThen(nopFunction);         // Checked usage pattern         final FailableBiFunction<Object, Integer, Integer, IOException> failingBiFunctionTest = (t, u) -> {             throw new IOException();         };         final FailableFunction<Object, Integer, IOException> failingFunction = t -> {             throw new IOException();         };         final FailableBiFunction<Object, Integer, Integer, IOException> nopFailableBiFunction = FailableBiFunction             .nop();         final FailableFunction<Object, Integer, IOException> nopFailableFunction = FailableFunction.nop();         //         assertThrows(IOException.class, () -> failingBiFunctionTest.andThen(failingFunction).apply(null, null));         assertThrows(IOException.class, () -> failingBiFunctionTest.andThen(nopFailableFunction).apply(null, null));         //         assertThrows(IOException.class, () -> nopFailableBiFunction.andThen(failingFunction).apply(null, null));         nopFailableBiFunction.andThen(nopFailableFunction).apply(null, null);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failingBiFunctionTest.andThen(null));     }      @Test     @DisplayName("Test that asPredicate(FailableBiPredicate) is converted to -> BiPredicate ")     public void testBiPredicate() {         FailureOnOddInvocations.invocations = 0;         final FailableBiPredicate<Object, Object, Throwable> failableBiPredicate = (t1, t2) -> FailureOnOddInvocations             .failingBool();         final BiPredicate<?, ?> predicate = Failable.asBiPredicate(failableBiPredicate);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> predicate.test(null, null));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         assertTrue(predicate.test(null, null));     }      @Test     public void testBiPredicateAnd() throws Throwable {         assertTrue(FailableBiPredicate.TRUE.and(FailableBiPredicate.TRUE).test(null, null));         assertFalse(FailableBiPredicate.TRUE.and(FailableBiPredicate.FALSE).test(null, null));         assertFalse(FailableBiPredicate.FALSE.and(FailableBiPredicate.TRUE).test(null, null));         assertFalse(FailableBiPredicate.FALSE.and(FailableBiPredicate.FALSE).test(null, null));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableBiPredicate.falsePredicate().and(null).test(null, null)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableBiPredicate.truePredicate().and(null).test(null, null)));     }      @Test     public void testBiPredicateNegate() throws Throwable {         assertFalse(FailableBiPredicate.TRUE.negate().test(null, null));         assertFalse(FailableBiPredicate.truePredicate().negate().test(null, null));         assertTrue(FailableBiPredicate.FALSE.negate().test(null, null));         assertTrue(FailableBiPredicate.falsePredicate().negate().test(null, null));     }      @Test     public void testBiPredicateOr() throws Throwable {         assertTrue(FailableBiPredicate.TRUE.or(FailableBiPredicate.TRUE).test(null, null));         assertTrue(FailableBiPredicate.TRUE.or(FailableBiPredicate.FALSE).test(null, null));         assertTrue(FailableBiPredicate.FALSE.or(FailableBiPredicate.TRUE).test(null, null));         assertFalse(FailableBiPredicate.FALSE.or(FailableBiPredicate.FALSE).test(null, null));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableBiPredicate.falsePredicate().or(null).test(null, null)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableBiPredicate.truePredicate().or(null).test(null, null)));     }      @Test     public void testCallable() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Failable.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance = Failable.call(FailureOnOddInvocations::new);         assertNotNull(instance);     }      @Test     public void testConsumerAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableConsumer<Throwable, Throwable> failableConsumer = th -> {             testable.setThrowable(th);             testable.test();         };         final FailableConsumer<Throwable, Throwable> nop = FailableConsumer.nop();         final Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failableConsumer).accept(ERROR));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failableConsumer.andThen(null));     }      @Test     public void testDoubleConsumerAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableDoubleConsumer<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();         };         final FailableDoubleConsumer<Throwable> nop = FailableDoubleConsumer.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).accept(0d));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).accept(0d));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testDoublePredicate() throws Throwable {         FailureOnOddInvocations.invocations = 0;         final FailableDoublePredicate<Throwable> failablePredicate = FailureOnOddInvocations::testDouble;         assertThrows(SomeException.class, () -> failablePredicate.test(1d));         failablePredicate.test(1d);     }      @Test     public void testDoublePredicateAnd() throws Throwable {         assertTrue(FailableDoublePredicate.TRUE.and(FailableDoublePredicate.TRUE).test(0));         assertFalse(FailableDoublePredicate.TRUE.and(FailableDoublePredicate.FALSE).test(0));         assertFalse(FailableDoublePredicate.FALSE.and(FailableDoublePredicate.TRUE).test(0));         assertFalse(FailableDoublePredicate.FALSE.and(FailableDoublePredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableDoublePredicate.falsePredicate().and(null).test(0)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableDoublePredicate.truePredicate().and(null).test(0)));     }      @Test     public void testDoublePredicateNegate() throws Throwable {         assertFalse(FailableDoublePredicate.TRUE.negate().test(0d));         assertFalse(FailableDoublePredicate.truePredicate().negate().test(0d));         assertTrue(FailableDoublePredicate.FALSE.negate().test(0d));         assertTrue(FailableDoublePredicate.falsePredicate().negate().test(0d));     }      @Test     public void testDoublePredicateOr() throws Throwable {         assertTrue(FailableDoublePredicate.TRUE.or(FailableDoublePredicate.TRUE).test(0));         assertTrue(FailableDoublePredicate.TRUE.or(FailableDoublePredicate.FALSE).test(0));         assertTrue(FailableDoublePredicate.FALSE.or(FailableDoublePredicate.TRUE).test(0));         assertFalse(FailableDoublePredicate.FALSE.or(FailableDoublePredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableDoublePredicate.falsePredicate().or(null).test(0)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableDoublePredicate.truePredicate().or(null).test(0)));     }      @Test     public void testDoubleUnaryOperatorAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableDoubleUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0d;         };         final FailableDoubleUnaryOperator<Throwable> nop = FailableDoubleUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).applyAsDouble(0d));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).applyAsDouble(0d));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testDoubleUnaryOperatorCompose() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableDoubleUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0d;         };         final FailableDoubleUnaryOperator<Throwable> nop = FailableDoubleUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.compose(failing).applyAsDouble(0d));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.compose(nop).applyAsDouble(0d));         assertSame(ERROR, e);         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.compose(null));     }      @Test     public void testDoubleUnaryOperatorIdentity() throws Throwable {         final FailableDoubleUnaryOperator<Throwable> nop = FailableDoubleUnaryOperator.identity();         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> nop.compose(null));     }      @Test     public void testFunction() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         final FailableFunction<Throwable, Integer, Throwable> failableFunction = th -> {             testable.setThrowable(th);             return testable.testAsInteger();         };         final Function<Throwable, Integer> function = Failable.asFunction(failableFunction);         Throwable e = assertThrows(IllegalStateException.class, () -> function.apply(ILLEGAL_STATE_EXCEPTION));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> function.apply(ERROR));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> function.apply(ioe));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          assertEquals(0, function.apply(null).intValue());     }      @Test     public void testFunctionAndThen() throws IOException {         // Unchecked usage pattern in JRE         final Function<Object, Integer> nopFunction = t -> null;         nopFunction.andThen(nopFunction);         // Checked usage pattern         final FailableFunction<Object, Integer, IOException> failingFunction = t -> {             throw new IOException();         };         final FailableFunction<Object, Integer, IOException> nopFailableFunction = FailableFunction.nop();         //         assertThrows(IOException.class, () -> failingFunction.andThen(failingFunction).apply(null));         assertThrows(IOException.class, () -> failingFunction.andThen(nopFailableFunction).apply(null));         //         assertThrows(IOException.class, () -> nopFailableFunction.andThen(failingFunction).apply(null));         nopFailableFunction.andThen(nopFailableFunction).apply(null);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failingFunction.andThen(null));     }      @Test     public void testFunctionCompose() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableFunction<Object, Integer, Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0;         };         final FailableFunction<Object, Integer, Throwable> nop = FailableFunction.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.compose(failing).apply(0));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.compose(nop).apply(0));         assertSame(ERROR, e);         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.compose(null));     }      @Test     public void testFunctionIdentity() throws Throwable {         final FailableFunction<Integer, Integer, Throwable> nop = FailableFunction.identity();         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> nop.compose(null));     }      @Test     public void testGetAsBooleanSupplier() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.getAsBoolean(testable::testAsBooleanPrimitive));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.getAsBoolean(testable::testAsBooleanPrimitive));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.getAsBoolean(testable::testAsBooleanPrimitive));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         assertFalse(Failable.getAsBoolean(testable::testAsBooleanPrimitive));     }      @Test     public void testGetAsDoubleSupplier() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.getAsDouble(testable::testAsDoublePrimitive));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.getAsDouble(testable::testAsDoublePrimitive));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.getAsDouble(testable::testAsDoublePrimitive));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         assertEquals(0, Failable.getAsDouble(testable::testAsDoublePrimitive));     }      @Test     public void testGetAsIntSupplier() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.getAsInt(testable::testAsIntPrimitive));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.getAsInt(testable::testAsIntPrimitive));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.getAsInt(testable::testAsIntPrimitive));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final int i = Failable.getAsInt(testable::testAsInteger);         assertEquals(0, i);     }      @Test     public void testGetAsLongSupplier() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.getAsLong(testable::testAsLongPrimitive));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.getAsLong(testable::testAsLongPrimitive));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.getAsLong(testable::testAsLongPrimitive));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final long i = Failable.getAsLong(testable::testAsLongPrimitive);         assertEquals(0, i);     }      @Test     public void testGetFromSupplier() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Failable.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final FailureOnOddInvocations instance = Failable.call(FailureOnOddInvocations::new);         assertNotNull(instance);     }      @Test     public void testGetSupplier() {         final Testable<?, ?> testable = new Testable<>(ILLEGAL_STATE_EXCEPTION);         Throwable e = assertThrows(IllegalStateException.class, () -> Failable.get(testable::testAsInteger));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          testable.setThrowable(ERROR);         e = assertThrows(OutOfMemoryError.class, () -> Failable.get(testable::testAsInteger));         assertSame(ERROR, e);          final IOException ioe = new IOException("Unknown I/O error");         testable.setThrowable(ioe);         e = assertThrows(UncheckedIOException.class, () -> Failable.get(testable::testAsInteger));         final Throwable t = e.getCause();         assertNotNull(t);         assertSame(ioe, t);          testable.setThrowable(null);         final Integer i = Failable.apply(Testable::testAsInteger, testable);         assertNotNull(i);         assertEquals(0, i.intValue());     }      @Test     public void testIntConsumerAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableIntConsumer<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();         };         final FailableIntConsumer<Throwable> nop = FailableIntConsumer.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).accept(0));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).accept(0));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testIntPredicate() throws Throwable {         FailureOnOddInvocations.invocations = 0;         final FailableIntPredicate<Throwable> failablePredicate = FailureOnOddInvocations::testInt;         assertThrows(SomeException.class, () -> failablePredicate.test(1));         failablePredicate.test(1);     }      @Test     public void testIntPredicateAnd() throws Throwable {         assertTrue(FailableIntPredicate.TRUE.and(FailableIntPredicate.TRUE).test(0));         assertFalse(FailableIntPredicate.TRUE.and(FailableIntPredicate.FALSE).test(0));         assertFalse(FailableIntPredicate.FALSE.and(FailableIntPredicate.TRUE).test(0));         assertFalse(FailableIntPredicate.FALSE.and(FailableIntPredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableIntPredicate.falsePredicate().and(null).test(0)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableIntPredicate.truePredicate().and(null).test(0)));     }      @Test     public void testIntPredicateNegate() throws Throwable {         assertFalse(FailableIntPredicate.TRUE.negate().test(0));         assertFalse(FailableIntPredicate.truePredicate().negate().test(0));         assertTrue(FailableIntPredicate.FALSE.negate().test(0));         assertTrue(FailableIntPredicate.falsePredicate().negate().test(0));     }      @Test     public void testIntPredicateOr() throws Throwable {         assertTrue(FailableIntPredicate.TRUE.or(FailableIntPredicate.TRUE).test(0));         assertTrue(FailableIntPredicate.TRUE.or(FailableIntPredicate.FALSE).test(0));         assertTrue(FailableIntPredicate.FALSE.or(FailableIntPredicate.TRUE).test(0));         assertFalse(FailableIntPredicate.FALSE.or(FailableIntPredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class,             () -> assertFalse(FailableIntPredicate.falsePredicate().or(null).test(0)));         assertThrows(NullPointerException.class,             () -> assertTrue(FailableIntPredicate.truePredicate().or(null).test(0)));     }      @Test     public void testIntUnaryOperatorAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableIntUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0;         };         final FailableIntUnaryOperator<Throwable> nop = FailableIntUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).applyAsInt(0));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).applyAsInt(0));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testIntUnaryOperatorCompose() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableIntUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0;         };         final FailableIntUnaryOperator<Throwable> nop = FailableIntUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.compose(failing).applyAsInt(0));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.compose(nop).applyAsInt(0));         assertSame(ERROR, e);         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.compose(null));     }      @Test     public void testIntUnaryOperatorIdentity() throws Throwable {         final FailableIntUnaryOperator<Throwable> nop = FailableIntUnaryOperator.identity();         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> nop.compose(null));     }      @Test     public void testLongConsumerAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableLongConsumer<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();         };         final FailableLongConsumer<Throwable> nop = FailableLongConsumer.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).accept(0L));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).accept(0L));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testLongPredicate() throws Throwable {         FailureOnOddInvocations.invocations = 0;         final FailableLongPredicate<Throwable> failablePredicate = FailureOnOddInvocations::testLong;         assertThrows(SomeException.class, () -> failablePredicate.test(1L));         failablePredicate.test(1L);     }      @Test     public void testLongPredicateAnd() throws Throwable {         assertTrue(FailableLongPredicate.TRUE.and(FailableLongPredicate.TRUE).test(0));         assertFalse(FailableLongPredicate.TRUE.and(FailableLongPredicate.FALSE).test(0));         assertFalse(FailableLongPredicate.FALSE.and(FailableLongPredicate.TRUE).test(0));         assertFalse(FailableLongPredicate.FALSE.and(FailableLongPredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class, () -> assertFalse(FailableLongPredicate.falsePredicate().and(null).test(0)));         assertThrows(NullPointerException.class, () -> assertTrue(FailableLongPredicate.truePredicate().and(null).test(0)));     }      @Test     public void testLongPredicateNegate() throws Throwable {         assertFalse(FailableLongPredicate.TRUE.negate().test(0L));         assertFalse(FailableLongPredicate.truePredicate().negate().test(0L));         assertTrue(FailableLongPredicate.FALSE.negate().test(0L));         assertTrue(FailableLongPredicate.falsePredicate().negate().test(0L));     }      @Test     public void testLongPredicateOr() throws Throwable {         assertTrue(FailableLongPredicate.TRUE.or(FailableLongPredicate.TRUE).test(0));         assertTrue(FailableLongPredicate.TRUE.or(FailableLongPredicate.FALSE).test(0));         assertTrue(FailableLongPredicate.FALSE.or(FailableLongPredicate.TRUE).test(0));         assertFalse(FailableLongPredicate.FALSE.or(FailableLongPredicate.FALSE).test(0));         // null tests         assertThrows(NullPointerException.class, () -> assertFalse(FailableLongPredicate.falsePredicate().or(null).test(0)));         assertThrows(NullPointerException.class, () -> assertTrue(FailableLongPredicate.truePredicate().or(null).test(0)));     }      @Test     public void testLongUnaryOperatorAndThen() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableLongUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0L;         };         final FailableLongUnaryOperator<Throwable> nop = FailableLongUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.andThen(failing).applyAsLong(0L));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.andThen(nop).applyAsLong(0L));         assertSame(ERROR, e);         // Does not throw         nop.andThen(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.andThen(null));     }      @Test     public void testLongUnaryOperatorCompose() throws Throwable {         final Testable<?, ?> testable = new Testable<>(null);         final FailableLongUnaryOperator<Throwable> failing = t -> {             testable.setThrowable(ERROR);             testable.test();             return 0L;         };         final FailableLongUnaryOperator<Throwable> nop = FailableLongUnaryOperator.nop();         Throwable e = assertThrows(OutOfMemoryError.class, () -> nop.compose(failing).applyAsLong(0L));         assertSame(ERROR, e);         e = assertThrows(OutOfMemoryError.class, () -> failing.compose(nop).applyAsLong(0L));         assertSame(ERROR, e);         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> failing.compose(null));     }      @Test     public void testLongUnaryOperatorIdentity() throws Throwable {         final FailableLongUnaryOperator<Throwable> nop = FailableLongUnaryOperator.identity();         // Does not throw         nop.compose(nop);         // Documented in Javadoc edge-case.         assertThrows(NullPointerException.class, () -> nop.compose(null));     }      @Test     @DisplayName("Test that asPredicate(FailablePredicate) is converted to -> Predicate ")     public void testPredicate() {         FailureOnOddInvocations.invocations = 0;         final FailablePredicate<Object, Throwable> failablePredicate = t -> FailureOnOddInvocations.failingBool();         final Predicate<?> predicate = Failable.asPredicate(failablePredicate);         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> predicate.test(null));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());         final boolean instance = predicate.test(null);         assertNotNull(instance);     }      @Test     public void testPredicateAnd() throws Throwable {         assertTrue(FailablePredicate.TRUE.and(FailablePredicate.TRUE).test(null));         assertFalse(FailablePredicate.TRUE.and(FailablePredicate.FALSE).test(null));         assertFalse(FailablePredicate.FALSE.and(FailablePredicate.TRUE).test(null));         assertFalse(FailablePredicate.FALSE.and(FailablePredicate.FALSE).test(null));         // null tests         assertThrows(NullPointerException.class, () -> assertFalse(FailablePredicate.FALSE.and(null).test(null)));         assertThrows(NullPointerException.class, () -> assertTrue(FailablePredicate.TRUE.and(null).test(null)));     }      @Test     public void testPredicateNegate() throws Throwable {         assertFalse(FailablePredicate.TRUE.negate().test(null));         assertFalse(FailablePredicate.truePredicate().negate().test(null));         assertTrue(FailablePredicate.FALSE.negate().test(null));         assertTrue(FailablePredicate.falsePredicate().negate().test(null));     }      @Test     public void testRunnable() {         FailureOnOddInvocations.invocations = 0;         final UndeclaredThrowableException e = assertThrows(UndeclaredThrowableException.class,             () -> Failable.run(FailureOnOddInvocations::new));         final Throwable cause = e.getCause();         assertNotNull(cause);         assertTrue(cause instanceof SomeException);         assertEquals("Odd Invocation: 1", cause.getMessage());          // Even invocations, should not throw an exception         Failable.run(FailureOnOddInvocations::new);     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiConsumer_Object_Throwable() {         new FailableBiConsumer<Object, Object, Throwable>() {              @Override             public void accept(final Object object1, final Object object2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiConsumer_String_IOException() {         new FailableBiConsumer<String, String, IOException>() {              @Override             public void accept(final String object1, final String object2) throws IOException {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiFunction_Object_Throwable() {         new FailableBiFunction<Object, Object, Object, Throwable>() {              @Override             public Object apply(final Object input1, final Object input2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiFunction_String_IOException() {         new FailableBiFunction<String, String, String, IOException>() {              @Override             public String apply(final String input1, final String input2) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBiPredicate_Object_Throwable() {         new FailableBiPredicate<Object, Object, Throwable>() {              @Override             public boolean test(final Object object1, final Object object2) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBiPredicate_String_IOException() {         new FailableBiPredicate<String, String, IOException>() {              @Override             public boolean test(final String object1, final String object2) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableBooleanSupplier_Object_Throwable() {         new FailableBooleanSupplier<Throwable>() {              @Override             public boolean getAsBoolean() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableBooleanSupplier_String_IOException() {         new FailableBooleanSupplier<IOException>() {              @Override             public boolean getAsBoolean() throws IOException {                 throw new IOException("test");             }         };     }      ///////////////////////////////////////////////      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableCallable_Object_Throwable() {         new FailableCallable<Object, Throwable>() {              @Override             public Object call() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableCallable_String_IOException() {         new FailableCallable<String, IOException>() {              @Override             public String call() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableConsumer_Object_Throwable() {         new FailableConsumer<Object, Throwable>() {              @Override             public void accept(final Object object) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableConsumer_String_IOException() {         new FailableConsumer<String, IOException>() {              @Override             public void accept(final String object) throws IOException {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleBinaryOperator_Object_Throwable() {         new FailableDoubleBinaryOperator<Throwable>() {              @Override             public double applyAsDouble(final double left, final double right) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleBinaryOperator_String_IOException() {         new FailableDoubleBinaryOperator<IOException>() {              @Override             public double applyAsDouble(final double left, final double right) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleConsumer_Object_Throwable() {         new FailableDoubleConsumer<Throwable>() {              @Override             public void accept(final double value) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleConsumer_String_IOException() {         new FailableDoubleConsumer<IOException>() {              @Override             public void accept(final double value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleFunction_Object_Throwable() {         new FailableDoubleFunction<Object, Throwable>() {              @Override             public Object apply(final double input) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleFunction_String_IOException() {         new FailableDoubleFunction<String, IOException>() {              @Override             public String apply(final double input) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleSupplier_Object_Throwable() {         new FailableDoubleSupplier<Throwable>() {              @Override             public double getAsDouble() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleSupplier_String_IOException() {         new FailableDoubleSupplier<IOException>() {              @Override             public double getAsDouble() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleToIntFunction_Object_Throwable() {         new FailableDoubleToIntFunction<Throwable>() {              @Override             public int applyAsInt(final double value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleToIntFunction_String_IOException() {         new FailableDoubleToIntFunction<IOException>() {              @Override             public int applyAsInt(final double value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableDoubleToLongFunction_Object_Throwable() {         new FailableDoubleToLongFunction<Throwable>() {              @Override             public int applyAsLong(final double value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableDoubleToLongFunction_String_IOException() {         new FailableDoubleToLongFunction<IOException>() {              @Override             public int applyAsLong(final double value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableFunction_Object_Throwable() {         new FailableFunction<Object, Object, Throwable>() {              @Override             public Object apply(final Object input) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableFunction_String_IOException() {         new FailableFunction<String, String, IOException>() {              @Override             public String apply(final String input) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntBinaryOperator_Object_Throwable() {         new FailableIntBinaryOperator<Throwable>() {              @Override             public int applyAsInt(final int left, final int right) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntBinaryOperator_String_IOException() {         new FailableIntBinaryOperator<IOException>() {              @Override             public int applyAsInt(final int left, final int right) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntConsumer_Object_Throwable() {         new FailableIntConsumer<Throwable>() {              @Override             public void accept(final int value) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntConsumer_String_IOException() {         new FailableIntConsumer<IOException>() {              @Override             public void accept(final int value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntFunction_Object_Throwable() {         new FailableIntFunction<Object, Throwable>() {              @Override             public Object apply(final int input) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntFunction_String_IOException() {         new FailableIntFunction<String, IOException>() {              @Override             public String apply(final int input) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntSupplier_Object_Throwable() {         new FailableIntSupplier<Throwable>() {              @Override             public int getAsInt() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntSupplier_String_IOException() {         new FailableIntSupplier<IOException>() {              @Override             public int getAsInt() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntToDoubleFunction_Object_Throwable() {         new FailableIntToDoubleFunction<Throwable>() {              @Override             public double applyAsDouble(final int value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntToDoubleFunction_String_IOException() {         new FailableIntToDoubleFunction<IOException>() {              @Override             public double applyAsDouble(final int value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableIntToLongFunction_Object_Throwable() {         new FailableIntToLongFunction<Throwable>() {              @Override             public long applyAsLong(final int value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableIntToLongFunction_String_IOException() {         new FailableIntToLongFunction<IOException>() {              @Override             public long applyAsLong(final int value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongBinaryOperator_Object_Throwable() {         new FailableLongBinaryOperator<Throwable>() {              @Override             public long applyAsLong(final long left, final long right) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongBinaryOperator_String_IOException() {         new FailableLongBinaryOperator<IOException>() {              @Override             public long applyAsLong(final long left, final long right) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongConsumer_Object_Throwable() {         new FailableLongConsumer<Throwable>() {              @Override             public void accept(final long object) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongConsumer_String_IOException() {         new FailableLongConsumer<IOException>() {              @Override             public void accept(final long object) throws IOException {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongFunction_Object_Throwable() {         new FailableLongFunction<Object, Throwable>() {              @Override             public Object apply(final long input) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongFunction_String_IOException() {         new FailableLongFunction<String, IOException>() {              @Override             public String apply(final long input) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongSupplier_Object_Throwable() {         new FailableLongSupplier<Throwable>() {              @Override             public long getAsLong() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongSupplier_String_IOException() {         new FailableLongSupplier<IOException>() {              @Override             public long getAsLong() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongToDoubleFunction_Object_Throwable() {         new FailableLongToDoubleFunction<Throwable>() {              @Override             public double applyAsDouble(final long value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongToDoubleFunction_String_IOException() {         new FailableLongToDoubleFunction<IOException>() {              @Override             public double applyAsDouble(final long value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableLongToIntFunction_Object_Throwable() {         new FailableLongToIntFunction<Throwable>() {              @Override             public int applyAsInt(final long value) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableLongToIntFunction_String_IOException() {         new FailableLongToIntFunction<IOException>() {              @Override             public int applyAsInt(final long value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableObjDoubleConsumer_Object_Throwable() {         new FailableObjDoubleConsumer<Object, Throwable>() {              @Override             public void accept(final Object object, final double value) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableObjDoubleConsumer_String_IOException() {         new FailableObjDoubleConsumer<String, IOException>() {              @Override             public void accept(final String object, final double value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableObjIntConsumer_Object_Throwable() {         new FailableObjIntConsumer<Object, Throwable>() {              @Override             public void accept(final Object object, final int value) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableObjIntConsumer_String_IOException() {         new FailableObjIntConsumer<String, IOException>() {              @Override             public void accept(final String object, final int value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableObjLongConsumer_Object_Throwable() {         new FailableObjLongConsumer<Object, Throwable>() {              @Override             public void accept(final Object object, final long value) throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableObjLongConsumer_String_IOException() {         new FailableObjLongConsumer<String, IOException>() {              @Override             public void accept(final String object, final long value) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailablePredicate_Object_Throwable() {         new FailablePredicate<Object, Throwable>() {              @Override             public boolean test(final Object object) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailablePredicate_String_IOException() {         new FailablePredicate<String, IOException>() {              @Override             public boolean test(final String object) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableRunnable_Object_Throwable() {         new FailableRunnable<Throwable>() {              @Override             public void run() throws Throwable {                 throw new IOException("test");              }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableRunnable_String_IOException() {         new FailableRunnable<IOException>() {              @Override             public void run() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableSupplier_Object_Throwable() {         new FailableSupplier<Object, Throwable>() {              @Override             public Object get() throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableSupplier_String_IOException() {         new FailableSupplier<String, IOException>() {              @Override             public String get() throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToDoubleBiFunction_Object_Throwable() {         new FailableToDoubleBiFunction<Object, Object, Throwable>() {              @Override             public double applyAsDouble(final Object t, final Object u) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToDoubleBiFunction_String_IOException() {         new FailableToDoubleBiFunction<String, String, IOException>() {              @Override             public double applyAsDouble(final String t, final String u) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToDoubleFunction_Object_Throwable() {         new FailableToDoubleFunction<Object, Throwable>() {              @Override             public double applyAsDouble(final Object t) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToDoubleFunction_String_IOException() {         new FailableToDoubleFunction<String, IOException>() {              @Override             public double applyAsDouble(final String t) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToIntBiFunction_Object_Throwable() {         new FailableToIntBiFunction<Object, Object, Throwable>() {              @Override             public int applyAsInt(final Object t, final Object u) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToIntBiFunction_String_IOException() {         new FailableToIntBiFunction<String, String, IOException>() {              @Override             public int applyAsInt(final String t, final String u) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToIntFunction_Object_Throwable() {         new FailableToIntFunction<Object, Throwable>() {              @Override             public int applyAsInt(final Object t) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToIntFunction_String_IOException() {         new FailableToIntFunction<String, IOException>() {              @Override             public int applyAsInt(final String t) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToLongBiFunction_Object_Throwable() {         new FailableToLongBiFunction<Object, Object, Throwable>() {              @Override             public long applyAsLong(final Object t, final Object u) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToLongBiFunction_String_IOException() {         new FailableToLongBiFunction<String, String, IOException>() {              @Override             public long applyAsLong(final String t, final String u) throws IOException {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception. using the top level generic types      * Object and Throwable.      */     @Test     public void testThrows_FailableToLongFunction_Object_Throwable() {         new FailableToLongFunction<Object, Throwable>() {              @Override             public long applyAsLong(final Object t) throws Throwable {                 throw new IOException("test");             }         };     }      /**      * Tests that our failable interface is properly defined to throw any exception using String and IOExceptions as      * generic test types.      */     @Test     public void testThrows_FailableToLongFunction_String_IOException() {         new FailableToLongFunction<String, IOException>() {              @Override             public long applyAsLong(final String t) throws IOException {                 throw new IOException("test");             }         };     }      @Test     public void testTryWithResources() {         final CloseableObject closeable = new CloseableObject();         final FailableConsumer<Throwable, ? extends Throwable> consumer = closeable::run;         Throwable e = assertThrows(IllegalStateException.class,             () -> Failable.tryWithResources(() -> consumer.accept(ILLEGAL_STATE_EXCEPTION), closeable::close));         assertSame(ILLEGAL_STATE_EXCEPTION, e);          assertTrue(closeable.isClosed());         closeable.reset();         e = assertThrows(OutOfMemoryError.class,             () -> Failable.tryWithResources(() -> consumer.accept(ERROR), closeable::close));         assertSame(ERROR, e);          assertTrue(closeable.isClosed());         closeable.reset();         final IOException ioe = new IOException("Unknown I/O error");         final UncheckedIOException uioe = assertThrows(UncheckedIOException.class,             () -> Failable.tryWithResources(() -> consumer.accept(ioe), closeable::close));         final IOException cause = uioe.getCause();         assertSame(ioe, cause);          assertTrue(closeable.isClosed());         closeable.reset();         Failable.tryWithResources(() -> consumer.accept(null), closeable::close);         assertTrue(closeable.isClosed());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableLong  */ public class MutableLongTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals(0, new MutableLong().longValue());          assertEquals(1, new MutableLong(1).longValue());          assertEquals(2, new MutableLong(Long.valueOf(2)).longValue());         assertEquals(3, new MutableLong(new MutableLong(3)).longValue());          assertEquals(2, new MutableLong("2").longValue());      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableLong((Number) null));     }      @Test     public void testGetSet() {         final MutableLong mutNum = new MutableLong(0);         assertEquals(0, new MutableLong().longValue());         assertEquals(Long.valueOf(0), new MutableLong().getValue());          mutNum.setValue(1);         assertEquals(1, mutNum.longValue());         assertEquals(Long.valueOf(1), mutNum.getValue());          mutNum.setValue(Long.valueOf(2));         assertEquals(2, mutNum.longValue());         assertEquals(Long.valueOf(2), mutNum.getValue());          mutNum.setValue(new MutableLong(3));         assertEquals(3, mutNum.longValue());         assertEquals(Long.valueOf(3), mutNum.getValue());     }      @Test     public void testSetNull() {         final MutableLong mutNum = new MutableLong(0);         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testEquals() {         final MutableLong mutNumA = new MutableLong(0);         final MutableLong mutNumB = new MutableLong(0);         final MutableLong mutNumC = new MutableLong(1);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, Long.valueOf(0));         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableLong mutNumA = new MutableLong(0);         final MutableLong mutNumB = new MutableLong(0);         final MutableLong mutNumC = new MutableLong(1);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Long.valueOf(0).hashCode());     }      @Test     public void testCompareTo() {         final MutableLong mutNum = new MutableLong(0);          assertEquals(0, mutNum.compareTo(new MutableLong(0)));         assertEquals(+1, mutNum.compareTo(new MutableLong(-1)));         assertEquals(-1, mutNum.compareTo(new MutableLong(1)));     }      @Test     public void testCompareToNull() {         final MutableLong mutNum = new MutableLong(0);         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableLong mutNum = new MutableLong(1L);         assertEquals(1.0F, mutNum.floatValue());         assertEquals(1.0, mutNum.doubleValue());         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals( 1, mutNum.intValue() );         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToLong() {         assertEquals(Long.valueOf(0L), new MutableLong(0L).toLong());         assertEquals(Long.valueOf(123L), new MutableLong(123L).toLong());     }      @Test     public void testIncrement() {         final MutableLong mutNum = new MutableLong(1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableLong mutNum = new MutableLong(1L);         final long result = mutNum.incrementAndGet();          assertEquals(2, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableLong mutNum = new MutableLong(1L);         final long result = mutNum.getAndIncrement();          assertEquals(1, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableLong mutNum = new MutableLong(1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableLong mutNum = new MutableLong(1L);         final long result = mutNum.decrementAndGet();          assertEquals(0, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableLong mutNum = new MutableLong(1L);         final long result = mutNum.getAndDecrement();          assertEquals(1, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableLong mutNum = new MutableLong(1);         mutNum.add(1);          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testAddValueObject() {         final MutableLong mutNum = new MutableLong(1);         mutNum.add(Long.valueOf(1));          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableLong mutableLong = new MutableLong(0L);         final long result = mutableLong.getAndAdd(1L);          assertEquals(0L, result);         assertEquals(1L, mutableLong.longValue());     }      @Test     public void testGetAndAddValueObject() {         final MutableLong mutableLong = new MutableLong(0L);         final long result = mutableLong.getAndAdd(Long.valueOf(1L));          assertEquals(0L, result);         assertEquals(1L, mutableLong.longValue());     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableLong mutableLong = new MutableLong(0L);         final long result = mutableLong.addAndGet(1L);          assertEquals(1L, result);         assertEquals(1L, mutableLong.longValue());     }      @Test     public void testAddAndGetValueObject() {         final MutableLong mutableLong = new MutableLong(0L);         final long result = mutableLong.addAndGet(Long.valueOf(1L));          assertEquals(1L, result);         assertEquals(1L, mutableLong.longValue());     }      @Test     public void testSubtractValuePrimitive() {         final MutableLong mutNum = new MutableLong(1);         mutNum.subtract(1);          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testSubtractValueObject() {         final MutableLong mutNum = new MutableLong(1);         mutNum.subtract(Long.valueOf(1));          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testToString() {         assertEquals("0", new MutableLong(0).toString());         assertEquals("10", new MutableLong(10).toString());         assertEquals("-123", new MutableLong(-123).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame;  import org.junit.jupiter.api.Test;   /**  * JUnit tests.  *  * @see MutableShort  */ public class MutableObjectTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertNull(new MutableObject<String>().getValue());          final Integer i = Integer.valueOf(6);         assertSame(i, new MutableObject<>(i).getValue());         assertSame("HI", new MutableObject<>("HI").getValue());         assertSame(null, new MutableObject<>(null).getValue());     }      @Test     public void testGetSet() {         final MutableObject<String> mutNum = new MutableObject<>();         assertNull(new MutableObject<>().getValue());          mutNum.setValue("HELLO");         assertSame("HELLO", mutNum.getValue());          mutNum.setValue(null);         assertSame(null, mutNum.getValue());     }      @Test     public void testEquals() {         final MutableObject<String> mutNumA = new MutableObject<>("ALPHA");         final MutableObject<String> mutNumB = new MutableObject<>("ALPHA");         final MutableObject<String> mutNumC = new MutableObject<>("BETA");         final MutableObject<String> mutNumD = new MutableObject<>(null);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(mutNumA, mutNumD);         assertEquals(mutNumD, mutNumD);          assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, new Object());         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableObject<String> mutNumA = new MutableObject<>("ALPHA");         final MutableObject<String> mutNumB = new MutableObject<>("ALPHA");         final MutableObject<String> mutNumC = new MutableObject<>("BETA");         final MutableObject<String> mutNumD = new MutableObject<>(null);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumD.hashCode());         assertEquals(mutNumA.hashCode(), "ALPHA".hashCode());         assertEquals(0, mutNumD.hashCode());     }      @Test     public void testToString() {         assertEquals("HI", new MutableObject<>("HI").toString());         assertEquals("10.0", new MutableObject<>(Double.valueOf(10)).toString());         assertEquals("null", new MutableObject<>(null).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableDouble  */ public class MutableDoubleTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);          assertEquals(1d, new MutableDouble(1d).doubleValue(), 0.0001d);          assertEquals(2d, new MutableDouble(Double.valueOf(2d)).doubleValue(), 0.0001d);         assertEquals(3d, new MutableDouble(new MutableDouble(3d)).doubleValue(), 0.0001d);          assertEquals(2d, new MutableDouble("2.0").doubleValue(), 0.0001d);      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableDouble((Number) null));     }      @Test     public void testGetSet() {         final MutableDouble mutNum = new MutableDouble(0d);         assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);         assertEquals(Double.valueOf(0), new MutableDouble().getValue());          mutNum.setValue(1);         assertEquals(1d, mutNum.doubleValue(), 0.0001d);         assertEquals(Double.valueOf(1d), mutNum.getValue());          mutNum.setValue(Double.valueOf(2d));         assertEquals(2d, mutNum.doubleValue(), 0.0001d);         assertEquals(Double.valueOf(2d), mutNum.getValue());          mutNum.setValue(new MutableDouble(3d));         assertEquals(3d, mutNum.doubleValue(), 0.0001d);         assertEquals(Double.valueOf(3d), mutNum.getValue());     }      @Test     public void testSetNull() {         final MutableDouble mutNum = new MutableDouble(0d);         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testNanInfinite() {         MutableDouble mutNum = new MutableDouble(Double.NaN);         assertTrue(mutNum.isNaN());          mutNum = new MutableDouble(Double.POSITIVE_INFINITY);         assertTrue(mutNum.isInfinite());          mutNum = new MutableDouble(Double.NEGATIVE_INFINITY);         assertTrue(mutNum.isInfinite());     }      @Test     public void testEquals() {         final MutableDouble mutNumA = new MutableDouble(0d);         final MutableDouble mutNumB = new MutableDouble(0d);         final MutableDouble mutNumC = new MutableDouble(1d);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, Double.valueOf(0d));         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableDouble mutNumA = new MutableDouble(0d);         final MutableDouble mutNumB = new MutableDouble(0d);         final MutableDouble mutNumC = new MutableDouble(1d);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Double.valueOf(0d).hashCode());     }      @Test     public void testCompareTo() {         final MutableDouble mutNum = new MutableDouble(0d);          assertEquals(0, mutNum.compareTo(new MutableDouble(0d)));         assertEquals(+1, mutNum.compareTo(new MutableDouble(-1d)));         assertEquals(-1, mutNum.compareTo(new MutableDouble(1d)));     }      @Test     public void testCompareToNull() {         final MutableDouble mutNum = new MutableDouble(0d);         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableDouble mutNum = new MutableDouble(1.7);         assertEquals(1.7F, mutNum.floatValue());         assertEquals(1.7, mutNum.doubleValue());         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals( 1, mutNum.intValue() );         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToDouble() {         assertEquals(Double.valueOf(0d), new MutableDouble(0d).toDouble());         assertEquals(Double.valueOf(12.3d), new MutableDouble(12.3d).toDouble());     }      @Test     public void testIncrement() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableDouble mutNum = new MutableDouble(1d);         final double result = mutNum.incrementAndGet();          assertEquals(2d, result, 0.01d);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableDouble mutNum = new MutableDouble(1d);         final double result = mutNum.getAndIncrement();          assertEquals(1d, result, 0.01d);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableDouble mutNum = new MutableDouble(1d);         final double result = mutNum.decrementAndGet();          assertEquals(0d, result, 0.01d);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableDouble mutNum = new MutableDouble(1d);         final double result = mutNum.getAndDecrement();          assertEquals(1d, result, 0.01d);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.add(1.1d);          assertEquals(2.1d, mutNum.doubleValue(), 0.01d);     }      @Test     public void testAddValueObject() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.add(Double.valueOf(1.1d));          assertEquals(2.1d, mutNum.doubleValue(), 0.01d);     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableDouble mutableDouble = new MutableDouble(0.5d);         final double result = mutableDouble.getAndAdd(1d);          assertEquals(0.5d, result, 0.01d);         assertEquals(1.5d, mutableDouble.doubleValue(), 0.01d);     }      @Test     public void testGetAndAddValueObject() {         final MutableDouble mutableDouble = new MutableDouble(0.5d);         final double result = mutableDouble.getAndAdd(Double.valueOf(2d));          assertEquals(0.5d, result, 0.01d);         assertEquals(2.5d, mutableDouble.doubleValue(), 0.01d);     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableDouble mutableDouble = new MutableDouble(10.5d);         final double result = mutableDouble.addAndGet(-0.5d);          assertEquals(10d, result, 0.01d);         assertEquals(10d, mutableDouble.doubleValue(), 0.01d);     }      @Test     public void testAddAndGetValueObject() {         final MutableDouble mutableDouble = new MutableDouble(7.5d);         final double result = mutableDouble.addAndGet(Double.valueOf(-2.5d));          assertEquals(5d, result, 0.01d);         assertEquals(5d, mutableDouble.doubleValue(), 0.01d);     }      @Test     public void testSubtractValuePrimitive() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.subtract(0.9d);          assertEquals(0.1d, mutNum.doubleValue(), 0.01d);     }      @Test     public void testSubtractValueObject() {         final MutableDouble mutNum = new MutableDouble(1);         mutNum.subtract(Double.valueOf(0.9d));          assertEquals(0.1d, mutNum.doubleValue(), 0.01d);     }      @Test     public void testToString() {         assertEquals("0.0", new MutableDouble(0d).toString());         assertEquals("10.0", new MutableDouble(10d).toString());         assertEquals("-123.0", new MutableDouble(-123d).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @since 2.2  * @see MutableBoolean  */ public class MutableBooleanTest {      @Test     public void testCompareTo() {         final MutableBoolean mutBool = new MutableBoolean(false);          assertEquals(0, mutBool.compareTo(new MutableBoolean(false)));         assertEquals(-1, mutBool.compareTo(new MutableBoolean(true)));         mutBool.setValue(true);         assertEquals(+1, mutBool.compareTo(new MutableBoolean(false)));         assertEquals(0, mutBool.compareTo(new MutableBoolean(true)));     }      @Test     public void testCompareToNull() {         final MutableBoolean mutBool = new MutableBoolean(false);         assertThrows(NullPointerException.class, () -> mutBool.compareTo(null));     }      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertFalse(new MutableBoolean().booleanValue());          assertTrue(new MutableBoolean(true).booleanValue());         assertFalse(new MutableBoolean(false).booleanValue());          assertTrue(new MutableBoolean(Boolean.TRUE).booleanValue());         assertFalse(new MutableBoolean(Boolean.FALSE).booleanValue());      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableBoolean(null));     }      @Test     public void testEquals() {         final MutableBoolean mutBoolA = new MutableBoolean(false);         final MutableBoolean mutBoolB = new MutableBoolean(false);         final MutableBoolean mutBoolC = new MutableBoolean(true);          assertEquals(mutBoolA, mutBoolA);         assertEquals(mutBoolA, mutBoolB);         assertEquals(mutBoolB, mutBoolA);         assertEquals(mutBoolB, mutBoolB);         assertNotEquals(mutBoolA, mutBoolC);         assertNotEquals(mutBoolB, mutBoolC);         assertEquals(mutBoolC, mutBoolC);         assertNotEquals(null, mutBoolA);         assertNotEquals(mutBoolA, Boolean.FALSE);         assertNotEquals("false", mutBoolA);     }      @Test     public void testGetSet() {         assertFalse(new MutableBoolean().booleanValue());         assertEquals(Boolean.FALSE, new MutableBoolean().getValue());          final MutableBoolean mutBool = new MutableBoolean(false);         assertEquals(Boolean.FALSE, mutBool.toBoolean());         assertFalse(mutBool.booleanValue());         assertTrue(mutBool.isFalse());         assertFalse(mutBool.isTrue());          mutBool.setValue(Boolean.TRUE);         assertEquals(Boolean.TRUE, mutBool.toBoolean());         assertTrue(mutBool.booleanValue());         assertFalse(mutBool.isFalse());         assertTrue(mutBool.isTrue());          mutBool.setValue(false);         assertFalse(mutBool.booleanValue());          mutBool.setValue(true);         assertTrue(mutBool.booleanValue());          mutBool.setFalse();         assertFalse(mutBool.booleanValue());          mutBool.setTrue();         assertTrue(mutBool.booleanValue());      }      @Test     public void testSetNull() {         final MutableBoolean mutBool = new MutableBoolean(false);         assertThrows(NullPointerException.class, () -> mutBool.setValue(null));     }      @Test     public void testHashCode() {         final MutableBoolean mutBoolA = new MutableBoolean(false);         final MutableBoolean mutBoolB = new MutableBoolean(false);         final MutableBoolean mutBoolC = new MutableBoolean(true);          assertEquals(mutBoolA.hashCode(), mutBoolA.hashCode());         assertEquals(mutBoolA.hashCode(), mutBoolB.hashCode());         assertNotEquals(mutBoolA.hashCode(), mutBoolC.hashCode());         assertEquals(mutBoolA.hashCode(), Boolean.FALSE.hashCode());         assertEquals(mutBoolC.hashCode(), Boolean.TRUE.hashCode());     }      @Test     public void testToString() {         assertEquals(Boolean.FALSE.toString(), new MutableBoolean(false).toString());         assertEquals(Boolean.TRUE.toString(), new MutableBoolean(true).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableShort  */ public class MutableShortTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals((short) 0, new MutableShort().shortValue());          assertEquals((short) 1, new MutableShort((short) 1).shortValue());          assertEquals((short) 2, new MutableShort(Short.valueOf((short) 2)).shortValue());         assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue());          assertEquals((short) 2, new MutableShort("2").shortValue());          assertThrows(NullPointerException.class, () -> new MutableShort((Number) null));     }      @Test     public void testGetSet() {         final MutableShort mutNum = new MutableShort((short) 0);         assertEquals((short) 0, new MutableShort().shortValue());         assertEquals(Short.valueOf((short) 0), new MutableShort().getValue());          mutNum.setValue((short) 1);         assertEquals((short) 1, mutNum.shortValue());         assertEquals(Short.valueOf((short) 1), mutNum.getValue());          mutNum.setValue(Short.valueOf((short) 2));         assertEquals((short) 2, mutNum.shortValue());         assertEquals(Short.valueOf((short) 2), mutNum.getValue());          mutNum.setValue(new MutableShort((short) 3));         assertEquals((short) 3, mutNum.shortValue());         assertEquals(Short.valueOf((short) 3), mutNum.getValue());         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testEquals() {         final MutableShort mutNumA = new MutableShort((short) 0);         final MutableShort mutNumB = new MutableShort((short) 0);         final MutableShort mutNumC = new MutableShort((short) 1);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, Short.valueOf((short) 0));         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableShort mutNumA = new MutableShort((short) 0);         final MutableShort mutNumB = new MutableShort((short) 0);         final MutableShort mutNumC = new MutableShort((short) 1);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Short.valueOf((short) 0).hashCode());     }      @Test     public void testCompareTo() {         final MutableShort mutNum = new MutableShort((short) 0);          assertEquals((short) 0, mutNum.compareTo(new MutableShort((short) 0)));         assertEquals((short) +1, mutNum.compareTo(new MutableShort((short) -1)));         assertEquals((short) -1, mutNum.compareTo(new MutableShort((short) 1)));         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableShort mutNum = new MutableShort( (short) 1 );         assertEquals(1.0F, mutNum.floatValue());         assertEquals(1.0, mutNum.doubleValue());         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals( 1, mutNum.intValue() );         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToShort() {         assertEquals(Short.valueOf((short) 0), new MutableShort((short) 0).toShort());         assertEquals(Short.valueOf((short) 123), new MutableShort((short) 123).toShort());     }      @Test     public void testIncrement() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableShort mutNum = new MutableShort((short) 1);         final short result = mutNum.incrementAndGet();          assertEquals(2, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableShort mutNum = new MutableShort((short) 1);         final short result = mutNum.getAndIncrement();          assertEquals(1, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableShort mutNum = new MutableShort((short) 1);         final short result = mutNum.decrementAndGet();          assertEquals(0, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableShort mutNum = new MutableShort((short) 1);         final short result = mutNum.getAndDecrement();          assertEquals(1, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.add((short) 1);          assertEquals((short) 2, mutNum.shortValue());     }      @Test     public void testAddValueObject() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.add(Short.valueOf((short) 1));          assertEquals((short) 2, mutNum.shortValue());     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableShort mutableShort = new MutableShort((short) 0);         final short result = mutableShort.getAndAdd((short) 1);          assertEquals((short) 0, result);         assertEquals((short) 1, mutableShort.shortValue());     }      @Test     public void testGetAndAddValueObject() {         final MutableShort mutableShort = new MutableShort((short) 0);         final short result = mutableShort.getAndAdd(Short.valueOf((short) 1));          assertEquals((short) 0, result);         assertEquals((short) 1, mutableShort.shortValue());     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableShort mutableShort = new MutableShort((short) 0);         final short result = mutableShort.addAndGet((short) 1);          assertEquals((short) 1, result);         assertEquals((short) 1, mutableShort.shortValue());     }      @Test     public void testAddAndGetValueObject() {         final MutableShort mutableShort = new MutableShort((short) 0);         final short result = mutableShort.addAndGet(Short.valueOf((short) 1));          assertEquals((short) 1, result);         assertEquals((short) 1, mutableShort.shortValue());     }      @Test     public void testSubtractValuePrimitive() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.subtract((short) 1);          assertEquals((short) 0, mutNum.shortValue());     }      @Test     public void testSubtractValueObject() {         final MutableShort mutNum = new MutableShort((short) 1);         mutNum.subtract(Short.valueOf((short) 1));          assertEquals((short) 0, mutNum.shortValue());     }      @Test     public void testToString() {         assertEquals("0", new MutableShort((short) 0).toString());         assertEquals("10", new MutableShort((short) 10).toString());         assertEquals("-123", new MutableShort((short) -123).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableInt  */ public class MutableIntTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals(0, new MutableInt().intValue());          assertEquals(1, new MutableInt(1).intValue());          assertEquals(2, new MutableInt(Integer.valueOf(2)).intValue());         assertEquals(3, new MutableInt(new MutableLong(3)).intValue());          assertEquals(2, new MutableInt("2").intValue());      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableInt((Number) null));     }      @Test     public void testGetSet() {         final MutableInt mutNum = new MutableInt(0);         assertEquals(0, new MutableInt().intValue());         assertEquals(Integer.valueOf(0), new MutableInt().getValue());          mutNum.setValue(1);         assertEquals(1, mutNum.intValue());         assertEquals(Integer.valueOf(1), mutNum.getValue());          mutNum.setValue(Integer.valueOf(2));         assertEquals(2, mutNum.intValue());         assertEquals(Integer.valueOf(2), mutNum.getValue());          mutNum.setValue(new MutableLong(3));         assertEquals(3, mutNum.intValue());         assertEquals(Integer.valueOf(3), mutNum.getValue());     }      @Test     public void testSetNull() {         final MutableInt mutNum = new MutableInt(0);         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testEquals() {         this.testEquals(new MutableInt(0), new MutableInt(0), new MutableInt(1));         // Should Numbers be supported? GaryG July-21-2005.         //this.testEquals(mutNumA, Integer.valueOf(0), mutNumC);     }      /**      * @param numA must not be a 0 Integer; must not equal numC.      * @param numB must equal numA; must not equal numC.      * @param numC must not equal numA; must not equal numC.      */     void testEquals(final Number numA, final Number numB, final Number numC) {         assertEquals(numA, numA);         assertEquals(numA, numB);         assertEquals(numB, numA);         assertEquals(numB, numB);         assertNotEquals(numA, numC);         assertNotEquals(numB, numC);         assertEquals(numC, numC);         assertNotEquals(null, numA);         assertNotEquals(numA, Integer.valueOf(0));         assertNotEquals("0", numA);     }      @Test     public void testHashCode() {         final MutableInt mutNumA = new MutableInt(0);         final MutableInt mutNumB = new MutableInt(0);         final MutableInt mutNumC = new MutableInt(1);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Integer.valueOf(0).hashCode());     }      @Test     public void testCompareTo() {         final MutableInt mutNum = new MutableInt(0);          assertEquals(0, mutNum.compareTo(new MutableInt(0)));         assertEquals(+1, mutNum.compareTo(new MutableInt(-1)));         assertEquals(-1, mutNum.compareTo(new MutableInt(1)));     }      @Test     public void testCompareToNull() {         final MutableInt mutNum = new MutableInt(0);         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableInt mutNum = new MutableInt(1);         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals(1.0F, mutNum.floatValue());         assertEquals(1.0, mutNum.doubleValue());         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToInteger() {         assertEquals(Integer.valueOf(0), new MutableInt(0).toInteger());         assertEquals(Integer.valueOf(123), new MutableInt(123).toInteger());     }      @Test     public void testIncrement() {         final MutableInt mutNum = new MutableInt(1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableInt mutNum = new MutableInt(1);         final int result = mutNum.incrementAndGet();          assertEquals(2, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableInt mutNum = new MutableInt(1);         final int result = mutNum.getAndIncrement();          assertEquals(1, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableInt mutNum = new MutableInt(1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableInt mutNum = new MutableInt(1);         final int result = mutNum.decrementAndGet();          assertEquals(0, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableInt mutNum = new MutableInt(1);         final int result = mutNum.getAndDecrement();          assertEquals(1, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableInt mutNum = new MutableInt(1);         mutNum.add(1);          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testAddValueObject() {         final MutableInt mutNum = new MutableInt(1);         mutNum.add(Integer.valueOf(1));          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableInt mutableInteger = new MutableInt(0);         final int result = mutableInteger.getAndAdd(1);          assertEquals(0, result);         assertEquals(1, mutableInteger.intValue());     }      @Test     public void testGetAndAddValueObject() {         final MutableInt mutableInteger = new MutableInt(0);         final int result = mutableInteger.getAndAdd(Integer.valueOf(1));          assertEquals(0, result);         assertEquals(1, mutableInteger.intValue());     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableInt mutableInteger = new MutableInt(0);         final int result = mutableInteger.addAndGet(1);          assertEquals(1, result);         assertEquals(1, mutableInteger.intValue());     }      @Test     public void testAddAndGetValueObject() {         final MutableInt mutableInteger = new MutableInt(0);         final int result = mutableInteger.addAndGet(Integer.valueOf(1));          assertEquals(1, result);         assertEquals(1, mutableInteger.intValue());     }      @Test     public void testSubtractValuePrimitive() {         final MutableInt mutNum = new MutableInt(1);         mutNum.subtract(1);          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testSubtractValueObject() {         final MutableInt mutNum = new MutableInt(1);         mutNum.subtract(Integer.valueOf(1));          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testToString() {         assertEquals("0", new MutableInt(0).toString());         assertEquals("10", new MutableInt(10).toString());         assertEquals("-123", new MutableInt(-123).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableByte  */ public class MutableByteTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals((byte) 0, new MutableByte().byteValue());          assertEquals((byte) 1, new MutableByte((byte) 1).byteValue());          assertEquals((byte) 2, new MutableByte(Byte.valueOf((byte) 2)).byteValue());         assertEquals((byte) 3, new MutableByte(new MutableByte((byte) 3)).byteValue());          assertEquals((byte) 2, new MutableByte("2").byteValue());      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableByte((Number) null));     }      @Test     public void testGetSet() {         final MutableByte mutNum = new MutableByte((byte) 0);         assertEquals((byte) 0, new MutableByte().byteValue());         assertEquals(Byte.valueOf((byte) 0), new MutableByte().getValue());          mutNum.setValue((byte) 1);         assertEquals((byte) 1, mutNum.byteValue());         assertEquals(Byte.valueOf((byte) 1), mutNum.getValue());          mutNum.setValue(Byte.valueOf((byte) 2));         assertEquals((byte) 2, mutNum.byteValue());         assertEquals(Byte.valueOf((byte) 2), mutNum.getValue());          mutNum.setValue(new MutableByte((byte) 3));         assertEquals((byte) 3, mutNum.byteValue());         assertEquals(Byte.valueOf((byte) 3), mutNum.getValue());     }      @Test     public void testSetNull() {         final MutableByte mutNum = new MutableByte((byte) 0);         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testEquals() {         final MutableByte mutNumA = new MutableByte((byte) 0);         final MutableByte mutNumB = new MutableByte((byte) 0);         final MutableByte mutNumC = new MutableByte((byte) 1);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, Byte.valueOf((byte) 0));         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableByte mutNumA = new MutableByte((byte) 0);         final MutableByte mutNumB = new MutableByte((byte) 0);         final MutableByte mutNumC = new MutableByte((byte) 1);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Byte.valueOf((byte) 0).hashCode());     }      @Test     public void testCompareTo() {         final MutableByte mutNum = new MutableByte((byte) 0);          assertEquals((byte) 0, mutNum.compareTo(new MutableByte((byte) 0)));         assertEquals((byte) +1, mutNum.compareTo(new MutableByte((byte) -1)));         assertEquals((byte) -1, mutNum.compareTo(new MutableByte((byte) 1)));     }      @Test     public void testCompareToNull() {         final MutableByte mutNum = new MutableByte((byte) 0);         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableByte mutNum = new MutableByte( (byte) 1 );         assertEquals(1.0F, mutNum.floatValue());         assertEquals(1.0, mutNum.doubleValue());         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals( 1, mutNum.intValue() );         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToByte() {         assertEquals(Byte.valueOf((byte) 0), new MutableByte((byte) 0).toByte());         assertEquals(Byte.valueOf((byte) 123), new MutableByte((byte) 123).toByte());     }      @Test     public void testIncrement() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableByte mutNum = new MutableByte((byte) 1);         final byte result = mutNum.incrementAndGet();          assertEquals(2, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableByte mutNum = new MutableByte((byte) 1);         final byte result = mutNum.getAndIncrement();          assertEquals(1, result);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableByte mutNum = new MutableByte((byte) 1);         final byte result = mutNum.decrementAndGet();          assertEquals(0, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableByte mutNum = new MutableByte((byte) 1);         final byte result = mutNum.getAndDecrement();          assertEquals(1, result);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.add((byte) 1);          assertEquals((byte) 2, mutNum.byteValue());     }      @Test     public void testAddValueObject() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.add(Integer.valueOf(1));          assertEquals((byte) 2, mutNum.byteValue());     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableByte mutableByte = new MutableByte((byte) 0);         final byte result = mutableByte.getAndAdd((byte) 1);          assertEquals((byte) 0, result);         assertEquals((byte) 1, mutableByte.byteValue());     }      @Test     public void testGetAndAddValueObject() {         final MutableByte mutableByte = new MutableByte((byte) 0);         final byte result = mutableByte.getAndAdd(Byte.valueOf((byte) 1));          assertEquals((byte) 0, result);         assertEquals((byte) 1, mutableByte.byteValue());     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableByte mutableByte = new MutableByte((byte) 0);         final byte result = mutableByte.addAndGet((byte) 1);          assertEquals((byte) 1, result);         assertEquals((byte) 1, mutableByte.byteValue());     }      @Test     public void testAddAndGetValueObject() {         final MutableByte mutableByte = new MutableByte((byte) 0);         final byte result = mutableByte.addAndGet(Byte.valueOf((byte) 1));          assertEquals((byte) 1, result);         assertEquals((byte) 1, mutableByte.byteValue());     }      @Test     public void testSubtractValuePrimitive() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.subtract((byte) 1);          assertEquals((byte) 0, mutNum.byteValue());     }      @Test     public void testSubtractValueObject() {         final MutableByte mutNum = new MutableByte((byte) 1);         mutNum.subtract(Integer.valueOf(1));          assertEquals((byte) 0, mutNum.byteValue());     }      @Test     public void testToString() {         assertEquals("0", new MutableByte((byte) 0).toString());         assertEquals("10", new MutableByte((byte) 10).toString());         assertEquals("-123", new MutableByte((byte) -123).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.mutable;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * JUnit tests.  *  * @see MutableFloat  */ public class MutableFloatTest {      // ----------------------------------------------------------------     @Test     public void testConstructors() {         assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);          assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f);          assertEquals(2f, new MutableFloat(Float.valueOf(2f)).floatValue(), 0.0001f);         assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f);          assertEquals(2f, new MutableFloat("2.0").floatValue(), 0.0001f);      }      @Test     public void testConstructorNull() {         assertThrows(NullPointerException.class, () -> new MutableFloat((Number) null));     }      @Test     public void testGetSet() {         final MutableFloat mutNum = new MutableFloat(0f);         assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);         assertEquals(Float.valueOf(0), new MutableFloat().getValue());          mutNum.setValue(1);         assertEquals(1f, mutNum.floatValue(), 0.0001f);         assertEquals(Float.valueOf(1f), mutNum.getValue());          mutNum.setValue(Float.valueOf(2f));         assertEquals(2f, mutNum.floatValue(), 0.0001f);         assertEquals(Float.valueOf(2f), mutNum.getValue());          mutNum.setValue(new MutableFloat(3f));         assertEquals(3f, mutNum.floatValue(), 0.0001f);         assertEquals(Float.valueOf(3f), mutNum.getValue());     }      @Test     public void testSetNull() {         final MutableFloat mutNum = new MutableFloat(0f);         assertThrows(NullPointerException.class, () -> mutNum.setValue(null));     }      @Test     public void testNanInfinite() {         MutableFloat mutNum = new MutableFloat(Float.NaN);         assertTrue(mutNum.isNaN());          mutNum = new MutableFloat(Float.POSITIVE_INFINITY);         assertTrue(mutNum.isInfinite());          mutNum = new MutableFloat(Float.NEGATIVE_INFINITY);         assertTrue(mutNum.isInfinite());     }      @Test     public void testEquals() {         final MutableFloat mutNumA = new MutableFloat(0f);         final MutableFloat mutNumB = new MutableFloat(0f);         final MutableFloat mutNumC = new MutableFloat(1f);          assertEquals(mutNumA, mutNumA);         assertEquals(mutNumA, mutNumB);         assertEquals(mutNumB, mutNumA);         assertEquals(mutNumB, mutNumB);         assertNotEquals(mutNumA, mutNumC);         assertNotEquals(mutNumB, mutNumC);         assertEquals(mutNumC, mutNumC);         assertNotEquals(null, mutNumA);         assertNotEquals(mutNumA, Float.valueOf(0f));         assertNotEquals("0", mutNumA);     }      @Test     public void testHashCode() {         final MutableFloat mutNumA = new MutableFloat(0f);         final MutableFloat mutNumB = new MutableFloat(0f);         final MutableFloat mutNumC = new MutableFloat(1f);          assertEquals(mutNumA.hashCode(), mutNumA.hashCode());         assertEquals(mutNumA.hashCode(), mutNumB.hashCode());         assertNotEquals(mutNumA.hashCode(), mutNumC.hashCode());         assertEquals(mutNumA.hashCode(), Float.valueOf(0f).hashCode());     }      @Test     public void testCompareTo() {         final MutableFloat mutNum = new MutableFloat(0f);          assertEquals(0, mutNum.compareTo(new MutableFloat(0f)));         assertEquals(+1, mutNum.compareTo(new MutableFloat(-1f)));         assertEquals(-1, mutNum.compareTo(new MutableFloat(1f)));     }      @Test     public void testCompareToNull() {         final MutableFloat mutNum = new MutableFloat(0f);         assertThrows(NullPointerException.class, () -> mutNum.compareTo(null));     }      @Test     public void testPrimitiveValues() {         final MutableFloat mutNum = new MutableFloat(1.7F);          assertEquals( 1, mutNum.intValue() );         assertEquals( 1.7, mutNum.doubleValue(), 0.00001 );         assertEquals( (byte) 1, mutNum.byteValue() );         assertEquals( (short) 1, mutNum.shortValue() );         assertEquals( 1, mutNum.intValue() );         assertEquals( 1L, mutNum.longValue() );     }      @Test     public void testToFloat() {         assertEquals(Float.valueOf(0f), new MutableFloat(0f).toFloat());         assertEquals(Float.valueOf(12.3f), new MutableFloat(12.3f).toFloat());     }      @Test     public void testIncrement() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.increment();          assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testIncrementAndGet() {         final MutableFloat mutNum = new MutableFloat(1f);         final float result = mutNum.incrementAndGet();          assertEquals(2f, result, 0.01f);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testGetAndIncrement() {         final MutableFloat mutNum = new MutableFloat(1f);         final float result = mutNum.getAndIncrement();          assertEquals(1f, result, 0.01f);         assertEquals(2, mutNum.intValue());         assertEquals(2L, mutNum.longValue());     }      @Test     public void testDecrement() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.decrement();          assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testDecrementAndGet() {         final MutableFloat mutNum = new MutableFloat(1f);         final float result = mutNum.decrementAndGet();          assertEquals(0f, result, 0.01f);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testGetAndDecrement() {         final MutableFloat mutNum = new MutableFloat(1f);         final float result = mutNum.getAndDecrement();          assertEquals(1f, result, 0.01f);         assertEquals(0, mutNum.intValue());         assertEquals(0L, mutNum.longValue());     }      @Test     public void testAddValuePrimitive() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.add(1.1f);          assertEquals(2.1f, mutNum.floatValue(), 0.01f);     }      @Test     public void testAddValueObject() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.add(Float.valueOf(1.1f));          assertEquals(2.1f, mutNum.floatValue(), 0.01f);     }      @Test     public void testGetAndAddValuePrimitive() {         final MutableFloat mutableFloat = new MutableFloat(1.25f);         final float result = mutableFloat.getAndAdd(0.75f);          assertEquals(1.25f, result, 0.01f);         assertEquals(2f, mutableFloat.floatValue(), 0.01f);     }      @Test     public void testGetAndAddValueObject() {         final MutableFloat mutableFloat = new MutableFloat(7.75f);         final float result = mutableFloat.getAndAdd(Float.valueOf(2.25f));          assertEquals(7.75f, result, 0.01f);         assertEquals(10f, mutableFloat.floatValue(), 0.01f);     }      @Test     public void testAddAndGetValuePrimitive() {         final MutableFloat mutableFloat = new MutableFloat(0.5f);         final float result = mutableFloat.addAndGet(1f);          assertEquals(1.5f, result, 0.01f);         assertEquals(1.5f, mutableFloat.floatValue(), 0.01f);     }      @Test     public void testAddAndGetValueObject() {         final MutableFloat mutableFloat = new MutableFloat(5f);         final float result = mutableFloat.addAndGet(Float.valueOf(2.5f));          assertEquals(7.5f, result, 0.01f);         assertEquals(7.5f, mutableFloat.floatValue(), 0.01f);     }      @Test     public void testSubtractValuePrimitive() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.subtract(0.9f);          assertEquals(0.1f, mutNum.floatValue(), 0.01f);     }      @Test     public void testSubtractValueObject() {         final MutableFloat mutNum = new MutableFloat(1);         mutNum.subtract(Float.valueOf(0.9f));          assertEquals(0.1f, mutNum.floatValue(), 0.01f);     }      @Test     public void testToString() {         assertEquals("0.0", new MutableFloat(0f).toString());         assertEquals("10.0", new MutableFloat(10f).toString());         assertEquals("-123.0", new MutableFloat(-123f).toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException;  import org.junit.jupiter.api.Test;  /**  * Unit tests for methods of {@link org.apache.commons.lang3.RegExUtils} which been moved to their own test classes.  */ public class RegExUtilsTest {      @Test     public void testRemoveAll_StringPattern() {         assertNull(RegExUtils.removeAll(null, Pattern.compile("")));         assertEquals("any", RegExUtils.removeAll("any", (Pattern) null));          assertEquals("any", RegExUtils.removeAll("any", Pattern.compile("")));         assertEquals("", RegExUtils.removeAll("any", Pattern.compile(".*")));         assertEquals("", RegExUtils.removeAll("any", Pattern.compile(".+")));         assertEquals("", RegExUtils.removeAll("any", Pattern.compile(".?")));          assertEquals("A\nB", RegExUtils.removeAll("A<__>\n<__>B", Pattern.compile("<.*>")));         assertEquals("AB", RegExUtils.removeAll("A<__>\n<__>B", Pattern.compile("(?s)<.*>")));         assertEquals("ABC123", RegExUtils.removeAll("ABCabc123abc", Pattern.compile("[a-z]")));          assertEquals("AB", RegExUtils.removeAll("A<__>\n<__>B", Pattern.compile("<.*>", Pattern.DOTALL)));         assertEquals("AB", RegExUtils.removeAll("A<__>\\n<__>B", Pattern.compile("<.*>")));         assertEquals("", RegExUtils.removeAll("<A>x\\ny</A>", Pattern.compile("<A>.*</A>")));         assertEquals("", RegExUtils.removeAll("<A>\nxy\n</A>", Pattern.compile("<A>.*</A>", Pattern.DOTALL)));     }      @Test     public void testRemoveAll_StringString() {         assertNull(RegExUtils.removeAll(null, ""));         assertEquals("any", RegExUtils.removeAll("any", (String) null));          assertEquals("any", RegExUtils.removeAll("any", ""));         assertEquals("", RegExUtils.removeAll("any", ".*"));         assertEquals("", RegExUtils.removeAll("any", ".+"));         assertEquals("", RegExUtils.removeAll("any", ".?"));          assertEquals("A\nB", RegExUtils.removeAll("A<__>\n<__>B", "<.*>"));         assertEquals("AB", RegExUtils.removeAll("A<__>\n<__>B", "(?s)<.*>"));         assertEquals("ABC123", RegExUtils.removeAll("ABCabc123abc", "[a-z]"));          assertThrows(                 PatternSyntaxException.class,                 () -> RegExUtils.removeAll("any", "{badRegexSyntax}"),                 "RegExUtils.removeAll expecting PatternSyntaxException");     }      @Test     public void testRemoveFirst_StringPattern() {         assertNull(RegExUtils.removeFirst(null, Pattern.compile("")));         assertEquals("any", RegExUtils.removeFirst("any", (Pattern) null));          assertEquals("any", RegExUtils.removeFirst("any", Pattern.compile("")));         assertEquals("", RegExUtils.removeFirst("any", Pattern.compile(".*")));         assertEquals("", RegExUtils.removeFirst("any", Pattern.compile(".+")));         assertEquals("bc", RegExUtils.removeFirst("abc", Pattern.compile(".?")));          assertEquals("A\n<__>B", RegExUtils.removeFirst("A<__>\n<__>B", Pattern.compile("<.*>")));         assertEquals("AB", RegExUtils.removeFirst("A<__>\n<__>B", Pattern.compile("(?s)<.*>")));         assertEquals("ABCbc123", RegExUtils.removeFirst("ABCabc123", Pattern.compile("[a-z]")));         assertEquals("ABC123abc", RegExUtils.removeFirst("ABCabc123abc", Pattern.compile("[a-z]+")));     }      @Test     public void testRemoveFirst_StringString() {         assertNull(RegExUtils.removeFirst(null, ""));         assertEquals("any", RegExUtils.removeFirst("any", (String) null));          assertEquals("any", RegExUtils.removeFirst("any", ""));         assertEquals("", RegExUtils.removeFirst("any", ".*"));         assertEquals("", RegExUtils.removeFirst("any", ".+"));         assertEquals("bc", RegExUtils.removeFirst("abc", ".?"));          assertEquals("A\n<__>B", RegExUtils.removeFirst("A<__>\n<__>B", "<.*>"));         assertEquals("AB", RegExUtils.removeFirst("A<__>\n<__>B", "(?s)<.*>"));         assertEquals("ABCbc123", RegExUtils.removeFirst("ABCabc123", "[a-z]"));         assertEquals("ABC123abc", RegExUtils.removeFirst("ABCabc123abc", "[a-z]+"));          assertThrows(                 PatternSyntaxException.class,                 () -> RegExUtils.removeFirst("any", "{badRegexSyntax}"),                 "RegExUtils.removeFirst expecting PatternSyntaxException");     }      @Test     public void testRemovePattern_StringString() {         assertNull(RegExUtils.removePattern(null, ""));         assertEquals("any", RegExUtils.removePattern("any", (String) null));          assertEquals("", RegExUtils.removePattern("", ""));         assertEquals("", RegExUtils.removePattern("", ".*"));         assertEquals("", RegExUtils.removePattern("", ".+"));          assertEquals("AB", RegExUtils.removePattern("A<__>\n<__>B", "<.*>"));         assertEquals("AB", RegExUtils.removePattern("A<__>\\n<__>B", "<.*>"));         assertEquals("", RegExUtils.removePattern("<A>x\\ny</A>", "<A>.*</A>"));         assertEquals("", RegExUtils.removePattern("<A>\nxy\n</A>", "<A>.*</A>"));          assertEquals("ABC123", RegExUtils.removePattern("ABCabc123", "[a-z]"));     }      @Test     public void testReplaceAll_StringPatternString() {         assertNull(RegExUtils.replaceAll(null, Pattern.compile(""), ""));          assertEquals("any", RegExUtils.replaceAll("any", (Pattern) null, ""));         assertEquals("any", RegExUtils.replaceAll("any", Pattern.compile(""), null));          assertEquals("zzz", RegExUtils.replaceAll("", Pattern.compile(""), "zzz"));         assertEquals("zzz", RegExUtils.replaceAll("", Pattern.compile(".*"), "zzz"));         assertEquals("", RegExUtils.replaceAll("", Pattern.compile(".+"), "zzz"));         assertEquals("ZZaZZbZZcZZ", RegExUtils.replaceAll("abc", Pattern.compile(""), "ZZ"));          assertEquals("z\nz", RegExUtils.replaceAll("<__>\n<__>", Pattern.compile("<.*>"), "z"));         assertEquals("z", RegExUtils.replaceAll("<__>\n<__>", Pattern.compile("(?s)<.*>"), "z"));          assertEquals("z", RegExUtils.replaceAll("<__>\n<__>", Pattern.compile("<.*>", Pattern.DOTALL), "z"));         assertEquals("z", RegExUtils.replaceAll("<__>\\n<__>", Pattern.compile("<.*>"), "z"));         assertEquals("X", RegExUtils.replaceAll("<A>\nxy\n</A>", Pattern.compile("<A>.*</A>", Pattern.DOTALL), "X"));          assertEquals("ABC___123", RegExUtils.replaceAll("ABCabc123", Pattern.compile("[a-z]"), "_"));         assertEquals("ABC_123", RegExUtils.replaceAll("ABCabc123", Pattern.compile("[^A-Z0-9]+"), "_"));         assertEquals("ABC123", RegExUtils.replaceAll("ABCabc123", Pattern.compile("[^A-Z0-9]+"), ""));         assertEquals("Lorem_ipsum_dolor_sit",                 RegExUtils.replaceAll("Lorem ipsum  dolor   sit", Pattern.compile("( +)([a-z]+)"), "_$2"));     }      @Test     public void testReplaceAll_StringStringString() {         assertNull(RegExUtils.replaceAll(null, "", ""));          assertEquals("any", RegExUtils.replaceAll("any", (String) null, ""));         assertEquals("any", RegExUtils.replaceAll("any", "", null));          assertEquals("zzz", RegExUtils.replaceAll("", "", "zzz"));         assertEquals("zzz", RegExUtils.replaceAll("", ".*", "zzz"));         assertEquals("", RegExUtils.replaceAll("", ".+", "zzz"));         assertEquals("ZZaZZbZZcZZ", RegExUtils.replaceAll("abc", "", "ZZ"));          assertEquals("z\nz", RegExUtils.replaceAll("<__>\n<__>", "<.*>", "z"));         assertEquals("z", RegExUtils.replaceAll("<__>\n<__>", "(?s)<.*>", "z"));          assertEquals("ABC___123", RegExUtils.replaceAll("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123", RegExUtils.replaceAll("ABCabc123", "[^A-Z0-9]+", "_"));         assertEquals("ABC123", RegExUtils.replaceAll("ABCabc123", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum_dolor_sit", RegExUtils.replaceAll("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));          assertThrows(                 PatternSyntaxException.class,                 () -> RegExUtils.replaceAll("any", "{badRegexSyntax}", ""),                 "RegExUtils.replaceAll expecting PatternSyntaxException");     }      @Test     public void testReplaceFirst_StringPatternString() {         assertNull(RegExUtils.replaceFirst(null, Pattern.compile(""), ""));          assertEquals("any", RegExUtils.replaceFirst("any", (Pattern) null, ""));         assertEquals("any", RegExUtils.replaceFirst("any", Pattern.compile(""), null));          assertEquals("zzz", RegExUtils.replaceFirst("", Pattern.compile(""), "zzz"));         assertEquals("zzz", RegExUtils.replaceFirst("", Pattern.compile(".*"), "zzz"));         assertEquals("", RegExUtils.replaceFirst("", Pattern.compile(".+"), "zzz"));         assertEquals("ZZabc", RegExUtils.replaceFirst("abc", Pattern.compile(""), "ZZ"));          assertEquals("z\n<__>", RegExUtils.replaceFirst("<__>\n<__>", Pattern.compile("<.*>"), "z"));         assertEquals("z", RegExUtils.replaceFirst("<__>\n<__>", Pattern.compile("(?s)<.*>"), "z"));          assertEquals("ABC_bc123", RegExUtils.replaceFirst("ABCabc123", Pattern.compile("[a-z]"), "_"));         assertEquals("ABC_123abc", RegExUtils.replaceFirst("ABCabc123abc", Pattern.compile("[^A-Z0-9]+"), "_"));         assertEquals("ABC123abc", RegExUtils.replaceFirst("ABCabc123abc", Pattern.compile("[^A-Z0-9]+"), ""));         assertEquals("Lorem_ipsum  dolor   sit",                 RegExUtils.replaceFirst("Lorem ipsum  dolor   sit", Pattern.compile("( +)([a-z]+)"), "_$2"));     }      @Test     public void testReplaceFirst_StringStringString() {         assertNull(RegExUtils.replaceFirst(null, "", ""));          assertEquals("any", RegExUtils.replaceFirst("any", (String) null, ""));         assertEquals("any", RegExUtils.replaceFirst("any", "", null));          assertEquals("zzz", RegExUtils.replaceFirst("", "", "zzz"));         assertEquals("zzz", RegExUtils.replaceFirst("", ".*", "zzz"));         assertEquals("", RegExUtils.replaceFirst("", ".+", "zzz"));         assertEquals("ZZabc", RegExUtils.replaceFirst("abc", "", "ZZ"));          assertEquals("z\n<__>", RegExUtils.replaceFirst("<__>\n<__>", "<.*>", "z"));         assertEquals("z", RegExUtils.replaceFirst("<__>\n<__>", "(?s)<.*>", "z"));          assertEquals("ABC_bc123", RegExUtils.replaceFirst("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123abc", RegExUtils.replaceFirst("ABCabc123abc", "[^A-Z0-9]+", "_"));         assertEquals("ABC123abc", RegExUtils.replaceFirst("ABCabc123abc", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum  dolor   sit",                 RegExUtils.replaceFirst("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));          assertThrows(                 PatternSyntaxException.class,                 () -> RegExUtils.replaceFirst("any", "{badRegexSyntax}", ""),                 "RegExUtils.replaceFirst expecting PatternSyntaxException");     }      @Test     public void testReplacePattern_StringStringString() {         assertNull(RegExUtils.replacePattern(null, "", ""));         assertEquals("any", RegExUtils.replacePattern("any", (String) null, ""));         assertEquals("any", RegExUtils.replacePattern("any", "", null));          assertEquals("zzz", RegExUtils.replacePattern("", "", "zzz"));         assertEquals("zzz", RegExUtils.replacePattern("", ".*", "zzz"));         assertEquals("", RegExUtils.replacePattern("", ".+", "zzz"));          assertEquals("z", RegExUtils.replacePattern("<__>\n<__>", "<.*>", "z"));         assertEquals("z", RegExUtils.replacePattern("<__>\\n<__>", "<.*>", "z"));         assertEquals("X", RegExUtils.replacePattern("<A>\nxy\n</A>", "<A>.*</A>", "X"));          assertEquals("ABC___123", RegExUtils.replacePattern("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123", RegExUtils.replacePattern("ABCabc123", "[^A-Z0-9]+", "_"));         assertEquals("ABC123", RegExUtils.replacePattern("ABCabc123", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum_dolor_sit",                 RegExUtils.replacePattern("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Modifier; import java.util.Iterator; import java.util.NoSuchElementException;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.CharRange}.  */ public class CharRangeTest  {      //-----------------------------------------------------------------------     @Test     public void testClass() {         // class changed to non-public in 3.0         assertFalse(Modifier.isPublic(CharRange.class.getModifiers()));         assertTrue(Modifier.isFinal(CharRange.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testConstructorAccessors_is() {         final CharRange rangea = CharRange.is('a');         assertEquals('a', rangea.getStart());         assertEquals('a', rangea.getEnd());         assertFalse(rangea.isNegated());         assertEquals("a", rangea.toString());     }      @Test     public void testConstructorAccessors_isNot() {         final CharRange rangea = CharRange.isNot('a');         assertEquals('a', rangea.getStart());         assertEquals('a', rangea.getEnd());         assertTrue(rangea.isNegated());         assertEquals("^a", rangea.toString());     }      @Test     public void testConstructorAccessors_isIn_Same() {         final CharRange rangea = CharRange.isIn('a', 'a');         assertEquals('a', rangea.getStart());         assertEquals('a', rangea.getEnd());         assertFalse(rangea.isNegated());         assertEquals("a", rangea.toString());     }      @Test     public void testConstructorAccessors_isIn_Normal() {         final CharRange rangea = CharRange.isIn('a', 'e');         assertEquals('a', rangea.getStart());         assertEquals('e', rangea.getEnd());         assertFalse(rangea.isNegated());         assertEquals("a-e", rangea.toString());     }      @Test     public void testConstructorAccessors_isIn_Reversed() {         final CharRange rangea = CharRange.isIn('e', 'a');         assertEquals('a', rangea.getStart());         assertEquals('e', rangea.getEnd());         assertFalse(rangea.isNegated());         assertEquals("a-e", rangea.toString());     }      @Test     public void testConstructorAccessors_isNotIn_Same() {         final CharRange rangea = CharRange.isNotIn('a', 'a');         assertEquals('a', rangea.getStart());         assertEquals('a', rangea.getEnd());         assertTrue(rangea.isNegated());         assertEquals("^a", rangea.toString());     }      @Test     public void testConstructorAccessors_isNotIn_Normal() {         final CharRange rangea = CharRange.isNotIn('a', 'e');         assertEquals('a', rangea.getStart());         assertEquals('e', rangea.getEnd());         assertTrue(rangea.isNegated());         assertEquals("^a-e", rangea.toString());     }      @Test     public void testConstructorAccessors_isNotIn_Reversed() {         final CharRange rangea = CharRange.isNotIn('e', 'a');         assertEquals('a', rangea.getStart());         assertEquals('e', rangea.getEnd());         assertTrue(rangea.isNegated());         assertEquals("^a-e", rangea.toString());     }      //-----------------------------------------------------------------------     @Test     public void testEquals_Object() {         final CharRange rangea = CharRange.is('a');         final CharRange rangeae = CharRange.isIn('a', 'e');         final CharRange rangenotbf = CharRange.isIn('b', 'f');          assertNotEquals(null, rangea);          assertEquals(rangea, rangea);         assertEquals(rangea, CharRange.is('a'));         assertEquals(rangeae, rangeae);         assertEquals(rangeae, CharRange.isIn('a', 'e'));         assertEquals(rangenotbf, rangenotbf);         assertEquals(rangenotbf, CharRange.isIn('b', 'f'));          assertNotEquals(rangea, rangeae);         assertNotEquals(rangea, rangenotbf);         assertNotEquals(rangeae, rangea);         assertNotEquals(rangeae, rangenotbf);         assertNotEquals(rangenotbf, rangea);         assertNotEquals(rangenotbf, rangeae);     }      @Test     public void testHashCode() {         final CharRange rangea = CharRange.is('a');         final CharRange rangeae = CharRange.isIn('a', 'e');         final CharRange rangenotbf = CharRange.isIn('b', 'f');          assertEquals(rangea.hashCode(), rangea.hashCode());         assertEquals(rangea.hashCode(), CharRange.is('a').hashCode());         assertEquals(rangeae.hashCode(), rangeae.hashCode());         assertEquals(rangeae.hashCode(), CharRange.isIn('a', 'e').hashCode());         assertEquals(rangenotbf.hashCode(), rangenotbf.hashCode());         assertEquals(rangenotbf.hashCode(), CharRange.isIn('b', 'f').hashCode());          assertNotEquals(rangea.hashCode(), rangeae.hashCode());         assertNotEquals(rangea.hashCode(), rangenotbf.hashCode());         assertNotEquals(rangeae.hashCode(), rangea.hashCode());         assertNotEquals(rangeae.hashCode(), rangenotbf.hashCode());         assertNotEquals(rangenotbf.hashCode(), rangea.hashCode());         assertNotEquals(rangenotbf.hashCode(), rangeae.hashCode());     }      //-----------------------------------------------------------------------     @Test     public void testContains_Char() {         CharRange range = CharRange.is('c');         assertFalse(range.contains('b'));         assertTrue(range.contains('c'));         assertFalse(range.contains('d'));         assertFalse(range.contains('e'));          range = CharRange.isIn('c', 'd');         assertFalse(range.contains('b'));         assertTrue(range.contains('c'));         assertTrue(range.contains('d'));         assertFalse(range.contains('e'));          range = CharRange.isIn('d', 'c');         assertFalse(range.contains('b'));         assertTrue(range.contains('c'));         assertTrue(range.contains('d'));         assertFalse(range.contains('e'));          range = CharRange.isNotIn('c', 'd');         assertTrue(range.contains('b'));         assertFalse(range.contains('c'));         assertFalse(range.contains('d'));         assertTrue(range.contains('e'));         assertTrue(range.contains((char) 0));         assertTrue(range.contains(Character.MAX_VALUE));     }      //-----------------------------------------------------------------------     @Test     public void testContains_Charrange() {         final CharRange a = CharRange.is('a');         final CharRange b = CharRange.is('b');         final CharRange c = CharRange.is('c');         final CharRange c2 = CharRange.is('c');         final CharRange d = CharRange.is('d');         final CharRange e = CharRange.is('e');         final CharRange cd = CharRange.isIn('c', 'd');         final CharRange bd = CharRange.isIn('b', 'd');         final CharRange bc = CharRange.isIn('b', 'c');         final CharRange ab = CharRange.isIn('a', 'b');         final CharRange de = CharRange.isIn('d', 'e');         final CharRange ef = CharRange.isIn('e', 'f');         final CharRange ae = CharRange.isIn('a', 'e');          // normal/normal         assertFalse(c.contains(b));         assertTrue(c.contains(c));         assertTrue(c.contains(c2));         assertFalse(c.contains(d));          assertFalse(c.contains(cd));         assertFalse(c.contains(bd));         assertFalse(c.contains(bc));         assertFalse(c.contains(ab));         assertFalse(c.contains(de));          assertTrue(cd.contains(c));         assertTrue(bd.contains(c));         assertTrue(bc.contains(c));         assertFalse(ab.contains(c));         assertFalse(de.contains(c));          assertTrue(ae.contains(b));         assertTrue(ae.contains(ab));         assertTrue(ae.contains(bc));         assertTrue(ae.contains(cd));         assertTrue(ae.contains(de));          final CharRange notb = CharRange.isNot('b');         final CharRange notc = CharRange.isNot('c');         final CharRange notd = CharRange.isNot('d');         final CharRange notab = CharRange.isNotIn('a', 'b');         final CharRange notbc = CharRange.isNotIn('b', 'c');         final CharRange notbd = CharRange.isNotIn('b', 'd');         final CharRange notcd = CharRange.isNotIn('c', 'd');         final CharRange notde = CharRange.isNotIn('d', 'e');         final CharRange notae = CharRange.isNotIn('a', 'e');         final CharRange all = CharRange.isIn((char) 0, Character.MAX_VALUE);         final CharRange allbutfirst = CharRange.isIn((char) 1, Character.MAX_VALUE);          // normal/negated         assertFalse(c.contains(notc));         assertFalse(c.contains(notbd));         assertTrue(all.contains(notc));         assertTrue(all.contains(notbd));         assertFalse(allbutfirst.contains(notc));         assertFalse(allbutfirst.contains(notbd));          // negated/normal         assertTrue(notc.contains(a));         assertTrue(notc.contains(b));         assertFalse(notc.contains(c));         assertTrue(notc.contains(d));         assertTrue(notc.contains(e));          assertTrue(notc.contains(ab));         assertFalse(notc.contains(bc));         assertFalse(notc.contains(bd));         assertFalse(notc.contains(cd));         assertTrue(notc.contains(de));         assertFalse(notc.contains(ae));         assertFalse(notc.contains(all));         assertFalse(notc.contains(allbutfirst));          assertTrue(notbd.contains(a));         assertFalse(notbd.contains(b));         assertFalse(notbd.contains(c));         assertFalse(notbd.contains(d));         assertTrue(notbd.contains(e));          assertTrue(notcd.contains(ab));         assertFalse(notcd.contains(bc));         assertFalse(notcd.contains(bd));         assertFalse(notcd.contains(cd));         assertFalse(notcd.contains(de));         assertFalse(notcd.contains(ae));         assertTrue(notcd.contains(ef));         assertFalse(notcd.contains(all));         assertFalse(notcd.contains(allbutfirst));          // negated/negated         assertFalse(notc.contains(notb));         assertTrue(notc.contains(notc));         assertFalse(notc.contains(notd));          assertFalse(notc.contains(notab));         assertTrue(notc.contains(notbc));         assertTrue(notc.contains(notbd));         assertTrue(notc.contains(notcd));         assertFalse(notc.contains(notde));          assertFalse(notbd.contains(notb));         assertFalse(notbd.contains(notc));         assertFalse(notbd.contains(notd));          assertFalse(notbd.contains(notab));         assertFalse(notbd.contains(notbc));         assertTrue(notbd.contains(notbd));         assertFalse(notbd.contains(notcd));         assertFalse(notbd.contains(notde));         assertTrue(notbd.contains(notae));     }      @Test     public void testContainsNullArg() {         final CharRange range = CharRange.is('a');         final NullPointerException e = assertThrows(NullPointerException.class, () -> range.contains(null));         assertEquals("The Range must not be null", e.getMessage());     }      @Test     public void testIterator() {         final CharRange a = CharRange.is('a');         final CharRange ad = CharRange.isIn('a', 'd');         final CharRange nota = CharRange.isNot('a');         final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE);         final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE);         final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1));          final Iterator<Character> aIt = a.iterator();         assertNotNull(aIt);         assertTrue(aIt.hasNext());         assertEquals(Character.valueOf('a'), aIt.next());         assertFalse(aIt.hasNext());          final Iterator<Character> adIt = ad.iterator();         assertNotNull(adIt);         assertTrue(adIt.hasNext());         assertEquals(Character.valueOf('a'), adIt.next());         assertEquals(Character.valueOf('b'), adIt.next());         assertEquals(Character.valueOf('c'), adIt.next());         assertEquals(Character.valueOf('d'), adIt.next());         assertFalse(adIt.hasNext());          final Iterator<Character> notaIt = nota.iterator();         assertNotNull(notaIt);         assertTrue(notaIt.hasNext());         while (notaIt.hasNext()) {             final Character c = notaIt.next();             assertNotEquals('a', c.charValue());         }          final Iterator<Character> emptySetIt = emptySet.iterator();         assertNotNull(emptySetIt);         assertFalse(emptySetIt.hasNext());         assertThrows(NoSuchElementException.class, emptySetIt::next);          final Iterator<Character> notFirstIt = notFirst.iterator();         assertNotNull(notFirstIt);         assertTrue(notFirstIt.hasNext());         assertEquals(Character.valueOf((char) 0), notFirstIt.next());         assertFalse(notFirstIt.hasNext());         assertThrows(NoSuchElementException.class, notFirstIt::next);          final Iterator<Character> notLastIt = notLast.iterator();         assertNotNull(notLastIt);         assertTrue(notLastIt.hasNext());         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next());         assertFalse(notLastIt.hasNext());         assertThrows(NoSuchElementException.class, notLastIt::next);     }      //-----------------------------------------------------------------------     @Test     public void testSerialization() {         CharRange range = CharRange.is('a');         assertEquals(range, SerializationUtils.clone(range));         range = CharRange.isIn('a', 'e');         assertEquals(range, SerializationUtils.clone(range));         range = CharRange.isNotIn('a', 'e');         assertEquals(range, SerializationUtils.clone(range));     }      //-----------------------------------------------------------------------     @Test     public void testIteratorRemove() {         final CharRange a = CharRange.is('a');         final Iterator<Character> aIt = a.iterator();         assertThrows(UnsupportedOperationException.class, aIt::remove);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Calendar; import java.util.TimeZone; import java.util.stream.Stream;  import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  public class FastDatePrinterTimeZonesTest {      private static final String PATTERN = "h:mma z";      public static Stream<TimeZone> data() {         return Arrays.stream(TimeZone.getAvailableIDs()).map(TimeZone::getTimeZone);     }      @ParameterizedTest     @MethodSource("data")     public void testCalendarTimezoneRespected(final TimeZone timeZone) {         final Calendar cal = Calendar.getInstance(timeZone);          final SimpleDateFormat sdf = new SimpleDateFormat(PATTERN);         sdf.setTimeZone(timeZone);         final String expectedValue = sdf.format(cal.getTime());         final String actualValue = FastDateFormat.getInstance(PATTERN, timeZone).format(cal);         assertEquals(expectedValue, actualValue);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Calendar; import java.util.TimeZone;  import org.junit.jupiter.api.Test;  /**  * TestCase for DurationFormatUtils.  */ public class DurationFormatUtilsTest {      // -----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new DurationFormatUtils());         final Constructor<?>[] cons = DurationFormatUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(DurationFormatUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(DurationFormatUtils.class.getModifiers()));     }      // -----------------------------------------------------------------------     @Test     public void testFormatDurationWords() {         String text = null;          text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false);         assertEquals("50 seconds", text);         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false);         assertEquals("1 minute 5 seconds", text);         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false);         assertEquals("2 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false);         assertEquals("2 minutes 1 second", text);         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false);         assertEquals("1 hour 12 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false);         assertEquals("1 day 0 hours 0 minutes 0 seconds", text);          text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true);         assertEquals("50 seconds", text);         text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true);         assertEquals("1 minute 5 seconds", text);         text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true);         assertEquals("2 minutes", text);         text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true);         assertEquals("2 minutes 1 second", text);         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true);         assertEquals("1 hour 12 minutes", text);         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true);         assertEquals("1 day", text);          text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true);         assertEquals("0 days 0 hours 0 minutes 50 seconds", text);         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true);         assertEquals("0 days 0 hours 1 minute 5 seconds", text);         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true);         assertEquals("0 days 0 hours 2 minutes", text);         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true);         assertEquals("0 days 0 hours 2 minutes 1 second", text);         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true);         assertEquals("0 days 1 hour 12 minutes", text);         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true);         assertEquals("1 day", text);          text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false);         assertEquals("0 days 0 hours 0 minutes 50 seconds", text);         text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false);         assertEquals("0 days 0 hours 1 minute 5 seconds", text);         text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false);         assertEquals("0 days 0 hours 2 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false);         assertEquals("0 days 0 hours 2 minutes 1 second", text);         text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false);         assertEquals("0 days 1 hour 12 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);         assertEquals("1 day 1 hour 12 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);         assertEquals("2 days 1 hour 12 minutes 0 seconds", text);         for (int i = 2; i < 31; i++) {             text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false);             assertEquals(i + " days 0 hours 0 minutes 0 seconds", text);         }     }      /**      * Tests that "1 &lt;unit&gt;s" gets converted to "1 &lt;unit&gt;" but that "11 &lt;unit&gt;s" is left alone.      */     @Test     public void testFormatDurationPluralWords() {         final long oneSecond = 1000;         final long oneMinute = oneSecond * 60;         final long oneHour = oneMinute * 60;         final long oneDay = oneHour * 24;         String text = null;          text = DurationFormatUtils.formatDurationWords(oneSecond, false, false);         assertEquals("0 days 0 hours 0 minutes 1 second", text);         text = DurationFormatUtils.formatDurationWords(oneSecond * 2, false, false);         assertEquals("0 days 0 hours 0 minutes 2 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneSecond * 11, false, false);         assertEquals("0 days 0 hours 0 minutes 11 seconds", text);          text = DurationFormatUtils.formatDurationWords(oneMinute, false, false);         assertEquals("0 days 0 hours 1 minute 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneMinute * 2, false, false);         assertEquals("0 days 0 hours 2 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneMinute * 11, false, false);         assertEquals("0 days 0 hours 11 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneMinute + oneSecond, false, false);         assertEquals("0 days 0 hours 1 minute 1 second", text);          text = DurationFormatUtils.formatDurationWords(oneHour, false, false);         assertEquals("0 days 1 hour 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneHour * 2, false, false);         assertEquals("0 days 2 hours 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneHour * 11, false, false);         assertEquals("0 days 11 hours 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneHour + oneMinute + oneSecond, false, false);         assertEquals("0 days 1 hour 1 minute 1 second", text);          text = DurationFormatUtils.formatDurationWords(oneDay, false, false);         assertEquals("1 day 0 hours 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneDay * 2, false, false);         assertEquals("2 days 0 hours 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneDay * 11, false, false);         assertEquals("11 days 0 hours 0 minutes 0 seconds", text);         text = DurationFormatUtils.formatDurationWords(oneDay + oneHour + oneMinute + oneSecond, false, false);         assertEquals("1 day 1 hour 1 minute 1 second", text);     }      @Test     public void testFormatNegativeDurationWords() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDurationWords(-5000, true, true));     }      @Test     public void testFormatDurationHMS() {         long time = 0;         assertEquals("00:00:00.000", DurationFormatUtils.formatDurationHMS(time));          time = 1;         assertEquals("00:00:00.001", DurationFormatUtils.formatDurationHMS(time));          time = 15;         assertEquals("00:00:00.015", DurationFormatUtils.formatDurationHMS(time));          time = 165;         assertEquals("00:00:00.165", DurationFormatUtils.formatDurationHMS(time));          time = 1675;         assertEquals("00:00:01.675", DurationFormatUtils.formatDurationHMS(time));          time = 13465;         assertEquals("00:00:13.465", DurationFormatUtils.formatDurationHMS(time));          time = 72789;         assertEquals("00:01:12.789", DurationFormatUtils.formatDurationHMS(time));          time = 12789 + 32 * 60000;         assertEquals("00:32:12.789", DurationFormatUtils.formatDurationHMS(time));          time = 12789 + 62 * 60000;         assertEquals("01:02:12.789", DurationFormatUtils.formatDurationHMS(time));     }      @Test     public void testFormatNegativeDurationHMS() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDurationHMS(-5000));     }      @Test     public void testFormatDurationISO() {         assertEquals("P0Y0M0DT0H0M0.000S", DurationFormatUtils.formatDurationISO(0L));         assertEquals("P0Y0M0DT0H0M0.001S", DurationFormatUtils.formatDurationISO(1L));         assertEquals("P0Y0M0DT0H0M0.010S", DurationFormatUtils.formatDurationISO(10L));         assertEquals("P0Y0M0DT0H0M0.100S", DurationFormatUtils.formatDurationISO(100L));         assertEquals("P0Y0M0DT0H1M15.321S", DurationFormatUtils.formatDurationISO(75321L));     }      @Test     public void testFormatNegativeDurationISO() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDurationISO(-5000));     }      @Test     public void testFormatDuration() {         long duration = 0;         assertEquals("0", DurationFormatUtils.formatDuration(duration, "y"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "M"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "d"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "H"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "m"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "s"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "S"));         assertEquals("0000", DurationFormatUtils.formatDuration(duration, "SSSS"));         assertEquals("0000", DurationFormatUtils.formatDuration(duration, "yyyy"));         assertEquals("0000", DurationFormatUtils.formatDuration(duration, "yyMM"));          duration = 60 * 1000;         assertEquals("0", DurationFormatUtils.formatDuration(duration, "y"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "M"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "d"));         assertEquals("0", DurationFormatUtils.formatDuration(duration, "H"));         assertEquals("1", DurationFormatUtils.formatDuration(duration, "m"));         assertEquals("60", DurationFormatUtils.formatDuration(duration, "s"));         assertEquals("60000", DurationFormatUtils.formatDuration(duration, "S"));         assertEquals("01:00", DurationFormatUtils.formatDuration(duration, "mm:ss"));          final Calendar base = Calendar.getInstance();         base.set(2000, Calendar.JANUARY, 1, 0, 0, 0);         base.set(Calendar.MILLISECOND, 0);          final Calendar cal = Calendar.getInstance();         cal.set(2003, Calendar.FEBRUARY, 1, 0, 0, 0);         cal.set(Calendar.MILLISECOND, 0);         duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal         // don't use 1970 in test as time zones were less reliable in 1970 than now         // remember that duration formatting ignores time zones, working on strict hour lengths         final int days = 366 + 365 + 365 + 31;         assertEquals("0 0 " + days, DurationFormatUtils.formatDuration(duration, "y M d"));     }      @Test     public void testFormatNegativeDuration() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(-5000, "S", true));     }      @SuppressWarnings("deprecation")     @Test     public void testFormatPeriodISO() {         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3");         final Calendar base = Calendar.getInstance(timeZone);         base.set(1970, Calendar.JANUARY, 1, 0, 0, 0);         base.set(Calendar.MILLISECOND, 0);          final Calendar cal = Calendar.getInstance(timeZone);         cal.set(2002, Calendar.FEBRUARY, 23, 9, 11, 12);         cal.set(Calendar.MILLISECOND, 1);         String text;         // repeat a test from testDateTimeISO to compare extended and not extended.         text = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone);         assertEquals("2002-02-23T09:11:12-03:00", text);         // test fixture is the same as above, but now with extended format.         text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),                 DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);         assertEquals("P32Y1M22DT9H11M12.001S", text);         // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration         cal.set(1971, Calendar.FEBRUARY, 3, 10, 30, 0);         cal.set(Calendar.MILLISECOND, 0);         text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),                 DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);         assertEquals("P1Y1M2DT10H30M0.000S", text);         // want a way to say 'don't print the seconds in format()' or other fields for that matter:         // assertEquals("P1Y2M3DT10H30M", text);     }      @Test     public void testFormatPeriodISOStartGreaterEnd() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatPeriodISO(5000, 2000));     }      @Test     public void testFormatPeriodISOMethod() {         assertEquals("P0Y0M0DT0H0M0.000S", DurationFormatUtils.formatPeriodISO(0L, 0L));         assertEquals("P0Y0M0DT0H0M1.000S", DurationFormatUtils.formatPeriodISO(0L, 1000L));         assertEquals("P0Y0M0DT0H1M1.000S", DurationFormatUtils.formatPeriodISO(0L, 61000L));     }      @Test     public void testFormatPeriod() {         final Calendar cal1970 = Calendar.getInstance();         cal1970.set(1970, Calendar.JANUARY, 1, 0, 0, 0);         cal1970.set(Calendar.MILLISECOND, 0);         final long time1970 = cal1970.getTime().getTime();          assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "y"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "M"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "d"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "H"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "m"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "s"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time1970, "S"));         assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "SSSS"));         assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyyy"));         assertEquals("0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyMM"));          long time = time1970 + 60 * 1000;         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "y"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "M"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "d"));         assertEquals("0", DurationFormatUtils.formatPeriod(time1970, time, "H"));         assertEquals("1", DurationFormatUtils.formatPeriod(time1970, time, "m"));         assertEquals("60", DurationFormatUtils.formatPeriod(time1970, time, "s"));         assertEquals("60000", DurationFormatUtils.formatPeriod(time1970, time, "S"));         assertEquals("01:00", DurationFormatUtils.formatPeriod(time1970, time, "mm:ss"));          final Calendar cal = Calendar.getInstance();         cal.set(1973, Calendar.JULY, 1, 0, 0, 0);         cal.set(Calendar.MILLISECOND, 0);         time = cal.getTime().getTime();         assertEquals("36", DurationFormatUtils.formatPeriod(time1970, time, "yM"));         assertEquals("3 years 6 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'"));         assertEquals("03/06", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM"));          cal.set(1973, Calendar.NOVEMBER, 1, 0, 0, 0);         cal.set(Calendar.MILLISECOND, 0);         time = cal.getTime().getTime();         assertEquals("310", DurationFormatUtils.formatPeriod(time1970, time, "yM"));         assertEquals("3 years 10 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'"));         assertEquals("03/10", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM"));          cal.set(1974, Calendar.JANUARY, 1, 0, 0, 0);         cal.set(Calendar.MILLISECOND, 0);         time = cal.getTime().getTime();         assertEquals("40", DurationFormatUtils.formatPeriod(time1970, time, "yM"));         assertEquals("4 years 0 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'"));         assertEquals("04/00", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM"));         assertEquals("48", DurationFormatUtils.formatPeriod(time1970, time, "M"));         assertEquals("48", DurationFormatUtils.formatPeriod(time1970, time, "MM"));         assertEquals("048", DurationFormatUtils.formatPeriod(time1970, time, "MMM"));     }      @Test     public void testFormatPeriodeStartGreaterEnd() {         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatPeriod(5000, 2500, "yy/MM"));     }      @Test     public void testLexx() {         // tests each constant         assertArrayEquals(new DurationFormatUtils.Token[]{             new DurationFormatUtils.Token(DurationFormatUtils.y, 1),             new DurationFormatUtils.Token(DurationFormatUtils.M, 1),             new DurationFormatUtils.Token(DurationFormatUtils.d, 1),             new DurationFormatUtils.Token(DurationFormatUtils.H, 1),             new DurationFormatUtils.Token(DurationFormatUtils.m, 1),             new DurationFormatUtils.Token(DurationFormatUtils.s, 1),             new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx("yMdHmsS"));          // tests the ISO 8601-like         assertArrayEquals(new DurationFormatUtils.Token[]{             new DurationFormatUtils.Token(DurationFormatUtils.H, 2),             new DurationFormatUtils.Token(new StringBuilder(":"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.m, 2),             new DurationFormatUtils.Token(new StringBuilder(":"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.s, 2),             new DurationFormatUtils.Token(new StringBuilder("."), 1),             new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx("HH:mm:ss.SSS"));          // test the iso extended format         assertArrayEquals(new DurationFormatUtils.Token[]{             new DurationFormatUtils.Token(new StringBuilder("P"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.y, 4),             new DurationFormatUtils.Token(new StringBuilder("Y"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.M, 1),             new DurationFormatUtils.Token(new StringBuilder("M"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.d, 1),             new DurationFormatUtils.Token(new StringBuilder("DT"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.H, 1),             new DurationFormatUtils.Token(new StringBuilder("H"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.m, 1),             new DurationFormatUtils.Token(new StringBuilder("M"), 1),             new DurationFormatUtils.Token(DurationFormatUtils.s, 1),             new DurationFormatUtils.Token(new StringBuilder("."), 1),             new DurationFormatUtils.Token(DurationFormatUtils.S, 3),             new DurationFormatUtils.Token(new StringBuilder("S"), 1)}, DurationFormatUtils                 .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));          // test failures in equals         final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);         assertNotEquals(token, new Object(), "Token equal to non-Token class. ");         assertNotEquals(token, new DurationFormatUtils.Token(new Object()), "Token equal to Token with wrong value class. ");         assertNotEquals(token, new DurationFormatUtils.Token(DurationFormatUtils.y, 1), "Token equal to Token with different count. ");         final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4);         assertEquals(numToken, numToken, "Token with Number value not equal to itself. ");     }       // https://issues.apache.org/bugzilla/show_bug.cgi?id=38401     @Test     public void testBugzilla38401() {         assertEqualDuration( "0000/00/30 16:00:00 000", new int[] { 2006, 0, 26, 18, 47, 34 },                              new int[] { 2006, 1, 26, 10, 47, 34 }, "yyyy/MM/dd HH:mm:ss SSS");     }      // https://issues.apache.org/jira/browse/LANG-281     @Test     public void testJiraLang281() {         assertEqualDuration( "09", new int[] { 2005, 11, 31, 0, 0, 0 },                              new int[] { 2006, 9, 6, 0, 0, 0 }, "MM");     }      @Test     public void testLANG815() {         final Calendar calendar = Calendar.getInstance();         calendar.set(2012, Calendar.JULY, 30, 0, 0, 0);         final long startMillis = calendar.getTimeInMillis();          calendar.set(2012, Calendar.SEPTEMBER, 8);         final long endMillis = calendar.getTimeInMillis();          assertEquals("1 9", DurationFormatUtils.formatPeriod(startMillis, endMillis, "M d"));     }      // Testing the under a day range in DurationFormatUtils.formatPeriod     @Test     public void testLowDurations() {         for (int hr=0; hr < 24; hr++) {             for (int min=0; min < 60; min++) {                 for (int sec=0; sec < 60; sec++) {                     assertEqualDuration( hr + ":" + min + ":" + sec,                                          new int[] { 2000, 0, 1, 0, 0, 0, 0 },                                          new int[] { 2000, 0, 1, hr, min, sec },                                          "H:m:s"                                        );                 }             }         }     }      // Attempting to test edge cases in DurationFormatUtils.formatPeriod     @Test     public void testEdgeDurations() {         // This test case must use a time zone without DST         TimeZone.setDefault(FastTimeZone.getGmtTimeZone());         assertEqualDuration( "01", new int[] { 2006, 0, 15, 0, 0, 0 },                              new int[] { 2006, 2, 10, 0, 0, 0 }, "MM");         assertEqualDuration( "12", new int[] { 2005, 0, 15, 0, 0, 0 },                              new int[] { 2006, 0, 15, 0, 0, 0 }, "MM");         assertEqualDuration( "12", new int[] { 2005, 0, 15, 0, 0, 0 },                              new int[] { 2006, 0, 16, 0, 0, 0 }, "MM");         assertEqualDuration( "11", new int[] { 2005, 0, 15, 0, 0, 0 },                              new int[] { 2006, 0, 14, 0, 0, 0 }, "MM");          assertEqualDuration( "01 26", new int[] { 2006, 0, 15, 0, 0, 0 },                              new int[] { 2006, 2, 10, 0, 0, 0 }, "MM dd");         assertEqualDuration( "54", new int[] { 2006, 0, 15, 0, 0, 0 },                              new int[] { 2006, 2, 10, 0, 0, 0 }, "dd");          assertEqualDuration( "09 12", new int[] { 2006, 1, 20, 0, 0, 0 },                              new int[] { 2006, 11, 4, 0, 0, 0 }, "MM dd");         assertEqualDuration( "287", new int[] { 2006, 1, 20, 0, 0, 0 },                              new int[] { 2006, 11, 4, 0, 0, 0 }, "dd");          assertEqualDuration( "11 30", new int[] { 2006, 0, 2, 0, 0, 0 },                              new int[] { 2007, 0, 1, 0, 0, 0 }, "MM dd");         assertEqualDuration( "364", new int[] { 2006, 0, 2, 0, 0, 0 },                              new int[] { 2007, 0, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "12 00", new int[] { 2006, 0, 1, 0, 0, 0 },                              new int[] { 2007, 0, 1, 0, 0, 0 }, "MM dd");         assertEqualDuration( "365", new int[] { 2006, 0, 1, 0, 0, 0 },                              new int[] { 2007, 0, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "31", new int[] { 2006, 0, 1, 0, 0, 0 },                 new int[] { 2006, 1, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "92", new int[] { 2005, 9, 1, 0, 0, 0 },                 new int[] { 2006, 0, 1, 0, 0, 0 }, "dd");         assertEqualDuration( "77", new int[] { 2005, 9, 16, 0, 0, 0 },                 new int[] { 2006, 0, 1, 0, 0, 0 }, "dd");          // test month larger in start than end         assertEqualDuration( "136", new int[] { 2005, 9, 16, 0, 0, 0 },                 new int[] { 2006, 2, 1, 0, 0, 0 }, "dd");         // test when start in leap year         assertEqualDuration( "136", new int[] { 2004, 9, 16, 0, 0, 0 },                 new int[] { 2005, 2, 1, 0, 0, 0 }, "dd");         // test when end in leap year         assertEqualDuration( "137", new int[] { 2003, 9, 16, 0, 0, 0 },                 new int[] { 2004, 2, 1, 0, 0, 0 }, "dd");         // test when end in leap year but less than end of feb         assertEqualDuration( "135", new int[] { 2003, 9, 16, 0, 0, 0 },                 new int[] { 2004, 1, 28, 0, 0, 0 }, "dd");          assertEqualDuration( "364", new int[] { 2007, 0, 2, 0, 0, 0 },                 new int[] { 2008, 0, 1, 0, 0, 0 }, "dd");         assertEqualDuration( "729", new int[] { 2006, 0, 2, 0, 0, 0 },                 new int[] { 2008, 0, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "365", new int[] { 2007, 2, 2, 0, 0, 0 },                 new int[] { 2008, 2, 1, 0, 0, 0 }, "dd");         assertEqualDuration( "333", new int[] { 2007, 1, 2, 0, 0, 0 },                 new int[] { 2008, 0, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "28", new int[] { 2008, 1, 2, 0, 0, 0 },                 new int[] { 2008, 2, 1, 0, 0, 0 }, "dd");         assertEqualDuration( "393", new int[] { 2007, 1, 2, 0, 0, 0 },                 new int[] { 2008, 2, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "369", new int[] { 2004, 0, 29, 0, 0, 0 },                 new int[] { 2005, 1, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "338", new int[] { 2004, 1, 29, 0, 0, 0 },                 new int[] { 2005, 1, 1, 0, 0, 0 }, "dd");          assertEqualDuration( "28", new int[] { 2004, 2, 8, 0, 0, 0 },                 new int[] { 2004, 3, 5, 0, 0, 0 }, "dd");          assertEqualDuration( "48", new int[] { 1992, 1, 29, 0, 0, 0 },                 new int[] { 1996, 1, 29, 0, 0, 0 }, "M");           // this seems odd - and will fail if I throw it in as a brute force         // below as it expects the answer to be 12. It's a tricky edge case         assertEqualDuration( "11", new int[] { 1996, 1, 29, 0, 0, 0 },                 new int[] { 1997, 1, 28, 0, 0, 0 }, "M");         // again - this seems odd         assertEqualDuration( "11 28", new int[] { 1996, 1, 29, 0, 0, 0 },                 new int[] { 1997, 1, 28, 0, 0, 0 }, "M d");      }      @Test     public void testLANG984() { // Long durations         assertEquals("0", DurationFormatUtils.formatDuration(0, "S"));         assertEquals(Integer.toString(Integer.MAX_VALUE), DurationFormatUtils.formatDuration(Integer.MAX_VALUE, "S"));         long maxIntPlus=Integer.MAX_VALUE;         maxIntPlus++;         assertEquals(Long.toString(maxIntPlus), DurationFormatUtils.formatDuration(maxIntPlus, "S"));         assertEquals(Long.toString(Long.MAX_VALUE), DurationFormatUtils.formatDuration(Long.MAX_VALUE, "S"));     }      @Test     public void testLANG982() { // More than 3 millisecond digits following a second         assertEquals("61.999", DurationFormatUtils.formatDuration(61999, "s.S"));         assertEquals("1 1999", DurationFormatUtils.formatDuration(61999, "m S"));         assertEquals("61.999", DurationFormatUtils.formatDuration(61999, "s.SSS"));         assertEquals("1 1999", DurationFormatUtils.formatDuration(61999, "m SSS"));         assertEquals("61.0999", DurationFormatUtils.formatDuration(61999, "s.SSSS"));         assertEquals("1 1999", DurationFormatUtils.formatDuration(61999, "m SSSS"));         assertEquals("61.00999", DurationFormatUtils.formatDuration(61999, "s.SSSSS"));         assertEquals("1 01999", DurationFormatUtils.formatDuration(61999, "m SSSSS"));     }      @Test     public void testDurationsByBruteForce() {         bruteForce(2006, 0, 1, "d", Calendar.DAY_OF_MONTH);         bruteForce(2006, 0, 2, "d", Calendar.DAY_OF_MONTH);         bruteForce(2007, 1, 2, "d", Calendar.DAY_OF_MONTH);         bruteForce(2004, 1, 29, "d", Calendar.DAY_OF_MONTH);         bruteForce(1996, 1, 29, "d", Calendar.DAY_OF_MONTH);          bruteForce(1969, 1, 28, "M", Calendar.MONTH);  // tests for 48 years         //bruteForce(1996, 1, 29, "M", Calendar.MONTH);  // this will fail     }      @Test     public void testLANG981() { // unmatched quote char in lexx         assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.lexx("'yMdHms''S"));     }      private static final int FOUR_YEARS = 365 * 3 + 366;      // Takes a minute to run, so generally turned off //    public void testBrutally() { //        Calendar c = Calendar.getInstance(); //        c.set(2004, 0, 1, 0, 0, 0); //        for (int i=0; i < FOUR_YEARS; i++) { //            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), "d", Calendar.DAY_OF_MONTH ); //            c.add(Calendar.DAY_OF_MONTH, 1); //        } //    }      private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) {         final String msg = year + "-" + month + "-" + day + " to ";         final Calendar c = Calendar.getInstance();         c.set(year, month, day, 0, 0, 0);         final int[] array1 = new int[] { year, month, day, 0, 0, 0 };         final int[] array2 = new int[] { year, month, day, 0, 0, 0 };         for (int i=0; i < FOUR_YEARS; i++) {             array2[0] = c.get(Calendar.YEAR);             array2[1] = c.get(Calendar.MONTH);             array2[2] = c.get(Calendar.DAY_OF_MONTH);             final String tmpMsg = msg + array2[0] + "-" + array2[1] + "-" + array2[2] + " at ";             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format );             c.add(calendarType, 1);         }     }      private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) {         assertEqualDuration(null, expected, start, end, format);     }     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) {         final Calendar cal1 = Calendar.getInstance();         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]);         cal1.set(Calendar.MILLISECOND, 0);         final Calendar cal2 = Calendar.getInstance();         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]);         cal2.set(Calendar.MILLISECOND, 0);         final long milli1 = cal1.getTime().getTime();         final long milli2 = cal2.getTime().getTime();         final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format);         if (message == null) {             assertEquals(expected, result);         } else {             assertEquals(expected, result, message);         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.Serializable; import java.text.FieldPosition; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone;  import org.apache.commons.lang3.SerializationUtils; import org.junit.jupiter.api.Test; import org.junitpioneer.jupiter.DefaultLocale; import org.junitpioneer.jupiter.DefaultTimeZone;  /**  * Unit tests {@link org.apache.commons.lang3.time.FastDatePrinter}.  *  * @since 3.0  */ public class FastDatePrinterTest {      private static final String YYYY_MM_DD = "yyyy/MM/dd";     private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York");     private static final TimeZone GMT = TimeZone.getTimeZone("GMT");     private static final TimeZone INDIA = TimeZone.getTimeZone("Asia/Calcutta");     private static final Locale SWEDEN = new Locale("sv", "SE");      DatePrinter getInstance(final String format) {         return getInstance(format, TimeZone.getDefault(), Locale.getDefault());     }      private DatePrinter getDateInstance(final int dateStyle, final Locale locale) {         return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());     }      private DatePrinter getInstance(final String format, final Locale locale) {         return getInstance(format, TimeZone.getDefault(), locale);     }      private DatePrinter getInstance(final String format, final TimeZone timeZone) {         return getInstance(format, timeZone, Locale.getDefault());     }      /**      * Override this method in derived tests to change the construction of instances      * @param format the format string to use      * @param timeZone the time zone to use      * @param locale the locale to use      * @return the DatePrinter to use for testing      */     protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {         return new FastDatePrinter(format, timeZone, locale);     }      @DefaultLocale(language = "en", country = "US")     @DefaultTimeZone("America/New_York")     @Test     public void testFormat() {         final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);         final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 0, 0);         final Date date1 = cal1.getTime();         final Date date2 = cal2.getTime();         final long millis1 = date1.getTime();         final long millis2 = date2.getTime();          DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss");         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");         assertEquals(sdf.format(date1), fdf.format(date1));         assertEquals("2003-01-10T15:33:20", fdf.format(date1));         assertEquals("2003-01-10T15:33:20", fdf.format(cal1));         assertEquals("2003-01-10T15:33:20", fdf.format(millis1));         assertEquals("2003-07-10T09:00:00", fdf.format(date2));         assertEquals("2003-07-10T09:00:00", fdf.format(cal2));         assertEquals("2003-07-10T09:00:00", fdf.format(millis2));          fdf = getInstance("Z");         assertEquals("-0500", fdf.format(date1));         assertEquals("-0500", fdf.format(cal1));         assertEquals("-0500", fdf.format(millis1));          assertEquals("-0400", fdf.format(date2));         assertEquals("-0400", fdf.format(cal2));         assertEquals("-0400", fdf.format(millis2));          fdf = getInstance("ZZ");         assertEquals("-05:00", fdf.format(date1));         assertEquals("-05:00", fdf.format(cal1));         assertEquals("-05:00", fdf.format(millis1));          assertEquals("-04:00", fdf.format(date2));         assertEquals("-04:00", fdf.format(cal2));         assertEquals("-04:00", fdf.format(millis2));          final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" +                 " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z";         fdf = getInstance(pattern);         sdf = new SimpleDateFormat(pattern);         // SDF bug fix starting with Java 7         assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1));         assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2));     }      /**      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.      */     @Test     public void testShortDateStyleWithLocales() {         final Locale usLocale = Locale.US;         final Locale swedishLocale = new Locale("sv", "SE");         final Calendar cal = Calendar.getInstance();         cal.set(2004, Calendar.FEBRUARY, 3);         DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale);         assertEquals("2/3/04", fdf.format(cal));          fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale);         assertEquals("2004-02-03", fdf.format(cal));      }      /**      * Tests that pre-1000AD years get padded with yyyy      */     @Test     public void testLowYearPadding() {         final Calendar cal = Calendar.getInstance();         final DatePrinter format = getInstance(YYYY_MM_DD);          cal.set(1, Calendar.JANUARY, 1);         assertEquals("0001/01/01", format.format(cal));         cal.set(10, Calendar.JANUARY, 1);         assertEquals("0010/01/01", format.format(cal));         cal.set(100, Calendar.JANUARY, 1);         assertEquals("0100/01/01", format.format(cal));         cal.set(999, Calendar.JANUARY, 1);         assertEquals("0999/01/01", format.format(cal));     }     /**      * Show Bug #39410 is solved      */     @Test     public void testMilleniumBug() {         final Calendar cal = Calendar.getInstance();         final DatePrinter format = getInstance("dd.MM.yyyy");          cal.set(1000, Calendar.JANUARY, 1);         assertEquals("01.01.1000", format.format(cal));     }      /**      * testLowYearPadding showed that the date was buggy      * This test confirms it, getting 366 back as a date      */     @Test     public void testSimpleDate() {         final Calendar cal = Calendar.getInstance();         final DatePrinter format = getInstance(YYYY_MM_DD);          cal.set(2004, Calendar.DECEMBER, 31);         assertEquals("2004/12/31", format.format(cal));         cal.set(999, Calendar.DECEMBER, 31);         assertEquals("0999/12/31", format.format(cal));         cal.set(1, Calendar.MARCH, 2);         assertEquals("0001/03/02", format.format(cal));     }      @Test     public void testLang303() {         final Calendar cal = Calendar.getInstance();         cal.set(2004, Calendar.DECEMBER, 31);          DatePrinter format = getInstance(YYYY_MM_DD);         final String output = format.format(cal);          format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format));         assertEquals(output, format.format(cal));     }      @Test     public void testLang538() {         // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)         // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone         final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));         cal.clear();         cal.set(2009, Calendar.OCTOBER, 16, 8, 42, 16);          final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));         assertEquals("2009-10-16T16:42:16.000Z", format.format(cal.getTime()), "dateTime");         assertEquals("2009-10-16T16:42:16.000Z", format.format(cal), "dateTime");     }      @Test     public void testLang645() {         final Locale locale = new Locale("sv", "SE");          final Calendar cal = Calendar.getInstance();         cal.set(2010, Calendar.JANUARY, 1, 12, 0, 0);         final Date d = cal.getTime();          final DatePrinter fdf = getInstance("EEEE', week 'ww", locale);          assertEquals("fredag, week 53", fdf.format(d));     }      @Test     public void testEquals() {         final DatePrinter printer1= getInstance(YYYY_MM_DD);         final DatePrinter printer2= getInstance(YYYY_MM_DD);          assertEquals(printer1, printer2);         assertEquals(printer1.hashCode(), printer2.hashCode());          assertNotEquals(printer1, new Object());     }      @Test     public void testToStringContainsName() {         final DatePrinter printer= getInstance(YYYY_MM_DD);         assertTrue(printer.toString().startsWith("FastDate"));     }      @Test     public void testPatternMatches() {         final DatePrinter printer= getInstance(YYYY_MM_DD);         assertEquals(YYYY_MM_DD, printer.getPattern());     }      @Test     public void testLocaleMatches() {         final DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN);         assertEquals(SWEDEN, printer.getLocale());     }      @Test     public void testTimeZoneMatches() {         final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK);         assertEquals(NEW_YORK, printer.getTimeZone());     }      @DefaultTimeZone("UTC")     @Test     public void testTimeZoneAsZ() {         final Calendar c = Calendar.getInstance(FastTimeZone.getGmtTimeZone());         final FastDateFormat noColonFormat = FastDateFormat.getInstance("Z");         assertEquals("+0000", noColonFormat.format(c));          final FastDateFormat isoFormat = FastDateFormat.getInstance("ZZ");         assertEquals("Z", isoFormat.format(c));          final FastDateFormat colonFormat = FastDateFormat.getInstance("ZZZ");         assertEquals("+00:00", colonFormat.format(c));     }      private static Calendar initializeCalendar(final TimeZone tz) {         final Calendar cal = Calendar.getInstance(tz);         cal.set(Calendar.YEAR, 2001);         cal.set(Calendar.MONTH, 1); // not daylight savings         cal.set(Calendar.DAY_OF_MONTH, 4);         cal.set(Calendar.HOUR_OF_DAY, 12);         cal.set(Calendar.MINUTE, 8);         cal.set(Calendar.SECOND, 56);         cal.set(Calendar.MILLISECOND, 235);         return cal;     }      @Test     public void test1806Argument() {         assertThrows(IllegalArgumentException.class, () -> getInstance("XXXX"));     }      private enum Expected1806 {         India(INDIA, "+05", "+0530", "+05:30"), Greenwich(GMT, "Z", "Z", "Z"), NewYork(                 NEW_YORK, "-05", "-0500", "-05:00");          Expected1806(final TimeZone zone, final String one, final String two, final String three) {             this.zone = zone;             this.one = one;             this.two = two;             this.three = three;         }          final TimeZone zone;         final String one;         final String two;         final String three;     }      @Test     public void test1806() {         for (final Expected1806 trial : Expected1806.values()) {             final Calendar cal = initializeCalendar(trial.zone);              DatePrinter printer = getInstance("X", trial.zone);             assertEquals(trial.one, printer.format(cal));              printer = getInstance("XX", trial.zone);             assertEquals(trial.two, printer.format(cal));              printer = getInstance("XXX", trial.zone);             assertEquals(trial.three, printer.format(cal));         }     }      @Test     public void testLang1103() {         final Calendar cal = Calendar.getInstance(SWEDEN);         cal.set(Calendar.DAY_OF_MONTH, 2);          assertEquals("2", getInstance("d", SWEDEN).format(cal));         assertEquals("02", getInstance("dd", SWEDEN).format(cal));         assertEquals("002", getInstance("ddd", SWEDEN).format(cal));         assertEquals("0002", getInstance("dddd", SWEDEN).format(cal));         assertEquals("00002", getInstance("ddddd", SWEDEN).format(cal));     }      /**      * According to LANG-916 (https://issues.apache.org/jira/browse/LANG-916),      * the format method did contain a bug: it did not use the TimeZone data.      *      * This method test that the bug is fixed.      */     @Test     public void testLang916() {          final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("Europe/Paris"));         cal.clear();         cal.set(2009, 9, 16, 8, 42, 16);          // calendar fast.         {             final String value = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss Z", TimeZone.getTimeZone("Europe/Paris")).format(cal);             assertEquals("2009-10-16T08:42:16 +0200", value, "calendar");         }         {             final String value = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss Z", TimeZone.getTimeZone("Asia/Kolkata")).format(cal);             assertEquals("2009-10-16T12:12:16 +0530", value, "calendar");         }         {             final String value = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss Z", TimeZone.getTimeZone("Europe/London")).format(cal);             assertEquals("2009-10-16T07:42:16 +0100", value, "calendar");         }     }      @Test     public void testHourFormats() {         final Calendar calendar = Calendar.getInstance();         calendar.clear();         final DatePrinter printer = getInstance("K k H h");          calendar.set(Calendar.HOUR_OF_DAY, 0);         assertEquals("0 24 0 12", printer.format(calendar));          calendar.set(Calendar.HOUR_OF_DAY, 12);         assertEquals("0 12 12 12", printer.format(calendar));          calendar.set(Calendar.HOUR_OF_DAY, 23);         assertEquals("11 23 23 11", printer.format(calendar));     }      @SuppressWarnings("deprecation")     @Test     public void testStringBufferOptions() {         final DatePrinter format = getInstance("yyyy-MM-dd HH:mm:ss.SSS Z", TimeZone.getTimeZone("GMT"));         final Calendar calendar = Calendar.getInstance();         final StringBuffer sb = new StringBuffer();         final String expected = format.format(calendar, sb, new FieldPosition(0)).toString();         sb.setLength(0);         assertEquals(expected, format.format(calendar, sb).toString());         sb.setLength(0);          final Date date = calendar.getTime();         assertEquals(expected, format.format(date, sb, new FieldPosition(0)).toString());         sb.setLength(0);         assertEquals(expected, format.format(date, sb).toString());         sb.setLength(0);          final long epoch = date.getTime();         assertEquals(expected, format.format(epoch, sb, new FieldPosition(0)).toString());         sb.setLength(0);         assertEquals(expected, format.format(epoch, sb).toString());     }      @Test     public void testAppendableOptions() {         final DatePrinter format = getInstance("yyyy-MM-dd HH:mm:ss.SSS Z", TimeZone.getTimeZone("GMT"));         final Calendar calendar = Calendar.getInstance();         final StringBuilder sb = new StringBuilder();         final String expected = format.format(calendar, sb).toString();         sb.setLength(0);          final Date date = calendar.getTime();         assertEquals(expected, format.format(date, sb).toString());         sb.setLength(0);          final long epoch = date.getTime();         assertEquals(expected, format.format(epoch, sb).toString());     }      @Test     public void testDayNumberOfWeek() {         final DatePrinter printer = getInstance("u");         final Calendar calendar = Calendar.getInstance();          calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);         assertEquals("1", printer.format(calendar.getTime()));          calendar.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);         assertEquals("6", printer.format(calendar.getTime()));          calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);         assertEquals("7", printer.format(calendar.getTime()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.time;  import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone;  import org.apache.commons.lang3.function.TriFunction; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  /**  * These tests fail on Java 15 due to a bug which was only fixed for Java 16.  * <ul>  * <li>https://bugs.openjdk.java.net/browse/JDK-8248434</li>  * <li>https://bugs.openjdk.java.net/browse/JDK-8248655</li>  * </ul>  */ public class Java15BugFastDateParserTest {      private static final String DATE_PARSER_PARAMETERS = "org.apache.commons.lang3.time.FastDateParserTest#dateParserParameters()";      @Test     public void java15BuggyLocaleTest() throws ParseException {         final String buggyLocaleName = "ff_LR_#Adlm";         Locale buggyLocale = null;         for (final Locale locale : Locale.getAvailableLocales()) {             if (buggyLocaleName.equals(locale.toString())) {                 buggyLocale = locale;                 break;             }         }         if (buggyLocale == null) {             return;         }         testSingleLocale(buggyLocale);     }      @Test     public void java15BuggyLocaleTestAll() throws ParseException {         for (final Locale locale : Locale.getAvailableLocales()) {             testSingleLocale(locale);         }     }      private void testLocales(final TriFunction<String, TimeZone, Locale, DateParser> dbProvider, final String format,         final boolean eraBC) throws Exception {          final Calendar cal = Calendar.getInstance(FastDateParserTest.GMT);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10);         if (eraBC) {             cal.set(Calendar.ERA, GregorianCalendar.BC);         }          for (final Locale locale : Locale.getAvailableLocales()) {             // ja_JP_JP cannot handle dates before 1868 properly             if (eraBC && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {                 continue;             }             final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);             final DateParser fdf = dbProvider.apply(format, TimeZone.getDefault(), locale);              // If parsing fails, a ParseException will be thrown and the test will fail             FastDateParserTest.checkParse(locale, cal, sdf, fdf);         }     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_Long_AD(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.LONG_FORMAT, false);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_Long_BC(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.LONG_FORMAT, true);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_LongNoEra_AD(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.LONG_FORMAT_NOERA, false);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_LongNoEra_BC(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.LONG_FORMAT_NOERA, true);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_Short_AD(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.SHORT_FORMAT, false);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_Short_BC(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.SHORT_FORMAT, true);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_ShortNoEra_AD(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.SHORT_FORMAT_NOERA, false);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLocales_ShortNoEra_BC(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testLocales(dpProvider, FastDateParserTest.SHORT_FORMAT_NOERA, true);     }      private void testSingleLocale(final Locale locale) throws ParseException {         final Calendar cal = Calendar.getInstance(FastDateParserTest.GMT);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10);         final SimpleDateFormat sdf = new SimpleDateFormat(FastDateParserTest.LONG_FORMAT, locale);         final String formattedDate = sdf.format(cal.getTime());         sdf.parse(formattedDate);         sdf.parse(formattedDate.toUpperCase(locale));         sdf.parse(formattedDate.toLowerCase(locale));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.fail;  import java.io.Serializable; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.TimeZone; import java.util.stream.Stream;  import org.apache.commons.lang3.LocaleUtils; import org.apache.commons.lang3.SerializationUtils; import org.apache.commons.lang3.function.TriFunction; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  /**  * Unit tests {@link org.apache.commons.lang3.time.FastDateParser}.  *  * @since 3.2  */ public class FastDateParserTest {      private enum Expected1806 {         India(INDIA, "+05", "+0530", "+05:30", true), Greenwich(GMT, "Z", "Z", "Z", false),         NewYork(NEW_YORK, "-05", "-0500", "-05:00", false);          final TimeZone zone;          final String one;         final String two;         final String three;         final long offset;          Expected1806(final TimeZone zone, final String one, final String two, final String three,             final boolean hasHalfHourOffset) {             this.zone = zone;             this.one = one;             this.two = two;             this.three = three;             this.offset = hasHalfHourOffset ? 30 * 60 * 1000 : 0;         }     }      static final String DATE_PARSER_PARAMETERS = "dateParserParameters";      static final String SHORT_FORMAT_NOERA = "y/M/d/h/a/m/s/E";      static final String LONG_FORMAT_NOERA = "yyyy/MMMM/dddd/hhhh/mmmm/ss/aaaa/EEEE";     static final String SHORT_FORMAT = "G/" + SHORT_FORMAT_NOERA;     static final String LONG_FORMAT = "GGGG/" + LONG_FORMAT_NOERA;      private static final String yMdHmsSZ = "yyyy-MM-dd'T'HH:mm:ss.SSS Z";     private static final String DMY_DOT = "dd.MM.yyyy";     private static final String YMD_SLASH = "yyyy/MM/dd";     private static final String MDY_DASH = "MM-DD-yyyy";     private static final String MDY_SLASH = "MM/DD/yyyy";      private static final TimeZone REYKJAVIK = TimeZone.getTimeZone("Atlantic/Reykjavik");     private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York");     static final TimeZone GMT = TimeZone.getTimeZone("GMT");     private static final TimeZone INDIA = TimeZone.getTimeZone("Asia/Calcutta");      private static final Locale SWEDEN = new Locale("sv", "SE");      static Stream<Arguments> dateParserParameters() {         return Stream.of(         // @formatter:off             Arguments.of((TriFunction<String, TimeZone, Locale, DateParser>) (format, timeZone, locale)                 -> new FastDateParser(format, timeZone, locale, null)),             Arguments.of((TriFunction<String, TimeZone, Locale, DateParser>) FastDateFormat::getInstance)         // @formatter:on         );     }      private static Calendar initializeCalendar(final TimeZone tz) {         final Calendar cal = Calendar.getInstance(tz);         cal.set(Calendar.YEAR, 2001);         cal.set(Calendar.MONTH, 1); // not daylight savings         cal.set(Calendar.DAY_OF_MONTH, 4);         cal.set(Calendar.HOUR_OF_DAY, 12);         cal.set(Calendar.MINUTE, 8);         cal.set(Calendar.SECOND, 56);         cal.set(Calendar.MILLISECOND, 235);         return cal;     }      private final TriFunction<String, TimeZone, Locale, DateParser> dateParserProvider = (format, timeZone,         locale) -> new FastDateParser(format, timeZone, locale, null);      static void checkParse(final Locale locale, final Calendar cal, final SimpleDateFormat sdf, final DateParser fdf) {         final String formattedDate = sdf.format(cal.getTime());         checkParse(locale, sdf, fdf, formattedDate);         checkParse(locale, sdf, fdf, formattedDate.toLowerCase(locale));         checkParse(locale, sdf, fdf, formattedDate.toUpperCase(locale));     }      static void checkParse(final Locale locale, final SimpleDateFormat sdf, final DateParser fdf,         final String formattedDate) {         try {             final Date expectedTime = sdf.parse(formattedDate);             final Date actualTime = fdf.parse(formattedDate);             assertEquals(expectedTime, actualTime, "locale : " + locale + " formattedDate : " + formattedDate + "\n");         } catch (final Exception e) {             fail("locale : " + locale + " formattedDate : " + formattedDate + " error : " + e + "\n", e);         }     }      private DateParser getDateInstance(final int dateStyle, final Locale locale) {         return getInstance(null, FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale),             TimeZone.getDefault(), Locale.getDefault());     }      private Calendar getEraStart(int year, final TimeZone zone, final Locale locale) {         final Calendar cal = Calendar.getInstance(zone, locale);         cal.clear();          // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html         if (locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {             if (year < 1868) {                 cal.set(Calendar.ERA, 0);                 cal.set(Calendar.YEAR, 1868 - year);             }         } else {             if (year < 0) {                 cal.set(Calendar.ERA, GregorianCalendar.BC);                 year = -year;             }             cal.set(Calendar.YEAR, year / 100 * 100);         }         return cal;     }      DateParser getInstance(final String format) {         return getInstance(null, format, TimeZone.getDefault(), Locale.getDefault());     }      DateParser getInstance(final String format, final Locale locale) {         return getInstance(null, format, TimeZone.getDefault(), locale);     }      private DateParser getInstance(final String format, final TimeZone timeZone) {         return getInstance(null, format, timeZone, Locale.getDefault());     }      /**      * Override this method in derived tests to change the construction of instances      *      * @param dpProvider TODO      * @param format the format string to use      * @param timeZone the time zone to use      * @param locale the locale to use      *      * @return the DateParser instance to use for testing      */     protected DateParser getInstance(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider,         final String format, final TimeZone timeZone, final Locale locale) {         return (dpProvider == null ? this.dateParserProvider : dpProvider).apply(format, timeZone, locale);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void test_Equality_Hash(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) {         final DateParser[] parsers = {getInstance(dpProvider, yMdHmsSZ, NEW_YORK, Locale.US),             getInstance(dpProvider, DMY_DOT, NEW_YORK, Locale.US),             getInstance(dpProvider, YMD_SLASH, NEW_YORK, Locale.US),             getInstance(dpProvider, MDY_DASH, NEW_YORK, Locale.US),             getInstance(dpProvider, MDY_SLASH, NEW_YORK, Locale.US),             getInstance(dpProvider, MDY_SLASH, REYKJAVIK, Locale.US),             getInstance(dpProvider, MDY_SLASH, REYKJAVIK, SWEDEN)};          final Map<DateParser, Integer> map = new HashMap<>();         int i = 0;         for (final DateParser parser : parsers) {             map.put(parser, Integer.valueOf(i++));         }          i = 0;         for (final DateParser parser : parsers) {             assertEquals(i++, map.get(parser).intValue());         }     }      @Test     public void test1806() throws ParseException {         final String formatStub = "yyyy-MM-dd'T'HH:mm:ss.SSS";         final String dateStub = "2001-02-04T12:08:56.235";          for (final Expected1806 trial : Expected1806.values()) {             final Calendar cal = initializeCalendar(trial.zone);              final String message = trial.zone.getDisplayName() + ";";              DateParser parser = getInstance(formatStub + "X", trial.zone);             assertEquals(cal.getTime().getTime(), parser.parse(dateStub + trial.one).getTime() - trial.offset,                 message + trial.one);              parser = getInstance(formatStub + "XX", trial.zone);             assertEquals(cal.getTime(), parser.parse(dateStub + trial.two), message + trial.two);              parser = getInstance(formatStub + "XXX", trial.zone);             assertEquals(cal.getTime(), parser.parse(dateStub + trial.three), message + trial.three);         }     }      @Test     public void test1806Argument() {         assertThrows(IllegalArgumentException.class, () -> getInstance("XXXX"));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testAmPm(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();          final DateParser h = getInstance(dpProvider, "yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US);         final DateParser K = getInstance(dpProvider, "yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US);         final DateParser k = getInstance(dpProvider, "yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US);         final DateParser H = getInstance(dpProvider, "yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US);          cal.set(2010, Calendar.AUGUST, 1, 0, 33, 20);         assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20"));         assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20"));         assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20"));         assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20"));          cal.set(2010, Calendar.AUGUST, 1, 3, 33, 20);         assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20"));         assertEquals(cal.getTime(), K.parse("2010-08-01 3 AM 33:20"));         assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20"));         assertEquals(cal.getTime(), H.parse("2010-08-01 03:33:20"));          cal.set(2010, Calendar.AUGUST, 1, 15, 33, 20);         assertEquals(cal.getTime(), h.parse("2010-08-01 3 PM 33:20"));         assertEquals(cal.getTime(), K.parse("2010-08-01 3 PM 33:20"));         assertEquals(cal.getTime(), k.parse("2010-08-01 15:33:20"));         assertEquals(cal.getTime(), H.parse("2010-08-01 15:33:20"));          cal.set(2010, Calendar.AUGUST, 1, 12, 33, 20);         assertEquals(cal.getTime(), h.parse("2010-08-01 12 PM 33:20"));         assertEquals(cal.getTime(), K.parse("2010-08-01 0 PM 33:20"));         assertEquals(cal.getTime(), k.parse("2010-08-01 12:33:20"));         assertEquals(cal.getTime(), H.parse("2010-08-01 12:33:20"));     }      @Test     public void testDayNumberOfWeek() throws ParseException {         final DateParser parser = getInstance("u");         final Calendar calendar = Calendar.getInstance();          calendar.setTime(parser.parse("1"));         assertEquals(Calendar.MONDAY, calendar.get(Calendar.DAY_OF_WEEK));          calendar.setTime(parser.parse("6"));         assertEquals(Calendar.SATURDAY, calendar.get(Calendar.DAY_OF_WEEK));          calendar.setTime(parser.parse("7"));         assertEquals(Calendar.SUNDAY, calendar.get(Calendar.DAY_OF_WEEK));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testDayOf(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10);          final DateParser fdf = getInstance(dpProvider, "W w F D y", NEW_YORK, Locale.US);         assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03"));     }      @Test     public void testEquals() {         final DateParser parser1 = getInstance(YMD_SLASH);         final DateParser parser2 = getInstance(YMD_SLASH);          assertEquals(parser1, parser2);         assertEquals(parser1.hashCode(), parser2.hashCode());          assertNotEquals(parser1, new Object());     }      /**      * @throws ParseException      */     @Test     public void testJpLocales() throws ParseException {          final Calendar cal = Calendar.getInstance(GMT);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10);         cal.set(Calendar.ERA, GregorianCalendar.BC);          final Locale locale = LocaleUtils.toLocale("zh");         // ja_JP_JP cannot handle dates before 1868 properly          final SimpleDateFormat sdf = new SimpleDateFormat(LONG_FORMAT, locale);         final DateParser fdf = getInstance(LONG_FORMAT, locale);          // If parsing fails, a ParseException will be thrown and the test will fail         checkParse(locale, cal, sdf, fdf);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLANG_831(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws Exception {         testSdfAndFdp(dpProvider, "M E", "3  Tue", true);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLANG_832(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws Exception {         testSdfAndFdp(dpProvider, "'d'd", "d3", false); // OK         testSdfAndFdp(dpProvider, "'d'd'", "d3", true); // should fail (unterminated quote)     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLang1121(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final TimeZone kst = TimeZone.getTimeZone("KST");         final DateParser fdp = getInstance(dpProvider, "yyyyMMdd", kst, Locale.KOREA);          assertThrows(ParseException.class, () -> fdp.parse("2015"));          // Wed Apr 29 00:00:00 KST 2015         Date actual = fdp.parse("20150429");         final Calendar cal = Calendar.getInstance(kst, Locale.KOREA);         cal.clear();         cal.set(2015, 3, 29);         Date expected = cal.getTime();         assertEquals(expected, actual);          final SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd", Locale.KOREA);         df.setTimeZone(kst);         expected = df.parse("20150429113100");          // Thu Mar 16 00:00:00 KST 81724         actual = fdp.parse("20150429113100");         assertEquals(expected, actual);     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLang1380(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final Calendar expected = Calendar.getInstance(GMT, Locale.FRANCE);         expected.clear();         expected.set(2014, Calendar.APRIL, 14);          final DateParser fdp = getInstance(dpProvider, "dd MMM yyyy", GMT, Locale.FRANCE);         assertEquals(expected.getTime(), fdp.parse("14 avril 2014"));         assertEquals(expected.getTime(), fdp.parse("14 avr. 2014"));         assertEquals(expected.getTime(), fdp.parse("14 avr 2014"));     }      @Test     public void testLang303() throws ParseException {         DateParser parser = getInstance(YMD_SLASH);         final Calendar cal = Calendar.getInstance();         cal.set(2004, Calendar.DECEMBER, 31);          final Date date = parser.parse("2004/11/31");          parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser));         assertEquals(date, parser.parse("2004/11/31"));     }      @Test     public void testLang538() throws ParseException {         final DateParser parser = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", GMT);          final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT-8"));         cal.clear();         cal.set(2009, Calendar.OCTOBER, 16, 8, 42, 16);          assertEquals(cal.getTime(), parser.parse("2009-10-16T16:42:16.000Z"));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testLang996(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final Calendar expected = Calendar.getInstance(NEW_YORK, Locale.US);         expected.clear();         expected.set(2014, Calendar.MAY, 14);          final DateParser fdp = getInstance(dpProvider, "ddMMMyyyy", NEW_YORK, Locale.US);         assertEquals(expected.getTime(), fdp.parse("14may2014"));         assertEquals(expected.getTime(), fdp.parse("14MAY2014"));         assertEquals(expected.getTime(), fdp.parse("14May2014"));     }      @Test     public void testLocaleMatches() {         final DateParser parser = getInstance(yMdHmsSZ, SWEDEN);         assertEquals(SWEDEN, parser.getLocale());     }      /**      * Tests that pre-1000AD years get padded with yyyy      *      * @throws ParseException so we don't have to catch it      */     @Test     public void testLowYearPadding() throws ParseException {         final DateParser parser = getInstance(YMD_SLASH);         final Calendar cal = Calendar.getInstance();         cal.clear();          cal.set(1, Calendar.JANUARY, 1);         assertEquals(cal.getTime(), parser.parse("0001/01/01"));         cal.set(10, Calendar.JANUARY, 1);         assertEquals(cal.getTime(), parser.parse("0010/01/01"));         cal.set(100, Calendar.JANUARY, 1);         assertEquals(cal.getTime(), parser.parse("0100/01/01"));         cal.set(999, Calendar.JANUARY, 1);         assertEquals(cal.getTime(), parser.parse("0999/01/01"));     }      @Test     public void testMilleniumBug() throws ParseException {         final DateParser parser = getInstance(DMY_DOT);         final Calendar cal = Calendar.getInstance();         cal.clear();          cal.set(1000, Calendar.JANUARY, 1);         assertEquals(cal.getTime(), parser.parse("01.01.1000"));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testParseLongShort(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10, 15, 33, 20);         cal.set(Calendar.MILLISECOND, 989);         cal.setTimeZone(NEW_YORK);          DateParser fdf = getInstance(dpProvider, "yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK,             Locale.US);          assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00"));         cal.set(Calendar.ERA, GregorianCalendar.BC);          final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00");         assertEquals(cal.getTime(), parse);          fdf = getInstance(null, "y G M d a E H m s S Z", NEW_YORK, Locale.US);         assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500"));          cal.set(Calendar.ERA, GregorianCalendar.AD);         assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500"));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testParseNumerics(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10, 15, 33, 20);         cal.set(Calendar.MILLISECOND, 989);          final DateParser fdf = getInstance(dpProvider, "yyyyMMddHHmmssSSS", NEW_YORK, Locale.US);         assertEquals(cal.getTime(), fdf.parse("20030210153320989"));     }      @Test     public void testParseOffset() {         final DateParser parser = getInstance(YMD_SLASH);         final Date date = parser.parse("Today is 2015/07/04", new ParsePosition(9));          final Calendar cal = Calendar.getInstance();         cal.clear();         cal.set(2015, Calendar.JULY, 4);         assertEquals(cal.getTime(), date);     }      @Test     // Check that all Locales can parse the formats we use     public void testParses() throws Exception {         for (final String format : new String[] {LONG_FORMAT, SHORT_FORMAT}) {             for (final Locale locale : Locale.getAvailableLocales()) {                 for (final TimeZone tz : new TimeZone[] {NEW_YORK, REYKJAVIK, GMT}) {                     for (final int year : new int[] {2003, 1940, 1868, 1867, 1, -1, -1940}) {                         final Calendar cal = getEraStart(year, tz, locale);                         final Date centuryStart = cal.getTime();                          cal.set(Calendar.MONTH, 1);                         cal.set(Calendar.DAY_OF_MONTH, 10);                         final Date in = cal.getTime();                          final FastDateParser fdp = new FastDateParser(format, tz, locale, centuryStart);                         validateSdfFormatFdpParseEquality(format, locale, tz, fdp, in, year, centuryStart);                     }                 }             }         }     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testParseZone(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();         cal.set(2003, Calendar.JULY, 10, 16, 33, 20);          final DateParser fdf = getInstance(dpProvider, yMdHmsSZ, NEW_YORK, Locale.US);          assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 -0500"));         assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 GMT-05:00"));         assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 Eastern Daylight Time"));         assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 EDT"));          cal.setTimeZone(TimeZone.getTimeZone("GMT-3"));         cal.set(2003, Calendar.FEBRUARY, 10, 9, 0, 0);          assertEquals(cal.getTime(), fdf.parse("2003-02-10T09:00:00.000 -0300"));          cal.setTimeZone(TimeZone.getTimeZone("GMT+5"));         cal.set(2003, Calendar.FEBRUARY, 10, 15, 5, 6);          assertEquals(cal.getTime(), fdf.parse("2003-02-10T15:05:06.000 +0500"));     }      @Test     public void testPatternMatches() {         final DateParser parser = getInstance(yMdHmsSZ);         assertEquals(yMdHmsSZ, parser.getPattern());     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testQuotes(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {         final Calendar cal = Calendar.getInstance(NEW_YORK, Locale.US);         cal.clear();         cal.set(2003, Calendar.FEBRUARY, 10, 15, 33, 20);         cal.set(Calendar.MILLISECOND, 989);          final DateParser fdf = getInstance(dpProvider, "''yyyyMMdd'A''B'HHmmssSSS''", NEW_YORK, Locale.US);         assertEquals(cal.getTime(), fdf.parse("'20030210A'B153320989'"));     }      private void testSdfAndFdp(final TriFunction<String, TimeZone, Locale, DateParser> dbProvider, final String format,         final String date, final boolean shouldFail) throws Exception {         Date dfdp = null;         Date dsdf = null;         Throwable f = null;         Throwable s = null;          try {             final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);             sdf.setTimeZone(NEW_YORK);             dsdf = sdf.parse(date);             assertFalse(shouldFail, "Expected SDF failure, but got " + dsdf + " for [" + format + ", " + date + "]");         } catch (final Exception e) {             s = e;             if (!shouldFail) {                 throw e;             }         }          try {             final DateParser fdp = getInstance(dbProvider, format, NEW_YORK, Locale.US);             dfdp = fdp.parse(date);             assertFalse(shouldFail, "Expected FDF failure, but got " + dfdp + " for [" + format + ", " + date + "]");         } catch (final Exception e) {             f = e;             if (!shouldFail) {                 throw e;             }         }         // SDF and FDF should produce equivalent results         assertEquals((f == null), (s == null), "Should both or neither throw Exceptions");         assertEquals(dsdf, dfdp, "Parsed dates should be equal");     }      /**      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.      *      * @throws ParseException so we don't have to catch it      */     @Test     public void testShortDateStyleWithLocales() throws ParseException {         DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);         final Calendar cal = Calendar.getInstance();         cal.clear();          cal.set(2004, Calendar.FEBRUARY, 3);         assertEquals(cal.getTime(), fdf.parse("2/3/04"));          fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);         assertEquals(cal.getTime(), fdf.parse("2004-02-03"));     }      @ParameterizedTest     @MethodSource(DATE_PARSER_PARAMETERS)     public void testSpecialCharacters(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider)         throws Exception {         testSdfAndFdp(dpProvider, "q", "", true); // bad pattern character (at present)         testSdfAndFdp(dpProvider, "Q", "", true); // bad pattern character         testSdfAndFdp(dpProvider, "$", "$", false); // OK         testSdfAndFdp(dpProvider, "?.d", "?.12", false); // OK         testSdfAndFdp(dpProvider, "''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK         testSdfAndFdp(dpProvider, "''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK         testSdfAndFdp(dpProvider, "'$\\Ed'", "$\\Ed", false); // OK          // quoted charaters are case sensitive         testSdfAndFdp(dpProvider, "'QED'", "QED", false);         testSdfAndFdp(dpProvider, "'QED'", "qed", true);         // case sensitive after insensitive Month field         testSdfAndFdp(dpProvider, "yyyy-MM-dd 'QED'", "2003-02-10 QED", false);         testSdfAndFdp(dpProvider, "yyyy-MM-dd 'QED'", "2003-02-10 qed", true);     }      @Test     public void testTimeZoneMatches() {         final DateParser parser = getInstance(yMdHmsSZ, REYKJAVIK);         assertEquals(REYKJAVIK, parser.getTimeZone());     }      @Test     public void testToStringContainsName() {         final DateParser parser = getInstance(YMD_SLASH);         assertTrue(parser.toString().startsWith("FastDate"));     }      // we cannot use historic dates to test timezone parsing, some timezones have second offsets     // as well as hours and minutes which makes the z formats a low fidelity round trip     @Test     public void testTzParses() throws Exception {         // Check that all Locales can parse the time formats we use         for (final Locale locale : Locale.getAvailableLocales()) {             final FastDateParser fdp = new FastDateParser("yyyy/MM/dd z", TimeZone.getDefault(), locale);              for (final TimeZone tz : new TimeZone[] {NEW_YORK, REYKJAVIK, GMT}) {                 final Calendar cal = Calendar.getInstance(tz, locale);                 cal.clear();                 cal.set(Calendar.YEAR, 2000);                 cal.set(Calendar.MONTH, 1);                 cal.set(Calendar.DAY_OF_MONTH, 10);                 final Date expected = cal.getTime();                  final Date actual = fdp.parse("2000/02/10 " + tz.getDisplayName(locale));                 assertEquals(expected, actual, "tz:" + tz.getID() + " locale:" + locale.getDisplayName());             }         }     }      private void validateSdfFormatFdpParseEquality(final String format, final Locale locale, final TimeZone tz,         final DateParser fdp, final Date in, final int year, final Date cs) throws ParseException {         final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);         sdf.setTimeZone(tz);         if (format.equals(SHORT_FORMAT)) {             sdf.set2DigitYearStart(cs);         }         final String fmt = sdf.format(in);         try {             final Date out = fdp.parse(fmt);             assertEquals(in, out, locale.toString() + " " + in + " " + format + " " + tz.getID());         } catch (final ParseException pe) {             if (year >= 1868 || !locale.getCountry().equals("JP")) {// LANG-978                 throw pe;             }         }     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.concurrent.TimeUnit;  import org.apache.commons.lang3.reflect.FieldUtils; import org.junit.jupiter.api.Test;  /**  * TestCase for StopWatch.  */ public class StopWatchTest {      private static final String MESSAGE = "Baking cookies";     private static final int MIN_SLEEP_MILLISECONDS = 20;     private static final String ZERO_HOURS_PREFIX = "00:";     private static final String ZERO_TIME_ELAPSED = "00:00:00.000";      /**      * <p>      * Creates a suspended StopWatch object which appears to have elapsed      * for the requested amount of time in nanoseconds.      * <p>      * <p>      * <pre>      * // Create a mock StopWatch with a time of 2:59:01.999      * final long nanos = TimeUnit.HOURS.toNanos(2)      *         + TimeUnit.MINUTES.toNanos(59)      *         + TimeUnit.SECONDS.toNanos(1)      *         + TimeUnit.MILLISECONDS.toNanos(999);      * final StopWatch watch = createMockStopWatch(nanos);      * </pre>      *      * @param nanos Time in nanoseconds to have elapsed on the stop watch      * @return StopWatch in a suspended state with the elapsed time      */     private StopWatch createMockStopWatch(final long nanos) {         final StopWatch watch = StopWatch.createStarted();         watch.suspend();         try {             final long currentNanos = System.nanoTime();             FieldUtils.writeField(watch, "startTime", currentNanos - nanos, true);             FieldUtils.writeField(watch, "stopTime", currentNanos, true);         } catch (final IllegalAccessException e) {             return null;         }         return watch;     }      // test bad states     @Test     public void testBadStates() {         final StopWatch watch = new StopWatch();         assertThrows(                 IllegalStateException.class,                 watch::stop,                 "Calling stop on an unstarted StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::suspend,                 "Calling suspend on an unstarted StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::split,                 "Calling split on a non-running StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::unsplit,                 "Calling unsplit on an unsplit StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::resume,                 "Calling resume on an unsuspended StopWatch should throw an exception. ");          watch.start();          assertThrows(                 IllegalStateException.class,                 watch::start,                 "Calling start on a started StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::unsplit,                 "Calling unsplit on an unsplit StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::getSplitTime,                 "Calling getSplitTime on an unsplit StopWatch should throw an exception. ");          assertThrows(                 IllegalStateException.class,                 watch::resume,                 "Calling resume on an unsuspended StopWatch should throw an exception. ");          watch.stop();          assertThrows(                 IllegalStateException.class,                 watch::start,                 "Calling start on a stopped StopWatch should throw an exception as it needs to be reset. ");     }      @Test     public void testBooleanStates() {         final StopWatch watch = new StopWatch();         assertFalse(watch.isStarted());         assertFalse(watch.isSuspended());         assertTrue(watch.isStopped());          watch.start();         assertTrue(watch.isStarted());         assertFalse(watch.isSuspended());         assertFalse(watch.isStopped());          watch.suspend();         assertTrue(watch.isStarted());         assertTrue(watch.isSuspended());         assertFalse(watch.isStopped());          watch.stop();         assertFalse(watch.isStarted());         assertFalse(watch.isSuspended());         assertTrue(watch.isStopped());     }      @Test     public void testFormatSplitTime() throws InterruptedException {         final StopWatch watch = StopWatch.createStarted();         Thread.sleep(MIN_SLEEP_MILLISECONDS);         watch.split();         final String formatSplitTime = watch.formatSplitTime();         assertNotEquals(ZERO_TIME_ELAPSED, formatSplitTime);         assertTrue(formatSplitTime.startsWith(ZERO_HOURS_PREFIX));     }      @Test     public void testFormatSplitTimeWithMessage() throws InterruptedException {         final StopWatch watch = new StopWatch(MESSAGE);         watch.start();         Thread.sleep(MIN_SLEEP_MILLISECONDS);         watch.split();         final String formatSplitTime = watch.formatSplitTime();         assertFalse(formatSplitTime.startsWith(MESSAGE), formatSplitTime);         assertTrue(formatSplitTime.startsWith(ZERO_HOURS_PREFIX));     }      @Test     public void testFormatTime() {         final StopWatch watch = StopWatch.create();         final String formatTime = watch.formatTime();         assertEquals(ZERO_TIME_ELAPSED, formatTime);         assertTrue(formatTime.startsWith(ZERO_HOURS_PREFIX));     }      @Test     public void testFormatTimeWithMessage() {         final StopWatch watch = new StopWatch(MESSAGE);         final String formatTime = watch.formatTime();         assertFalse(formatTime.startsWith(MESSAGE), formatTime);     }      @Test     public void testGetStartTime() {         final long beforeStopWatch = System.currentTimeMillis();         final StopWatch watch = new StopWatch();         assertThrows(                 IllegalStateException.class,                 watch::getStartTime,                 "Calling getStartTime on an unstarted StopWatch should throw an exception");         watch.start();          watch.getStartTime();         assertTrue(watch.getStartTime() >= beforeStopWatch);          watch.reset();         assertThrows(                 IllegalStateException.class,                 watch::getStartTime,                 "Calling getStartTime on a reset, but unstarted StopWatch should throw an exception");     }      @Test     public void testLang315() {         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(200);         } catch (final InterruptedException ex) {             // ignore         }         watch.suspend();         final long suspendTime = watch.getTime();         try {             Thread.sleep(200);         } catch (final InterruptedException ex) {             // ignore         }         watch.stop();         final long totalTime = watch.getTime();         assertEquals(suspendTime, totalTime);     }      @Test     public void testMessage() {         assertNull(StopWatch.create().getMessage());         final StopWatch stopWatch = new StopWatch(MESSAGE);         assertEquals(MESSAGE, stopWatch.getMessage());         assertTrue(stopWatch.toString().startsWith(MESSAGE));         stopWatch.start();         stopWatch.split();         assertTrue(stopWatch.toSplitString().startsWith(MESSAGE));     }      @Test     public void testStopWatchGetWithTimeUnit() {         // Create a mock StopWatch with a time of 2:59:01.999         final StopWatch watch = createMockStopWatch(                 TimeUnit.HOURS.toNanos(2)                         + TimeUnit.MINUTES.toNanos(59)                         + TimeUnit.SECONDS.toNanos(1)                         + TimeUnit.MILLISECONDS.toNanos(999));          assertEquals(2L, watch.getTime(TimeUnit.HOURS));         assertEquals(179L, watch.getTime(TimeUnit.MINUTES));         assertEquals(10741L, watch.getTime(TimeUnit.SECONDS));         assertEquals(10741999L, watch.getTime(TimeUnit.MILLISECONDS));     }      @Test     public void testStopWatchSimple() {         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.stop();         final long time = watch.getTime();         assertEquals(time, watch.getTime());          assertTrue(time >= 500);         assertTrue(time < 700);          watch.reset();         assertEquals(0, watch.getTime());     }      @Test     public void testStopWatchSimpleGet() {         final StopWatch watch = new StopWatch();         assertEquals(0, watch.getTime());         assertEquals(ZERO_TIME_ELAPSED, watch.toString());          watch.start();         try {             Thread.sleep(500);         } catch (final InterruptedException ex) {             // ignore         }         assertTrue(watch.getTime() < 2000);     }      @Test     public void testStopWatchSplit() {         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.split();         final long splitTime = watch.getSplitTime();         final String splitStr = watch.toSplitString();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.unsplit();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.stop();         final long totalTime = watch.getTime();          assertEquals(splitStr.length(), 12, "Formatted split string not the correct length");         assertTrue(splitTime >= 500);         assertTrue(splitTime < 700);         assertTrue(totalTime >= 1500);         assertTrue(totalTime < 1900);     }      @Test     public void testStopWatchStatic() {         final StopWatch watch = StopWatch.createStarted();         assertTrue(watch.isStarted());     }      @Test     public void testStopWatchSuspend() {         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.suspend();         final long suspendTime = watch.getTime();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.resume();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.stop();         final long totalTime = watch.getTime();          assertTrue(suspendTime >= 500);         assertTrue(suspendTime < 700);         assertTrue(totalTime >= 1000);         assertTrue(totalTime < 1300);     }      @Test     public void testToSplitString() {         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.split();         final String splitStr = watch.toSplitString();         assertEquals(splitStr.length(), 12, "Formatted split string not the correct length");     }      @Test     public void testToSplitStringWithMessage() {         final StopWatch watch = new StopWatch(MESSAGE);         watch.start();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.split();         final String splitStr = watch.toSplitString();         assertEquals(splitStr.length(), 12 + MESSAGE.length() + 1, "Formatted split string not the correct length");     }      @Test     public void testToString() {         //         final StopWatch watch = StopWatch.createStarted();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.split();         final String splitStr = watch.toString();         assertEquals(splitStr.length(), 12, "Formatted split string not the correct length");     }      @Test     public void testToStringWithMessage() {         assertTrue(new StopWatch(MESSAGE).toString().startsWith(MESSAGE));         //         final StopWatch watch = new StopWatch(MESSAGE);         watch.start();         try {             Thread.sleep(550);         } catch (final InterruptedException ex) {             // ignore         }         watch.split();         final String splitStr = watch.toString();         assertEquals(splitStr.length(), 12 + MESSAGE.length() + 1, "Formatted split string not the correct length");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.TimeZone;  import org.junit.jupiter.api.Test;  /**  * Tests for FastTimeZone  */ public class FastTimeZoneTest {      private static final int HOURS_23 = 23 * 60 * 60 * 1000;     private static final int HOURS_2 = 2 * 60 * 60 * 1000;     private static final int MINUTES_59 = 59 * 60 * 1000;     private static final int MINUTES_5 = 5 * 60 * 1000;      @Test     public void testGetGmtTimeZone() {         assertEquals(0, FastTimeZone.getGmtTimeZone().getRawOffset());     }      @Test     public void testBareGmt() {         assertEquals(FastTimeZone.getGmtTimeZone(), FastTimeZone.getTimeZone("GMT"));     }      @Test     public void testZ() {         assertEquals(FastTimeZone.getGmtTimeZone(), FastTimeZone.getTimeZone("Z"));     }      @Test     public void testUTC() {         assertEquals(FastTimeZone.getGmtTimeZone(), FastTimeZone.getTimeZone("UTC"));     }      @Test     public void testZeroOffsetsReturnSingleton() {         assertEquals(FastTimeZone.getGmtTimeZone(), FastTimeZone.getTimeZone("+0"));         assertEquals(FastTimeZone.getGmtTimeZone(), FastTimeZone.getTimeZone("-0"));     }      @Test     public void testOlson() {         assertEquals(TimeZone.getTimeZone("America/New_York"), FastTimeZone.getTimeZone("America/New_York"));     }      @Test     public void testGmtPrefix() {         assertEquals(HOURS_23, FastTimeZone.getGmtTimeZone("GMT+23:00").getRawOffset());         assertEquals(-HOURS_23, FastTimeZone.getGmtTimeZone("GMT-23:00").getRawOffset());     }      @Test     public void testSign() {         assertEquals(HOURS_23, FastTimeZone.getGmtTimeZone("+23:00").getRawOffset());         assertEquals(HOURS_2, FastTimeZone.getGmtTimeZone("+2:00").getRawOffset());         assertEquals(-HOURS_23, FastTimeZone.getGmtTimeZone("-23:00").getRawOffset());         assertEquals(-HOURS_2, FastTimeZone.getGmtTimeZone("-2:00").getRawOffset());     }      @Test     public void testHoursColonMinutes() {         assertEquals(HOURS_23, FastTimeZone.getGmtTimeZone("23:00").getRawOffset());         assertEquals(HOURS_2, FastTimeZone.getGmtTimeZone("2:00").getRawOffset());         assertEquals(MINUTES_59, FastTimeZone.getGmtTimeZone("00:59").getRawOffset());         assertEquals(MINUTES_5, FastTimeZone.getGmtTimeZone("00:5").getRawOffset());         assertEquals(HOURS_23+MINUTES_59, FastTimeZone.getGmtTimeZone("23:59").getRawOffset());         assertEquals(HOURS_2+MINUTES_5, FastTimeZone.getGmtTimeZone("2:5").getRawOffset());     }      @Test     public void testHoursMinutes() {         assertEquals(HOURS_23, FastTimeZone.getGmtTimeZone("2300").getRawOffset());         assertEquals(HOURS_2, FastTimeZone.getGmtTimeZone("0200").getRawOffset());         assertEquals(MINUTES_59, FastTimeZone.getGmtTimeZone("0059").getRawOffset());         assertEquals(MINUTES_5, FastTimeZone.getGmtTimeZone("0005").getRawOffset());         assertEquals(HOURS_23+MINUTES_59, FastTimeZone.getGmtTimeZone("2359").getRawOffset());         assertEquals(HOURS_2+MINUTES_5, FastTimeZone.getGmtTimeZone("0205").getRawOffset());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import java.util.Locale; import java.util.TimeZone;  /**  * Unit tests for the print methods of FastDateFormat  *  * @since 3.2  */ public class FastDateFormat_PrinterTest extends FastDatePrinterTest {      @Override     protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {         return FastDateFormat.getInstance(format, timeZone, locale);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.Calendar; import java.util.Date;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  public class DateUtilsFragmentTest {      private static final int months = 7;   // second final prime before 12     private static final int days = 23;    // second final prime before 31 (and valid)     private static final int hours = 19;   // second final prime before 24     private static final int minutes = 53; // second final prime before 60     private static final int seconds = 47; // third final prime before 60     private static final int millis = 991; // second final prime before 1000      private Date aDate;     private Calendar aCalendar;       @BeforeEach     public void setUp() {         aCalendar = Calendar.getInstance();         aCalendar.set(2005, months, days, hours, minutes, seconds);         aCalendar.set(Calendar.MILLISECOND, millis);         aDate = aCalendar.getTime();     }      @Test     public void testNullDate() {         assertThrows(                 NullPointerException.class,                 () -> DateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND));          assertThrows(                 NullPointerException.class,                 () -> DateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND));          assertThrows(                 NullPointerException.class,                 () -> DateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND));          assertThrows(                 NullPointerException.class,                 () -> DateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND));          assertThrows(                 NullPointerException.class,                 () -> DateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND));     }      @Test     public void testNullCalendar() {         assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND));          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND));          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND));          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND));          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND));     }      @Test     public void testInvalidFragmentWithDate() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMilliseconds(aDate, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInSeconds(aDate, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMinutes(aDate, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInHours(aDate, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInDays(aDate, 0));     }      @Test     public void testInvalidFragmentWithCalendar() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMilliseconds(aCalendar, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInSeconds(aCalendar, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMinutes(aCalendar, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInHours(aCalendar, 0));         assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInDays(aCalendar, 0));     }      @Test     public void testMillisecondFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInMilliseconds(aDate, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MILLISECOND));     }      @Test     public void testMillisecondFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND));         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND));     }      @Test     public void testSecondFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.SECOND));     }      @Test     public void testSecondFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.SECOND));         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.SECOND));     }      @Test     public void testMinuteFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MINUTE));         assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MINUTE));         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MINUTE));     }      @Test     public void testMinuteFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MINUTE));         assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MINUTE));         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MINUTE));     }      @Test     public void testHourOfDayFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.HOUR_OF_DAY));         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.HOUR_OF_DAY));     }      @Test     public void testHourOfDayFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.HOUR_OF_DAY));         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.HOUR_OF_DAY));     }      @Test     public void testDayOfYearFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DAY_OF_YEAR));     }      @Test     public void testDayOfYearFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DAY_OF_YEAR));     }      @Test     public void testDateFragmentInLargerUnitWithDate() {         assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DATE));     }      @Test     public void testDateFragmentInLargerUnitWithCalendar() {         assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DATE));     }      //Calendar.SECOND as useful fragment      @Test     public void testMillisecondsOfSecondWithDate() {         final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);         assertEquals(millis, testResult);     }      @Test     public void testMillisecondsOfSecondWithCalendar() {         final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);         assertEquals(millis, testResult);         assertEquals(aCalendar.get(Calendar.MILLISECOND), testResult);     }      //Calendar.MINUTE as useful fragment      @Test     public void testMillisecondsOfMinuteWithDate() {         final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);     }      @Test     public void testMillisecondsOfMinuteWithCalender() {         final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);     }      @Test     public void testSecondsofMinuteWithDate() {         final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);         assertEquals(seconds, testResult);     }      @Test     public void testSecondsofMinuteWithCalendar() {         final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);         assertEquals(seconds, testResult);         assertEquals(aCalendar.get(Calendar.SECOND), testResult);     }      //Calendar.HOUR_OF_DAY as useful fragment      @Test     public void testMillisecondsOfHourWithDate() {         final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);     }      @Test     public void testMillisecondsOfHourWithCalendar() {         final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);     }      @Test     public void testSecondsofHourWithDate() {         final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);         assertEquals(                 seconds                         + (minutes                                 * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),                 testResult);     }      @Test     public void testSecondsofHourWithCalendar() {         final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);         assertEquals(                 seconds                         + (minutes                                 * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),                 testResult);     }      @Test     public void testMinutesOfHourWithDate() {         final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);         assertEquals(minutes, testResult);     }      @Test     public void testMinutesOfHourWithCalendar() {         final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);         assertEquals(minutes, testResult);     }      //Calendar.DATE and Calendar.DAY_OF_YEAR as useful fragment     @Test     public void testMillisecondsOfDayWithDate() {         long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);         final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR);         assertEquals(expectedValue, testresult);         testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testresult);     }      @Test     public void testMillisecondsOfDayWithCalendar() {         long testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE);         final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR);         assertEquals(expectedValue, testresult);         testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testresult);     }      @Test     public void testSecondsOfDayWithDate() {         long testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE);         final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;         assertEquals(expectedValue, testresult);         testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testresult);     }      @Test     public void testSecondsOfDayWithCalendar() {         long testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE);         final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;         assertEquals(expectedValue, testresult);         testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testresult);     }      @Test     public void testMinutesOfDayWithDate() {         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE);         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;         assertEquals(expectedValue, testResult);         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testResult);     }      @Test     public void testMinutesOfDayWithCalendar() {         long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE);         final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;         assertEquals(expectedValue, testResult);         testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testResult);     }      @Test     public void testHoursOfDayWithDate() {         long testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE);         final long expectedValue = hours;         assertEquals(expectedValue, testResult);         testResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testResult);     }      @Test     public void testHoursOfDayWithCalendar() {         long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE);         final long expectedValue = hours;         assertEquals(expectedValue, testResult);         testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR);         assertEquals(expectedValue, testResult);     }       //Calendar.MONTH as useful fragment     @Test     public void testMillisecondsOfMonthWithDate() {         final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY),                 testResult);     }      @Test     public void testMillisecondsOfMonthWithCalendar() {         final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY), testResult);     }      @Test     public void testSecondsOfMonthWithDate() {         final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);         assertEquals(                 seconds                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_SECOND,                 testResult);     }      @Test     public void testSecondsOfMonthWithCalendar() {         final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);         assertEquals(                 seconds                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_SECOND,                 testResult);     }      @Test     public void testMinutesOfMonthWithDate() {         final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);         assertEquals(minutes                                 + ((hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_MINUTE,                 testResult);     }      @Test     public void testMinutesOfMonthWithCalendar() {         final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);         assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_MINUTE,                 testResult);     }      @Test     public void testHoursOfMonthWithDate() {         final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);         assertEquals(hours + (((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_HOUR,                 testResult);     }      @Test     public void testHoursOfMonthWithCalendar() {         final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);         assertEquals( hours +(((days - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_HOUR,                 testResult);     }      //Calendar.YEAR as useful fragment     @Test     public void testMillisecondsOfYearWithDate() {         final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((cal.get(Calendar.DAY_OF_YEAR) - 1)* DateUtils.MILLIS_PER_DAY),                 testResult);     }      @Test     public void testMillisecondsOfYearWithCalendar() {         final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((aCalendar.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY), testResult);     }      @Test     public void testSecondsOfYearWithDate() {         final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(                 seconds                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((cal.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_SECOND,                 testResult);     }      @Test     public void testSecondsOfYearWithCalendar() {         final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR);         assertEquals(                 seconds                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)                                 + (hours * DateUtils.MILLIS_PER_HOUR) + ((aCalendar.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_SECOND,                 testResult);     }      @Test     public void testMinutesOfYearWithDate() {         final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(minutes                                 + ((hours * DateUtils.MILLIS_PER_HOUR) + ((cal.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_MINUTE,                 testResult);     }      @Test     public void testMinutesOfYearWithCalendar() {         final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR);         assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + ((aCalendar.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_MINUTE,                 testResult);     }      @Test     public void testMinutesOfYearWithWrongOffsetBugWithCalendar() {         final Calendar c = Calendar.getInstance();         c.set(Calendar.MONTH, Calendar.JANUARY);         c.set(Calendar.DAY_OF_YEAR, 1);         c.set(Calendar.HOUR_OF_DAY, 0);         c.set(Calendar.MINUTE, 0);         c.set(Calendar.SECOND, 0);         c.set(Calendar.MILLISECOND, 0);         final long testResult = DateUtils.getFragmentInMinutes(c, Calendar.YEAR);         assertEquals( 0, testResult);     }      @Test     public void testHoursOfYearWithDate() {         final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(hours + (((cal.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_HOUR,                 testResult);     }      @Test     public void testHoursOfYearWithCalendar() {         final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR);         assertEquals( hours +(((aCalendar.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY))                         / DateUtils.MILLIS_PER_HOUR,                 testResult);     }      @Test     public void testDaysOfMonthWithCalendar() {         final long testResult = DateUtils.getFragmentInDays(aCalendar, Calendar.MONTH);         assertEquals(days, testResult);     }      @Test     public void testDaysOfMonthWithDate() {         final long testResult = DateUtils.getFragmentInDays(aDate, Calendar.MONTH);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(cal.get(Calendar.DAY_OF_MONTH), testResult);     }      @Test     public void testDaysOfYearWithCalendar() {         final long testResult = DateUtils.getFragmentInDays(aCalendar, Calendar.YEAR);         assertEquals(aCalendar.get(Calendar.DAY_OF_YEAR), testResult);     }      @Test     public void testDaysOfYearWithDate() {         final long testResult = DateUtils.getFragmentInDays(aDate, Calendar.YEAR);         final Calendar cal = Calendar.getInstance();         cal.setTime(aDate);         assertEquals(cal.get(Calendar.DAY_OF_YEAR), testResult);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.fail;  import java.text.FieldPosition; import java.text.Format; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; import java.util.TimeZone; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLongArray;  import org.junit.jupiter.api.Test; import org.junitpioneer.jupiter.DefaultLocale; import org.junitpioneer.jupiter.DefaultTimeZone;  /**  * Unit tests {@link org.apache.commons.lang3.time.FastDateFormat}.  *  * @since 2.0  */ public class FastDateFormatTest {     /*      * Only the cache methods need to be tested here.      * The print methods are tested by {@link FastDateFormat_PrinterTest}      * and the parse methods are tested by {@link FastDateFormat_ParserTest}      */     @Test     public void test_getInstance() {         final FastDateFormat format1 = FastDateFormat.getInstance();         final FastDateFormat format2 = FastDateFormat.getInstance();         assertSame(format1, format2);     }      @Test     public void test_getInstance_String() {         final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy");         final FastDateFormat format2 = FastDateFormat.getInstance("MM-DD-yyyy");         final FastDateFormat format3 = FastDateFormat.getInstance("MM-DD-yyyy");          assertNotSame(format1, format2);         assertSame(format2, format3);         assertEquals("MM/DD/yyyy", format1.getPattern());         assertEquals(TimeZone.getDefault(), format1.getTimeZone());         assertEquals(TimeZone.getDefault(), format2.getTimeZone());     }      @DefaultLocale(language = "en", country = "US")     @DefaultTimeZone("America/New_York")     @Test     public void test_getInstance_String_TimeZone() {          final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",                 TimeZone.getTimeZone("Atlantic/Reykjavik"));         final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");         final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());         final FastDateFormat format4 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());         final FastDateFormat format5 = FastDateFormat.getInstance("MM-DD-yyyy", TimeZone.getDefault());         final FastDateFormat format6 = FastDateFormat.getInstance("MM-DD-yyyy");          assertNotSame(format1, format2);         assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());         assertEquals(TimeZone.getDefault(), format2.getTimeZone());         assertSame(format3, format4);         assertNotSame(format3, format5);         assertNotSame(format4, format6);     }      @DefaultLocale(language = "en", country = "US")     @Test     public void test_getInstance_String_Locale() {         final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);         final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");         final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);          assertNotSame(format1, format2);         assertSame(format1, format3);         assertEquals(Locale.GERMANY, format1.getLocale());     }      @DefaultLocale(language = "en", country = "US")     @Test     public void test_changeDefault_Locale_DateInstance() {         final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);         final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);         Locale.setDefault(Locale.GERMANY);         final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);          assertSame(Locale.GERMANY, format1.getLocale());         assertEquals(Locale.US, format2.getLocale());         assertSame(Locale.GERMANY, format3.getLocale());         assertNotSame(format1, format2);         assertNotSame(format2, format3);     }      @DefaultLocale(language = "en", country = "US")     @Test     public void test_changeDefault_Locale_DateTimeInstance() {         final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);         final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);         Locale.setDefault(Locale.GERMANY);         final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);          assertSame(Locale.GERMANY, format1.getLocale());         assertEquals(Locale.US, format2.getLocale());         assertSame(Locale.GERMANY, format3.getLocale());         assertNotSame(format1, format2);         assertNotSame(format2, format3);     }      @DefaultLocale(language = "en", country = "US")     @DefaultTimeZone("America/New_York")     @Test     public void test_getInstance_String_TimeZone_Locale() {         final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",                 TimeZone.getTimeZone("Atlantic/Reykjavik"), Locale.GERMANY);         final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);         final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy",                 TimeZone.getDefault(), Locale.GERMANY);          assertNotSame(format1, format2);         assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());         assertEquals(TimeZone.getDefault(), format2.getTimeZone());         assertEquals(TimeZone.getDefault(), format3.getTimeZone());         assertEquals(Locale.GERMANY, format1.getLocale());         assertEquals(Locale.GERMANY, format2.getLocale());         assertEquals(Locale.GERMANY, format3.getLocale());     }      @Test     public void testCheckDefaults() {         final FastDateFormat format = FastDateFormat.getInstance();         final FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT);         assertEquals(medium, format);          final SimpleDateFormat sdf = new SimpleDateFormat();         assertEquals(sdf.toPattern(), format.getPattern());          assertEquals(Locale.getDefault(), format.getLocale());         assertEquals(TimeZone.getDefault(), format.getTimeZone());     }      @Test     public void testCheckDifferingStyles() {         final FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US);         final FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US);         final FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US);         final FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US);          assertNotEquals(shortShort, shortLong);         assertNotEquals(shortShort, longShort);         assertNotEquals(shortShort, longLong);         assertNotEquals(shortLong, longShort);         assertNotEquals(shortLong, longLong);         assertNotEquals(longShort, longLong);     }      @Test     public void testDateDefaults() {         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA),                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));          assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")),                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault()));          assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG),                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));     }      @Test     public void testTimeDefaults() {         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA),                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));          assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York")),                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone("America/New_York"), Locale.getDefault()));          assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG),                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));     }      @Test     public void testTimeDateDefaults() {         assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA),                 FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA));          assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York")),                 FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone("America/New_York"), Locale.getDefault()));          assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM),                 FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault()));     }      @Test     public void testParseSync() throws InterruptedException {         final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS";         final SimpleDateFormat inner = new SimpleDateFormat(pattern);         final Format sdf= new Format() {             private static final long serialVersionUID = 1L;              @Override             public StringBuffer format(final Object obj,                     final StringBuffer toAppendTo,                     final FieldPosition fieldPosition) {                 synchronized(this) {                     return inner.format(obj, toAppendTo, fieldPosition);                 }             }              @Override             public Object parseObject(final String source, final ParsePosition pos) {                 synchronized(this) {                     return inner.parseObject(source, pos);                 }             }         };         final AtomicLongArray sdfTime= measureTime(sdf, sdf);          final Format fdf = FastDateFormat.getInstance(pattern);         final AtomicLongArray fdfTime= measureTime(fdf, fdf);          //System.out.println(">>FastDateFormatTest: FastDatePrinter:"+fdfTime.get(0)+"  SimpleDateFormat:"+sdfTime.get(0));         //System.out.println(">>FastDateFormatTest: FastDateParser:"+fdfTime.get(1)+"  SimpleDateFormat:"+sdfTime.get(1));     }      private static final int NTHREADS = 10;     private static final int NROUNDS = 10000;      private AtomicLongArray measureTime(final Format printer, final Format parser) throws InterruptedException {         final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS);         final AtomicInteger failures = new AtomicInteger(0);         final AtomicLongArray totalElapsed = new AtomicLongArray(2);         try {             for (int i = 0; i < NTHREADS; ++i) {                 pool.submit(() -> {                     for (int j = 0; j < NROUNDS; ++j) {                         try {                             final Date date = new Date();                              final long t0 = System.currentTimeMillis();                             final String formattedDate = printer.format(date);                             totalElapsed.addAndGet(0, System.currentTimeMillis() - t0);                              final long t1 = System.currentTimeMillis();                             final Object pd = parser.parseObject(formattedDate);                             totalElapsed.addAndGet(1, System.currentTimeMillis() - t1);                              if (!date.equals(pd)) {                                 failures.incrementAndGet();                             }                         } catch (final Exception e) {                             failures.incrementAndGet();                             e.printStackTrace();                         }                     }                 });             }         } finally {             pool.shutdown();             // depending on the performance of the machine used to run the parsing,             // the tests can run for a while. It should however complete within             // 30 seconds. Might need increase on very slow machines.             if (!pool.awaitTermination(30, TimeUnit.SECONDS)) {                 pool.shutdownNow();                 fail("did not complete tasks");             }         }         assertEquals(0, failures.get());         return totalElapsed;     }      /**      * According to LANG-954 (https://issues.apache.org/jira/browse/LANG-954) this is broken in Android 2.1.      */     @Test     public void testLANG_954() {         final String pattern = "yyyy-MM-dd'T'";         FastDateFormat.getInstance(pattern);     }      @Test     public void testLANG_1152() {         final TimeZone utc = FastTimeZone.getGmtTimeZone();         final Date date = new Date(Long.MAX_VALUE);          String dateAsString = FastDateFormat.getInstance("yyyy-MM-dd", utc, Locale.US).format(date);         assertEquals("292278994-08-17", dateAsString);          dateAsString = FastDateFormat.getInstance("dd/MM/yyyy", utc, Locale.US).format(date);         assertEquals("17/08/292278994", dateAsString);     }      @Test     public void testLANG_1267() {         FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Iterator; import java.util.Locale; import java.util.NoSuchElementException; import java.util.TimeZone;  import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junitpioneer.jupiter.DefaultLocale;  /**  * Unit tests {@link org.apache.commons.lang3.time.DateUtils}.  */ public class DateUtilsTest {      private static Date BASE_DATE;      @BeforeAll     public static void classSetup() {         final GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2);         cal.set(Calendar.MILLISECOND, 1);         BASE_DATE = cal.getTime();     }      private DateFormat dateParser = null;     private DateFormat dateTimeParser = null;     private Date dateAmPm1 = null;     private Date dateAmPm2 = null;     private Date dateAmPm3 = null;     private Date dateAmPm4 = null;     private Date date0 = null;     private Date date1 = null;     private Date date2 = null;     private Date date3 = null;     private Date date4 = null;     private Date date5 = null;     private Date date6 = null;     private Date date7 = null;     private Date date8 = null;     private Calendar calAmPm1 = null;     private Calendar calAmPm2 = null;     private Calendar calAmPm3 = null;     private Calendar calAmPm4 = null;     private Calendar cal1 = null;     private Calendar cal2 = null;     private Calendar cal3 = null;     private Calendar cal4 = null;     private Calendar cal5 = null;     private Calendar cal6 = null;     private Calendar cal7 = null;     private Calendar cal8 = null;     private TimeZone zone = null;     private TimeZone defaultZone = null;      @BeforeEach     public void setUp() throws Exception {         dateParser = new SimpleDateFormat("MMM dd, yyyy", Locale.ENGLISH);         dateTimeParser = new SimpleDateFormat("MMM dd, yyyy H:mm:ss.SSS", Locale.ENGLISH);          dateAmPm1 = dateTimeParser.parse("February 3, 2002 01:10:00.000");         dateAmPm2 = dateTimeParser.parse("February 3, 2002 11:10:00.000");         dateAmPm3 = dateTimeParser.parse("February 3, 2002 13:10:00.000");         dateAmPm4 = dateTimeParser.parse("February 3, 2002 19:10:00.000");         date0 = dateTimeParser.parse("February 3, 2002 12:34:56.789");         date1 = dateTimeParser.parse("February 12, 2002 12:34:56.789");         date2 = dateTimeParser.parse("November 18, 2001 1:23:11.321");         defaultZone = TimeZone.getDefault();         zone = TimeZone.getTimeZone("MET");         try {             TimeZone.setDefault(zone);             dateTimeParser.setTimeZone(zone);             date3 = dateTimeParser.parse("March 30, 2003 05:30:45.000");             date4 = dateTimeParser.parse("March 30, 2003 01:10:00.000");             date5 = dateTimeParser.parse("March 30, 2003 01:40:00.000");             date6 = dateTimeParser.parse("March 30, 2003 02:10:00.000");             date7 = dateTimeParser.parse("March 30, 2003 02:40:00.000");             date8 = dateTimeParser.parse("October 26, 2003 05:30:45.000");         } finally {             dateTimeParser.setTimeZone(defaultZone);             TimeZone.setDefault(defaultZone);         }         calAmPm1 = Calendar.getInstance();         calAmPm1.setTime(dateAmPm1);         calAmPm2 = Calendar.getInstance();         calAmPm2.setTime(dateAmPm2);         calAmPm3 = Calendar.getInstance();         calAmPm3.setTime(dateAmPm3);         calAmPm4 = Calendar.getInstance();         calAmPm4.setTime(dateAmPm4);         cal1 = Calendar.getInstance();         cal1.setTime(date1);         cal2 = Calendar.getInstance();         cal2.setTime(date2);         try {             TimeZone.setDefault(zone);             cal3 = Calendar.getInstance();             cal3.setTime(date3);             cal4 = Calendar.getInstance();             cal4.setTime(date4);             cal5 = Calendar.getInstance();             cal5.setTime(date5);             cal6 = Calendar.getInstance();             cal6.setTime(date6);             cal7 = Calendar.getInstance();             cal7.setTime(date7);             cal8 = Calendar.getInstance();             cal8.setTime(date8);         } finally {             TimeZone.setDefault(defaultZone);         }     }      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new DateUtils());         final Constructor<?>[] cons = DateUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(DateUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(DateUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testIsSameDay_Date() {         Date datea = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();         Date dateb = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();         assertTrue(DateUtils.isSameDay(datea, dateb));         dateb = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();         assertFalse(DateUtils.isSameDay(datea, dateb));         datea = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();         assertTrue(DateUtils.isSameDay(datea, dateb));         dateb = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();         assertFalse(DateUtils.isSameDay(datea, dateb));     }      @Test     public void testIsSameDay_DateNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay((Date) null, null));     }      @Test     public void testIsSameDay_DateNullNotNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay(null, new Date()));     }      @Test     public void testIsSameDay_DateNotNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay(new Date(), null));     }      //-----------------------------------------------------------------------     @Test     public void testIsSameDay_Cal() {         final GregorianCalendar cala = new GregorianCalendar(2004, 6, 9, 13, 45);         final GregorianCalendar calb = new GregorianCalendar(2004, 6, 9, 13, 45);         assertTrue(DateUtils.isSameDay(cala, calb));         calb.add(Calendar.DAY_OF_YEAR, 1);         assertFalse(DateUtils.isSameDay(cala, calb));         cala.add(Calendar.DAY_OF_YEAR, 1);         assertTrue(DateUtils.isSameDay(cala, calb));         calb.add(Calendar.YEAR, 1);         assertFalse(DateUtils.isSameDay(cala, calb));     }      @Test     public void testIsSameDay_CalNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay((Calendar) null, null));     }      @Test     public void testIsSameDay_CalNullNotNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay(null, Calendar.getInstance()));     }      @Test     public void testIsSameDay_CalNotNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameDay(Calendar.getInstance(), null));     }      //-----------------------------------------------------------------------     @Test     public void testIsSameInstant_Date() {         Date datea = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();         Date dateb = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();         assertTrue(DateUtils.isSameInstant(datea, dateb));         dateb = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();         assertFalse(DateUtils.isSameInstant(datea, dateb));         datea = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();         assertTrue(DateUtils.isSameInstant(datea, dateb));         dateb = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();         assertFalse(DateUtils.isSameInstant(datea, dateb));     }      @Test     public void testIsSameInstant_DateNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant((Date) null, null));     }      @Test     public void testIsSameInstant_DateNullNotNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant(null, new Date()));     }      @Test     public void testIsSameInstant_DateNotNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant(new Date(), null));     }      //-----------------------------------------------------------------------     @Test     public void testIsSameInstant_Cal() {         final GregorianCalendar cala = new GregorianCalendar(TimeZone.getTimeZone("GMT+1"));         final GregorianCalendar calb = new GregorianCalendar(TimeZone.getTimeZone("GMT-1"));         cala.set(2004, Calendar.JULY, 9, 13, 45, 0);         cala.set(Calendar.MILLISECOND, 0);         calb.set(2004, Calendar.JULY, 9, 13, 45, 0);         calb.set(Calendar.MILLISECOND, 0);         assertFalse(DateUtils.isSameInstant(cala, calb));          calb.set(2004, Calendar.JULY, 9, 11, 45, 0);         assertTrue(DateUtils.isSameInstant(cala, calb));     }      @Test     public void testIsSameInstant_CalNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant((Calendar) null, null));     }      @Test     public void testIsSameInstant_CalNullNotNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant(null, Calendar.getInstance()));     }      @Test     public void testIsSameInstant_CalNotNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameInstant(Calendar.getInstance(), null));     }      //-----------------------------------------------------------------------     @Test     public void testIsSameLocalTime_Cal() {         final GregorianCalendar cala = new GregorianCalendar(TimeZone.getTimeZone("GMT+1"));         final GregorianCalendar calb = new GregorianCalendar(TimeZone.getTimeZone("GMT-1"));         cala.set(2004, Calendar.JULY, 9, 13, 45, 0);         cala.set(Calendar.MILLISECOND, 0);         calb.set(2004, Calendar.JULY, 9, 13, 45, 0);         calb.set(Calendar.MILLISECOND, 0);         assertTrue(DateUtils.isSameLocalTime(cala, calb));          final Calendar calc = Calendar.getInstance();         final Calendar cald = Calendar.getInstance();         calc.set(2004, Calendar.JULY, 9, 4,  0, 0);         cald.set(2004, Calendar.JULY, 9, 16, 0, 0);         calc.set(Calendar.MILLISECOND, 0);         cald.set(Calendar.MILLISECOND, 0);         assertFalse(DateUtils.isSameLocalTime(calc, cald), "LANG-677");          calb.set(2004, Calendar.JULY, 9, 11, 45, 0);         assertFalse(DateUtils.isSameLocalTime(cala, calb));     }      @Test     public void testIsSameLocalTime_CalNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameLocalTime(null, null));     }      @Test     public void testIsSameLocalTime_CalNullNotNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameLocalTime(null, Calendar.getInstance()));     }      @Test     public void testIsSameLocalTime_CalNotNullNull() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.isSameLocalTime(Calendar.getInstance(), null));     }      //-----------------------------------------------------------------------     @Test     public void testParseDate() throws Exception {         final GregorianCalendar cal = new GregorianCalendar(1972, 11, 3);         String dateStr = "1972-12-03";         final String[] parsers = new String[] {"yyyy'-'DDD", "yyyy'-'MM'-'dd", "yyyyMMdd"};         Date date = DateUtils.parseDate(dateStr, parsers);         assertEquals(cal.getTime(), date);          dateStr = "1972-338";         date = DateUtils.parseDate(dateStr, parsers);         assertEquals(cal.getTime(), date);          dateStr = "19721203";         date = DateUtils.parseDate(dateStr, parsers);         assertEquals(cal.getTime(), date);     }      @Test     public void testParseDate_NoDateString() {         final String[] parsers = new String[] {"yyyy'-'DDD", "yyyy'-'MM'-'dd", "yyyyMMdd"};         assertThrows(ParseException.class, () -> DateUtils.parseDate("PURPLE", parsers));     }      @Test     public void testParseDate_InvalidDateString() {         final String[] parsers = new String[] {"yyyy'-'DDD", "yyyy'-'MM'-'dd", "yyyyMMdd"};         assertThrows(ParseException.class, () -> DateUtils.parseDate("197212AB", parsers));     }      @Test     public void testParseDate_Null() {         final String[] parsers = new String[] {"yyyy'-'DDD", "yyyy'-'MM'-'dd", "yyyyMMdd"};         assertThrows(IllegalArgumentException.class, () -> DateUtils.parseDate(null, parsers));     }      @Test     public void testParse_NullParsers() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.parseDate("19721203", (String[]) null));     }      @Test     public void testParse_EmptyParsers() {         assertThrows(ParseException.class, () -> DateUtils.parseDate("19721203"));     }      // LANG-486     @Test     public void testParseDateWithLeniency() throws Exception {         final GregorianCalendar cal = new GregorianCalendar(1998, 6, 30);         final String dateStr = "02 942, 1996";         final String[] parsers = new String[] {"MM DDD, yyyy"};          final Date date = DateUtils.parseDate(dateStr, parsers);         assertEquals(cal.getTime(), date);          assertThrows(ParseException.class, () -> DateUtils.parseDateStrictly(dateStr, parsers));     }      //-----------------------------------------------------------------------     @Test     public void testAddYears() throws Exception {         Date result = DateUtils.addYears(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addYears(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2001, 6, 5, 4, 3, 2, 1);          result = DateUtils.addYears(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 1999, 6, 5, 4, 3, 2, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddMonths() throws Exception {         Date result = DateUtils.addMonths(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addMonths(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 7, 5, 4, 3, 2, 1);          result = DateUtils.addMonths(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 5, 5, 4, 3, 2, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddWeeks() throws Exception {         Date result = DateUtils.addWeeks(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addWeeks(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 12, 4, 3, 2, 1);          result = DateUtils.addWeeks(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);      // july         assertDate(result, 2000, 5, 28, 4, 3, 2, 1);   // june     }      //-----------------------------------------------------------------------     @Test     public void testAddDays() throws Exception {         Date result = DateUtils.addDays(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addDays(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 6, 4, 3, 2, 1);          result = DateUtils.addDays(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 4, 4, 3, 2, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddHours() throws Exception {         Date result = DateUtils.addHours(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addHours(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 5, 3, 2, 1);          result = DateUtils.addHours(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 3, 3, 2, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddMinutes() throws Exception {         Date result = DateUtils.addMinutes(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addMinutes(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 4, 2, 1);          result = DateUtils.addMinutes(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 2, 2, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddSeconds() throws Exception {         Date result = DateUtils.addSeconds(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addSeconds(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 3, 1);          result = DateUtils.addSeconds(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 1, 1);     }      //-----------------------------------------------------------------------     @Test     public void testAddMilliseconds() throws Exception {         Date result = DateUtils.addMilliseconds(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.addMilliseconds(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 2);          result = DateUtils.addMilliseconds(BASE_DATE, -1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 0);     }      // -----------------------------------------------------------------------     @Test     public void testSetYears() throws Exception {         Date result = DateUtils.setYears(BASE_DATE, 2000);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 1);          result = DateUtils.setYears(BASE_DATE, 2008);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2008, 6, 5, 4, 3, 2, 1);          result = DateUtils.setYears(BASE_DATE, 2005);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2005, 6, 5, 4, 3, 2, 1);     }      // -----------------------------------------------------------------------     @Test     public void testSetMonths() throws Exception {         Date result = DateUtils.setMonths(BASE_DATE, 5);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 5, 5, 4, 3, 2, 1);          result = DateUtils.setMonths(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 1, 5, 4, 3, 2, 1);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setMonths(BASE_DATE, 12),                 "DateUtils.setMonths did not throw an expected IllegalArgumentException.");     }      // -----------------------------------------------------------------------     @Test     public void testSetDays() throws Exception {         Date result = DateUtils.setDays(BASE_DATE, 1);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 1, 4, 3, 2, 1);          result = DateUtils.setDays(BASE_DATE, 29);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 29, 4, 3, 2, 1);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setDays(BASE_DATE, 32),                 "DateUtils.setDays did not throw an expected IllegalArgumentException.");     }      // -----------------------------------------------------------------------     @Test     public void testSetHours() throws Exception {         Date result = DateUtils.setHours(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 0, 3, 2, 1);          result = DateUtils.setHours(BASE_DATE, 23);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 23, 3, 2, 1);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setHours(BASE_DATE, 24),                 "DateUtils.setHours did not throw an expected IllegalArgumentException.");     }      // -----------------------------------------------------------------------     @Test     public void testSetMinutes() throws Exception {         Date result = DateUtils.setMinutes(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 0, 2, 1);          result = DateUtils.setMinutes(BASE_DATE, 59);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 59, 2, 1);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setMinutes(BASE_DATE, 60),                 "DateUtils.setMinutes did not throw an expected IllegalArgumentException.");     }      // -----------------------------------------------------------------------     @Test     public void testSetSeconds() throws Exception {         Date result = DateUtils.setSeconds(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 0, 1);          result = DateUtils.setSeconds(BASE_DATE, 59);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 59, 1);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setSeconds(BASE_DATE, 60),                 "DateUtils.setSeconds did not throw an expected IllegalArgumentException.");     }      // -----------------------------------------------------------------------     @Test     public void testSetMilliseconds() throws Exception {         Date result = DateUtils.setMilliseconds(BASE_DATE, 0);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 0);          result = DateUtils.setMilliseconds(BASE_DATE, 999);         assertNotSame(BASE_DATE, result);         assertDate(BASE_DATE, 2000, 6, 5, 4, 3, 2, 1);         assertDate(result, 2000, 6, 5, 4, 3, 2, 999);          assertThrows(                 IllegalArgumentException.class,                 () -> DateUtils.setMilliseconds(BASE_DATE, 1000),                 "DateUtils.setMilliseconds did not throw an expected IllegalArgumentException.");     }      //-----------------------------------------------------------------------     private void assertDate(final Date date, final int year, final int month, final int day, final int hour, final int min, final int sec, final int mil) {         final GregorianCalendar cal = new GregorianCalendar();         cal.setTime(date);         assertEquals(year, cal.get(Calendar.YEAR));         assertEquals(month, cal.get(Calendar.MONTH));         assertEquals(day, cal.get(Calendar.DAY_OF_MONTH));         assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));         assertEquals(min, cal.get(Calendar.MINUTE));         assertEquals(sec, cal.get(Calendar.SECOND));         assertEquals(mil, cal.get(Calendar.MILLISECOND));     }      //-----------------------------------------------------------------------     @Test     public void testToCalendar() {         assertEquals(date1, DateUtils.toCalendar(date1).getTime(), "Failed to convert to a Calendar and back");         assertThrows(NullPointerException.class, () -> DateUtils.toCalendar(null));     }      //-----------------------------------------------------------------------     @Test     public void testToCalendarWithDateNull() {         assertThrows(NullPointerException.class, () -> DateUtils.toCalendar(null, zone));     }      //-----------------------------------------------------------------------     @Test     public void testToCalendarWithTimeZoneNull() {         assertThrows(NullPointerException.class, () -> DateUtils.toCalendar(date1, null));     }      //-----------------------------------------------------------------------     @Test     public void testToCalendarWithDateAndTimeZoneNotNull() {         final Calendar c = DateUtils.toCalendar(date2, defaultZone);         assertEquals(date2, c.getTime(), "Convert Date and TimeZone to a Calendar, but failed to get the Date back");         assertEquals(defaultZone, c.getTimeZone(), "Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back");     }      //-----------------------------------------------------------------------     @Test     public void testToCalendarWithDateAndTimeZoneNull() {         assertThrows(NullPointerException.class, () -> DateUtils.toCalendar(null, null));     }      //-----------------------------------------------------------------------     /**      * Tests various values with the round method      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testRound() throws Exception {         // tests for public static Date round(Date date, int field)         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.round(date1, Calendar.YEAR),                 "round year-1 failed");         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.round(date2, Calendar.YEAR),                 "round year-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.round(date1, Calendar.MONTH),                 "round month-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.round(date2, Calendar.MONTH),                 "round month-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.round(date0, DateUtils.SEMI_MONTH),                 "round semimonth-0 failed");         assertEquals(dateParser.parse("February 16, 2002"),                 DateUtils.round(date1, DateUtils.SEMI_MONTH),                 "round semimonth-1 failed");         assertEquals(dateParser.parse("November 16, 2001"),                 DateUtils.round(date2, DateUtils.SEMI_MONTH),                 "round semimonth-2 failed");           assertEquals(dateParser.parse("February 13, 2002"),                 DateUtils.round(date1, Calendar.DATE),                 "round date-1 failed");         assertEquals(dateParser.parse("November 18, 2001"),                 DateUtils.round(date2, Calendar.DATE),                 "round date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 13:00:00.000"),                 DateUtils.round(date1, Calendar.HOUR),                 "round hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:00:00.000"),                 DateUtils.round(date2, Calendar.HOUR),                 "round hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:35:00.000"),                 DateUtils.round(date1, Calendar.MINUTE),                 "round minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:00.000"),                 DateUtils.round(date2, Calendar.MINUTE),                 "round minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.round(date1, Calendar.SECOND),                 "round second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.round(date2, Calendar.SECOND),                 "round second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.round(dateAmPm1, Calendar.AM_PM),                 "round ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round(dateAmPm2, Calendar.AM_PM),                 "round ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round(dateAmPm3, Calendar.AM_PM),                 "round ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.round(dateAmPm4, Calendar.AM_PM),                 "round ampm-4 failed");          // tests for public static Date round(Object date, int field)         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.round((Object) date1, Calendar.YEAR),                 "round year-1 failed");         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.round((Object) date2, Calendar.YEAR),                 "round year-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.round((Object) date1, Calendar.MONTH),                 "round month-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.round((Object) date2, Calendar.MONTH),                 "round month-2 failed");         assertEquals(dateParser.parse("February 16, 2002"),                 DateUtils.round((Object) date1, DateUtils.SEMI_MONTH),                 "round semimonth-1 failed");         assertEquals(dateParser.parse("November 16, 2001"),                 DateUtils.round((Object) date2, DateUtils.SEMI_MONTH),                 "round semimonth-2 failed");         assertEquals(dateParser.parse("February 13, 2002"),                 DateUtils.round((Object) date1, Calendar.DATE),                 "round date-1 failed");         assertEquals(dateParser.parse("November 18, 2001"),                 DateUtils.round((Object) date2, Calendar.DATE),                 "round date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 13:00:00.000"),                 DateUtils.round((Object) date1, Calendar.HOUR),                 "round hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:00:00.000"),                 DateUtils.round((Object) date2, Calendar.HOUR),                 "round hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:35:00.000"),                 DateUtils.round((Object) date1, Calendar.MINUTE),                 "round minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:00.000"),                 DateUtils.round((Object) date2, Calendar.MINUTE),                 "round minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.round((Object) date1, Calendar.SECOND),                 "round second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.round((Object) date2, Calendar.SECOND),                 "round second-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.round((Object) cal1, Calendar.SECOND),                 "round calendar second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.round((Object) cal2, Calendar.SECOND),                 "round calendar second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.round((Object) dateAmPm1, Calendar.AM_PM),                 "round ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round((Object) dateAmPm2, Calendar.AM_PM),                 "round ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round((Object) dateAmPm3, Calendar.AM_PM),                 "round ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.round((Object) dateAmPm4, Calendar.AM_PM),                 "round ampm-4 failed");          assertThrows(NullPointerException.class, () -> DateUtils.round((Date) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.round((Calendar) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.round((Object) null, Calendar.SECOND));         assertThrows(ClassCastException.class, () -> DateUtils.round("", Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.round(date1, -9999));          assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.round((Object) calAmPm1, Calendar.AM_PM),                 "round ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round((Object) calAmPm2, Calendar.AM_PM),                 "round ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.round((Object) calAmPm3, Calendar.AM_PM),                 "round ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.round((Object) calAmPm4, Calendar.AM_PM),                 "round ampm-4 failed");          // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13         // Test rounding across the beginning of daylight saving time         try {             TimeZone.setDefault(zone);             dateTimeParser.setTimeZone(zone);             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round(date4, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round((Object) cal4, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round(date5, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round((Object) cal5, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round(date6, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round((Object) cal6, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round(date7, Calendar.DATE),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.round((Object) cal7, Calendar.DATE),                     "round MET date across DST change-over");              assertEquals(dateTimeParser.parse("March 30, 2003 01:00:00.000"),                     DateUtils.round(date4, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 01:00:00.000"),                     DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.round(date5, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.round(date6, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.round(date7, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY),                     "round MET date across DST change-over");         } finally {             TimeZone.setDefault(defaultZone);             dateTimeParser.setTimeZone(defaultZone);         }     }      /**      * Tests the Changes Made by LANG-346 to the DateUtils.modify() private method invoked      * by DateUtils.round().      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testRoundLang346() throws Exception {         final Calendar testCalendar = Calendar.getInstance();         testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);         Date date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:09:00.000"),                 DateUtils.round(date, Calendar.MINUTE),                 "Minute Round Up Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:08:00.000"),                 DateUtils.round(date, Calendar.MINUTE),                 "Minute No Round Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);         testCalendar.set(Calendar.MILLISECOND, 600);         date = testCalendar.getTime();          assertEquals(dateTimeParser.parse("July 2, 2007 08:08:51.000"),                 DateUtils.round(date, Calendar.SECOND),                 "Second Round Up with 600 Milli Seconds Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);         testCalendar.set(Calendar.MILLISECOND, 200);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:08:50.000"),                 DateUtils.round(date, Calendar.SECOND),                 "Second Round Down with 200 Milli Seconds Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);         testCalendar.set(Calendar.MILLISECOND, 600);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:08:21.000"),                 DateUtils.round(date, Calendar.SECOND),                 "Second Round Up with 200 Milli Seconds Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 20);         testCalendar.set(Calendar.MILLISECOND, 200);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:08:20.000"),                 DateUtils.round(date, Calendar.SECOND),                 "Second Round Down with 200 Milli Seconds Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 8, 50);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 08:00:00.000"),                 DateUtils.round(date, Calendar.HOUR),                 "Hour Round Down Failed");          testCalendar.set(2007, Calendar.JULY, 2, 8, 31, 50);         date = testCalendar.getTime();         assertEquals(dateTimeParser.parse("July 2, 2007 09:00:00.000"),                 DateUtils.round(date, Calendar.HOUR),                 "Hour Round Up Failed");     }      /**      * Tests various values with the trunc method      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testTruncate() throws Exception {         // tests public static Date truncate(Date date, int field)         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.truncate(date1, Calendar.YEAR),                 "truncate year-1 failed");         assertEquals(dateParser.parse("January 1, 2001"),                 DateUtils.truncate(date2, Calendar.YEAR),                 "truncate year-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.truncate(date1, Calendar.MONTH),                 "truncate month-1 failed");         assertEquals(dateParser.parse("November 1, 2001"),                 DateUtils.truncate(date2, Calendar.MONTH),                 "truncate month-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.truncate(date1, DateUtils.SEMI_MONTH),                 "truncate semimonth-1 failed");         assertEquals(dateParser.parse("November 16, 2001"),                 DateUtils.truncate(date2, DateUtils.SEMI_MONTH),                 "truncate semimonth-2 failed");         assertEquals(dateParser.parse("February 12, 2002"),                 DateUtils.truncate(date1, Calendar.DATE),                 "truncate date-1 failed");         assertEquals(dateParser.parse("November 18, 2001"),                 DateUtils.truncate(date2, Calendar.DATE),                 "truncate date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:00:00.000"),                 DateUtils.truncate(date1, Calendar.HOUR),                 "truncate hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:00:00.000"),                 DateUtils.truncate(date2, Calendar.HOUR),                 "truncate hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:00.000"),                 DateUtils.truncate(date1, Calendar.MINUTE),                 "truncate minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:00.000"),                 DateUtils.truncate(date2, Calendar.MINUTE),                 "truncate minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:56.000"),                 DateUtils.truncate(date1, Calendar.SECOND),                 "truncate second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.truncate(date2, Calendar.SECOND),                 "truncate second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate(dateAmPm1, Calendar.AM_PM),                 "truncate ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate(dateAmPm2, Calendar.AM_PM),                 "truncate ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate(dateAmPm3, Calendar.AM_PM),                 "truncate ampm-3 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate(dateAmPm4, Calendar.AM_PM),                 "truncate ampm-4 failed");          // tests public static Date truncate(Object date, int field)         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.truncate((Object) date1, Calendar.YEAR),                 "truncate year-1 failed");         assertEquals(dateParser.parse("January 1, 2001"),                 DateUtils.truncate((Object) date2, Calendar.YEAR),                 "truncate year-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.truncate((Object) date1, Calendar.MONTH),                 "truncate month-1 failed");         assertEquals(dateParser.parse("November 1, 2001"),                 DateUtils.truncate((Object) date2, Calendar.MONTH),                 "truncate month-2 failed");         assertEquals(dateParser.parse("February 1, 2002"),                 DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH),                 "truncate semimonth-1 failed");         assertEquals(dateParser.parse("November 16, 2001"),                 DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH),                 "truncate semimonth-2 failed");         assertEquals(dateParser.parse("February 12, 2002"),                 DateUtils.truncate((Object) date1, Calendar.DATE),                 "truncate date-1 failed");         assertEquals(dateParser.parse("November 18, 2001"),                 DateUtils.truncate((Object) date2, Calendar.DATE),                 "truncate date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:00:00.000"),                 DateUtils.truncate((Object) date1, Calendar.HOUR),                 "truncate hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:00:00.000"),                 DateUtils.truncate((Object) date2, Calendar.HOUR),                 "truncate hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:00.000"),                 DateUtils.truncate((Object) date1, Calendar.MINUTE),                 "truncate minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:00.000"),                 DateUtils.truncate((Object) date2, Calendar.MINUTE),                 "truncate minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:56.000"),                 DateUtils.truncate((Object) date1, Calendar.SECOND),                 "truncate second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.truncate((Object) date2, Calendar.SECOND),                 "truncate second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM),                 "truncate ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM),                 "truncate ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM),                 "truncate ampm-3 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM),                 "truncate ampm-4 failed");          assertEquals(dateTimeParser.parse("February 12, 2002 12:34:56.000"),                 DateUtils.truncate((Object) cal1, Calendar.SECOND),                 "truncate calendar second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:11.000"),                 DateUtils.truncate((Object) cal2, Calendar.SECOND),                 "truncate calendar second-2 failed");          assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM),                 "truncate ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 00:00:00.000"),                 DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM),                 "truncate ampm-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM),                 "truncate ampm-3 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM),                 "truncate ampm-4 failed");          assertThrows(NullPointerException.class, () -> DateUtils.truncate((Date) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.truncate((Calendar) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.truncate((Object) null, Calendar.SECOND));         assertThrows(ClassCastException.class, () -> DateUtils.truncate("", Calendar.SECOND));          // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560         // Test truncate across beginning of daylight saving time         try {             TimeZone.setDefault(zone);             dateTimeParser.setTimeZone(zone);             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.truncate(date3, Calendar.DATE),                     "truncate MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 00:00:00.000"),                     DateUtils.truncate((Object) cal3, Calendar.DATE),                     "truncate MET date across DST change-over");             // Test truncate across end of daylight saving time             assertEquals(dateTimeParser.parse("October 26, 2003 00:00:00.000"),                     DateUtils.truncate(date8, Calendar.DATE),                     "truncate MET date across DST change-over");             assertEquals(dateTimeParser.parse("October 26, 2003 00:00:00.000"),                     DateUtils.truncate((Object) cal8, Calendar.DATE),                     "truncate MET date across DST change-over");         } finally {             TimeZone.setDefault(defaultZone);             dateTimeParser.setTimeZone(defaultZone);         }          // Bug 31395, large dates         final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis         final GregorianCalendar endCal = new GregorianCalendar();         endCal.setTime(endOfTime);         assertThrows(ArithmeticException.class, () -> DateUtils.truncate(endCal, Calendar.DATE));         endCal.set(Calendar.YEAR, 280000001);         assertThrows(ArithmeticException.class, () -> DateUtils.truncate(endCal, Calendar.DATE));         endCal.set(Calendar.YEAR, 280000000);         final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);         assertEquals(0, cal.get(Calendar.HOUR));     }      /**      * Tests for LANG-59      *      * see https://issues.apache.org/jira/browse/LANG-59      */     @Test     public void testTruncateLang59() {         try {             // Set TimeZone to Mountain Time             final TimeZone denverZone = TimeZone.getTimeZone("America/Denver");             TimeZone.setDefault(denverZone);             final DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS XXX");             format.setTimeZone(denverZone);              final Date oct31_01MDT = new Date(1099206000000L);              final Date oct31MDT = new Date(oct31_01MDT.getTime() - 3600000L); // - 1 hour             final Date oct31_01_02MDT = new Date(oct31_01MDT.getTime() + 120000L);  // + 2 minutes             final Date oct31_01_02_03MDT = new Date(oct31_01_02MDT.getTime() + 3000L);    // + 3 seconds             final Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds              assertEquals("2004-10-31 00:00:00.000 -06:00", format.format(oct31MDT), "Check 00:00:00.000");             assertEquals("2004-10-31 01:00:00.000 -06:00", format.format(oct31_01MDT), "Check 01:00:00.000");             assertEquals("2004-10-31 01:02:00.000 -06:00", format.format(oct31_01_02MDT), "Check 01:02:00.000");             assertEquals("2004-10-31 01:02:03.000 -06:00", format.format(oct31_01_02_03MDT), "Check 01:02:03.000");             assertEquals("2004-10-31 01:02:03.004 -06:00", format.format(oct31_01_02_03_04MDT), "Check 01:02:03.004");              // ------- Demonstrate Problem -------             final Calendar gval = Calendar.getInstance();             gval.setTime(new Date(oct31_01MDT.getTime()));             gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value             assertEquals(gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L, "Demonstrate Problem");              // ---------- Test Truncate ----------             assertEquals(oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND),                     "Truncate Calendar.MILLISECOND");              assertEquals(oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND),                     "Truncate Calendar.SECOND");              assertEquals(oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE),                     "Truncate Calendar.MINUTE");              assertEquals(oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY),                     "Truncate Calendar.HOUR_OF_DAY");              assertEquals(oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR),                     "Truncate Calendar.HOUR");              assertEquals(oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE),                     "Truncate Calendar.DATE");              // ---------- Test Round (down) ----------             assertEquals(oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND),                     "Round Calendar.MILLISECOND");              assertEquals(oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND),                     "Round Calendar.SECOND");              assertEquals(oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE),                     "Round Calendar.MINUTE");              assertEquals(oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY),                     "Round Calendar.HOUR_OF_DAY");              assertEquals(oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR),                     "Round Calendar.HOUR");              assertEquals(oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE),                     "Round Calendar.DATE");         } finally {             // restore default time zone             TimeZone.setDefault(defaultZone);         }     }      // https://issues.apache.org/jira/browse/LANG-530     @SuppressWarnings("deprecation")     @Test     public void testLang530() throws ParseException {         final Date d = new Date();         final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);         final Date d2 = DateUtils.parseDate(isoDateStr, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern());         // the format loses milliseconds so have to reintroduce them         assertEquals(d.getTime(), d2.getTime() + d.getTime() % 1000, "Date not equal to itself ISO formatted and parsed");     }      /**      * Tests various values with the ceiling method      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testCeil() throws Exception {         // test javadoc         assertEquals(dateTimeParser.parse("March 28, 2002 14:00:00.000"),                 DateUtils.ceiling(                             dateTimeParser.parse("March 28, 2002 13:45:01.231"),                         Calendar.HOUR),                 "ceiling javadoc-1 failed");         assertEquals(dateTimeParser.parse("April 1, 2002 00:00:00.000"),                 DateUtils.ceiling(                             dateTimeParser.parse("March 28, 2002 13:45:01.231"),                         Calendar.MONTH),                 "ceiling javadoc-2 failed");          // tests public static Date ceiling(Date date, int field)         assertEquals(dateParser.parse("January 1, 2003"),                 DateUtils.ceiling(date1, Calendar.YEAR),                 "ceiling year-1 failed");         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.ceiling(date2, Calendar.YEAR),                 "ceiling year-2 failed");         assertEquals(dateParser.parse("March 1, 2002"),                 DateUtils.ceiling(date1, Calendar.MONTH),                 "ceiling month-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.ceiling(date2, Calendar.MONTH),                 "ceiling month-2 failed");         assertEquals(dateParser.parse("February 16, 2002"),                 DateUtils.ceiling(date1, DateUtils.SEMI_MONTH),                 "ceiling semimonth-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.ceiling(date2, DateUtils.SEMI_MONTH),                 "ceiling semimonth-2 failed");         assertEquals(dateParser.parse("February 13, 2002"),                 DateUtils.ceiling(date1, Calendar.DATE),                 "ceiling date-1 failed");         assertEquals(dateParser.parse("November 19, 2001"),                 DateUtils.ceiling(date2, Calendar.DATE),                 "ceiling date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 13:00:00.000"),                 DateUtils.ceiling(date1, Calendar.HOUR),                 "ceiling hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 2:00:00.000"),                 DateUtils.ceiling(date2, Calendar.HOUR),                 "ceiling hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:35:00.000"),                 DateUtils.ceiling(date1, Calendar.MINUTE),                 "ceiling minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:24:00.000"),                 DateUtils.ceiling(date2, Calendar.MINUTE),                 "ceiling minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.ceiling(date1, Calendar.SECOND),                 "ceiling second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:12.000"),                 DateUtils.ceiling(date2, Calendar.SECOND),                 "ceiling second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling(dateAmPm1, Calendar.AM_PM),                 "ceiling ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling(dateAmPm2, Calendar.AM_PM),                 "ceiling ampm-2 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling(dateAmPm3, Calendar.AM_PM),                 "ceiling ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling(dateAmPm4, Calendar.AM_PM),                 "ceiling ampm-4 failed");       // tests public static Date ceiling(Object date, int field)         assertEquals(dateParser.parse("January 1, 2003"),                 DateUtils.ceiling((Object) date1, Calendar.YEAR),                 "ceiling year-1 failed");         assertEquals(dateParser.parse("January 1, 2002"),                 DateUtils.ceiling((Object) date2, Calendar.YEAR),                 "ceiling year-2 failed");         assertEquals(dateParser.parse("March 1, 2002"),                 DateUtils.ceiling((Object) date1, Calendar.MONTH),                 "ceiling month-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.ceiling((Object) date2, Calendar.MONTH),                 "ceiling month-2 failed");         assertEquals(dateParser.parse("February 16, 2002"),                 DateUtils.ceiling((Object) date1, DateUtils.SEMI_MONTH),                 "ceiling semimonth-1 failed");         assertEquals(dateParser.parse("December 1, 2001"),                 DateUtils.ceiling((Object) date2, DateUtils.SEMI_MONTH),                 "ceiling semimonth-2 failed");         assertEquals(dateParser.parse("February 13, 2002"),                 DateUtils.ceiling((Object) date1, Calendar.DATE),                 "ceiling date-1 failed");         assertEquals(dateParser.parse("November 19, 2001"),                 DateUtils.ceiling((Object) date2, Calendar.DATE),                 "ceiling date-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 13:00:00.000"),                 DateUtils.ceiling((Object) date1, Calendar.HOUR),                 "ceiling hour-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 2:00:00.000"),                 DateUtils.ceiling((Object) date2, Calendar.HOUR),                 "ceiling hour-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:35:00.000"),                 DateUtils.ceiling((Object) date1, Calendar.MINUTE),                 "ceiling minute-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:24:00.000"),                 DateUtils.ceiling((Object) date2, Calendar.MINUTE),                 "ceiling minute-2 failed");         assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.ceiling((Object) date1, Calendar.SECOND),                 "ceiling second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:12.000"),                 DateUtils.ceiling((Object) date2, Calendar.SECOND),                 "ceiling second-2 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling((Object) dateAmPm1, Calendar.AM_PM),                 "ceiling ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling((Object) dateAmPm2, Calendar.AM_PM),                 "ceiling ampm-2 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling((Object) dateAmPm3, Calendar.AM_PM),                 "ceiling ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling((Object) dateAmPm4, Calendar.AM_PM),                 "ceiling ampm-4 failed");          assertEquals(dateTimeParser.parse("February 12, 2002 12:34:57.000"),                 DateUtils.ceiling((Object) cal1, Calendar.SECOND),                 "ceiling calendar second-1 failed");         assertEquals(dateTimeParser.parse("November 18, 2001 1:23:12.000"),                 DateUtils.ceiling((Object) cal2, Calendar.SECOND),                 "ceiling calendar second-2 failed");          assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling((Object) calAmPm1, Calendar.AM_PM),                 "ceiling ampm-1 failed");         assertEquals(dateTimeParser.parse("February 3, 2002 12:00:00.000"),                 DateUtils.ceiling((Object) calAmPm2, Calendar.AM_PM),                 "ceiling ampm-2 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling((Object) calAmPm3, Calendar.AM_PM),                 "ceiling ampm-3 failed");         assertEquals(dateTimeParser.parse("February 4, 2002 00:00:00.000"),                 DateUtils.ceiling((Object) calAmPm4, Calendar.AM_PM),                 "ceiling ampm-4 failed");          assertThrows(NullPointerException.class, () -> DateUtils.ceiling((Date) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.ceiling((Calendar) null, Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.ceiling((Object) null, Calendar.SECOND));         assertThrows(ClassCastException.class, () -> DateUtils.ceiling("", Calendar.SECOND));         assertThrows(IllegalArgumentException.class, () -> DateUtils.ceiling(date1, -9999));          // Fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=25560         // Test ceiling across the beginning of daylight saving time         try {             TimeZone.setDefault(zone);             dateTimeParser.setTimeZone(zone);              assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling(date4, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling((Object) cal4, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling(date5, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling((Object) cal5, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling(date6, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling((Object) cal6, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling(date7, Calendar.DATE),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 31, 2003 00:00:00.000"),                     DateUtils.ceiling((Object) cal7, Calendar.DATE),                     "ceiling MET date across DST change-over");              assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 03:00:00.000"),                     DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");             assertEquals(dateTimeParser.parse("March 30, 2003 04:00:00.000"),                     DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY),                     "ceiling MET date across DST change-over");          } finally {             TimeZone.setDefault(defaultZone);             dateTimeParser.setTimeZone(defaultZone);         }       // Bug 31395, large dates         final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis         final GregorianCalendar endCal = new GregorianCalendar();         endCal.setTime(endOfTime);         assertThrows(ArithmeticException.class, () -> DateUtils.ceiling(endCal, Calendar.DATE));         endCal.set(Calendar.YEAR, 280000001);         assertThrows(ArithmeticException.class, () -> DateUtils.ceiling(endCal, Calendar.DATE));         endCal.set(Calendar.YEAR, 280000000);         final Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE);         assertEquals(0, cal.get(Calendar.HOUR));     }      /**      * Tests the iterator exceptions      */     @Test     public void testIteratorEx() {         assertThrows(IllegalArgumentException.class, () -> DateUtils.iterator(Calendar.getInstance(), -9999));         assertThrows                 (NullPointerException.class, () -> DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER));         assertThrows                 (IllegalArgumentException.class, () -> DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER));         assertThrows                 (IllegalArgumentException.class, () -> DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER));         assertThrows(ClassCastException.class, () -> DateUtils.iterator("", DateUtils.RANGE_WEEK_CENTER));     }      /**      * Tests the calendar iterator for week ranges      */     @Test     public void testWeekIterator() {         final Calendar now = Calendar.getInstance();         for (int i = 0; i< 7; i++) {             final Calendar today = DateUtils.truncate(now, Calendar.DATE);             final Calendar sunday = DateUtils.truncate(now, Calendar.DATE);             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));             final Calendar monday = DateUtils.truncate(now, Calendar.DATE);             if (monday.get(Calendar.DAY_OF_WEEK) == 1) {                 //This is sunday... roll back 6 days                 monday.add(Calendar.DATE, -6);             } else {                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));             }             final Calendar centered = DateUtils.truncate(now, Calendar.DATE);             centered.add(Calendar.DATE, -3);              Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);             assertWeekIterator(it, sunday);             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY);             assertWeekIterator(it, monday);             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE);             assertWeekIterator(it, today);             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);             assertWeekIterator(it, centered);              it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER);             assertWeekIterator(it, centered);             final Iterator<?> it2 = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER);             assertWeekIterator(it2, centered);             assertThrows(NoSuchElementException.class, it2::next);             final Iterator<?> it3 = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);             it3.next();             assertThrows(UnsupportedOperationException.class, it3::remove);              now.add(Calendar.DATE, 1);         }     }      /**      * Tests the calendar iterator for month-based ranges      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testMonthIterator() throws Exception {         Iterator<?> it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY);         assertWeekIterator(it,                 dateParser.parse("January 27, 2002"),                 dateParser.parse("March 2, 2002"));          it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY);         assertWeekIterator(it,                 dateParser.parse("January 28, 2002"),                 dateParser.parse("March 3, 2002"));          it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY);         assertWeekIterator(it,                 dateParser.parse("October 28, 2001"),                 dateParser.parse("December 1, 2001"));          it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY);         assertWeekIterator(it,                 dateParser.parse("October 29, 2001"),                 dateParser.parse("December 2, 2001"));     }      @DefaultLocale(language = "en")     @Test     public void testLANG799_EN_OK() throws ParseException {         DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");         DateUtils.parseDateStrictly("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");     }      // Parse German date with English Locale     @DefaultLocale(language = "en")     @Test     public void testLANG799_EN_FAIL() {         assertThrows(ParseException.class, () -> DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"));     }      @DefaultLocale(language = "de")     @Test     public void testLANG799_DE_OK() throws ParseException {         DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");         DateUtils.parseDateStrictly("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");     }      // Parse English date with German Locale     @DefaultLocale(language = "de")     @Test     public void testLANG799_DE_FAIL() {         assertThrows(ParseException.class, () -> DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz"));     }      // Parse German date with English Locale, specifying German Locale override     @DefaultLocale(language = "en")     @Test     public void testLANG799_EN_WITH_DE_LOCALE() throws ParseException {         DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", Locale.GERMAN, "EEE, dd MMM yyyy HH:mm:ss zzz");     }      /**      * This checks that this is a 7 element iterator of Calendar objects      * that are dates (no time), and exactly 1 day spaced after each other.      */     private static void assertWeekIterator(final Iterator<?> it, final Calendar start) {         final Calendar end = (Calendar) start.clone();         end.add(Calendar.DATE, 6);          assertWeekIterator(it, start, end);     }      /**      * Convenience method for when working with Date objects      */     private static void assertWeekIterator(final Iterator<?> it, final Date start, final Date end) {         final Calendar calStart = Calendar.getInstance();         calStart.setTime(start);         final Calendar calEnd = Calendar.getInstance();         calEnd.setTime(end);          assertWeekIterator(it, calStart, calEnd);     }      /**      * This checks that this is a 7 divisble iterator of Calendar objects      * that are dates (no time), and exactly 1 day spaced after each other      * (in addition to the proper start and stop dates)      */     private static void assertWeekIterator(final Iterator<?> it, final Calendar start, final Calendar end) {         Calendar cal = (Calendar) it.next();         assertCalendarsEquals("", start, cal, 0);         Calendar last = null;         int count = 1;         while (it.hasNext()) {             //Check this is just a date (no time component)             assertCalendarsEquals("", cal, DateUtils.truncate(cal, Calendar.DATE), 0);              last = cal;             cal = (Calendar) it.next();             count++;              //Check that this is one day more than the last date             last.add(Calendar.DATE, 1);             assertCalendarsEquals("", last, cal, 0);         }          assertFalse(count % 7 != 0, "There were " + count + " days in this iterator");         assertCalendarsEquals("", end, cal, 0);     }      /**      * Used to check that Calendar objects are close enough      * delta is in milliseconds      */     private static void assertCalendarsEquals(final String message, final Calendar cal1, final Calendar cal2, final long delta) {         assertFalse(Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta,                 message + " expected " + cal1.getTime() + " but got " + cal2.getTime());     }      @Test     public void testLANG799() throws ParseException {         DateUtils.parseDateStrictly("09 abril 2008 23:55:38 GMT", new Locale("es"), "dd MMM yyyy HH:mm:ss zzz");     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals;  import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.Locale;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * These Unit-tests will check all possible extremes when using some rounding-methods of DateUtils.  * The extremes are tested at the switch-point in milliseconds  *  * According to the implementation SEMI_MONTH will either round/truncate to the 1st or 16th  * When rounding Calendar.MONTH it depends on the number of days within that month.  * A month with 28 days will be rounded up from the 15th  * A month with 29 or 30 days will be rounded up from the 16th  * A month with 31 days will be rounded up from the 17th  *  * @since 3.0  */ public class DateUtilsRoundingTest {      DateFormat dateTimeParser;      Date januaryOneDate;     Date targetYearDate;     //No targetMonths, these must be tested for every type of month(28-31 days)     Date targetDateDate, targetDayOfMonthDate, targetAmDate, targetPmDate;     Date targetHourOfDayDate, targetHourDate;     Date targetMinuteDate;     Date targetSecondDate;     Date targetMilliSecondDate;      Calendar januaryOneCalendar;     @SuppressWarnings("deprecation")     FastDateFormat fdf = DateFormatUtils.ISO_DATETIME_FORMAT;       @BeforeEach     public void setUp() throws Exception {          dateTimeParser = new SimpleDateFormat("MMM dd, yyyy H:mm:ss.SSS", Locale.ENGLISH);          targetYearDate = dateTimeParser.parse("January 1, 2007 0:00:00.000");         targetDateDate = targetDayOfMonthDate = dateTimeParser.parse("June 1, 2008 0:00:00.000");         targetAmDate =  dateTimeParser.parse("June 1, 2008 0:00:00.000");         targetPmDate = dateTimeParser.parse("June 1, 2008 12:00:00.000");         targetHourDate = dateTimeParser.parse("June 1, 2008 8:00:00.000");         targetHourOfDayDate = dateTimeParser.parse("June 1, 2008 8:00:00.000");         targetMinuteDate =  dateTimeParser.parse("June 1, 2008 8:15:00.000");         targetSecondDate =  dateTimeParser.parse("June 1, 2008 8:15:14.000");         targetMilliSecondDate =  dateTimeParser.parse("June 1, 2008 8:15:14.231");          januaryOneDate = dateTimeParser.parse("January 1, 2008 0:00:00.000");         januaryOneCalendar = Calendar.getInstance();         januaryOneCalendar.setTime(januaryOneDate);     }      /**      * Tests DateUtils.round()-method with Calendar.Year      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundYear() throws Exception {         final int calendarField = Calendar.YEAR;         final Date roundedUpDate = dateTimeParser.parse("January 1, 2008 0:00:00.000");         final Date roundedDownDate = targetYearDate;         final Date lastRoundedDownDate = dateTimeParser.parse("June 30, 2007 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.MONTH      * Includes rounding months with 28, 29, 30 and 31 days      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundMonth() throws Exception {         final int calendarField = Calendar.MONTH;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          //month with 28 days         roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 14, 2007 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 29 days         roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 15, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 30 days         roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("April 15, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 31 days         roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("May 16, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 17, 2007 00:00:00.000");         maxDate = dateTimeParser.parse("January 16, 2008 23:59:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with DateUtils.SEMI_MONTH      * Includes rounding months with 28, 29, 30 and 31 days, each with first and second half      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundSemiMonth() throws Exception {         final int calendarField = DateUtils.SEMI_MONTH;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          //month with 28 days (1)         roundedUpDate = dateTimeParser.parse("February 16, 2007 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 1, 2007 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 8, 2007 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 28 days (2)         roundedUpDate = dateTimeParser.parse("March 1, 2007 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 16, 2007 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 23, 2007 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 29 days (1)         roundedUpDate = dateTimeParser.parse("February 16, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 8, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 29 days (2)         roundedUpDate = dateTimeParser.parse("March 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("February 16, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("February 23, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 30 days (1)         roundedUpDate = dateTimeParser.parse("April 16, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("April 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("April 8, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 30 days (2)         roundedUpDate = dateTimeParser.parse("May 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("April 16, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("April 23, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 31 days (1)         roundedUpDate = dateTimeParser.parse("May 16, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("May 1, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("May 8, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //month with 31 days (2)         roundedUpDate = dateTimeParser.parse("June 1, 2008 0:00:00.000");         roundedDownDate = dateTimeParser.parse("May 16, 2008 0:00:00.000");         lastRoundedDownDate = dateTimeParser.parse("May 23, 2008 23:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 24, 2007 00:00:00.000");         maxDate = dateTimeParser.parse("January 8, 2008 23:59:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.DATE      * Includes rounding the extremes of one day      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundDate() throws Exception {         final int calendarField = Calendar.DATE;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000");         roundedDownDate = targetDateDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 11:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 12:00:00.000");         maxDate = dateTimeParser.parse("January 1, 2008 11:59:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.DAY_OF_MONTH      * Includes rounding the extremes of one day      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundDayOfMonth() throws Exception {         final int calendarField = Calendar.DAY_OF_MONTH;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000");         roundedDownDate = targetDayOfMonthDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 11:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 12:00:00.000");         maxDate = dateTimeParser.parse("January 1, 2008 11:59:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.AM_PM      * Includes rounding the extremes of both AM and PM of one day      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundAmPm() throws Exception {         final int calendarField = Calendar.AM_PM;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          //AM         roundedUpDate = dateTimeParser.parse("June 1, 2008 12:00:00.000");         roundedDownDate = targetAmDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 5:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //PM         roundedUpDate = dateTimeParser.parse("June 2, 2008 0:00:00.000");         roundedDownDate = targetPmDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 17:59:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 18:00:00.000");         maxDate = dateTimeParser.parse("January 1, 2008 5:59:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.HOUR_OF_DAY      * Includes rounding the extremes of one hour      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundHourOfDay() throws Exception {         final int calendarField = Calendar.HOUR_OF_DAY;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 1, 2008 9:00:00.000");         roundedDownDate = targetHourOfDayDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:29:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 23:30:00.000");         maxDate = dateTimeParser.parse("January 1, 2008 0:29:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.HOUR      * Includes rounding the extremes of one hour      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundHour() throws Exception {         final int calendarField = Calendar.HOUR;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 1, 2008 9:00:00.000");         roundedDownDate = targetHourDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:29:59.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 23:30:00.000");         maxDate = dateTimeParser.parse("January 1, 2008 0:29:59.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.MINUTE      * Includes rounding the extremes of one minute      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundMinute() throws Exception {         final int calendarField = Calendar.MINUTE;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 1, 2008 8:16:00.000");         roundedDownDate = targetMinuteDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:15:29.999");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 23:59:30.000");         maxDate = dateTimeParser.parse("January 1, 2008 0:00:29.999");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.SECOND      * Includes rounding the extremes of one second      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundSecond() throws Exception {         final int calendarField = Calendar.SECOND;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedUpDate = dateTimeParser.parse("June 1, 2008 8:15:15.000");         roundedDownDate = targetSecondDate;         lastRoundedDownDate = dateTimeParser.parse("June 1, 2008 8:15:14.499");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = dateTimeParser.parse("December 31, 2007 23:59:59.500");         maxDate = dateTimeParser.parse("January 1, 2008 0:00:00.499");         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Tests DateUtils.round()-method with Calendar.MILLISECOND      * Includes rounding the extremes of one second      * Includes rounding to January 1      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testRoundMilliSecond() throws Exception {         final int calendarField = Calendar.MILLISECOND;         Date roundedUpDate, roundedDownDate, lastRoundedDownDate;         Date minDate, maxDate;          roundedDownDate = lastRoundedDownDate = targetMilliSecondDate;         roundedUpDate = dateTimeParser.parse("June 1, 2008 8:15:14.232");         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);          //round to January 1         minDate = maxDate = januaryOneDate;         roundToJanuaryFirst(minDate, maxDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.YEAR      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateYear() throws Exception {         final int calendarField = Calendar.YEAR;         final Date lastTruncateDate = dateTimeParser.parse("December 31, 2007 23:59:59.999");         baseTruncateTest(targetYearDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.MONTH      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateMonth() throws Exception {         final int calendarField = Calendar.MONTH;         final Date truncatedDate = dateTimeParser.parse("March 1, 2008 0:00:00.000");         final Date lastTruncateDate = dateTimeParser.parse("March 31, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with DateUtils.SEMI_MONTH      * Includes truncating months with 28, 29, 30 and 31 days, each with first and second half      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateSemiMonth() throws Exception {         final int calendarField = DateUtils.SEMI_MONTH;         Date truncatedDate, lastTruncateDate;          //month with 28 days (1)         truncatedDate = dateTimeParser.parse("February 1, 2007 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("February 15, 2007 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 28 days (2)         truncatedDate = dateTimeParser.parse("February 16, 2007 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("February 28, 2007 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 29 days (1)         truncatedDate = dateTimeParser.parse("February 1, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("February 15, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 29 days (2)         truncatedDate = dateTimeParser.parse("February 16, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("February 29, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 30 days (1)         truncatedDate = dateTimeParser.parse("April 1, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("April 15, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 30 days (2)         truncatedDate = dateTimeParser.parse("April 16, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("April 30, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 31 days (1)         truncatedDate = dateTimeParser.parse("March 1, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("March 15, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);          //month with 31 days (2)         truncatedDate = dateTimeParser.parse("March 16, 2008 0:00:00.000");         lastTruncateDate = dateTimeParser.parse("March 31, 2008 23:59:59.999");         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);      }      /**      * Test DateUtils.truncate()-method with Calendar.DATE      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateDate() throws Exception {         final int calendarField = Calendar.DATE;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999");         baseTruncateTest(targetDateDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.DAY_OF_MONTH      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateDayOfMonth() throws Exception {         final int calendarField = Calendar.DAY_OF_MONTH;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999");         baseTruncateTest(targetDayOfMonthDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.AM_PM      * Includes truncating the extremes of both AM and PM of one day      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateAmPm() throws Exception {         final int calendarField = Calendar.AM_PM;          //AM         Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 11:59:59.999");         baseTruncateTest(targetAmDate, lastTruncateDate, calendarField);          //PM         lastTruncateDate = dateTimeParser.parse("June 1, 2008 23:59:59.999");         baseTruncateTest(targetPmDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.HOUR      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateHour() throws Exception {         final int calendarField = Calendar.HOUR;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:59:59.999");         baseTruncateTest(targetHourDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.HOUR_OF_DAY      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateHourOfDay() throws Exception {         final int calendarField = Calendar.HOUR_OF_DAY;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:59:59.999");         baseTruncateTest(targetHourOfDayDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.MINUTE      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateMinute() throws Exception {         final int calendarField = Calendar.MINUTE;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:59.999");         baseTruncateTest(targetMinuteDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.SECOND      *      * @throws Exception so we don't have to catch it      * @since 3.0      */     @Test     public void testTruncateSecond() throws Exception {         final int calendarField = Calendar.SECOND;         final Date lastTruncateDate = dateTimeParser.parse("June 1, 2008 8:15:14.999");         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField);     }      /**      * Test DateUtils.truncate()-method with Calendar.SECOND      *      * @since 3.0      */     @Test     public void testTruncateMilliSecond() {         final int calendarField = Calendar.MILLISECOND;         baseTruncateTest(targetMilliSecondDate, targetMilliSecondDate, calendarField);     }      /**      * When using this basetest all extremes are tested.<br>      * It will test the Date, Calendar and Object-implementation<br>      * lastRoundDownDate should round down to roundedDownDate<br>      * lastRoundDownDate + 1 millisecond should round up to roundedUpDate      *      * @param roundedUpDate the next rounded date after <strong>roundedDownDate</strong> when using <strong>calendarField</strong>      * @param roundedDownDate the result if <strong>lastRoundDownDate</strong> was rounded with <strong>calendarField</strong>      * @param lastRoundDownDate rounding this value with <strong>calendarField</strong> will result in <strong>roundedDownDate</strong>      * @param calendarField a Calendar.field value      * @since 3.0      */     protected void baseRoundTest(final Date roundedUpDate, final Date roundedDownDate, final Date lastRoundDownDate, final int calendarField) {         final Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1);          //Date-comparison         assertEquals(roundedDownDate, DateUtils.round(roundedDownDate, calendarField));         assertEquals(roundedUpDate, DateUtils.round(roundedUpDate, calendarField));         assertEquals(roundedDownDate, DateUtils.round(lastRoundDownDate, calendarField));         assertEquals(roundedUpDate, DateUtils.round(firstRoundUpDate, calendarField));          //Calendar-initiations         Calendar roundedUpCalendar, roundedDownCalendar, lastRoundDownCalendar, firstRoundUpCalendar;         roundedDownCalendar = Calendar.getInstance();         roundedUpCalendar = Calendar.getInstance();         lastRoundDownCalendar = Calendar.getInstance();         firstRoundUpCalendar = Calendar.getInstance();         roundedDownCalendar.setTime(roundedDownDate);         roundedUpCalendar.setTime(roundedUpDate);         lastRoundDownCalendar.setTime(lastRoundDownDate);         firstRoundUpCalendar.setTime(firstRoundUpDate);          //Calendar-comparison         assertEquals(roundedDownCalendar, DateUtils.round(roundedDownCalendar, calendarField));         assertEquals(roundedUpCalendar, DateUtils.round(roundedUpCalendar, calendarField));         assertEquals(roundedDownCalendar, DateUtils.round(lastRoundDownCalendar, calendarField));         assertEquals(roundedUpCalendar, DateUtils.round(firstRoundUpCalendar, calendarField));          //Object-comparison         assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownDate, calendarField));         assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpDate, calendarField));         assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));         assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));         assertEquals(roundedDownDate, DateUtils.round((Object) roundedDownCalendar, calendarField));         assertEquals(roundedUpDate, DateUtils.round((Object) roundedUpCalendar, calendarField));         assertEquals(roundedDownDate, DateUtils.round((Object) lastRoundDownDate, calendarField));         assertEquals(roundedUpDate, DateUtils.round((Object) firstRoundUpDate, calendarField));     }      /**      * When using this basetest all extremes are tested.<br>      * It will test the Date, Calendar and Object-implementation<br>      * lastTruncateDate should round down to truncatedDate<br>      * lastTruncateDate + 1 millisecond should never round down to truncatedDate      *      * @param truncatedDate expected Date when <strong>lastTruncateDate</strong> is truncated with <strong>calendarField</strong>      * @param lastTruncateDate the last possible Date which will truncate to <strong>truncatedDate</strong> with <strong>calendarField</strong>      * @param calendarField a Calendar.field value      * @since 3.0      */     protected void baseTruncateTest(final Date truncatedDate, final Date lastTruncateDate, final int calendarField) {         final Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1);          //Date-comparison         assertEquals(truncatedDate, DateUtils.truncate(truncatedDate, calendarField), "Truncating "+ fdf.format(truncatedDate) +" as Date with CalendarField-value "+ calendarField +" must return itself");         assertEquals(truncatedDate, DateUtils.truncate(lastTruncateDate, calendarField));         assertNotEquals(truncatedDate, DateUtils.truncate(nextTruncateDate, calendarField), fdf.format(lastTruncateDate) + " is not an extreme when truncating as Date with CalendarField-value " + calendarField);          //Calendar-initiations         Calendar truncatedCalendar, lastTruncateCalendar, nextTruncateCalendar;         truncatedCalendar = Calendar.getInstance();         lastTruncateCalendar = Calendar.getInstance();         nextTruncateCalendar = Calendar.getInstance();         truncatedCalendar.setTime(truncatedDate);         lastTruncateCalendar.setTime(lastTruncateDate);         nextTruncateCalendar.setTime(nextTruncateDate);          //Calendar-comparison         assertEquals(truncatedCalendar, DateUtils.truncate(truncatedCalendar, calendarField), "Truncating "+ fdf.format(truncatedCalendar) +" as Calendar with CalendarField-value "+ calendarField +" must return itself");         assertEquals(truncatedCalendar, DateUtils.truncate(lastTruncateCalendar, calendarField));         assertNotEquals(truncatedCalendar, DateUtils.truncate(nextTruncateCalendar, calendarField), fdf.format(lastTruncateCalendar) + " is not an extreme when truncating as Calendar with CalendarField-value " + calendarField);          //Object-comparison         assertEquals(truncatedDate, DateUtils.truncate((Object) truncatedDate, calendarField), "Truncating "+ fdf.format(truncatedDate) +" as Date cast to Object with CalendarField-value "+ calendarField +" must return itself as Date");         assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateDate, calendarField));         assertNotEquals(truncatedDate, DateUtils.truncate((Object) nextTruncateDate, calendarField), fdf.format(lastTruncateDate) + " is not an extreme when truncating as Date cast to Object with CalendarField-value " + calendarField);         assertEquals(truncatedDate, DateUtils.truncate((Object) truncatedCalendar, calendarField), "Truncating "+ fdf.format(truncatedCalendar) +" as Calendar cast to Object with CalendarField-value "+ calendarField +" must return itself as Date");         assertEquals(truncatedDate, DateUtils.truncate((Object) lastTruncateCalendar, calendarField));         assertNotEquals(truncatedDate, DateUtils.truncate((Object) nextTruncateCalendar, calendarField), fdf.format(lastTruncateCalendar) + " is not an extreme when truncating as Calendar cast to Object with CalendarField-value " + calendarField);     }      /**      *      * Any January 1 could be considered as the ultimate extreme.      * Instead of comparing the results if the input has a difference of 1 millisecond we check the output to be exactly January first.      *      * @param minDate the lower bound      * @param maxDate the upper bound      * @param calendarField a Calendar.field value      * @since 3.0      */     protected void roundToJanuaryFirst(final Date minDate, final Date maxDate, final int calendarField) {         assertEquals(januaryOneDate, DateUtils.round(januaryOneDate, calendarField), "Rounding "+ fdf.format(januaryOneDate) +" as Date with CalendarField-value "+ calendarField +" must return itself");         assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField));         assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField));          final Calendar minCalendar = Calendar.getInstance();         minCalendar.setTime(minDate);         final Calendar maxCalendar = Calendar.getInstance();         maxCalendar.setTime(maxDate);         assertEquals(januaryOneCalendar, DateUtils.round(januaryOneCalendar, calendarField), "Rounding "+ fdf.format(januaryOneCalendar) +" as Date with CalendarField-value "+ calendarField +" must return itself");         assertEquals(januaryOneCalendar, DateUtils.round(minCalendar, calendarField));         assertEquals(januaryOneCalendar, DateUtils.round(maxCalendar, calendarField));          final Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1);         final Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1);         assertNotEquals(januaryOneDate, DateUtils.round(toPrevRoundDate, calendarField), fdf.format(minDate) + " is not an lower-extreme when rounding as Date with CalendarField-value " + calendarField);         assertNotEquals(januaryOneDate, DateUtils.round(toNextRoundDate, calendarField), fdf.format(maxDate) + " is not an upper-extreme when rounding as Date with CalendarField-value " + calendarField);          final Calendar toPrevRoundCalendar = Calendar.getInstance();         toPrevRoundCalendar.setTime(toPrevRoundDate);         final Calendar toNextRoundCalendar = Calendar.getInstance();         toNextRoundCalendar.setTime(toNextRoundDate);         assertNotEquals(januaryOneDate, DateUtils.round(toPrevRoundDate, calendarField), fdf.format(minCalendar) + " is not an lower-extreme when rounding as Date with CalendarField-value " + calendarField);         assertNotEquals(januaryOneDate, DateUtils.round(toNextRoundDate, calendarField), fdf.format(maxCalendar) + " is not an upper-extreme when rounding as Date with CalendarField-value " + calendarField);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.text.ParsePosition; import java.util.Calendar; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import java.util.stream.Stream;  import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  public class WeekYearTest {      public static Stream<Arguments> data() {         return Stream.of(             Arguments.of(new GregorianCalendar( 2005, Calendar.JANUARY, 1), "2004-W53-6"),             Arguments.of(new GregorianCalendar( 2005, Calendar.JANUARY, 2), "2004-W53-7"),             Arguments.of(new GregorianCalendar( 2005, Calendar.DECEMBER, 31), "2005-W52-6"),             Arguments.of(new GregorianCalendar( 2007, Calendar.JANUARY, 1), "2007-W01-1"),             Arguments.of(new GregorianCalendar( 2007, Calendar.DECEMBER, 30), "2007-W52-7"),             Arguments.of(new GregorianCalendar( 2007, Calendar.DECEMBER, 31), "2008-W01-1"),             Arguments.of(new GregorianCalendar( 2008, Calendar.JANUARY, 1), "2008-W01-2"),             Arguments.of(new GregorianCalendar( 2008, Calendar.DECEMBER, 28), "2008-W52-7"),             Arguments.of(new GregorianCalendar( 2008, Calendar.DECEMBER, 29), "2009-W01-1"),             Arguments.of(new GregorianCalendar( 2008, Calendar.DECEMBER, 30), "2009-W01-2"),             Arguments.of(new GregorianCalendar( 2008, Calendar.DECEMBER, 31), "2009-W01-3"),             Arguments.of(new GregorianCalendar( 2009, Calendar.JANUARY, 1), "2009-W01-4"),             Arguments.of(new GregorianCalendar( 2009, Calendar.DECEMBER, 31), "2009-W53-4"),             Arguments.of(new GregorianCalendar( 2010, Calendar.JANUARY, 1), "2009-W53-5"),             Arguments.of(new GregorianCalendar( 2010, Calendar.JANUARY, 2), "2009-W53-6"),             Arguments.of(new GregorianCalendar( 2010, Calendar.JANUARY, 3), "2009-W53-7")         );     }      @ParameterizedTest     @MethodSource("data")     public void testParser(final Calendar vulgar, final String isoForm) {         final DateParser parser = new FastDateParser("YYYY-'W'ww-u", TimeZone.getDefault(), Locale.getDefault());          final Calendar cal = Calendar.getInstance();         cal.setMinimalDaysInFirstWeek(4);         cal.setFirstDayOfWeek(Calendar.MONDAY);         cal.clear();          parser.parse(isoForm, new ParsePosition(0), cal);         assertEquals(vulgar.getTime(), cal.getTime());     }      @ParameterizedTest     @MethodSource("data")     public void testPrinter(final Calendar vulgar, final String isoForm) {         final FastDatePrinter printer = new FastDatePrinter("YYYY-'W'ww-u", TimeZone.getDefault(), Locale.getDefault());          vulgar.setMinimalDaysInFirstWeek(4);         vulgar.setFirstDayOfWeek(Calendar.MONDAY);          assertEquals(isoForm, printer.format(vulgar));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull;  import java.text.ParsePosition; import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.util.TimeZone;  import org.junit.jupiter.api.Test;  public class FastDateParser_MoreOrLessTest {      private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York");      @Test     public void testInputHasPrecedingCharacters() {         final FastDateParser parser = new FastDateParser("MM/dd", TimeZone.getDefault(), Locale.getDefault());         final ParsePosition parsePosition = new ParsePosition(0);         final Date date = parser.parse("A 3/23/61", parsePosition);         assertNull(date);         assertEquals(0, parsePosition.getIndex());         assertEquals(0, parsePosition.getErrorIndex());     }      @Test     public void testInputHasWhitespace() {         final FastDateParser parser = new FastDateParser("M/d/y", TimeZone.getDefault(), Locale.getDefault());         //SimpleDateFormat parser = new SimpleDateFormat("M/d/y");         final ParsePosition parsePosition = new ParsePosition(0);         final Date date = parser.parse(" 3/ 23/ 1961", parsePosition);         assertEquals(12, parsePosition.getIndex());          final Calendar calendar = Calendar.getInstance();         calendar.setTime(date);         assertEquals(1961, calendar.get(Calendar.YEAR));         assertEquals(2, calendar.get(Calendar.MONTH));         assertEquals(23, calendar.get(Calendar.DATE));     }      @Test     public void testInputHasMoreCharacters() {         final FastDateParser parser = new FastDateParser("MM/dd", TimeZone.getDefault(), Locale.getDefault());         final ParsePosition parsePosition = new ParsePosition(0);         final Date date = parser.parse("3/23/61", parsePosition);         assertEquals(4, parsePosition.getIndex());          final Calendar calendar = Calendar.getInstance();         calendar.setTime(date);         assertEquals(2, calendar.get(Calendar.MONTH));         assertEquals(23, calendar.get(Calendar.DATE));     }      @Test     public void testInputHasWrongCharacters() {         final FastDateParser parser = new FastDateParser("MM-dd-yyy", TimeZone.getDefault(), Locale.getDefault());         final ParsePosition parsePosition = new ParsePosition(0);         assertNull(parser.parse("03/23/1961", parsePosition));         assertEquals(2, parsePosition.getErrorIndex());     }      @Test     public void testInputHasLessCharacters() {         final FastDateParser parser = new FastDateParser("MM/dd/yyy", TimeZone.getDefault(), Locale.getDefault());         final ParsePosition parsePosition = new ParsePosition(0);         assertNull(parser.parse("03/23", parsePosition));         assertEquals(5, parsePosition.getErrorIndex());     }      @Test     public void testInputHasWrongTimeZone() {         final FastDateParser parser = new FastDateParser("mm:ss z", NEW_YORK, Locale.US);          final String input = "11:23 Pacific Standard Time";         final ParsePosition parsePosition = new ParsePosition(0);         assertNotNull(parser.parse(input, parsePosition));         assertEquals(input.length(), parsePosition.getIndex());          parsePosition.setIndex(0);         assertNull(parser.parse( "11:23 Pacific Standard ", parsePosition));         assertEquals(6, parsePosition.getErrorIndex());     }      @Test     public void testInputHasWrongDay() {         final FastDateParser parser = new FastDateParser("EEEE, MM/dd/yyy", NEW_YORK, Locale.US);         final String input = "Thursday, 03/23/61";         final ParsePosition parsePosition = new ParsePosition(0);         assertNotNull(parser.parse(input, parsePosition));         assertEquals(input.length(), parsePosition.getIndex());          parsePosition.setIndex(0);         assertNull(parser.parse( "Thorsday, 03/23/61", parsePosition));         assertEquals(0, parsePosition.getErrorIndex());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertNotEquals;  import java.text.DateFormatSymbols; import java.text.ParseException; import java.util.Date; import java.util.Locale; import java.util.TimeZone;  import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  class FastDateParser_TimeZoneStrategyTest {      @ParameterizedTest     @MethodSource("java.util.Locale#getAvailableLocales")     void testTimeZoneStrategyPattern(final Locale locale) throws ParseException {         final FastDateParser parser = new FastDateParser("z", TimeZone.getDefault(), locale);         final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();         for (final String[] zone : zones) {             for (int t = 1; t < zone.length; ++t) {                 final String tzDisplay = zone[t];                 if (tzDisplay == null) {                     break;                 }                 // An exception will be thrown and the test will fail if parsing isn't successful                 parser.parse(tzDisplay);             }         }     }      @Test     void testLang1219() throws ParseException {         final FastDateParser parser = new FastDateParser("dd.MM.yyyy HH:mm:ss z", TimeZone.getDefault(), Locale.GERMAN);          final Date summer = parser.parse("26.10.2014 02:00:00 MESZ");         final Date standard = parser.parse("26.10.2014 02:00:00 MEZ");         assertNotEquals(summer.getTime(), standard.getTime());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.text.ParseException; import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.util.TimeZone;  import org.junit.jupiter.api.Test; import org.junitpioneer.jupiter.DefaultLocale; import org.junitpioneer.jupiter.DefaultTimeZone;  /**  * TestCase for DateFormatUtils.  */ @SuppressWarnings("deprecation") // tests lots of deprecated items public class DateFormatUtilsTest {     //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new DateFormatUtils());         final Constructor<?>[] cons = DateFormatUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(DateFormatUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(DateFormatUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testFormat() {         final Calendar c = Calendar.getInstance(FastTimeZone.getGmtTimeZone());         c.set(2005, Calendar.JANUARY, 1, 12, 0, 0);         c.setTimeZone(TimeZone.getDefault());         final StringBuilder buffer = new StringBuilder ();         final int year = c.get(Calendar.YEAR);         final int month = c.get(Calendar.MONTH) + 1;         final int day = c.get(Calendar.DAY_OF_MONTH);         final int hour = c.get(Calendar.HOUR_OF_DAY);         buffer.append (year);         buffer.append(month);         buffer.append(day);         buffer.append(hour);         assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH"));          assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH"));          assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH", Locale.US));          assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), "yyyyMdH", Locale.US));     }      //-----------------------------------------------------------------------     @Test     public void testFormatCalendar() {         final Calendar c = Calendar.getInstance(FastTimeZone.getGmtTimeZone());         c.set(2005, Calendar.JANUARY, 1, 12, 0, 0);         c.setTimeZone(TimeZone.getDefault());         final StringBuilder buffer = new StringBuilder ();         final int year = c.get(Calendar.YEAR);         final int month = c.get(Calendar.MONTH) + 1;         final int day = c.get(Calendar.DAY_OF_MONTH);         final int hour = c.get(Calendar.HOUR_OF_DAY);         buffer.append (year);         buffer.append(month);         buffer.append(day);         buffer.append(hour);         assertEquals(buffer.toString(), DateFormatUtils.format(c, "yyyyMdH"));          assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH"));          assertEquals(buffer.toString(), DateFormatUtils.format(c, "yyyyMdH", Locale.US));          assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), "yyyyMdH", Locale.US));     }      @Test     public void testFormatUTC() {         final Calendar c = Calendar.getInstance(FastTimeZone.getGmtTimeZone());         c.set(2005, Calendar.JANUARY, 1, 12, 0, 0);         assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));          assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));          assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));          assertEquals ("2005-01-01T12:00:00", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));     }      private void assertFormats(final String expectedValue, final String pattern, final TimeZone timeZone, final Calendar cal) {         assertEquals(expectedValue, DateFormatUtils.format(cal.getTime(), pattern, timeZone));         assertEquals(expectedValue, DateFormatUtils.format(cal.getTime().getTime(), pattern, timeZone));         assertEquals(expectedValue, DateFormatUtils.format(cal, pattern, timeZone));     }      private Calendar createFebruaryTestDate(final TimeZone timeZone) {         final Calendar cal = Calendar.getInstance(timeZone);         cal.set(2002, Calendar.FEBRUARY, 23, 9, 11, 12);         return cal;     }      private Calendar createJuneTestDate(final TimeZone timeZone) {         final Calendar cal = Calendar.getInstance(timeZone);         cal.set(2003, Calendar.JUNE, 8, 10, 11, 12);         return cal;     }      private void testGmtMinus3(final String expectedValue, final String pattern) {         final TimeZone timeZone = TimeZone.getTimeZone("GMT-3");         assertFormats(expectedValue, pattern, timeZone, createFebruaryTestDate(timeZone));     }      private void testUTC(final String expectedValue, final String pattern) {         final TimeZone timeZone = FastTimeZone.getGmtTimeZone();         assertFormats(expectedValue, pattern, timeZone, createFebruaryTestDate(timeZone));     }      @Test     public void testDateTimeISO() {         testGmtMinus3("2002-02-23T09:11:12", DateFormatUtils.ISO_DATETIME_FORMAT.getPattern());         testGmtMinus3("2002-02-23T09:11:12-03:00", DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern());         testUTC("2002-02-23T09:11:12Z", DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern());     }      @Test     public void testDateISO() {         testGmtMinus3("2002-02-23", DateFormatUtils.ISO_DATE_FORMAT.getPattern());         testGmtMinus3("2002-02-23-03:00", DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern());         testUTC("2002-02-23Z", DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern());     }      @Test     public void testTimeISO() {         testGmtMinus3("T09:11:12", DateFormatUtils.ISO_TIME_FORMAT.getPattern());         testGmtMinus3("T09:11:12-03:00", DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern());         testUTC("T09:11:12Z", DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern());     }      @Test     public void testTimeNoTISO() {         testGmtMinus3("09:11:12", DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern());         testGmtMinus3("09:11:12-03:00", DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern());         testUTC("09:11:12Z", DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern());     }      @DefaultLocale(language = "en")     @Test     public void testSMTP() {         TimeZone timeZone = TimeZone.getTimeZone("GMT-3");         Calendar june = createJuneTestDate(timeZone);          assertFormats("Sun, 08 Jun 2003 10:11:12 -0300", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),                 timeZone, june);          timeZone = FastTimeZone.getGmtTimeZone();         june = createJuneTestDate(timeZone);         assertFormats("Sun, 08 Jun 2003 10:11:12 +0000", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),                 timeZone, june);     }      @Test     public void testLANG1000() throws Exception {         final String date = "2013-11-18T12:48:05Z";         DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.parse(date);     }      @DefaultTimeZone("UTC")     @Test     public void testLang530() throws ParseException {         final Date d = new Date();         final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);         final Date d2 = DateUtils.parseDate(isoDateStr, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern());         // the format loses milliseconds so have to reintroduce them         assertEquals(d.getTime(), d2.getTime() + d.getTime() % 1000, "Date not equal to itself ISO formatted and parsed");     }      /**      * According to LANG-916 (https://issues.apache.org/jira/browse/LANG-916),      * the format method did contain a bug: it did not use the TimeZone data.      *      * This method test that the bug is fixed.      */     @Test     public void testLang916() {          final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("Europe/Paris"));         cal.clear();         cal.set(2009, 9, 16, 8, 42, 16);          // Long.         {             final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Europe/Paris"));             assertEquals("2009-10-16T08:42:16+02:00", value, "long");         }         {             final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Asia/Kolkata"));             assertEquals("2009-10-16T12:12:16+05:30", value, "long");         }         {             final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Europe/London"));             assertEquals("2009-10-16T07:42:16+01:00", value, "long");         }          // Calendar.         {             final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Europe/Paris"));             assertEquals("2009-10-16T08:42:16+02:00", value, "calendar");         }         {             final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Asia/Kolkata"));             assertEquals("2009-10-16T12:12:16+05:30", value, "calendar");         }         {             final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Europe/London"));             assertEquals("2009-10-16T07:42:16+01:00", value, "calendar");         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Tests for GmtTimeZone  */ public class GmtTimeZoneTest {      @Test     public void hoursOutOfRange() {         assertThrows(IllegalArgumentException.class, () -> new GmtTimeZone(false, 24, 0));     }      @Test     public void hoursInRange() {         assertEquals(23 * 60 * 60 * 1000, new GmtTimeZone(false, 23, 0).getRawOffset());     }      @Test     public void minutesOutOfRange() {         assertThrows(IllegalArgumentException.class, () -> new GmtTimeZone(false, 0, 60));     }      @Test     public void minutesInRange() {         assertEquals(59 * 60 * 1000, new GmtTimeZone(false, 0, 59).getRawOffset());     }      @Test     public void getOffset() {         assertEquals(0, new GmtTimeZone(false, 0, 0).getOffset(234304));     }      @Test     public void setRawOffset() {         assertThrows(UnsupportedOperationException.class, () -> new GmtTimeZone(false, 0, 0).setRawOffset(0));     }      @Test     public void getRawOffset() {         assertEquals(0, new GmtTimeZone(false, 0, 0).getRawOffset());     }      @Test     public void getID() {         assertEquals("GMT+00:00", new GmtTimeZone(false, 0, 0).getID());         assertEquals("GMT+01:02", new GmtTimeZone(false, 1, 2).getID());         assertEquals("GMT+11:22", new GmtTimeZone(false, 11, 22).getID());         assertEquals("GMT-01:02", new GmtTimeZone(true, 1, 2).getID());         assertEquals("GMT-11:22", new GmtTimeZone(true, 11, 22).getID());     }      @Test     public void useDaylightTime() {         assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());     }      @Test     public void inDaylightTime() {         assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());     }      @Test     public void testToString() {         assertEquals("[GmtTimeZone id=\"GMT-12:00\",offset=-43200000]",             new GmtTimeZone(true, 12, 0).toString());     }      @Test     public void testGetOffset() {         assertEquals(-(6 * 60 + 30) * 60 * 1000,             new GmtTimeZone(true, 6, 30).getOffset(1, 1, 1, 1, 1, 1));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; import java.util.TimeZone; import java.util.stream.Stream;  import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  /**  * Compare FastDateParser with SimpleDateFormat  */ public class FastDateParserSDFTest {      public static Stream<Arguments> data() {         return Stream.of(                 // General Time zone tests                 Arguments.of("z yyyy", "GMT 2010",       Locale.UK, true), // no offset specified, but this is allowed as a TimeZone name                 Arguments.of("z yyyy", "GMT-123 2010",   Locale.UK, false),                 Arguments.of("z yyyy", "GMT-1234 2010",  Locale.UK, false),                 Arguments.of("z yyyy", "GMT-12:34 2010", Locale.UK, true),                 Arguments.of("z yyyy", "GMT-1:23 2010",  Locale.UK, true),                 // RFC 822 tests                 Arguments.of("z yyyy", "-1234 2010",     Locale.UK, true),                 Arguments.of("z yyyy", "-12:34 2010",    Locale.UK, false),                 Arguments.of("z yyyy", "-123 2010",      Locale.UK, false),                 // year tests                 Arguments.of( "MM/dd/yyyy", "01/11/12",  Locale.UK, true),                 Arguments.of( "MM/dd/yy", "01/11/12",    Locale.UK, true),                  // LANG-1089                 Arguments.of( "HH", "00",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "00",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "00",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "00",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "01",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "01",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "01",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "01",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "11",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "11",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "11",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "11",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "12",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "12",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "12",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "12",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "13",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "13",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "13",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "13",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "23",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "23",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "23",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "23",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "24",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "24",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "24",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "24",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "25",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "25",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "25",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "25",    Locale.UK, true), // Hour in day (1-24), i.e. midnight is 24, not 0                  Arguments.of( "HH", "48",    Locale.UK, true), // Hour in day (0-23)                 Arguments.of( "KK", "48",    Locale.UK, true), // Hour in am/pm (0-11)                 Arguments.of( "hh", "48",    Locale.UK, true), // Hour in am/pm (1-12), i.e. midday/midnight is 12, not 0                 Arguments.of( "kk", "48",    Locale.UK, true)  // Hour in day (1-24), i.e. midnight is 24, not 0         );     }      private static final TimeZone timeZone = TimeZone.getDefault();      @ParameterizedTest     @MethodSource("data")     public void testOriginal(final String format, final String input, final Locale locale, final boolean valid) {         checkParse(input, format, locale, valid);     }      @ParameterizedTest     @MethodSource("data")     public void testOriginalPP(final String format, final String input, final Locale locale, final boolean valid) {         checkParsePosition(input, format, locale, valid);     }      @ParameterizedTest     @MethodSource("data")     public void testUpperCase(final String format, final String input, final Locale locale, final boolean valid) {         checkParse(input.toUpperCase(locale), format, locale, valid);     }      @ParameterizedTest     @MethodSource("data")     public void testUpperCasePP(final String format, final String input, final Locale locale, final boolean valid) {         checkParsePosition(input.toUpperCase(locale), format, locale, valid);     }      @ParameterizedTest     @MethodSource("data")     public void testLowerCase(final String format, final String input, final Locale locale, final boolean valid) {         checkParse(input.toLowerCase(locale), format, locale, valid);     }      @ParameterizedTest     @MethodSource("data")     public void testLowerCasePP(final String format, final String input, final Locale locale, final boolean valid) {         checkParsePosition(input.toLowerCase(locale), format, locale, valid);     }      private void checkParse(final String formattedDate, final String format, final Locale locale, final boolean valid) {         final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);         sdf.setTimeZone(timeZone);         final DateParser fdf = new FastDateParser(format, timeZone, locale);         Date expectedTime=null;         Class<?> sdfE = null;         try {             expectedTime = sdf.parse(formattedDate);             if (!valid) {                 // Error in test data                 throw new RuntimeException("Test data error: expected SDF parse to fail, but got " + expectedTime);             }         } catch (final ParseException e) {             if (valid) {                 // Error in test data                 throw new RuntimeException("Test data error: expected SDF parse to succeed, but got " + e);             }             sdfE = e.getClass();         }         Date actualTime = null;         Class<?> fdfE = null;         try {             actualTime = fdf.parse(formattedDate);             // failure in test             assertTrue(valid, "Expected FDP parse to fail, but got " + actualTime);         } catch (final ParseException e) {             // failure in test             assertFalse(valid, "Expected FDP parse to succeed, but got " + e);             fdfE = e.getClass();         }         if (valid) {             assertEquals(expectedTime, actualTime, locale.toString()+" "+formattedDate +"\n");         } else {             assertEquals(sdfE, fdfE, locale.toString()+" "+formattedDate + " expected same Exception ");         }     }     private void checkParsePosition(final String formattedDate, final String format, final Locale locale, final boolean valid) {         final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);         sdf.setTimeZone(timeZone);         final DateParser fdf = new FastDateParser(format, timeZone, locale);          final ParsePosition sdfP = new ParsePosition(0);         final Date expectedTime = sdf.parse(formattedDate, sdfP);         final int sdferrorIndex = sdfP.getErrorIndex();         if (valid) {             assertEquals(-1, sdferrorIndex, "Expected SDF error index -1 ");             final int endIndex = sdfP.getIndex();             final int length = formattedDate.length();             if (endIndex != length) {                 // Error in test data                 throw new RuntimeException("Test data error: expected SDF parse to consume entire string; endindex " + endIndex + " != " + length);             }         } else {             final int errorIndex = sdfP.getErrorIndex();             if (errorIndex == -1) {                 throw new RuntimeException("Test data error: expected SDF parse to fail, but got " + expectedTime);             }         }          final ParsePosition fdfP = new ParsePosition(0);         final Date actualTime = fdf.parse(formattedDate, fdfP);         final int fdferrorIndex = fdfP.getErrorIndex();         if (valid) {             assertEquals(-1, fdferrorIndex, "Expected FDF error index -1 ");             final int endIndex = fdfP.getIndex();             final int length = formattedDate.length();             assertEquals(length, endIndex, "Expected FDF to parse full string " + fdfP);             assertEquals(expectedTime, actualTime, locale.toString()+" "+formattedDate +"\n");         } else {             assertNotEquals(-1, fdferrorIndex, "Test data error: expected FDF parse to fail, but got " + actualTime);             assertTrue(sdferrorIndex - fdferrorIndex <= 4,                     "FDF error index ("+ fdferrorIndex + ") should approximate SDF index (" + sdferrorIndex + ")");         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.time;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.Calendar;  import org.junit.jupiter.api.Test;  public class CalendarUtilsTest {      @Test     public void testGetYear() {         assertEquals(Calendar.getInstance().get(Calendar.YEAR), CalendarUtils.INSTANCE.getYear());     }      @Test     public void testGetMonth() {         assertEquals(Calendar.getInstance().get(Calendar.MONTH), CalendarUtils.INSTANCE.getMonth());     }      @Test     public void testGetDayOfMonth() {         assertEquals(Calendar.getInstance().get(Calendar.DAY_OF_MONTH), CalendarUtils.INSTANCE.getDayOfMonth());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.CharSetUtils}.  */ public class CharSetUtilsTest  {      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new CharSetUtils());         final Constructor<?>[] cons = CharSetUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(CharSetUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(CharSetUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testSqueeze_StringString() {         assertNull(CharSetUtils.squeeze(null, (String) null));         assertNull(CharSetUtils.squeeze(null, ""));          assertEquals("", CharSetUtils.squeeze("", (String) null));         assertEquals("", CharSetUtils.squeeze("", ""));         assertEquals("", CharSetUtils.squeeze("", "a-e"));          assertEquals("hello", CharSetUtils.squeeze("hello", (String) null));         assertEquals("hello", CharSetUtils.squeeze("hello", ""));         assertEquals("hello", CharSetUtils.squeeze("hello", "a-e"));         assertEquals("helo", CharSetUtils.squeeze("hello", "l-p"));         assertEquals("heloo", CharSetUtils.squeeze("helloo", "l"));         assertEquals("hello", CharSetUtils.squeeze("helloo", "^l"));     }      @Test     public void testSqueeze_StringStringarray() {         assertNull(CharSetUtils.squeeze(null, (String[]) null));         assertNull(CharSetUtils.squeeze(null));         assertNull(CharSetUtils.squeeze(null, null));         assertNull(CharSetUtils.squeeze(null, "el"));          assertEquals("", CharSetUtils.squeeze("", (String[]) null));         assertEquals("", CharSetUtils.squeeze(""));         assertEquals("", CharSetUtils.squeeze("", null));         assertEquals("", CharSetUtils.squeeze("", "a-e"));          assertEquals("hello", CharSetUtils.squeeze("hello", (String[]) null));         assertEquals("hello", CharSetUtils.squeeze("hello"));         assertEquals("hello", CharSetUtils.squeeze("hello", null));         assertEquals("hello", CharSetUtils.squeeze("hello", "a-e"));          assertEquals("helo", CharSetUtils.squeeze("hello", "el"));         assertEquals("hello", CharSetUtils.squeeze("hello", "e"));         assertEquals("fofof", CharSetUtils.squeeze("fooffooff", "of"));         assertEquals("fof", CharSetUtils.squeeze("fooooff", "fo"));     }      //-----------------------------------------------------------------------     @Test     public void testContainsAny_StringString() {         assertFalse(CharSetUtils.containsAny(null, (String) null));         assertFalse(CharSetUtils.containsAny(null, ""));          assertFalse(CharSetUtils.containsAny("", (String) null));         assertFalse(CharSetUtils.containsAny("", ""));         assertFalse(CharSetUtils.containsAny("", "a-e"));          assertFalse(CharSetUtils.containsAny("hello", (String) null));         assertFalse(CharSetUtils.containsAny("hello", ""));         assertTrue(CharSetUtils.containsAny("hello", "a-e"));         assertTrue(CharSetUtils.containsAny("hello", "l-p"));     }      @Test     public void testContainsAny_StringStringarray() {         assertFalse(CharSetUtils.containsAny(null, (String[]) null));         assertFalse(CharSetUtils.containsAny(null));         assertFalse(CharSetUtils.containsAny(null, null));         assertFalse(CharSetUtils.containsAny(null, "a-e"));          assertFalse(CharSetUtils.containsAny("", (String[]) null));         assertFalse(CharSetUtils.containsAny(""));         assertFalse(CharSetUtils.containsAny("", null));         assertFalse(CharSetUtils.containsAny("", "a-e"));          assertFalse(CharSetUtils.containsAny("hello", (String[]) null));         assertFalse(CharSetUtils.containsAny("hello"));         assertFalse(CharSetUtils.containsAny("hello", null));         assertTrue(CharSetUtils.containsAny("hello", "a-e"));          assertTrue(CharSetUtils.containsAny("hello", "el"));         assertFalse(CharSetUtils.containsAny("hello", "x"));         assertTrue(CharSetUtils.containsAny("hello", "e-i"));         assertTrue(CharSetUtils.containsAny("hello", "a-z"));         assertFalse(CharSetUtils.containsAny("hello", ""));     }      //-----------------------------------------------------------------------     @Test     public void testCount_StringString() {         assertEquals(0, CharSetUtils.count(null, (String) null));         assertEquals(0, CharSetUtils.count(null, ""));          assertEquals(0, CharSetUtils.count("", (String) null));         assertEquals(0, CharSetUtils.count("", ""));         assertEquals(0, CharSetUtils.count("", "a-e"));          assertEquals(0, CharSetUtils.count("hello", (String) null));         assertEquals(0, CharSetUtils.count("hello", ""));         assertEquals(1, CharSetUtils.count("hello", "a-e"));         assertEquals(3, CharSetUtils.count("hello", "l-p"));     }      @Test     public void testCount_StringStringarray() {         assertEquals(0, CharSetUtils.count(null, (String[]) null));         assertEquals(0, CharSetUtils.count(null));         assertEquals(0, CharSetUtils.count(null, null));         assertEquals(0, CharSetUtils.count(null, "a-e"));          assertEquals(0, CharSetUtils.count("", (String[]) null));         assertEquals(0, CharSetUtils.count(""));         assertEquals(0, CharSetUtils.count("", null));         assertEquals(0, CharSetUtils.count("", "a-e"));          assertEquals(0, CharSetUtils.count("hello", (String[]) null));         assertEquals(0, CharSetUtils.count("hello"));         assertEquals(0, CharSetUtils.count("hello", null));         assertEquals(1, CharSetUtils.count("hello", "a-e"));          assertEquals(3, CharSetUtils.count("hello", "el"));         assertEquals(0, CharSetUtils.count("hello", "x"));         assertEquals(2, CharSetUtils.count("hello", "e-i"));         assertEquals(5, CharSetUtils.count("hello", "a-z"));         assertEquals(0, CharSetUtils.count("hello", ""));     }      //-----------------------------------------------------------------------     @Test     public void testKeep_StringString() {         assertNull(CharSetUtils.keep(null, (String) null));         assertNull(CharSetUtils.keep(null, ""));          assertEquals("", CharSetUtils.keep("", (String) null));         assertEquals("", CharSetUtils.keep("", ""));         assertEquals("", CharSetUtils.keep("", "a-e"));          assertEquals("", CharSetUtils.keep("hello", (String) null));         assertEquals("", CharSetUtils.keep("hello", ""));         assertEquals("", CharSetUtils.keep("hello", "xyz"));         assertEquals("hello", CharSetUtils.keep("hello", "a-z"));         assertEquals("hello", CharSetUtils.keep("hello", "oleh"));         assertEquals("ell", CharSetUtils.keep("hello", "el"));     }      @Test     public void testKeep_StringStringarray() {         assertNull(CharSetUtils.keep(null, (String[]) null));         assertNull(CharSetUtils.keep(null));         assertNull(CharSetUtils.keep(null, null));         assertNull(CharSetUtils.keep(null, "a-e"));          assertEquals("", CharSetUtils.keep("", (String[]) null));         assertEquals("", CharSetUtils.keep(""));         assertEquals("", CharSetUtils.keep("", null));         assertEquals("", CharSetUtils.keep("", "a-e"));          assertEquals("", CharSetUtils.keep("hello", (String[]) null));         assertEquals("", CharSetUtils.keep("hello"));         assertEquals("", CharSetUtils.keep("hello", null));         assertEquals("e", CharSetUtils.keep("hello", "a-e"));          assertEquals("e", CharSetUtils.keep("hello", "a-e"));         assertEquals("ell", CharSetUtils.keep("hello", "el"));         assertEquals("hello", CharSetUtils.keep("hello", "elho"));         assertEquals("hello", CharSetUtils.keep("hello", "a-z"));         assertEquals("----", CharSetUtils.keep("----", "-"));         assertEquals("ll", CharSetUtils.keep("hello", "l"));     }      //-----------------------------------------------------------------------     @Test     public void testDelete_StringString() {         assertNull(CharSetUtils.delete(null, (String) null));         assertNull(CharSetUtils.delete(null, ""));          assertEquals("", CharSetUtils.delete("", (String) null));         assertEquals("", CharSetUtils.delete("", ""));         assertEquals("", CharSetUtils.delete("", "a-e"));          assertEquals("hello", CharSetUtils.delete("hello", (String) null));         assertEquals("hello", CharSetUtils.delete("hello", ""));         assertEquals("hllo", CharSetUtils.delete("hello", "a-e"));         assertEquals("he", CharSetUtils.delete("hello", "l-p"));         assertEquals("hello", CharSetUtils.delete("hello", "z"));     }      @Test     public void testDelete_StringStringarray() {         assertNull(CharSetUtils.delete(null, (String[]) null));         assertNull(CharSetUtils.delete(null));         assertNull(CharSetUtils.delete(null, null));         assertNull(CharSetUtils.delete(null, "el"));          assertEquals("", CharSetUtils.delete("", (String[]) null));         assertEquals("", CharSetUtils.delete(""));         assertEquals("", CharSetUtils.delete("", null));         assertEquals("", CharSetUtils.delete("", "a-e"));          assertEquals("hello", CharSetUtils.delete("hello", (String[]) null));         assertEquals("hello", CharSetUtils.delete("hello"));         assertEquals("hello", CharSetUtils.delete("hello", null));         assertEquals("hello", CharSetUtils.delete("hello", "xyz"));          assertEquals("ho", CharSetUtils.delete("hello", "el"));         assertEquals("", CharSetUtils.delete("hello", "elho"));         assertEquals("hello", CharSetUtils.delete("hello", ""));         assertEquals("hello", CharSetUtils.delete("hello", ""));         assertEquals("", CharSetUtils.delete("hello", "a-z"));         assertEquals("", CharSetUtils.delete("----", "-"));         assertEquals("heo", CharSetUtils.delete("hello", "l"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.nio.charset.StandardCharsets;  import org.junit.jupiter.api.Test;  /**  * Tests CharEncoding.  *  * @see CharEncoding  */ @SuppressWarnings("deprecation") public class CharEncodingTest  {      private void assertSupportedEncoding(final String name) {         assertTrue(CharEncoding.isSupported(name), "Encoding should be supported: " + name);     }      /**      * The class can be instantiated.      */     @Test     public void testConstructor() {         new CharEncoding();     }      @Test     public void testMustBeSupportedJava1_3_1_and_above() {         this.assertSupportedEncoding(CharEncoding.ISO_8859_1);         this.assertSupportedEncoding(CharEncoding.US_ASCII);         this.assertSupportedEncoding(CharEncoding.UTF_16);         this.assertSupportedEncoding(CharEncoding.UTF_16BE);         this.assertSupportedEncoding(CharEncoding.UTF_16LE);         this.assertSupportedEncoding(CharEncoding.UTF_8);     }      @Test     public void testSupported() {         assertTrue(CharEncoding.isSupported("UTF8"));         assertTrue(CharEncoding.isSupported("UTF-8"));         assertTrue(CharEncoding.isSupported("ASCII"));     }      @Test     public void testNotSupported() {         assertFalse(CharEncoding.isSupported(null));         assertFalse(CharEncoding.isSupported(""));         assertFalse(CharEncoding.isSupported(" "));         assertFalse(CharEncoding.isSupported("\t\r\n"));         assertFalse(CharEncoding.isSupported("DOESNOTEXIST"));         assertFalse(CharEncoding.isSupported("this is not a valid encoding name"));     }      @Test     public void testStandardCharsetsEquality() {         assertEquals(StandardCharsets.ISO_8859_1.name(), CharEncoding.ISO_8859_1);         assertEquals(StandardCharsets.US_ASCII.name(), CharEncoding.US_ASCII);         assertEquals(StandardCharsets.UTF_8.name(), CharEncoding.UTF_8);         assertEquals(StandardCharsets.UTF_16.name(), CharEncoding.UTF_16);         assertEquals(StandardCharsets.UTF_16BE.name(), CharEncoding.UTF_16BE);         assertEquals(StandardCharsets.UTF_16LE.name(), CharEncoding.UTF_16LE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.CharUtils}.  */ public class CharUtilsTest {      private static final char CHAR_COPY = '\u00a9';     private static final Character CHARACTER_A = Character.valueOf('A');     private static final Character CHARACTER_B = Character.valueOf('B');      @Test     public void testCompare() {         assertTrue(CharUtils.compare('a', 'b') < 0);         assertEquals(0, CharUtils.compare('c', 'c'));         assertTrue(CharUtils.compare('c', 'a') > 0);     }      @Test     public void testConstructor() {         assertNotNull(new CharUtils());         final Constructor<?>[] cons = CharUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(CharUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(CharUtils.class.getModifiers()));     }      @Test     public void testIsAscii_char() {         assertTrue(CharUtils.isAscii('a'));         assertTrue(CharUtils.isAscii('A'));         assertTrue(CharUtils.isAscii('3'));         assertTrue(CharUtils.isAscii('-'));         assertTrue(CharUtils.isAscii('\n'));         assertFalse(CharUtils.isAscii(CHAR_COPY));          for (int i = 0; i < 255; i++) {             assertEquals(i < 128, CharUtils.isAscii((char) i));         }     }      @Test     public void testIsAsciiAlpha_char() {         assertTrue(CharUtils.isAsciiAlpha('a'));         assertTrue(CharUtils.isAsciiAlpha('A'));         assertFalse(CharUtils.isAsciiAlpha('3'));         assertFalse(CharUtils.isAsciiAlpha('-'));         assertFalse(CharUtils.isAsciiAlpha('\n'));         assertFalse(CharUtils.isAsciiAlpha(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z')) {                 assertTrue(CharUtils.isAsciiAlpha((char) i));             } else {                 assertFalse(CharUtils.isAsciiAlpha((char) i));             }         }     }      @Test     public void testIsAsciiAlphaLower_char() {         assertTrue(CharUtils.isAsciiAlphaLower('a'));         assertFalse(CharUtils.isAsciiAlphaLower('A'));         assertFalse(CharUtils.isAsciiAlphaLower('3'));         assertFalse(CharUtils.isAsciiAlphaLower('-'));         assertFalse(CharUtils.isAsciiAlphaLower('\n'));         assertFalse(CharUtils.isAsciiAlphaLower(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if (i >= 'a' && i <= 'z') {                 assertTrue(CharUtils.isAsciiAlphaLower((char) i));             } else {                 assertFalse(CharUtils.isAsciiAlphaLower((char) i));             }         }     }      @Test     public void testIsAsciiAlphanumeric_char() {         assertTrue(CharUtils.isAsciiAlphanumeric('a'));         assertTrue(CharUtils.isAsciiAlphanumeric('A'));         assertTrue(CharUtils.isAsciiAlphanumeric('3'));         assertFalse(CharUtils.isAsciiAlphanumeric('-'));         assertFalse(CharUtils.isAsciiAlphanumeric('\n'));         assertFalse(CharUtils.isAsciiAlphanumeric(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z') || (i >= '0' && i <= '9')) {                 assertTrue(CharUtils.isAsciiAlphanumeric((char) i));             } else {                 assertFalse(CharUtils.isAsciiAlphanumeric((char) i));             }         }     }      @Test     public void testIsAsciiAlphaUpper_char() {         assertFalse(CharUtils.isAsciiAlphaUpper('a'));         assertTrue(CharUtils.isAsciiAlphaUpper('A'));         assertFalse(CharUtils.isAsciiAlphaUpper('3'));         assertFalse(CharUtils.isAsciiAlphaUpper('-'));         assertFalse(CharUtils.isAsciiAlphaUpper('\n'));         assertFalse(CharUtils.isAsciiAlphaUpper(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if (i >= 'A' && i <= 'Z') {                 assertTrue(CharUtils.isAsciiAlphaUpper((char) i));             } else {                 assertFalse(CharUtils.isAsciiAlphaUpper((char) i));             }         }     }      @Test     public void testIsAsciiControl_char() {         assertFalse(CharUtils.isAsciiControl('a'));         assertFalse(CharUtils.isAsciiControl('A'));         assertFalse(CharUtils.isAsciiControl('3'));         assertFalse(CharUtils.isAsciiControl('-'));         assertTrue(CharUtils.isAsciiControl('\n'));         assertFalse(CharUtils.isAsciiControl(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if (i < 32 || i == 127) {                 assertTrue(CharUtils.isAsciiControl((char) i));             } else {                 assertFalse(CharUtils.isAsciiControl((char) i));             }         }     }      @Test     public void testIsAsciiNumeric_char() {         assertFalse(CharUtils.isAsciiNumeric('a'));         assertFalse(CharUtils.isAsciiNumeric('A'));         assertTrue(CharUtils.isAsciiNumeric('3'));         assertFalse(CharUtils.isAsciiNumeric('-'));         assertFalse(CharUtils.isAsciiNumeric('\n'));         assertFalse(CharUtils.isAsciiNumeric(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if (i >= '0' && i <= '9') {                 assertTrue(CharUtils.isAsciiNumeric((char) i));             } else {                 assertFalse(CharUtils.isAsciiNumeric((char) i));             }         }     }      @Test     public void testIsAsciiPrintable_char() {         assertTrue(CharUtils.isAsciiPrintable('a'));         assertTrue(CharUtils.isAsciiPrintable('A'));         assertTrue(CharUtils.isAsciiPrintable('3'));         assertTrue(CharUtils.isAsciiPrintable('-'));         assertFalse(CharUtils.isAsciiPrintable('\n'));         assertFalse(CharUtils.isAsciiPrintable(CHAR_COPY));          for (int i = 0; i < 196; i++) {             if (i >= 32 && i <= 126) {                 assertTrue(CharUtils.isAsciiPrintable((char) i));             } else {                 assertFalse(CharUtils.isAsciiPrintable((char) i));             }         }     }      @Test     public void testToChar_Character() {         assertEquals('A', CharUtils.toChar(CHARACTER_A));         assertEquals('B', CharUtils.toChar(CHARACTER_B));         assertThrows(NullPointerException.class, () -> CharUtils.toChar((Character) null));     }      @Test     public void testToChar_Character_char() {         assertEquals('A', CharUtils.toChar(CHARACTER_A, 'X'));         assertEquals('B', CharUtils.toChar(CHARACTER_B, 'X'));         assertEquals('X', CharUtils.toChar((Character) null, 'X'));     }      @Test     public void testToChar_String() {         assertEquals('A', CharUtils.toChar("A"));         assertEquals('B', CharUtils.toChar("BA"));         assertThrows(NullPointerException.class, () -> CharUtils.toChar((String) null));         assertThrows(IllegalArgumentException.class, () -> CharUtils.toChar(""));     }      @Test     public void testToChar_String_char() {         assertEquals('A', CharUtils.toChar("A", 'X'));         assertEquals('B', CharUtils.toChar("BA", 'X'));         assertEquals('X', CharUtils.toChar("", 'X'));         assertEquals('X', CharUtils.toChar((String) null, 'X'));     }      @SuppressWarnings("deprecation") // intentional test of deprecated method     @Test     public void testToCharacterObject_char() {         assertEquals(Character.valueOf('a'), CharUtils.toCharacterObject('a'));         assertSame(CharUtils.toCharacterObject('a'), CharUtils.toCharacterObject('a'));          for (int i = 0; i < 128; i++) {             final Character ch = CharUtils.toCharacterObject((char) i);             final Character ch2 = CharUtils.toCharacterObject((char) i);             assertSame(ch, ch2);             assertEquals(i, ch.charValue());         }         for (int i = 128; i < 196; i++) {             final Character ch = CharUtils.toCharacterObject((char) i);             final Character ch2 = CharUtils.toCharacterObject((char) i);             assertEquals(ch, ch2);             assertNotSame(ch, ch2);             assertEquals(i, ch.charValue());             assertEquals(i, ch2.charValue());         }         assertSame(CharUtils.toCharacterObject("a"), CharUtils.toCharacterObject('a'));     }      @Test     public void testToCharacterObject_String() {         assertNull(CharUtils.toCharacterObject(null));         assertNull(CharUtils.toCharacterObject(""));         assertEquals(Character.valueOf('a'), CharUtils.toCharacterObject("a"));         assertEquals(Character.valueOf('a'), CharUtils.toCharacterObject("abc"));         assertSame(CharUtils.toCharacterObject("a"), CharUtils.toCharacterObject("a"));     }      @Test     public void testToIntValue_char() {         assertEquals(0, CharUtils.toIntValue('0'));         assertEquals(1, CharUtils.toIntValue('1'));         assertEquals(2, CharUtils.toIntValue('2'));         assertEquals(3, CharUtils.toIntValue('3'));         assertEquals(4, CharUtils.toIntValue('4'));         assertEquals(5, CharUtils.toIntValue('5'));         assertEquals(6, CharUtils.toIntValue('6'));         assertEquals(7, CharUtils.toIntValue('7'));         assertEquals(8, CharUtils.toIntValue('8'));         assertEquals(9, CharUtils.toIntValue('9'));         assertThrows(IllegalArgumentException.class, () -> CharUtils.toIntValue('a'));     }      @Test     public void testToIntValue_char_int() {         assertEquals(0, CharUtils.toIntValue('0', -1));         assertEquals(3, CharUtils.toIntValue('3', -1));         assertEquals(-1, CharUtils.toIntValue('a', -1));     }      @Test     public void testToIntValue_Character() {         assertEquals(0, CharUtils.toIntValue(Character.valueOf('0')));         assertEquals(3, CharUtils.toIntValue(Character.valueOf('3')));         assertThrows(NullPointerException.class, () -> CharUtils.toIntValue(null));         assertThrows(IllegalArgumentException.class, () -> CharUtils.toIntValue(CHARACTER_A));     }      @Test     public void testToIntValue_Character_int() {         assertEquals(0, CharUtils.toIntValue(Character.valueOf('0'), -1));         assertEquals(3, CharUtils.toIntValue(Character.valueOf('3'), -1));         assertEquals(-1, CharUtils.toIntValue(Character.valueOf('A'), -1));         assertEquals(-1, CharUtils.toIntValue(null, -1));     }      @Test     public void testToString_char() {         assertEquals("a", CharUtils.toString('a'));         assertSame(CharUtils.toString('a'), CharUtils.toString('a'));          for (int i = 0; i < 128; i++) {             final String str = CharUtils.toString((char) i);             final String str2 = CharUtils.toString((char) i);             assertSame(str, str2);             assertEquals(1, str.length());             assertEquals(i, str.charAt(0));         }         for (int i = 128; i < 196; i++) {             final String str = CharUtils.toString((char) i);             final String str2 = CharUtils.toString((char) i);             assertEquals(str, str2);             assertNotSame(str, str2);             assertEquals(1, str.length());             assertEquals(i, str.charAt(0));             assertEquals(1, str2.length());             assertEquals(i, str2.charAt(0));         }     }      @Test     public void testToString_Character() {         assertNull(CharUtils.toString(null));         assertEquals("A", CharUtils.toString(CHARACTER_A));         assertSame(CharUtils.toString(CHARACTER_A), CharUtils.toString(CHARACTER_A));     }      @Test     public void testToUnicodeEscaped_char() {         assertEquals("\\u0041", CharUtils.unicodeEscaped('A'));         assertEquals("\\u004c", CharUtils.unicodeEscaped('L'));          for (int i = 0; i < 196; i++) {             final String str = CharUtils.unicodeEscaped((char) i);             assertEquals(6, str.length());             final int val = Integer.parseInt(str.substring(2), 16);             assertEquals(i, val);         }         assertEquals("\\u0999", CharUtils.unicodeEscaped((char) 0x999));         assertEquals("\\u1001", CharUtils.unicodeEscaped((char) 0x1001));     }      @Test     public void testToUnicodeEscaped_Character() {         assertNull(CharUtils.unicodeEscaped(null));         assertEquals("\\u0041", CharUtils.unicodeEscaped(CHARACTER_A));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Class to test BitField functionality  */ public class BitFieldTest  {      private static final BitField bf_multi  = new BitField(0x3F80);     private static final BitField bf_single = new BitField(0x4000);     private static final BitField bf_zero = new BitField(0);      /**      * test the getValue() method      */     @Test     public void testGetValue() {         assertEquals(bf_multi.getValue(-1), 127);         assertEquals(bf_multi.getValue(0), 0);         assertEquals(bf_single.getValue(-1), 1);         assertEquals(bf_single.getValue(0), 0);         assertEquals(bf_zero.getValue(-1), 0);         assertEquals(bf_zero.getValue(0), 0);     }      /**      * test the getShortValue() method      */     @Test     public void testGetShortValue() {         assertEquals(bf_multi.getShortValue((short) - 1), (short) 127);         assertEquals(bf_multi.getShortValue((short) 0), (short) 0);         assertEquals(bf_single.getShortValue((short) - 1), (short) 1);         assertEquals(bf_single.getShortValue((short) 0), (short) 0);         assertEquals(bf_zero.getShortValue((short) -1), (short) 0);         assertEquals(bf_zero.getShortValue((short) 0), (short) 0);     }      /**      * test the getRawValue() method      */     @Test     public void testGetRawValue() {         assertEquals(bf_multi.getRawValue(-1), 0x3F80);         assertEquals(bf_multi.getRawValue(0), 0);         assertEquals(bf_single.getRawValue(-1), 0x4000);         assertEquals(bf_single.getRawValue(0), 0);         assertEquals(bf_zero.getRawValue(-1), 0);         assertEquals(bf_zero.getRawValue(0), 0);     }      /**      * test the getShortRawValue() method      */     @Test     public void testGetShortRawValue() {         assertEquals(bf_multi.getShortRawValue((short) - 1), (short) 0x3F80);         assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0);         assertEquals(bf_single.getShortRawValue((short) - 1), (short) 0x4000);         assertEquals(bf_single.getShortRawValue((short) 0), (short) 0);         assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0);         assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0);     }      /**      * test the isSet() method      */     @Test     public void testIsSet() {         assertFalse(bf_multi.isSet(0));         assertFalse(bf_zero.isSet(0));         for (int j = 0x80; j <= 0x3F80; j += 0x80) {             assertTrue(bf_multi.isSet(j));         }         for (int j = 0x80; j <= 0x3F80; j += 0x80) {             assertFalse(bf_zero.isSet(j));         }         assertFalse(bf_single.isSet(0));         assertTrue(bf_single.isSet(0x4000));     }      /**      * test the isAllSet() method      */     @Test     public void testIsAllSet() {         for (int j = 0; j < 0x3F80; j += 0x80) {             assertFalse(bf_multi.isAllSet(j));             assertTrue(bf_zero.isAllSet(j));         }         assertTrue(bf_multi.isAllSet(0x3F80));         assertFalse(bf_single.isAllSet(0));         assertTrue(bf_single.isAllSet(0x4000));     }      /**      * test the setValue() method      */     @Test     public void testSetValue() {         for (int j = 0; j < 128; j++) {             assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);             assertEquals(bf_multi.setValue(0, j), j << 7);         }         for (int j = 0; j < 128; j++) {           assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0);           assertEquals(bf_zero.setValue(0, j), 0);       }          // verify that excess bits are stripped off         assertEquals(bf_multi.setValue(0x3f80, 128), 0);         for (int j = 0; j < 2; j++) {             assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);             assertEquals(bf_single.setValue(0, j), j << 14);         }          // verify that excess bits are stripped off         assertEquals(bf_single.setValue(0x4000, 2), 0);     }      /**      * test the setShortValue() method      */     @Test     public void testSetShortValue() {         for (int j = 0; j < 128; j++) {             assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j);             assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7));         }         for (int j = 0; j < 128; j++) {             assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);             assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) 0);         }          // verify that excess bits are stripped off         assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0);         for (int j = 0; j < 2; j++) {             assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j);             assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14));         }          // verify that excess bits are stripped off         assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0);     }      @Test     public void testByte() {         assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true));         assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true));         assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true));         assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true));         assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true));         assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true));         assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true));         assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true));         assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true));         assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false));         assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false));         assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false));         assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false));         assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false));         assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false));         assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false));         assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false));         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false));         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false));         final byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);          assertFalse(new BitField(0x40).isSet(clearedBit));     }      /**      * test the clear() method      */     @Test     public void testClear() {         assertEquals(bf_multi.clear(-1), 0xFFFFC07F);         assertEquals(bf_single.clear(-1), 0xFFFFBFFF);         assertEquals(bf_zero.clear(-1), 0xFFFFFFFF);     }      /**      * test the clearShort() method      */     @Test     public void testClearShort() {         assertEquals(bf_multi.clearShort((short) - 1), (short) 0xC07F);         assertEquals(bf_single.clearShort((short) - 1), (short) 0xBFFF);         assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF);     }      /**      * test the set() method      */     @Test     public void testSet() {         assertEquals(bf_multi.set(0), 0x3F80);         assertEquals(bf_single.set(0), 0x4000);         assertEquals(bf_zero.set(0), 0);     }      /**      * test the setShort() method      */     @Test     public void testSetShort() {         assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80);         assertEquals(bf_single.setShort((short) 0), (short) 0x4000);         assertEquals(bf_zero.setShort((short) 0), (short) 0);     }      /**      * test the setBoolean() method      */     @Test     public void testSetBoolean() {         assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));         assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));         assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true));         assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));         assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));         assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false));     }      /**      * test the setShortBoolean() method      */     @Test     public void testSetShortBoolean() {         assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true));         assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true));         assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true));         assertEquals(bf_multi.clearShort((short) - 1), bf_multi.setShortBoolean((short) - 1, false));         assertEquals(bf_single.clearShort((short) - 1), bf_single.setShortBoolean((short) - 1, false));         assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.Serializable; import java.util.Arrays; import java.util.Collections; import java.util.Date; import java.util.List; import java.util.Set;  import org.apache.commons.lang3.SerializationUtils; import org.apache.commons.lang3.tuple.Pair; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;   /**  * Abstract test of an ExceptionContext implementation.  */ public abstract class AbstractExceptionContextTest<T extends ExceptionContext & Serializable> {      protected static final String TEST_MESSAGE_2 = "This is monotonous";     protected static final String TEST_MESSAGE = "Test Message";     protected T exceptionContext;      protected static class ObjectWithFaultyToString {         @Override         public String toString() {             throw new RuntimeException("Crap");         }     }       @BeforeEach     public void setUp() throws Exception {         exceptionContext             .addContextValue("test1", null)             .addContextValue("test2", "some value")             .addContextValue("test Date", new Date())             .addContextValue("test Nbr", Integer.valueOf(5))             .addContextValue("test Poorly written obj", new ObjectWithFaultyToString());     }      @Test     public void testAddContextValue() {         final String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);         assertTrue(message.contains(TEST_MESSAGE));         assertTrue(message.contains("test1"));         assertTrue(message.contains("test2"));         assertTrue(message.contains("test Date"));         assertTrue(message.contains("test Nbr"));         assertTrue(message.contains("some value"));         assertTrue(message.contains("5"));          assertNull(exceptionContext.getFirstContextValue("test1"));         assertEquals("some value", exceptionContext.getFirstContextValue("test2"));          assertEquals(5, exceptionContext.getContextLabels().size());         assertTrue(exceptionContext.getContextLabels().contains("test1"));         assertTrue(exceptionContext.getContextLabels().contains("test2"));         assertTrue(exceptionContext.getContextLabels().contains("test Date"));         assertTrue(exceptionContext.getContextLabels().contains("test Nbr"));          exceptionContext.addContextValue("test2", "different value");         assertEquals(5, exceptionContext.getContextLabels().size());         assertTrue(exceptionContext.getContextLabels().contains("test2"));          final String contextMessage = exceptionContext.getFormattedExceptionMessage(null);         assertFalse(contextMessage.contains(TEST_MESSAGE));     }      @Test     public void testSetContextValue() {         exceptionContext.addContextValue("test2", "different value");         exceptionContext.setContextValue("test3", "3");          final String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);         assertTrue(message.contains(TEST_MESSAGE));         assertTrue(message.contains("test Poorly written obj"));         assertTrue(message.contains("Crap"));          assertNull(exceptionContext.getFirstContextValue("crap"));         assertTrue(exceptionContext.getFirstContextValue("test Poorly written obj") instanceof ObjectWithFaultyToString);          assertEquals(7, exceptionContext.getContextEntries().size());         assertEquals(6, exceptionContext.getContextLabels().size());          assertTrue(exceptionContext.getContextLabels().contains("test Poorly written obj"));         assertFalse(exceptionContext.getContextLabels().contains("crap"));          exceptionContext.setContextValue("test Poorly written obj", "replacement");          assertEquals(7, exceptionContext.getContextEntries().size());         assertEquals(6, exceptionContext.getContextLabels().size());          exceptionContext.setContextValue("test2", "another");          assertEquals(6, exceptionContext.getContextEntries().size());         assertEquals(6, exceptionContext.getContextLabels().size());          final String contextMessage = exceptionContext.getFormattedExceptionMessage(null);         assertFalse(contextMessage.contains(TEST_MESSAGE));     }      @Test     public void testGetFirstContextValue() {         exceptionContext.addContextValue("test2", "different value");          assertNull(exceptionContext.getFirstContextValue("test1"));         assertEquals("some value", exceptionContext.getFirstContextValue("test2"));         assertNull(exceptionContext.getFirstContextValue("crap"));          exceptionContext.setContextValue("test2", "another");          assertEquals("another", exceptionContext.getFirstContextValue("test2"));     }      @Test     public void testGetContextValues() {         exceptionContext.addContextValue("test2", "different value");          assertEquals(exceptionContext.getContextValues("test1"), Collections.singletonList(null));         assertEquals(exceptionContext.getContextValues("test2"), Arrays.asList("some value", "different value"));          exceptionContext.setContextValue("test2", "another");          assertEquals("another", exceptionContext.getFirstContextValue("test2"));     }      @Test     public void testGetContextLabels() {         assertEquals(5, exceptionContext.getContextEntries().size());          exceptionContext.addContextValue("test2", "different value");          final Set<String> labels = exceptionContext.getContextLabels();         assertEquals(6, exceptionContext.getContextEntries().size());         assertEquals(5, labels.size());         assertTrue(labels.contains("test1"));         assertTrue(labels.contains("test2"));         assertTrue(labels.contains("test Date"));         assertTrue(labels.contains("test Nbr"));     }      @Test     public void testGetContextEntries() {         assertEquals(5, exceptionContext.getContextEntries().size());          exceptionContext.addContextValue("test2", "different value");          final List<Pair<String, Object>> entries = exceptionContext.getContextEntries();         assertEquals(6, entries.size());         assertEquals("test1", entries.get(0).getKey());         assertEquals("test2", entries.get(1).getKey());         assertEquals("test Date", entries.get(2).getKey());         assertEquals("test Nbr", entries.get(3).getKey());         assertEquals("test Poorly written obj", entries.get(4).getKey());         assertEquals("test2", entries.get(5).getKey());     }      @Test     public void testJavaSerialization() {         exceptionContext.setContextValue("test Poorly written obj", "serializable replacement");          final T clone = SerializationUtils.deserialize(SerializationUtils.serialize(exceptionContext));          assertEquals(exceptionContext.getFormattedExceptionMessage(null), clone.getFormattedExceptionMessage(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * JUnit tests for {@link CloneFailedExceptionTest}.  */ public class CloneFailedExceptionTest extends AbstractExceptionTest {      @Test     public void testThrowingInformativeException() {         assertThrows(CloneFailedException.class, () -> {             throw new CloneFailedException(EXCEPTION_MESSAGE, generateCause());         });     }      @Test     public void testThrowingExceptionWithMessage() {         assertThrows(CloneFailedException.class, () -> {             throw new CloneFailedException(EXCEPTION_MESSAGE);         });     }      @Test     public void testThrowingExceptionWithCause() {         assertThrows(CloneFailedException.class, () -> {             throw new CloneFailedException(generateCause());         });     }      @Test     public void testWithCauseAndMessage() {         final Exception exception = new CloneFailedException(EXCEPTION_MESSAGE, generateCause());         assertNotNull(exception);         assertEquals(EXCEPTION_MESSAGE, exception.getMessage(), WRONG_EXCEPTION_MESSAGE);          final Throwable cause = exception.getCause();         assertNotNull(cause);         assertEquals(CAUSE_MESSAGE, cause.getMessage(), WRONG_CAUSE_MESSAGE);     }      @Test     public void testWithoutCause() {         final Exception exception = new CloneFailedException(EXCEPTION_MESSAGE);         assertNotNull(exception);         assertEquals(EXCEPTION_MESSAGE, exception.getMessage(), WRONG_EXCEPTION_MESSAGE);          final Throwable cause = exception.getCause();         assertNull(cause);     }      @Test     public void testWithoutMessage() {         final Exception exception = new CloneFailedException(generateCause());         assertNotNull(exception);         assertNotNull(exception.getMessage());          final Throwable cause = exception.getCause();         assertNotNull(cause);         assertEquals(CAUSE_MESSAGE, cause.getMessage(), WRONG_CAUSE_MESSAGE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * JUnit tests for DefaultExceptionContext.  */ public class DefaultExceptionContextTest extends AbstractExceptionContextTest<DefaultExceptionContext> {      @Override     @BeforeEach     public void setUp() throws Exception {         exceptionContext = new DefaultExceptionContext();         super.setUp();     }      @Test     public void testFormattedExceptionMessageNull() {         exceptionContext = new DefaultExceptionContext();         exceptionContext.getFormattedExceptionMessage(null);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;   /**  * Base class for testing {@link Exception} descendants  */ public abstract class AbstractExceptionTest {      protected static final String CAUSE_MESSAGE = "Cause message";     protected static final String EXCEPTION_MESSAGE = "Exception message";      protected static final String WRONG_EXCEPTION_MESSAGE = "Wrong exception message";     protected static final String WRONG_CAUSE_MESSAGE = "Wrong cause message";      protected Exception generateCause() {         return new Exception(CAUSE_MESSAGE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintStream; import java.io.PrintWriter; import java.io.StringWriter; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.List;  import org.apache.commons.lang3.test.NotVisibleExceptionFactory; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test;  /**  * Tests {@link org.apache.commons.lang3.exception.ExceptionUtils}.  *  * @since 1.0  */ public class ExceptionUtilsTest {      /**      * Provides a method with a well known chained/nested exception      * name which matches the full signature (e.g. has a return value      * of {@code Throwable}.      */     private static class ExceptionWithCause extends Exception {         private static final long serialVersionUID = 1L;          private Throwable cause;          ExceptionWithCause(final String str, final Throwable cause) {             super(str);             setCause(cause);         }          ExceptionWithCause(final Throwable cause) {             super();             setCause(cause);         }          @Override         public Throwable getCause() {             return cause;         }          public void setCause(final Throwable cause) {             this.cause = cause;         }     }     /**      * Provides a method with a well known chained/nested exception      * name which does not match the full signature (e.g. lacks a      * return value of {@code Throwable}.      */     private static class ExceptionWithoutCause extends Exception {         private static final long serialVersionUID = 1L;          @SuppressWarnings("unused")         public void getTargetException() {             // noop         }     }     // Temporary classes to allow the nested exception code to be removed     // prior to a rewrite of this test class.     private static class NestableException extends Exception {         private static final long serialVersionUID = 1L;          @SuppressWarnings("unused")         NestableException() {             super();         }          NestableException(final Throwable t) {             super(t);         }     }     public static class TestThrowable extends Throwable {         private static final long serialVersionUID = 1L;     }     private static int redeclareCheckedException() {         return throwsCheckedException();     }     private static int throwsCheckedException() {         try {             throw new IOException();         } catch (final Exception e) {             return ExceptionUtils.<Integer>rethrow(e);         }     }       private NestableException nested;       private Throwable withCause;      private Throwable withoutCause;      private Throwable jdkNoCause;      //-----------------------------------------------------------------------      private ExceptionWithCause cyclicCause;      private Throwable notVisibleException;      private Throwable createExceptionWithCause() {         try {             try {                 throw new ExceptionWithCause(createExceptionWithoutCause());             } catch (final Throwable t) {                 throw new ExceptionWithCause(t);             }         } catch (final Throwable t) {             return t;         }     }      //-----------------------------------------------------------------------     private Throwable createExceptionWithoutCause() {         try {             throw new ExceptionWithoutCause();         } catch (final Throwable t) {             return t;         }     }      @BeforeEach     public void setUp() {         withoutCause = createExceptionWithoutCause();         nested = new NestableException(withoutCause);         withCause = new ExceptionWithCause(nested);         jdkNoCause = new NullPointerException();         final ExceptionWithCause a = new ExceptionWithCause(null);         final ExceptionWithCause b = new ExceptionWithCause(a);         a.setCause(b);         cyclicCause = new ExceptionWithCause(a);         notVisibleException = NotVisibleExceptionFactory.createException(withoutCause);     }      @AfterEach     public void tearDown() {         withoutCause = null;         nested = null;         withCause = null;         jdkNoCause = null;         cyclicCause = null;         notVisibleException = null;     }      @Test     public void test_getMessage_Throwable() {         Throwable th = null;         assertEquals("", ExceptionUtils.getMessage(th));          th = new IllegalArgumentException("Base");         assertEquals("IllegalArgumentException: Base", ExceptionUtils.getMessage(th));          th = new ExceptionWithCause("Wrapper", th);         assertEquals("ExceptionUtilsTest.ExceptionWithCause: Wrapper", ExceptionUtils.getMessage(th));     }      @Test     public void test_getRootCauseMessage_Throwable() {         Throwable th = null;         assertEquals("", ExceptionUtils.getRootCauseMessage(th));          th = new IllegalArgumentException("Base");         assertEquals("IllegalArgumentException: Base", ExceptionUtils.getRootCauseMessage(th));          th = new ExceptionWithCause("Wrapper", th);         assertEquals("IllegalArgumentException: Base", ExceptionUtils.getRootCauseMessage(th));     }      @Test     public void testCatchTechniques() {         IOException ioe = assertThrows(IOException.class, ExceptionUtilsTest::throwsCheckedException);         assertEquals(1, ExceptionUtils.getThrowableCount(ioe));          ioe = assertThrows(IOException.class, ExceptionUtilsTest::redeclareCheckedException);         assertEquals(1, ExceptionUtils.getThrowableCount(ioe));     }      @Test     public void testConstructor() {         assertNotNull(new ExceptionUtils());         final Constructor<?>[] cons = ExceptionUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(ExceptionUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(ExceptionUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @SuppressWarnings("deprecation") // Specifically tests the deprecated methods     @Test     public void testGetCause_Throwable() {         assertSame(null, ExceptionUtils.getCause(null));         assertSame(null, ExceptionUtils.getCause(withoutCause));         assertSame(withoutCause, ExceptionUtils.getCause(nested));         assertSame(nested, ExceptionUtils.getCause(withCause));         assertSame(null, ExceptionUtils.getCause(jdkNoCause));         assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(cyclicCause));         assertSame(cyclicCause.getCause().getCause(), ExceptionUtils.getCause(cyclicCause.getCause()));         assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(cyclicCause.getCause().getCause()));         assertSame(withoutCause, ExceptionUtils.getCause(notVisibleException));     }      @SuppressWarnings("deprecation") // Specifically tests the deprecated methods     @Test     public void testGetCause_ThrowableArray() {         assertSame(null, ExceptionUtils.getCause(null, null));         assertSame(null, ExceptionUtils.getCause(null, new String[0]));          // not known type, so match on supplied method names         assertSame(nested, ExceptionUtils.getCause(withCause, null));  // default names         assertSame(null, ExceptionUtils.getCause(withCause, new String[0]));         assertSame(null, ExceptionUtils.getCause(withCause, new String[]{null}));         assertSame(nested, ExceptionUtils.getCause(withCause, new String[]{"getCause"}));          // not known type, so match on supplied method names         assertSame(null, ExceptionUtils.getCause(withoutCause, null));         assertSame(null, ExceptionUtils.getCause(withoutCause, new String[0]));         assertSame(null, ExceptionUtils.getCause(withoutCause, new String[]{null}));         assertSame(null, ExceptionUtils.getCause(withoutCause, new String[]{"getCause"}));         assertSame(null, ExceptionUtils.getCause(withoutCause, new String[]{"getTargetException"}));     }      @Test     public void testGetRootCause_Throwable() {         assertSame(null, ExceptionUtils.getRootCause(null));         assertSame(withoutCause, ExceptionUtils.getRootCause(withoutCause));         assertSame(withoutCause, ExceptionUtils.getRootCause(nested));         assertSame(withoutCause, ExceptionUtils.getRootCause(withCause));         assertSame(jdkNoCause, ExceptionUtils.getRootCause(jdkNoCause));         assertSame(cyclicCause.getCause().getCause(), ExceptionUtils.getRootCause(cyclicCause));     }      //-----------------------------------------------------------------------     @Test     public void testGetRootCauseStackTrace_Throwable() {         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length);          final Throwable cause = createExceptionWithCause();         String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(cause);         boolean match = false;         for (final String element : stackTrace) {             if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {                 match = true;                 break;             }         }         assertTrue(match);          stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause);         match = false;         for (final String element : stackTrace) {             if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {                 match = true;                 break;             }         }         assertFalse(match);     }      //-----------------------------------------------------------------------     @Test     public void testGetThrowableCount_Throwable() {         assertEquals(0, ExceptionUtils.getThrowableCount(null));         assertEquals(1, ExceptionUtils.getThrowableCount(withoutCause));         assertEquals(2, ExceptionUtils.getThrowableCount(nested));         assertEquals(3, ExceptionUtils.getThrowableCount(withCause));         assertEquals(1, ExceptionUtils.getThrowableCount(jdkNoCause));         assertEquals(3, ExceptionUtils.getThrowableCount(cyclicCause));     }      @Test     public void testGetThrowableList_Throwable_jdkNoCause() {         final List<?> throwables = ExceptionUtils.getThrowableList(jdkNoCause);         assertEquals(1, throwables.size());         assertSame(jdkNoCause, throwables.get(0));     }      @Test     public void testGetThrowableList_Throwable_nested() {         final List<?> throwables = ExceptionUtils.getThrowableList(nested);         assertEquals(2, throwables.size());         assertSame(nested, throwables.get(0));         assertSame(withoutCause, throwables.get(1));     }      //-----------------------------------------------------------------------     @Test     public void testGetThrowableList_Throwable_null() {         final List<?> throwables = ExceptionUtils.getThrowableList(null);         assertEquals(0, throwables.size());     }      @Test     public void testGetThrowableList_Throwable_recursiveCause() {         final List<?> throwables = ExceptionUtils.getThrowableList(cyclicCause);         assertEquals(3, throwables.size());         assertSame(cyclicCause, throwables.get(0));         assertSame(cyclicCause.getCause(), throwables.get(1));         assertSame(cyclicCause.getCause().getCause(), throwables.get(2));     }      @Test     public void testGetThrowableList_Throwable_withCause() {         final List<?> throwables = ExceptionUtils.getThrowableList(withCause);         assertEquals(3, throwables.size());         assertSame(withCause, throwables.get(0));         assertSame(nested, throwables.get(1));         assertSame(withoutCause, throwables.get(2));     }      @Test     public void testGetThrowableList_Throwable_withoutCause() {         final List<?> throwables = ExceptionUtils.getThrowableList(withoutCause);         assertEquals(1, throwables.size());         assertSame(withoutCause, throwables.get(0));     }      @Test     public void testGetThrowables_Throwable_jdkNoCause() {         final Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause);         assertEquals(1, throwables.length);         assertSame(jdkNoCause, throwables[0]);     }      @Test     public void testGetThrowables_Throwable_nested() {         final Throwable[] throwables = ExceptionUtils.getThrowables(nested);         assertEquals(2, throwables.length);         assertSame(nested, throwables[0]);         assertSame(withoutCause, throwables[1]);     }      //-----------------------------------------------------------------------     @Test     public void testGetThrowables_Throwable_null() {         assertEquals(0, ExceptionUtils.getThrowables(null).length);     }      @Test     public void testGetThrowables_Throwable_recursiveCause() {         final Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause);         assertEquals(3, throwables.length);         assertSame(cyclicCause, throwables[0]);         assertSame(cyclicCause.getCause(), throwables[1]);         assertSame(cyclicCause.getCause().getCause(), throwables[2]);     }      @Test     public void testGetThrowables_Throwable_withCause() {         final Throwable[] throwables = ExceptionUtils.getThrowables(withCause);         assertEquals(3, throwables.length);         assertSame(withCause, throwables[0]);         assertSame(nested, throwables[1]);         assertSame(withoutCause, throwables[2]);     }      @Test     public void testGetThrowables_Throwable_withoutCause() {         final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause);         assertEquals(1, throwables.length);         assertSame(withoutCause, throwables[0]);     }      @Test     public void testIndexOf_ThrowableClass() {         assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null));         assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class));         assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class));          assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null));         assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class));         assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class));         assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));         assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class));         assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class));         assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Throwable.class));     }      @Test     public void testIndexOf_ThrowableClassInt() {         assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null, 0));         assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class, 0));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class, 0));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class, 0));         assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class, 0));          assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null, 0));         assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class, 0));         assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class, 0));         assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class, 0));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));         assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));         assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class, 0));         assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class, 0));          assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, -1));         assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 1));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 9));          assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class, 0));         assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Throwable.class, 0));     }      //-----------------------------------------------------------------------     @Test     public void testIndexOfType_ThrowableClass() {         assertEquals(-1, ExceptionUtils.indexOfType(null, null));         assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class));          assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));         assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class));         assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class));         assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class));          assertEquals(-1, ExceptionUtils.indexOfType(nested, null));         assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class));         assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class));         assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class));          assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));         assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class));         assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class));         assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class));          assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class));         assertEquals(0, ExceptionUtils.indexOfType(withCause, Throwable.class));     }      @Test     public void testIndexOfType_ThrowableClassInt() {         assertEquals(-1, ExceptionUtils.indexOfType(null, null, 0));         assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class, 0));          assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));         assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class, 0));         assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class, 0));         assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class, 0));          assertEquals(-1, ExceptionUtils.indexOfType(nested, null, 0));         assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class, 0));         assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class, 0));         assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class, 0));          assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));         assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));         assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class, 0));         assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class, 0));          assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, -1));         assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));         assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 1));         assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 9));          assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class, 0));         assertEquals(0, ExceptionUtils.indexOfType(withCause, Throwable.class, 0));     }      //-----------------------------------------------------------------------     @Test     public void testPrintRootCauseStackTrace_Throwable() {         ExceptionUtils.printRootCauseStackTrace(null);         // could pipe system.err to a known stream, but not much point as         // internally this method calls stream method anyway     }      //-----------------------------------------------------------------------      @Test     public void testPrintRootCauseStackTrace_ThrowableStream() {         ByteArrayOutputStream out = new ByteArrayOutputStream(1024);         ExceptionUtils.printRootCauseStackTrace(null, (PrintStream) null);         ExceptionUtils.printRootCauseStackTrace(null, new PrintStream(out));         assertEquals(0, out.toString().length());          out = new ByteArrayOutputStream(1024);         assertThrows(                 NullPointerException.class,                 () -> ExceptionUtils.printRootCauseStackTrace(withCause, (PrintStream) null));          out = new ByteArrayOutputStream(1024);         final Throwable cause = createExceptionWithCause();         ExceptionUtils.printRootCauseStackTrace(cause, new PrintStream(out));         String stackTrace = out.toString();         assertTrue(stackTrace.contains(ExceptionUtils.WRAPPED_MARKER));          out = new ByteArrayOutputStream(1024);         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintStream(out));         stackTrace = out.toString();         assertFalse(stackTrace.contains(ExceptionUtils.WRAPPED_MARKER));     }      @Test     public void testPrintRootCauseStackTrace_ThrowableWriter() {         StringWriter writer = new StringWriter(1024);         ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null);         ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer));         assertEquals(0, writer.getBuffer().length());          writer = new StringWriter(1024);         assertThrows(                 NullPointerException.class,                 () -> ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null));          writer = new StringWriter(1024);         final Throwable cause = createExceptionWithCause();         ExceptionUtils.printRootCauseStackTrace(cause, new PrintWriter(writer));         String stackTrace = writer.toString();         assertTrue(stackTrace.contains(ExceptionUtils.WRAPPED_MARKER));          writer = new StringWriter(1024);         ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer));         stackTrace = writer.toString();         assertFalse(stackTrace.contains(ExceptionUtils.WRAPPED_MARKER));     }      @Test     public void testRemoveCommonFrames_ListList() {         assertThrows(IllegalArgumentException.class, () -> ExceptionUtils.removeCommonFrames(null, null));     }      @Test     public void testThrow() {         final Exception expected = new InterruptedException();         final Exception actual = assertThrows(Exception.class, () -> ExceptionUtils.rethrow(expected));         assertSame(expected, actual);     }      @Test     public void testThrowableOf_ThrowableClass() {         assertEquals(null, ExceptionUtils.throwableOfThrowable(null, null));         assertEquals(null, ExceptionUtils.throwableOfThrowable(null, NestableException.class));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, null));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, ExceptionWithCause.class));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, NestableException.class));         assertEquals(withoutCause, ExceptionUtils.throwableOfThrowable(withoutCause, ExceptionWithoutCause.class));          assertEquals(null, ExceptionUtils.throwableOfThrowable(nested, null));         assertEquals(null, ExceptionUtils.throwableOfThrowable(nested, ExceptionWithCause.class));         assertEquals(nested, ExceptionUtils.throwableOfThrowable(nested, NestableException.class));         assertEquals(nested.getCause(), ExceptionUtils.throwableOfThrowable(nested, ExceptionWithoutCause.class));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, null));         assertEquals(withCause, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class));         assertEquals(withCause.getCause(), ExceptionUtils.throwableOfThrowable(withCause, NestableException.class));         assertEquals(withCause.getCause().getCause(), ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithoutCause.class));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, Exception.class));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, Throwable.class));     }      @Test     public void testThrowableOf_ThrowableClassInt() {         assertEquals(null, ExceptionUtils.throwableOfThrowable(null, null, 0));         assertEquals(null, ExceptionUtils.throwableOfThrowable(null, NestableException.class, 0));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, null));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, ExceptionWithCause.class, 0));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withoutCause, NestableException.class, 0));         assertEquals(withoutCause, ExceptionUtils.throwableOfThrowable(withoutCause, ExceptionWithoutCause.class, 0));          assertEquals(null, ExceptionUtils.throwableOfThrowable(nested, null, 0));         assertEquals(null, ExceptionUtils.throwableOfThrowable(nested, ExceptionWithCause.class, 0));         assertEquals(nested, ExceptionUtils.throwableOfThrowable(nested, NestableException.class, 0));         assertEquals(nested.getCause(), ExceptionUtils.throwableOfThrowable(nested, ExceptionWithoutCause.class, 0));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, null));         assertEquals(withCause, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class, 0));         assertEquals(withCause.getCause(), ExceptionUtils.throwableOfThrowable(withCause, NestableException.class, 0));         assertEquals(withCause.getCause().getCause(), ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithoutCause.class, 0));          assertEquals(withCause, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class, -1));         assertEquals(withCause, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class, 0));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class, 1));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, ExceptionWithCause.class, 9));          assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, Exception.class, 0));         assertEquals(null, ExceptionUtils.throwableOfThrowable(withCause, Throwable.class, 0));     }      @Test     public void testThrowableOfType_ThrowableClass() {         assertEquals(null, ExceptionUtils.throwableOfType(null, null));         assertEquals(null, ExceptionUtils.throwableOfType(null, NestableException.class));          assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, null));         assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, ExceptionWithCause.class));         assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, NestableException.class));         assertEquals(withoutCause, ExceptionUtils.throwableOfType(withoutCause, ExceptionWithoutCause.class));          assertEquals(null, ExceptionUtils.throwableOfType(nested, null));         assertEquals(null, ExceptionUtils.throwableOfType(nested, ExceptionWithCause.class));         assertEquals(nested, ExceptionUtils.throwableOfType(nested, NestableException.class));         assertEquals(nested.getCause(), ExceptionUtils.throwableOfType(nested, ExceptionWithoutCause.class));          assertEquals(null, ExceptionUtils.throwableOfType(withCause, null));         assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class));         assertEquals(withCause.getCause(), ExceptionUtils.throwableOfType(withCause, NestableException.class));         assertEquals(withCause.getCause().getCause(), ExceptionUtils.throwableOfType(withCause, ExceptionWithoutCause.class));          assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, Exception.class));         assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, Throwable.class));     }      @Test     public void testThrowableOfType_ThrowableClassInt() {         assertEquals(null, ExceptionUtils.throwableOfType(null, null, 0));         assertEquals(null, ExceptionUtils.throwableOfType(null, NestableException.class, 0));          assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, null));         assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, ExceptionWithCause.class, 0));         assertEquals(null, ExceptionUtils.throwableOfType(withoutCause, NestableException.class, 0));         assertEquals(withoutCause, ExceptionUtils.throwableOfType(withoutCause, ExceptionWithoutCause.class, 0));          assertEquals(null, ExceptionUtils.throwableOfType(nested, null, 0));         assertEquals(null, ExceptionUtils.throwableOfType(nested, ExceptionWithCause.class, 0));         assertEquals(nested, ExceptionUtils.throwableOfType(nested, NestableException.class, 0));         assertEquals(nested.getCause(), ExceptionUtils.throwableOfType(nested, ExceptionWithoutCause.class, 0));          assertEquals(null, ExceptionUtils.throwableOfType(withCause, null));         assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class, 0));         assertEquals(withCause.getCause(), ExceptionUtils.throwableOfType(withCause, NestableException.class, 0));         assertEquals(withCause.getCause().getCause(), ExceptionUtils.throwableOfType(withCause, ExceptionWithoutCause.class, 0));          assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class, -1));         assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class, 0));         assertEquals(null, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class, 1));         assertEquals(null, ExceptionUtils.throwableOfType(withCause, ExceptionWithCause.class, 9));          assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, Exception.class, 0));         assertEquals(withCause, ExceptionUtils.throwableOfType(withCause, Throwable.class, 0));     }      @Test     public void testWrapAndUnwrapCheckedException() {         final Throwable t = assertThrows(Throwable.class, () -> ExceptionUtils.wrapAndThrow(new IOException()));         assertTrue(ExceptionUtils.hasCause(t, IOException.class));     }      @Test     public void testWrapAndUnwrapError() {         final Throwable t = assertThrows(Throwable.class, () -> ExceptionUtils.wrapAndThrow(new OutOfMemoryError()));         assertTrue(ExceptionUtils.hasCause(t, Error.class));     }      @Test     public void testWrapAndUnwrapRuntimeException() {         final Throwable t = assertThrows(Throwable.class, () -> ExceptionUtils.wrapAndThrow(new IllegalArgumentException()));         assertTrue(ExceptionUtils.hasCause(t, RuntimeException.class));     }      @Test     public void testWrapAndUnwrapThrowable() {         final Throwable t = assertThrows(Throwable.class, () -> ExceptionUtils.wrapAndThrow(new TestThrowable()));         assertTrue(ExceptionUtils.hasCause(t, TestThrowable.class));     }      @Test     @DisplayName("getStackFrames returns the string array of the stack frames when there is a real exception")     public void testgetStackFramesNullArg() {         final String[] actual = ExceptionUtils.getStackFrames((Throwable) null);         assertEquals(0, actual.length);     }      @Test     @DisplayName("getStackFrames returns empty string array when the argument is null")     public void testgetStackFramesHappyPath() {         final String[] actual = ExceptionUtils.getStackFrames(new Throwable() {             // provide static stack trace to make test stable             @Override             public void printStackTrace(final PrintWriter s) {                 s.write("org.apache.commons.lang3.exception.ExceptionUtilsTest$1\n" +                     "\tat org.apache.commons.lang3.exception.ExceptionUtilsTest.testgetStackFramesGappyPath(ExceptionUtilsTest.java:706)\n" +                     "\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +                     "\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)\n" +                     "\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)\n");             }         });          assertArrayEquals(new String[]{             "org.apache.commons.lang3.exception.ExceptionUtilsTest$1",             "\tat org.apache.commons.lang3.exception.ExceptionUtilsTest.testgetStackFramesGappyPath(ExceptionUtilsTest.java:706)",             "\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",             "\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)",             "\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)"         }, actual);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Date;  import org.apache.commons.lang3.StringUtils; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * JUnit tests for ContextedRuntimeException.  */ public class ContextedRuntimeExceptionTest extends AbstractExceptionContextTest<ContextedRuntimeException> {      @BeforeEach     @Override     public void setUp() throws Exception {         exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE));         super.setUp();     }      @Test     public void testContextedException() {         exceptionContext = new ContextedRuntimeException();         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(StringUtils.isEmpty(message));     }      @Test     public void testContextedExceptionString() {         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE);         assertEquals(TEST_MESSAGE, exceptionContext.getMessage());          final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains(TEST_MESSAGE));     }      @Test     public void testContextedExceptionThrowable() {         exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE));         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(message.contains(TEST_MESSAGE));     }      @Test     public void testContextedExceptionStringThrowable() {         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(trace.contains(TEST_MESSAGE_2));         assertTrue(message.contains(TEST_MESSAGE_2));     }      @Test     public void testContextedExceptionStringThrowableContext() {         // Use an anonymous subclass to make sure users can provide custom implementations         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE),                 new DefaultExceptionContext() {                     private static final long serialVersionUID = 1L;                 });         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(trace.contains(TEST_MESSAGE_2));         assertTrue(message.contains(TEST_MESSAGE_2));     }      @Test     public void testNullExceptionPassing() {         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)         .addContextValue("test1", null)         .addContextValue("test2", "some value")         .addContextValue("test Date", new Date())         .addContextValue("test Nbr", Integer.valueOf(5))         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString());          final String message = exceptionContext.getMessage();         assertNotNull(message);     }      @Test     public void testRawMessage() {         assertEquals(Exception.class.getName() + ": " + TEST_MESSAGE, exceptionContext.getRawMessage());         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());         assertEquals(TEST_MESSAGE_2, exceptionContext.getRawMessage());         exceptionContext = new ContextedRuntimeException(null, new Exception(TEST_MESSAGE), new DefaultExceptionContext());         assertNull(exceptionContext.getRawMessage());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.exception;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Date;  import org.apache.commons.lang3.StringUtils; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * JUnit tests for ContextedException.  */ public class ContextedExceptionTest extends AbstractExceptionContextTest<ContextedException> {      @BeforeEach     @Override     public void setUp() throws Exception {         exceptionContext = new ContextedException(new Exception(TEST_MESSAGE));         super.setUp();     }      @Test     public void testContextedException() {         exceptionContext = new ContextedException();         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(StringUtils.isEmpty(message));     }      @Test     public void testContextedExceptionString() {         exceptionContext = new ContextedException(TEST_MESSAGE);         assertEquals(TEST_MESSAGE, exceptionContext.getMessage());          final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains(TEST_MESSAGE));     }      @Test     public void testContextedExceptionThrowable() {         exceptionContext = new ContextedException(new Exception(TEST_MESSAGE));         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(message.contains(TEST_MESSAGE));     }      @Test     public void testContextedExceptionStringThrowable() {         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(trace.contains(TEST_MESSAGE_2));         assertTrue(message.contains(TEST_MESSAGE_2));     }      @Test     public void testContextedExceptionStringThrowableContext() {         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());         final String message = exceptionContext.getMessage();         final String trace = ExceptionUtils.getStackTrace(exceptionContext);         assertTrue(trace.contains("ContextedException"));         assertTrue(trace.contains(TEST_MESSAGE));         assertTrue(trace.contains(TEST_MESSAGE_2));         assertTrue(message.contains(TEST_MESSAGE_2));     }      @Test     public void testNullExceptionPassing() {         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)         .addContextValue("test1", null)         .addContextValue("test2", "some value")         .addContextValue("test Date", new Date())         .addContextValue("test Nbr", Integer.valueOf(5))         .addContextValue("test Poorly written obj", new ObjectWithFaultyToString());          final String message = exceptionContext.getMessage();         assertNotNull(message);     }      @Test     public void testRawMessage() {         assertEquals(Exception.class.getName() + ": " + TEST_MESSAGE, exceptionContext.getRawMessage());         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());         assertEquals(TEST_MESSAGE_2, exceptionContext.getRawMessage());         exceptionContext = new ContextedException(null, new Exception(TEST_MESSAGE), new DefaultExceptionContext());         assertNull(exceptionContext.getRawMessage());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.UnsupportedEncodingException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.nio.CharBuffer; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.function.Supplier; import java.util.regex.PatternSyntaxException;  import org.apache.commons.lang3.mutable.MutableInt; import org.apache.commons.lang3.text.WordUtils; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.Disabled;  /**  * Unit tests for methods of {@link org.apache.commons.lang3.StringUtils}  * which been moved to their own test classes.  */ @SuppressWarnings("deprecation") // deliberate use of deprecated code public class StringUtilsTest {      static final String WHITESPACE;     static final String NON_WHITESPACE;     static final String HARD_SPACE;     static final String TRIMMABLE;     static final String NON_TRIMMABLE;      static {         final StringBuilder ws = new StringBuilder();         final StringBuilder nws = new StringBuilder();         final String hs = String.valueOf(((char) 160));         final StringBuilder tr = new StringBuilder();         final StringBuilder ntr = new StringBuilder();         for (int i = 0; i < Character.MAX_VALUE; i++) {             if (Character.isWhitespace((char) i)) {                 ws.append(String.valueOf((char) i));                 if (i > 32) {                     ntr.append(String.valueOf((char) i));                 }             } else if (i < 40) {                 nws.append(String.valueOf((char) i));             }         }         for (int i = 0; i <= 32; i++) {             tr.append(String.valueOf((char) i));         }         WHITESPACE = ws.toString();         NON_WHITESPACE = nws.toString();         HARD_SPACE = hs;         TRIMMABLE = tr.toString();         NON_TRIMMABLE = ntr.toString();     }      private static final String[] ARRAY_LIST = {"foo", "bar", "baz"};     private static final String[] EMPTY_ARRAY_LIST = {};     private static final String[] NULL_ARRAY_LIST = {null};     private static final Object[] NULL_TO_STRING_LIST = {             new Object() {                 @Override                 public String toString() {                     return null;                 }             }     };     private static final String[] MIXED_ARRAY_LIST = {null, "", "foo"};     private static final Object[] MIXED_TYPE_LIST = {"foo", Long.valueOf(2L)};     private static final long[] LONG_PRIM_LIST = {1, 2};     private static final int[] INT_PRIM_LIST = {1, 2};     private static final byte[] BYTE_PRIM_LIST = {1, 2};     private static final short[] SHORT_PRIM_LIST = {1, 2};     private static final char[] CHAR_PRIM_LIST = {'1', '2'};     private static final float[] FLOAT_PRIM_LIST = {1, 2};     private static final double[] DOUBLE_PRIM_LIST = {1, 2};     private static final List<String> MIXED_STRING_LIST = Arrays.asList(null, "", "foo");     private static final List<Object> MIXED_TYPE_OBJECT_LIST = Arrays.<Object>asList("foo", Long.valueOf(2L));     private static final List<String> STRING_LIST = Arrays.asList("foo", "bar", "baz");     private static final List<String> EMPTY_STRING_LIST = Collections.emptyList();     private static final List<String> NULL_STRING_LIST = Collections.singletonList(null);      private static final String SEPARATOR = ",";     private static final char SEPARATOR_CHAR = ';';      private static final String TEXT_LIST = "foo,bar,baz";     private static final String TEXT_LIST_CHAR = "foo;bar;baz";     private static final String TEXT_LIST_NOSEP = "foobarbaz";      private static final String FOO_UNCAP = "foo";     private static final String FOO_CAP = "Foo";      private static final String SENTENCE_UNCAP = "foo bar baz";     private static final String SENTENCE_CAP = "Foo Bar Baz";      private void assertAbbreviateWithAbbrevMarkerAndOffset(final String expected, final String abbrevMarker, final int offset, final int maxWidth) {         final String abcdefghijklmno = "abcdefghijklmno";         final String message = "abbreviate(String,String,int,int) failed";         final String actual = StringUtils.abbreviate(abcdefghijklmno, abbrevMarker, offset, maxWidth);         if (offset >= 0 && offset < abcdefghijklmno.length()) {             assertTrue(actual.indexOf((char) ('a' + offset)) != -1,                     message + " -- should contain offset character");         }         assertTrue(actual.length() <= maxWidth,                 message + " -- should not be greater than maxWidth");         assertEquals(expected, actual, message);     }      private void assertAbbreviateWithOffset(final String expected, final int offset, final int maxWidth) {         final String abcdefghijklmno = "abcdefghijklmno";         final String message = "abbreviate(String,int,int) failed";         final String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);         if (offset >= 0 && offset < abcdefghijklmno.length()) {             assertTrue(actual.indexOf((char) ('a' + offset)) != -1,                     message + " -- should contain offset character");         }         assertTrue(actual.length() <= maxWidth,                 message + " -- should not be greater than maxWidth");         assertEquals(expected, actual, message);     }      private void innerTestSplit(final char separator, final String sepStr, final char noMatch) {         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) +                 "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")";          final String str = "a" + separator + "b" + separator + separator + noMatch + "c";         String[] res;         // (str, sepStr)         res = StringUtils.split(str, sepStr);         assertEquals(3, res.length, msg);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals(noMatch + "c", res[2]);          final String str2 = separator + "a" + separator;         res = StringUtils.split(str2, sepStr);         assertEquals(1, res.length, msg);         assertEquals("a", res[0], msg);          res = StringUtils.split(str, sepStr, -1);         assertEquals(3, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals("b", res[1], msg);         assertEquals(noMatch + "c", res[2], msg);          res = StringUtils.split(str, sepStr, 0);         assertEquals(3, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals("b", res[1], msg);         assertEquals(noMatch + "c", res[2], msg);          res = StringUtils.split(str, sepStr, 1);         assertEquals(1, res.length, msg);         assertEquals(str, res[0], msg);          res = StringUtils.split(str, sepStr, 2);         assertEquals(2, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals(str.substring(2), res[1], msg);     }      private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) {         final String msg = "Failed on separator hex(" + Integer.toHexString(separator) +                 "), noMatch hex(" + Integer.toHexString(noMatch) + "), sepStr(" + sepStr + ")";          final String str = "a" + separator + "b" + separator + separator + noMatch + "c";         String[] res;         // (str, sepStr)         res = StringUtils.splitPreserveAllTokens(str, sepStr);         assertEquals(4, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals("b", res[1], msg);         assertEquals("", res[2], msg);         assertEquals(noMatch + "c", res[3], msg);          final String str2 = separator + "a" + separator;         res = StringUtils.splitPreserveAllTokens(str2, sepStr);         assertEquals(3, res.length, msg);         assertEquals("", res[0], msg);         assertEquals("a", res[1], msg);         assertEquals("", res[2], msg);          res = StringUtils.splitPreserveAllTokens(str, sepStr, -1);         assertEquals(4, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals("b", res[1], msg);         assertEquals("", res[2], msg);         assertEquals(noMatch + "c", res[3], msg);          res = StringUtils.splitPreserveAllTokens(str, sepStr, 0);         assertEquals(4, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals("b", res[1], msg);         assertEquals("", res[2], msg);         assertEquals(noMatch + "c", res[3], msg);          res = StringUtils.splitPreserveAllTokens(str, sepStr, 1);         assertEquals(1, res.length, msg);         assertEquals(str, res[0], msg);          res = StringUtils.splitPreserveAllTokens(str, sepStr, 2);         assertEquals(2, res.length, msg);         assertEquals("a", res[0], msg);         assertEquals(str.substring(2), res[1], msg);     }      //-----------------------------------------------------------------------     //Fixed LANG-1463     @Test     public void testAbbreviateMarkerWithEmptyString() {         final String greaterThanMaxTest = "much too long text";         assertEquals("much too long", StringUtils.abbreviate(greaterThanMaxTest, "", 13));     }      @Test     public void testAbbreviate_StringInt() {         assertNull(StringUtils.abbreviate(null, 10));         assertEquals("", StringUtils.abbreviate("", 10));         assertEquals("short", StringUtils.abbreviate("short", 10));         assertEquals("Now is ...", StringUtils.abbreviate("Now is the time for all good men to come to the aid of their party.", 10));          final String raspberry = "raspberry peach";         assertEquals("raspberry p...", StringUtils.abbreviate(raspberry, 14));         assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", 15));         assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", 16));         assertEquals("abc...", StringUtils.abbreviate("abcdefg", 6));         assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", 7));         assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", 8));         assertEquals("a...", StringUtils.abbreviate("abcdefg", 4));         assertEquals("", StringUtils.abbreviate("", 4));          assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abc", 3),                 "StringUtils.abbreviate expecting IllegalArgumentException");     }      @Test     public void testAbbreviate_StringIntInt() {         assertNull(StringUtils.abbreviate(null, 10, 12));         assertEquals("", StringUtils.abbreviate("", 0, 10));         assertEquals("", StringUtils.abbreviate("", 2, 10));          assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abcdefghij", 0, 3),                 "StringUtils.abbreviate expecting IllegalArgumentException");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abcdefghij", 5, 6),                 "StringUtils.abbreviate expecting IllegalArgumentException");          final String raspberry = "raspberry peach";         assertEquals("raspberry peach", StringUtils.abbreviate(raspberry, 11, 15));          assertNull(StringUtils.abbreviate(null, 7, 14));         assertAbbreviateWithOffset("abcdefg...", -1, 10);         assertAbbreviateWithOffset("abcdefg...", 0, 10);         assertAbbreviateWithOffset("abcdefg...", 1, 10);         assertAbbreviateWithOffset("abcdefg...", 2, 10);         assertAbbreviateWithOffset("abcdefg...", 3, 10);         assertAbbreviateWithOffset("abcdefg...", 4, 10);         assertAbbreviateWithOffset("...fghi...", 5, 10);         assertAbbreviateWithOffset("...ghij...", 6, 10);         assertAbbreviateWithOffset("...hijk...", 7, 10);         assertAbbreviateWithOffset("...ijklmno", 8, 10);         assertAbbreviateWithOffset("...ijklmno", 9, 10);         assertAbbreviateWithOffset("...ijklmno", 10, 10);         assertAbbreviateWithOffset("...ijklmno", 10, 10);         assertAbbreviateWithOffset("...ijklmno", 11, 10);         assertAbbreviateWithOffset("...ijklmno", 12, 10);         assertAbbreviateWithOffset("...ijklmno", 13, 10);         assertAbbreviateWithOffset("...ijklmno", 14, 10);         assertAbbreviateWithOffset("...ijklmno", 15, 10);         assertAbbreviateWithOffset("...ijklmno", 16, 10);         assertAbbreviateWithOffset("...ijklmno", Integer.MAX_VALUE, 10);     }      @Test     public void testAbbreviate_StringStringInt() {         assertNull(StringUtils.abbreviate(null, null, 10));         assertNull(StringUtils.abbreviate(null, "...", 10));         assertEquals("paranaguacu", StringUtils.abbreviate("paranaguacu", null, 10));         assertEquals("", StringUtils.abbreviate("", "...", 2));         assertEquals("wai**", StringUtils.abbreviate("waiheke", "**", 5));         assertEquals("And af,,,,", StringUtils.abbreviate("And after a long time, he finally met his son.", ",,,,", 10));          final String raspberry = "raspberry peach";         assertEquals("raspberry pe..", StringUtils.abbreviate(raspberry, "..", 14));         assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", "---*---", 15));         assertEquals("raspberry peach", StringUtils.abbreviate("raspberry peach", ".", 16));         assertEquals("abc()(", StringUtils.abbreviate("abcdefg", "()(", 6));         assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", ";", 7));         assertEquals("abcdefg", StringUtils.abbreviate("abcdefg", "_-", 8));         assertEquals("abc.", StringUtils.abbreviate("abcdefg", ".", 4));         assertEquals("", StringUtils.abbreviate("", 4));          assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abcdefghij", "...", 3),                 "StringUtils.abbreviate expecting IllegalArgumentException");     }      @Test     public void testAbbreviate_StringStringIntInt() {         assertNull(StringUtils.abbreviate(null, null, 10, 12));         assertNull(StringUtils.abbreviate(null, "...", 10, 12));         assertEquals("", StringUtils.abbreviate("", null, 0, 10));         assertEquals("", StringUtils.abbreviate("", "...", 2, 10));          assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abcdefghij", "::", 0, 2),                 "StringUtils.abbreviate expecting IllegalArgumentException");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.abbreviate("abcdefghij", "!!!", 5, 6),                 "StringUtils.abbreviate expecting IllegalArgumentException");          final String raspberry = "raspberry peach";         assertEquals("raspberry peach", StringUtils.abbreviate(raspberry, "--", 12, 15));          assertNull(StringUtils.abbreviate(null, ";", 7, 14));         assertAbbreviateWithAbbrevMarkerAndOffset("abcdefgh;;", ";;", -1, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("abcdefghi.", ".", 0, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("abcdefgh++", "++", 1, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("abcdefghi*", "*", 2, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("abcdef{{{{", "{{{{", 4, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("abcdef____", "____", 5, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("==fghijk==", "==", 5, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("___ghij___", "___", 6, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("/ghijklmno", "/", 7, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("/ghijklmno", "/", 8, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("/ghijklmno", "/", 9, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("///ijklmno", "///", 10, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("//hijklmno", "//", 10, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("//hijklmno", "//", 11, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("...ijklmno", "...", 12, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("/ghijklmno", "/", 13, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("/ghijklmno", "/", 14, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("999ijklmno", "999", 15, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("_ghijklmno", "_", 16, 10);         assertAbbreviateWithAbbrevMarkerAndOffset("+ghijklmno", "+", Integer.MAX_VALUE, 10);     }      @Test     public void testAbbreviateMiddle() {         // javadoc examples         assertNull(StringUtils.abbreviateMiddle(null, null, 0));         assertEquals("abc", StringUtils.abbreviateMiddle("abc", null, 0));         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 0));         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 3));         assertEquals("ab.f", StringUtils.abbreviateMiddle("abcdef", ".", 4));          // JIRA issue (LANG-405) example (slightly different than actual expected result)         assertEquals(                 "A very long text with un...f the text is complete.",                 StringUtils.abbreviateMiddle(                         "A very long text with unimportant stuff in the middle but interesting start and " +                                 "end to see if the text is complete.", "...", 50));          // Test a much longer text :)         final String longText = "Start text" + StringUtils.repeat("x", 10000) + "Close text";         assertEquals(                 "Start text->Close text",                 StringUtils.abbreviateMiddle(longText, "->", 22));          // Test negative length         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", -1));          // Test boundaries         // Fails to change anything as method ensures first and last char are kept         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 1));         assertEquals("abc", StringUtils.abbreviateMiddle("abc", ".", 2));          // Test length of n=1         assertEquals("a", StringUtils.abbreviateMiddle("a", ".", 1));          // Test smallest length that can lead to success         assertEquals("a.d", StringUtils.abbreviateMiddle("abcd", ".", 3));          // More from LANG-405         assertEquals("a..f", StringUtils.abbreviateMiddle("abcdef", "..", 4));         assertEquals("ab.ef", StringUtils.abbreviateMiddle("abcdef", ".", 5));     }      /**      * Tests {@code appendIfMissing}.      */     @Test     public void testAppendIfMissing() {         assertNull(StringUtils.appendIfMissing(null, null), "appendIfMissing(null,null)");         assertEquals("abc", StringUtils.appendIfMissing("abc", null), "appendIfMissing(abc,null)");         assertEquals("xyz", StringUtils.appendIfMissing("", "xyz"), "appendIfMissing(\"\",xyz)");         assertEquals("abcxyz", StringUtils.appendIfMissing("abc", "xyz"), "appendIfMissing(abc,xyz)");         assertEquals("abcxyz", StringUtils.appendIfMissing("abcxyz", "xyz"), "appendIfMissing(abcxyz,xyz)");         assertEquals("aXYZxyz", StringUtils.appendIfMissing("aXYZ", "xyz"), "appendIfMissing(aXYZ,xyz)");          assertNull(StringUtils.appendIfMissing(null, null, (CharSequence[]) null), "appendIfMissing(null,null,null)");         assertEquals("abc", StringUtils.appendIfMissing("abc", null, (CharSequence[]) null), "appendIfMissing(abc,null,null)");         assertEquals("xyz", StringUtils.appendIfMissing("", "xyz", (CharSequence[]) null), "appendIfMissing(\"\",xyz,null))");         assertEquals("abcxyz", StringUtils.appendIfMissing("abc", "xyz", null), "appendIfMissing(abc,xyz,{null})");         assertEquals("abc", StringUtils.appendIfMissing("abc", "xyz", ""), "appendIfMissing(abc,xyz,\"\")");         assertEquals("abcxyz", StringUtils.appendIfMissing("abc", "xyz", "mno"), "appendIfMissing(abc,xyz,mno)");         assertEquals("abcxyz", StringUtils.appendIfMissing("abcxyz", "xyz", "mno"), "appendIfMissing(abcxyz,xyz,mno)");         assertEquals("abcmno", StringUtils.appendIfMissing("abcmno", "xyz", "mno"), "appendIfMissing(abcmno,xyz,mno)");         assertEquals("abcXYZxyz", StringUtils.appendIfMissing("abcXYZ", "xyz", "mno"), "appendIfMissing(abcXYZ,xyz,mno)");         assertEquals("abcMNOxyz", StringUtils.appendIfMissing("abcMNO", "xyz", "mno"), "appendIfMissing(abcMNO,xyz,mno)");     }      /**      * Tests {@code appendIfMissingIgnoreCase}.      */     @Test     public void testAppendIfMissingIgnoreCase() {         assertNull(StringUtils.appendIfMissingIgnoreCase(null, null), "appendIfMissingIgnoreCase(null,null)");         assertEquals("abc", StringUtils.appendIfMissingIgnoreCase("abc", null), "appendIfMissingIgnoreCase(abc,null)");         assertEquals("xyz", StringUtils.appendIfMissingIgnoreCase("", "xyz"), "appendIfMissingIgnoreCase(\"\",xyz)");         assertEquals("abcxyz", StringUtils.appendIfMissingIgnoreCase("abc", "xyz"), "appendIfMissingIgnoreCase(abc,xyz)");         assertEquals("abcxyz", StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz"), "appendIfMissingIgnoreCase(abcxyz,xyz)");         assertEquals("abcXYZ", StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz"), "appendIfMissingIgnoreCase(abcXYZ,xyz)");          assertNull(StringUtils.appendIfMissingIgnoreCase(null, null, (CharSequence[]) null), "appendIfMissingIgnoreCase(null,null,null)");         assertEquals("abc", StringUtils.appendIfMissingIgnoreCase("abc", null, (CharSequence[]) null), "appendIfMissingIgnoreCase(abc,null,null)");         assertEquals("xyz", StringUtils.appendIfMissingIgnoreCase("", "xyz", (CharSequence[]) null), "appendIfMissingIgnoreCase(\"\",xyz,null)");         assertEquals("abcxyz", StringUtils.appendIfMissingIgnoreCase("abc", "xyz", null), "appendIfMissingIgnoreCase(abc,xyz,{null})");         assertEquals("abc", StringUtils.appendIfMissingIgnoreCase("abc", "xyz", ""), "appendIfMissingIgnoreCase(abc,xyz,\"\")");         assertEquals("abcxyz", StringUtils.appendIfMissingIgnoreCase("abc", "xyz", "mno"), "appendIfMissingIgnoreCase(abc,xyz,mno)");         assertEquals("abcxyz", StringUtils.appendIfMissingIgnoreCase("abcxyz", "xyz", "mno"), "appendIfMissingIgnoreCase(abcxyz,xyz,mno)");         assertEquals("abcmno", StringUtils.appendIfMissingIgnoreCase("abcmno", "xyz", "mno"), "appendIfMissingIgnoreCase(abcmno,xyz,mno)");         assertEquals("abcXYZ", StringUtils.appendIfMissingIgnoreCase("abcXYZ", "xyz", "mno"), "appendIfMissingIgnoreCase(abcXYZ,xyz,mno)");         assertEquals("abcMNO", StringUtils.appendIfMissingIgnoreCase("abcMNO", "xyz", "mno"), "appendIfMissingIgnoreCase(abcMNO,xyz,mno)");     }      @Test     public void testCapitalize() {         assertNull(StringUtils.capitalize(null));          assertEquals("", StringUtils.capitalize(""), "capitalize(empty-string) failed");         assertEquals("X", StringUtils.capitalize("x"), "capitalize(single-char-string) failed");         assertEquals(FOO_CAP, StringUtils.capitalize(FOO_CAP), "capitalize(String) failed");         assertEquals(FOO_CAP, StringUtils.capitalize(FOO_UNCAP), "capitalize(string) failed");          assertEquals("\u01C8", StringUtils.capitalize("\u01C9"), "capitalize(String) is not using TitleCase");          // Javadoc examples         assertNull(StringUtils.capitalize(null));         assertEquals("", StringUtils.capitalize(""));         assertEquals("Cat", StringUtils.capitalize("cat"));         assertEquals("CAt", StringUtils.capitalize("cAt"));         assertEquals("'cat'", StringUtils.capitalize("'cat'"));     }      //-----------------------------------------------------------------------     @Test     public void testCenter_StringInt() {         assertNull(StringUtils.center(null, -1));         assertNull(StringUtils.center(null, 4));         assertEquals("    ", StringUtils.center("", 4));         assertEquals("ab", StringUtils.center("ab", 0));         assertEquals("ab", StringUtils.center("ab", -1));         assertEquals("ab", StringUtils.center("ab", 1));         assertEquals("    ", StringUtils.center("", 4));         assertEquals(" ab ", StringUtils.center("ab", 4));         assertEquals("abcd", StringUtils.center("abcd", 2));         assertEquals(" a  ", StringUtils.center("a", 4));         assertEquals("  a  ", StringUtils.center("a", 5));     }      @Test     public void testCenter_StringIntChar() {         assertNull(StringUtils.center(null, -1, ' '));         assertNull(StringUtils.center(null, 4, ' '));         assertEquals("    ", StringUtils.center("", 4, ' '));         assertEquals("ab", StringUtils.center("ab", 0, ' '));         assertEquals("ab", StringUtils.center("ab", -1, ' '));         assertEquals("ab", StringUtils.center("ab", 1, ' '));         assertEquals("    ", StringUtils.center("", 4, ' '));         assertEquals(" ab ", StringUtils.center("ab", 4, ' '));         assertEquals("abcd", StringUtils.center("abcd", 2, ' '));         assertEquals(" a  ", StringUtils.center("a", 4, ' '));         assertEquals("  a  ", StringUtils.center("a", 5, ' '));         assertEquals("xxaxx", StringUtils.center("a", 5, 'x'));     }      @Test     public void testCenter_StringIntString() {         assertNull(StringUtils.center(null, 4, null));         assertNull(StringUtils.center(null, -1, " "));         assertNull(StringUtils.center(null, 4, " "));         assertEquals("    ", StringUtils.center("", 4, " "));         assertEquals("ab", StringUtils.center("ab", 0, " "));         assertEquals("ab", StringUtils.center("ab", -1, " "));         assertEquals("ab", StringUtils.center("ab", 1, " "));         assertEquals("    ", StringUtils.center("", 4, " "));         assertEquals(" ab ", StringUtils.center("ab", 4, " "));         assertEquals("abcd", StringUtils.center("abcd", 2, " "));         assertEquals(" a  ", StringUtils.center("a", 4, " "));         assertEquals("yayz", StringUtils.center("a", 4, "yz"));         assertEquals("yzyayzy", StringUtils.center("a", 7, "yz"));         assertEquals("  abc  ", StringUtils.center("abc", 7, null));         assertEquals("  abc  ", StringUtils.center("abc", 7, ""));     }      @Test     public void testChomp() {          final String[][] chompCases = {                 {FOO_UNCAP + "\r\n", FOO_UNCAP},                 {FOO_UNCAP + "\n", FOO_UNCAP},                 {FOO_UNCAP + "\r", FOO_UNCAP},                 {FOO_UNCAP + " \r", FOO_UNCAP + " "},                 {FOO_UNCAP, FOO_UNCAP},                 {FOO_UNCAP + "\n\n", FOO_UNCAP + "\n"},                 {FOO_UNCAP + "\r\n\r\n", FOO_UNCAP + "\r\n"},                 {"foo\nfoo", "foo\nfoo"},                 {"foo\n\rfoo", "foo\n\rfoo"},                 {"\n", ""},                 {"\r", ""},                 {"a", "a"},                 {"\r\n", ""},                 {"", ""},                 {null, null},                 {FOO_UNCAP + "\n\r", FOO_UNCAP + "\n"}         };         for (final String[] chompCase : chompCases) {             final String original = chompCase[0];             final String expectedResult = chompCase[1];             assertEquals(expectedResult, StringUtils.chomp(original), "chomp(String) failed");         }          assertEquals("foo", StringUtils.chomp("foobar", "bar"), "chomp(String, String) failed");         assertEquals("foobar", StringUtils.chomp("foobar", "baz"), "chomp(String, String) failed");         assertEquals("foo", StringUtils.chomp("foo", "foooo"), "chomp(String, String) failed");         assertEquals("foobar", StringUtils.chomp("foobar", ""), "chomp(String, String) failed");         assertEquals("foobar", StringUtils.chomp("foobar", null), "chomp(String, String) failed");         assertEquals("", StringUtils.chomp("", "foo"), "chomp(String, String) failed");         assertEquals("", StringUtils.chomp("", null), "chomp(String, String) failed");         assertEquals("", StringUtils.chomp("", ""), "chomp(String, String) failed");         assertNull(StringUtils.chomp(null, "foo"), "chomp(String, String) failed");         assertNull(StringUtils.chomp(null, null), "chomp(String, String) failed");         assertNull(StringUtils.chomp(null, ""), "chomp(String, String) failed");         assertEquals("", StringUtils.chomp("foo", "foo"), "chomp(String, String) failed");         assertEquals(" ", StringUtils.chomp(" foo", "foo"), "chomp(String, String) failed");         assertEquals("foo ", StringUtils.chomp("foo ", "foo"), "chomp(String, String) failed");     }      @Test     public void testChop() {          final String[][] chopCases = {                 {FOO_UNCAP + "\r\n", FOO_UNCAP},                 {FOO_UNCAP + "\n", FOO_UNCAP},                 {FOO_UNCAP + "\r", FOO_UNCAP},                 {FOO_UNCAP + " \r", FOO_UNCAP + " "},                 {"foo", "fo"},                 {"foo\nfoo", "foo\nfo"},                 {"\n", ""},                 {"\r", ""},                 {"\r\n", ""},                 {null, null},                 {"", ""},                 {"a", ""},         };         for (final String[] chopCase : chopCases) {             final String original = chopCase[0];             final String expectedResult = chopCase[1];             assertEquals(expectedResult, StringUtils.chop(original), "chop(String) failed");         }     }      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new StringUtils());         final Constructor<?>[] cons = StringUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(StringUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(StringUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testDefault_String() {         assertEquals("", StringUtils.defaultString(null));         assertEquals("", StringUtils.defaultString(""));         assertEquals("abc", StringUtils.defaultString("abc"));     }      @Test     public void testDefault_StringString() {         assertEquals("NULL", StringUtils.defaultString(null, "NULL"));         assertEquals("", StringUtils.defaultString("", "NULL"));         assertEquals("abc", StringUtils.defaultString("abc", "NULL"));     }      @Test     public void testDefaultIfBlank_CharBuffers() {         assertEquals("NULL", StringUtils.defaultIfBlank(CharBuffer.wrap(""), CharBuffer.wrap("NULL")).toString());         assertEquals("NULL", StringUtils.defaultIfBlank(CharBuffer.wrap(" "), CharBuffer.wrap("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfBlank(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")).toString());         assertNull(StringUtils.defaultIfBlank(CharBuffer.wrap(""), (CharBuffer) null));         // Tests compatibility for the API return type         final CharBuffer s = StringUtils.defaultIfBlank(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL"));         assertEquals("abc", s.toString());     }      @Test     public void testDefaultIfBlank_StringBuffers() {         assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuffer(""), new StringBuffer("NULL")).toString());         assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuffer(" "), new StringBuffer("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfBlank(new StringBuffer("abc"), new StringBuffer("NULL")).toString());         assertNull(StringUtils.defaultIfBlank(new StringBuffer(""), (StringBuffer) null));         // Tests compatibility for the API return type         final StringBuffer s = StringUtils.defaultIfBlank(new StringBuffer("abc"), new StringBuffer("NULL"));         assertEquals("abc", s.toString());     }      @Test     public void testDefaultIfBlank_StringBuilders() {         assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuilder(""), new StringBuilder("NULL")).toString());         assertEquals("NULL", StringUtils.defaultIfBlank(new StringBuilder(" "), new StringBuilder("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfBlank(new StringBuilder("abc"), new StringBuilder("NULL")).toString());         assertNull(StringUtils.defaultIfBlank(new StringBuilder(""), (StringBuilder) null));         // Tests compatibility for the API return type         final StringBuilder s = StringUtils.defaultIfBlank(new StringBuilder("abc"), new StringBuilder("NULL"));         assertEquals("abc", s.toString());     }      @Test     public void testDefaultIfBlank_StringString() {         assertEquals("NULL", StringUtils.defaultIfBlank(null, "NULL"));         assertEquals("NULL", StringUtils.defaultIfBlank("", "NULL"));         assertEquals("NULL", StringUtils.defaultIfBlank(" ", "NULL"));         assertEquals("abc", StringUtils.defaultIfBlank("abc", "NULL"));         assertNull(StringUtils.defaultIfBlank("", (String) null));         // Tests compatibility for the API return type         final String s = StringUtils.defaultIfBlank("abc", "NULL");         assertEquals("abc", s);     }       @Test     public void testGetIfBlank_StringStringSupplier() {         assertEquals("NULL", StringUtils.getIfBlank(null, () -> "NULL"));         assertEquals("NULL", StringUtils.getIfBlank("",  () -> "NULL"));         assertEquals("NULL", StringUtils.getIfBlank(" ", () -> "NULL"));         assertEquals("abc", StringUtils.getIfBlank("abc", () -> "NULL"));         assertNull(StringUtils.getIfBlank("", () -> null));         assertNull(StringUtils.defaultIfBlank("", (String) null));         // Tests compatibility for the API return type         final String s = StringUtils.getIfBlank("abc", () -> "NULL");         assertEquals("abc", s);         //Checking that default value supplied only on demand         final MutableInt numberOfCalls = new MutableInt(0);         final Supplier<String> countingDefaultSupplier = () -> {             numberOfCalls.increment();             return "NULL";         };         StringUtils.getIfBlank("abc", countingDefaultSupplier);         assertEquals(0, numberOfCalls.getValue());         StringUtils.getIfBlank("", countingDefaultSupplier);         assertEquals(1, numberOfCalls.getValue());         StringUtils.getIfBlank(" ", countingDefaultSupplier);         assertEquals(2, numberOfCalls.getValue());         StringUtils.getIfBlank(null, countingDefaultSupplier);         assertEquals(3, numberOfCalls.getValue());     }      @Test     public void testDefaultIfEmpty_CharBuffers() {         assertEquals("NULL", StringUtils.defaultIfEmpty(CharBuffer.wrap(""), CharBuffer.wrap("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfEmpty(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL")).toString());         assertNull(StringUtils.defaultIfEmpty(CharBuffer.wrap(""), (CharBuffer) null));         // Tests compatibility for the API return type         final CharBuffer s = StringUtils.defaultIfEmpty(CharBuffer.wrap("abc"), CharBuffer.wrap("NULL"));         assertEquals("abc", s.toString());     }       @Test     public void testDefaultIfEmpty_StringBuffers() {         assertEquals("NULL", StringUtils.defaultIfEmpty(new StringBuffer(""), new StringBuffer("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfEmpty(new StringBuffer("abc"), new StringBuffer("NULL")).toString());         assertNull(StringUtils.defaultIfEmpty(new StringBuffer(""), (StringBuffer) null));         // Tests compatibility for the API return type         final StringBuffer s = StringUtils.defaultIfEmpty(new StringBuffer("abc"), new StringBuffer("NULL"));         assertEquals("abc", s.toString());     }      @Test     public void testDefaultIfEmpty_StringBuilders() {         assertEquals("NULL", StringUtils.defaultIfEmpty(new StringBuilder(""), new StringBuilder("NULL")).toString());         assertEquals("abc", StringUtils.defaultIfEmpty(new StringBuilder("abc"), new StringBuilder("NULL")).toString());         assertNull(StringUtils.defaultIfEmpty(new StringBuilder(""), (StringBuilder) null));         // Tests compatibility for the API return type         final StringBuilder s = StringUtils.defaultIfEmpty(new StringBuilder("abc"), new StringBuilder("NULL"));         assertEquals("abc", s.toString());     }      @Test     public void testDefaultIfEmpty_StringString() {         assertEquals("NULL", StringUtils.defaultIfEmpty(null, "NULL"));         assertEquals("NULL", StringUtils.defaultIfEmpty("", "NULL"));         assertEquals("abc", StringUtils.defaultIfEmpty("abc", "NULL"));         assertNull(StringUtils.getIfEmpty("", null));         // Tests compatibility for the API return type         final String s = StringUtils.defaultIfEmpty("abc", "NULL");         assertEquals("abc", s);     }      @Test     public void testGetIfEmpty_StringStringSupplier() {         assertEquals("NULL", StringUtils.getIfEmpty((String) null, () -> "NULL"));         assertEquals("NULL", StringUtils.getIfEmpty("", () -> "NULL"));         assertEquals("abc", StringUtils.getIfEmpty("abc", () -> "NULL"));         assertNull(StringUtils.getIfEmpty("", () -> null));         assertNull(StringUtils.defaultIfEmpty("", (String) null));         // Tests compatibility for the API return type         final String s = StringUtils.getIfEmpty("abc", () -> "NULL");         assertEquals("abc", s);         //Checking that default value supplied only on demand         final MutableInt numberOfCalls = new MutableInt(0);         final Supplier<String> countingDefaultSupplier = () -> {             numberOfCalls.increment();             return "NULL";         };         StringUtils.getIfEmpty("abc", countingDefaultSupplier);         assertEquals(0, numberOfCalls.getValue());         StringUtils.getIfEmpty("", countingDefaultSupplier);         assertEquals(1, numberOfCalls.getValue());         StringUtils.getIfEmpty(null, countingDefaultSupplier);         assertEquals(2, numberOfCalls.getValue());     }       @Test     public void testDeleteWhitespace_String() {         assertNull(StringUtils.deleteWhitespace(null));         assertEquals("", StringUtils.deleteWhitespace(""));         assertEquals("", StringUtils.deleteWhitespace("  \u000C  \t\t\u001F\n\n \u000B  "));         assertEquals("", StringUtils.deleteWhitespace(StringUtilsTest.WHITESPACE));         assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.deleteWhitespace(StringUtilsTest.NON_WHITESPACE));         // Note: u-2007 and u-000A both cause problems in the source code         // it should ignore 2007 but delete 000A         assertEquals("\u00A0\u202F", StringUtils.deleteWhitespace("  \u00A0  \t\t\n\n \u202F  "));         assertEquals("\u00A0\u202F", StringUtils.deleteWhitespace("\u00A0\u202F"));         assertEquals("test", StringUtils.deleteWhitespace("\u000Bt  \t\n\u0009e\rs\n\n   \tt"));     }      //-----------------------------------------------------------------------     @Test     public void testDifference_StringString() {         assertNull(StringUtils.difference(null, null));         assertEquals("", StringUtils.difference("", ""));         assertEquals("abc", StringUtils.difference("", "abc"));         assertEquals("", StringUtils.difference("abc", ""));         assertEquals("i am a robot", StringUtils.difference(null, "i am a robot"));         assertEquals("i am a machine", StringUtils.difference("i am a machine", null));         assertEquals("robot", StringUtils.difference("i am a machine", "i am a robot"));         assertEquals("", StringUtils.difference("abc", "abc"));         assertEquals("you are a robot", StringUtils.difference("i am a robot", "you are a robot"));     }      @Test     public void testDifferenceAt_StringArray() {         assertEquals(-1, StringUtils.indexOfDifference((String[]) null));         assertEquals(-1, StringUtils.indexOfDifference());         assertEquals(-1, StringUtils.indexOfDifference("abc"));         assertEquals(-1, StringUtils.indexOfDifference(null, null));         assertEquals(-1, StringUtils.indexOfDifference("", ""));         assertEquals(0, StringUtils.indexOfDifference("", null));         assertEquals(0, StringUtils.indexOfDifference("abc", null, null));         assertEquals(0, StringUtils.indexOfDifference(null, null, "abc"));         assertEquals(0, StringUtils.indexOfDifference("", "abc"));         assertEquals(0, StringUtils.indexOfDifference("abc", ""));         assertEquals(-1, StringUtils.indexOfDifference("abc", "abc"));         assertEquals(1, StringUtils.indexOfDifference("abc", "a"));         assertEquals(2, StringUtils.indexOfDifference("ab", "abxyz"));         assertEquals(2, StringUtils.indexOfDifference("abcde", "abxyz"));         assertEquals(0, StringUtils.indexOfDifference("abcde", "xyz"));         assertEquals(0, StringUtils.indexOfDifference("xyz", "abcde"));         assertEquals(7, StringUtils.indexOfDifference("i am a machine", "i am a robot"));     }      @Test     public void testDifferenceAt_StringString() {         assertEquals(-1, StringUtils.indexOfDifference(null, null));         assertEquals(0, StringUtils.indexOfDifference(null, "i am a robot"));         assertEquals(-1, StringUtils.indexOfDifference("", ""));         assertEquals(0, StringUtils.indexOfDifference("", "abc"));         assertEquals(0, StringUtils.indexOfDifference("abc", ""));         assertEquals(0, StringUtils.indexOfDifference("i am a machine", null));         assertEquals(7, StringUtils.indexOfDifference("i am a machine", "i am a robot"));         assertEquals(-1, StringUtils.indexOfDifference("foo", "foo"));         assertEquals(0, StringUtils.indexOfDifference("i am a robot", "you are a robot"));     }      /**      * A sanity check for {@link StringUtils#EMPTY}.      */     @Test     public void testEMPTY() {         assertNotNull(StringUtils.EMPTY);         assertEquals("", StringUtils.EMPTY);         assertEquals(0, StringUtils.EMPTY.length());     }      @Test     public void testEscapeSurrogatePairs() {         assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30"));         // Examples from https://en.wikipedia.org/wiki/UTF-16         assertEquals("\uD800\uDC00", StringEscapeUtils.escapeCsv("\uD800\uDC00"));         assertEquals("\uD834\uDD1E", StringEscapeUtils.escapeCsv("\uD834\uDD1E"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeCsv("\uDBFF\uDFFD"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml3("\uDBFF\uDFFD"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeHtml4("\uDBFF\uDFFD"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.escapeXml("\uDBFF\uDFFD"));     }      /**      * Tests LANG-858.      */     @Test     public void testEscapeSurrogatePairsLang858() {         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858     }      @Test     public void testGetBytes_Charset() {         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, StringUtils.getBytes(null, (Charset) null));         assertArrayEquals(StringUtils.EMPTY.getBytes(), StringUtils.getBytes(StringUtils.EMPTY, (Charset) null));         assertArrayEquals(StringUtils.EMPTY.getBytes(StandardCharsets.US_ASCII),             StringUtils.getBytes(StringUtils.EMPTY, StandardCharsets.US_ASCII));     }      @Test     public void testGetBytes_String() throws UnsupportedEncodingException {         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, StringUtils.getBytes(null, (String) null));         assertArrayEquals(StringUtils.EMPTY.getBytes(), StringUtils.getBytes(StringUtils.EMPTY, (String) null));         assertArrayEquals(StringUtils.EMPTY.getBytes(StandardCharsets.US_ASCII.name()),             StringUtils.getBytes(StringUtils.EMPTY, StandardCharsets.US_ASCII.name()));     }      @Test     public void testGetCommonPrefix_StringArray() {         assertEquals("", StringUtils.getCommonPrefix((String[]) null));         assertEquals("", StringUtils.getCommonPrefix());         assertEquals("abc", StringUtils.getCommonPrefix("abc"));         assertEquals("", StringUtils.getCommonPrefix(null, null));         assertEquals("", StringUtils.getCommonPrefix("", ""));         assertEquals("", StringUtils.getCommonPrefix("", null));         assertEquals("", StringUtils.getCommonPrefix("abc", null, null));         assertEquals("", StringUtils.getCommonPrefix(null, null, "abc"));         assertEquals("", StringUtils.getCommonPrefix("", "abc"));         assertEquals("", StringUtils.getCommonPrefix("abc", ""));         assertEquals("abc", StringUtils.getCommonPrefix("abc", "abc"));         assertEquals("a", StringUtils.getCommonPrefix("abc", "a"));         assertEquals("ab", StringUtils.getCommonPrefix("ab", "abxyz"));         assertEquals("ab", StringUtils.getCommonPrefix("abcde", "abxyz"));         assertEquals("", StringUtils.getCommonPrefix("abcde", "xyz"));         assertEquals("", StringUtils.getCommonPrefix("xyz", "abcde"));         assertEquals("i am a ", StringUtils.getCommonPrefix("i am a machine", "i am a robot"));     }      @Test     public void testGetDigits() {         assertNull(StringUtils.getDigits(null));         assertEquals("", StringUtils.getDigits(""));         assertEquals("", StringUtils.getDigits("abc"));         assertEquals("1000", StringUtils.getDigits("1000$"));         assertEquals("12345", StringUtils.getDigits("123password45"));         assertEquals("5417543010", StringUtils.getDigits("(541) 754-3010"));         assertEquals("\u0967\u0968\u0969", StringUtils.getDigits("\u0967\u0968\u0969"));     }      @Test     public void testGetFuzzyDistance() {         assertEquals(0, StringUtils.getFuzzyDistance("", "", Locale.ENGLISH));         assertEquals(0, StringUtils.getFuzzyDistance("Workshop", "b", Locale.ENGLISH));         assertEquals(1, StringUtils.getFuzzyDistance("Room", "o", Locale.ENGLISH));         assertEquals(1, StringUtils.getFuzzyDistance("Workshop", "w", Locale.ENGLISH));         assertEquals(2, StringUtils.getFuzzyDistance("Workshop", "ws", Locale.ENGLISH));         assertEquals(4, StringUtils.getFuzzyDistance("Workshop", "wo", Locale.ENGLISH));         assertEquals(3, StringUtils.getFuzzyDistance("Apache Software Foundation", "asf", Locale.ENGLISH));     }      @Test     public void testGetFuzzyDistance_NullNullNull() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getFuzzyDistance(null, null, null));     }      @Test     public void testGetFuzzyDistance_NullStringLocale() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getFuzzyDistance(null, "clear", Locale.ENGLISH));     }      @Test     public void testGetFuzzyDistance_StringNullLoclae() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getFuzzyDistance(" ", null, Locale.ENGLISH));     }      @Test     public void testGetFuzzyDistance_StringStringNull() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getFuzzyDistance(" ", "clear", null));     }      @Test     public void testGetJaroWinklerDistance_NullNull() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getJaroWinklerDistance(null, null));     }      @Test     public void testGetJaroWinklerDistance_NullString() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getJaroWinklerDistance(null, "clear"));     }      @Test     public void testGetJaroWinklerDistance_StringNull() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getJaroWinklerDistance(" ", null));     }      @Test     public void testGetJaroWinklerDistance_StringString() {         assertEquals(0.93d, StringUtils.getJaroWinklerDistance("frog", "fog"));         assertEquals(0.0d, StringUtils.getJaroWinklerDistance("fly", "ant"));         assertEquals(0.44d, StringUtils.getJaroWinklerDistance("elephant", "hippo"));         assertEquals(0.84d, StringUtils.getJaroWinklerDistance("dwayne", "duane"));         assertEquals(0.93d, StringUtils.getJaroWinklerDistance("ABC Corporation", "ABC Corp"));         assertEquals(0.95d, StringUtils.getJaroWinklerDistance("D N H Enterprises Inc", "D & H Enterprises, Inc."));         assertEquals(0.92d, StringUtils.getJaroWinklerDistance("My Gym Children's Fitness Center", "My Gym. Childrens Fitness"));         assertEquals(0.88d, StringUtils.getJaroWinklerDistance("PENNSYLVANIA", "PENNCISYLVNIA"));         assertEquals(0.63d, StringUtils.getJaroWinklerDistance("Haus Ingeborg", "Ingeborg Esser"));     }      @Test     public void testGetLevenshteinDistance_NullString() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getLevenshteinDistance("a", null));     }      @Test     public void testGetLevenshteinDistance_NullStringInt() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getLevenshteinDistance(null, "a", 0));     }      @Test     public void testGetLevenshteinDistance_StringNull() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getLevenshteinDistance(null, "a"));     }      @Test     public void testGetLevenshteinDistance_StringNullInt() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getLevenshteinDistance("a", null, 0));     }      //-----------------------------------------------------------------------     @Test     public void testGetLevenshteinDistance_StringString() {         assertEquals(0, StringUtils.getLevenshteinDistance("", ""));         assertEquals(1, StringUtils.getLevenshteinDistance("", "a"));         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", ""));         assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog"));         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant"));         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo"));         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant"));         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz"));         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo"));         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo"));     }      @Test     public void testGetLevenshteinDistance_StringStringInt() {         // empty strings         assertEquals(0, StringUtils.getLevenshteinDistance("", "", 0));         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 8));         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "", 7));         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "", 6));          // unequal strings, zero threshold         assertEquals(-1, StringUtils.getLevenshteinDistance("b", "a", 0));         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "b", 0));          // equal strings         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 0));         assertEquals(0, StringUtils.getLevenshteinDistance("aa", "aa", 2));          // same length         assertEquals(-1, StringUtils.getLevenshteinDistance("aaa", "bbb", 2));         assertEquals(3, StringUtils.getLevenshteinDistance("aaa", "bbb", 3));          // big stripe         assertEquals(6, StringUtils.getLevenshteinDistance("aaaaaa", "b", 10));          // distance less than threshold         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 8));         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 4));          // distance equal to threshold         assertEquals(7, StringUtils.getLevenshteinDistance("aaapppp", "b", 7));         assertEquals(3, StringUtils.getLevenshteinDistance("a", "bbb", 3));          // distance greater than threshold         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 2));         assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 2));         assertEquals(-1, StringUtils.getLevenshteinDistance("aaapppp", "b", 6));          // stripe runs off array, strings not similar         assertEquals(-1, StringUtils.getLevenshteinDistance("a", "bbb", 1));         assertEquals(-1, StringUtils.getLevenshteinDistance("bbb", "a", 1));          // stripe runs off array, strings are similar         assertEquals(-1, StringUtils.getLevenshteinDistance("12345", "1234567", 1));         assertEquals(-1, StringUtils.getLevenshteinDistance("1234567", "12345", 1));          // old getLevenshteinDistance test cases         assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog", 1));         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant", 3));         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo", 7));         assertEquals(-1, StringUtils.getLevenshteinDistance("elephant", "hippo", 6));         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant", 7));         assertEquals(-1, StringUtils.getLevenshteinDistance("hippo", "elephant", 6));         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz", 8));         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo", 8));         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo", 1));          assertEquals(1, StringUtils.getLevenshteinDistance("frog", "fog", Integer.MAX_VALUE));         assertEquals(3, StringUtils.getLevenshteinDistance("fly", "ant", Integer.MAX_VALUE));         assertEquals(7, StringUtils.getLevenshteinDistance("elephant", "hippo", Integer.MAX_VALUE));         assertEquals(7, StringUtils.getLevenshteinDistance("hippo", "elephant", Integer.MAX_VALUE));         assertEquals(8, StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz", Integer.MAX_VALUE));         assertEquals(8, StringUtils.getLevenshteinDistance("zzzzzzzz", "hippo", Integer.MAX_VALUE));         assertEquals(1, StringUtils.getLevenshteinDistance("hello", "hallo", Integer.MAX_VALUE));     }      @Test     public void testGetLevenshteinDistance_StringStringNegativeInt() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.getLevenshteinDistance("a", "a", -1));     }      /**      * Test for {@link StringUtils#isAllLowerCase(CharSequence)}.      */     @Test     public void testIsAllLowerCase() {         assertFalse(StringUtils.isAllLowerCase(null));         assertFalse(StringUtils.isAllLowerCase(StringUtils.EMPTY));         assertFalse(StringUtils.isAllLowerCase("  "));         assertTrue(StringUtils.isAllLowerCase("abc"));         assertFalse(StringUtils.isAllLowerCase("abc "));         assertFalse(StringUtils.isAllLowerCase("abc\n"));         assertFalse(StringUtils.isAllLowerCase("abC"));         assertFalse(StringUtils.isAllLowerCase("ab c"));         assertFalse(StringUtils.isAllLowerCase("ab1c"));         assertFalse(StringUtils.isAllLowerCase("ab/c"));     }      /**      * Test for {@link StringUtils#isAllUpperCase(CharSequence)}.      */     @Test     public void testIsAllUpperCase() {         assertFalse(StringUtils.isAllUpperCase(null));         assertFalse(StringUtils.isAllUpperCase(StringUtils.EMPTY));         assertFalse(StringUtils.isAllUpperCase("  "));         assertTrue(StringUtils.isAllUpperCase("ABC"));         assertFalse(StringUtils.isAllUpperCase("ABC "));         assertFalse(StringUtils.isAllUpperCase("ABC\n"));         assertFalse(StringUtils.isAllUpperCase("aBC"));         assertFalse(StringUtils.isAllUpperCase("A C"));         assertFalse(StringUtils.isAllUpperCase("A1C"));         assertFalse(StringUtils.isAllUpperCase("A/C"));     }      /**      * Test for {@link StringUtils#isMixedCase(CharSequence)}.      */     @Test     public void testIsMixedCase() {         assertFalse(StringUtils.isMixedCase(null));         assertFalse(StringUtils.isMixedCase(StringUtils.EMPTY));         assertFalse(StringUtils.isMixedCase(" "));         assertFalse(StringUtils.isMixedCase("A"));         assertFalse(StringUtils.isMixedCase("a"));         assertFalse(StringUtils.isMixedCase("/"));         assertFalse(StringUtils.isMixedCase("A/"));         assertFalse(StringUtils.isMixedCase("/b"));         assertFalse(StringUtils.isMixedCase("abc"));         assertFalse(StringUtils.isMixedCase("ABC"));         assertTrue(StringUtils.isMixedCase("aBc"));         assertTrue(StringUtils.isMixedCase("aBc "));         assertTrue(StringUtils.isMixedCase("A c"));         assertTrue(StringUtils.isMixedCase("aBc\n"));         assertTrue(StringUtils.isMixedCase("A1c"));         assertTrue(StringUtils.isMixedCase("a/C"));     }      @Test     public void testJoin_ArrayCharSeparator() {         assertNull(StringUtils.join((Object[]) null, ','));         assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));         assertEquals(";;foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));         assertEquals("foo;2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));          assertNull(StringUtils.join((Object[]) null, ',', 0, 1));         assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length - 1));         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST, '/', 0, 1));         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1));     }      @Test     public void testJoin_ArrayOfBytes() {         assertNull(StringUtils.join((byte[]) null, ','));         assertEquals("1;2", StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2", StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((byte[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(BYTE_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfChars() {         assertNull(StringUtils.join((char[]) null, ','));         assertEquals("1;2", StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2", StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((char[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(CHAR_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfDoubles() {         assertNull(StringUtils.join((double[]) null, ','));         assertEquals("1.0;2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2.0", StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((double[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(DOUBLE_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfFloats() {         assertNull(StringUtils.join((float[]) null, ','));         assertEquals("1.0;2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2.0", StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((float[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(FLOAT_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfInts() {         assertNull(StringUtils.join((int[]) null, ','));         assertEquals("1;2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2", StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((int[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(INT_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfLongs() {         assertNull(StringUtils.join((long[]) null, ','));         assertEquals("1;2", StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2", StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((long[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(LONG_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayOfShorts() {         assertNull(StringUtils.join((short[]) null, ','));         assertEquals("1;2", StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR));         assertEquals("2", StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR, 1, 2));         assertNull(StringUtils.join((short[]) null, SEPARATOR_CHAR, 0, 1));         assertEquals(StringUtils.EMPTY, StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR, 0, 0));         assertEquals(StringUtils.EMPTY, StringUtils.join(SHORT_PRIM_LIST, SEPARATOR_CHAR, 1, 0));     }      @Test     public void testJoin_ArrayString() {         assertNull(StringUtils.join((Object[]) null, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, ""));          assertEquals("", StringUtils.join(NULL_ARRAY_LIST, null));          assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, null));         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, ""));         assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR));          assertEquals(TEXT_LIST, StringUtils.join(ARRAY_LIST, SEPARATOR));         assertEquals(",,foo", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR));         assertEquals("foo,2", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR));          assertEquals("/", StringUtils.join(MIXED_ARRAY_LIST, "/", 0, MIXED_ARRAY_LIST.length - 1));         assertEquals("", StringUtils.join(MIXED_ARRAY_LIST, "", 0, MIXED_ARRAY_LIST.length - 1));         assertEquals("foo", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 1));         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_LIST, "/", 0, 2));         assertEquals("2", StringUtils.join(MIXED_TYPE_LIST, "/", 1, 2));         assertEquals("", StringUtils.join(MIXED_TYPE_LIST, "/", 2, 1));     }      @Test     public void testJoin_IterableChar() {         assertNull(StringUtils.join((Iterable<?>) null, ','));         assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR_CHAR));         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), SEPARATOR_CHAR));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR_CHAR));         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), 'x'));     }      @Test     public void testJoin_IterableString() {         assertNull(StringUtils.join((Iterable<?>) null, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST), ""));         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), "x"));         assertEquals("foo", StringUtils.join(Collections.singleton("foo"), null));          assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST), null));          assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), null));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), ""));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST), SEPARATOR));          assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST), SEPARATOR));     }      @Test     public void testJoin_IteratorChar() {         assertNull(StringUtils.join((Iterator<?>) null, ','));         assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR));         assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR));         assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), 'x'));     }      @Test     public void testJoin_IteratorString() {         assertNull(StringUtils.join((Iterator<?>) null, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), ""));         assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), "x"));         assertEquals("foo", StringUtils.join(Collections.singleton("foo").iterator(), null));          assertEquals("", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), null));          assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), null));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), ""));         assertEquals("", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR));          assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR));          assertNull(StringUtils.join(Arrays.asList(NULL_TO_STRING_LIST).iterator(), SEPARATOR));     }      @Test     public void testJoin_List() {         assertNull(StringUtils.join((List<String>) null, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(STRING_LIST, null));         assertEquals(TEXT_LIST_NOSEP, StringUtils.join(STRING_LIST, ""));          assertEquals("", StringUtils.join(NULL_STRING_LIST, null));          assertEquals("", StringUtils.join(EMPTY_STRING_LIST, null));         assertEquals("", StringUtils.join(EMPTY_STRING_LIST, ""));         assertEquals("", StringUtils.join(EMPTY_STRING_LIST, SEPARATOR));          assertEquals(TEXT_LIST, StringUtils.join(STRING_LIST, SEPARATOR));         assertEquals(",,foo", StringUtils.join(MIXED_STRING_LIST, SEPARATOR));         assertEquals("foo,2", StringUtils.join(MIXED_TYPE_OBJECT_LIST, SEPARATOR));          assertEquals("/", StringUtils.join(MIXED_STRING_LIST, "/", 0, MIXED_STRING_LIST.size() - 1));         assertEquals("", StringUtils.join(MIXED_STRING_LIST, "", 0, MIXED_STRING_LIST.size()- 1));         assertEquals("foo", StringUtils.join(MIXED_TYPE_OBJECT_LIST, "/", 0, 1));         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_OBJECT_LIST, "/", 0, 2));         assertEquals("2", StringUtils.join(MIXED_TYPE_OBJECT_LIST, "/", 1, 2));         assertEquals("", StringUtils.join(MIXED_TYPE_OBJECT_LIST, "/", 2, 1));         assertNull(null, StringUtils.join((List<?>) null, "/", 0, 1));          assertEquals("/", StringUtils.join(MIXED_STRING_LIST, '/', 0, MIXED_STRING_LIST.size() - 1));         assertEquals("foo", StringUtils.join(MIXED_TYPE_OBJECT_LIST, '/', 0, 1));         assertEquals("foo/2", StringUtils.join(MIXED_TYPE_OBJECT_LIST, '/', 0, 2));         assertEquals("2", StringUtils.join(MIXED_TYPE_OBJECT_LIST, '/', 1, 2));         assertEquals("", StringUtils.join(MIXED_TYPE_OBJECT_LIST, '/', 2, 1));         assertNull(null, StringUtils.join((List<?>) null, '/', 0, 1));     }      @Test     public void testJoin_Objectarray() { //        assertNull(StringUtils.join(null)); // generates warning         assertNull(StringUtils.join((Object[]) null)); // equivalent explicit cast         // test additional varargs calls         assertEquals("", StringUtils.join()); // empty array         assertEquals("", StringUtils.join((Object) null)); // => new Object[]{null}          assertEquals("", StringUtils.join(EMPTY_ARRAY_LIST));         assertEquals("", StringUtils.join(NULL_ARRAY_LIST));         assertEquals("null", StringUtils.join(NULL_TO_STRING_LIST));         assertEquals("abc", StringUtils.join("a", "b", "c"));         assertEquals("a", StringUtils.join(null, "a", ""));         assertEquals("foo", StringUtils.join(MIXED_ARRAY_LIST));         assertEquals("foo2", StringUtils.join(MIXED_TYPE_LIST));     }      @Disabled     @Test     public void testLang1593() {         final int[] arr = new int[] {1, 2, 3, 4, 5, 6, 7};         final String expected = StringUtils.join(arr, '-');         final String actual = StringUtils.join(arr, "-");         assertEquals(expected, actual);     }      //-----------------------------------------------------------------------     @Test     public void testJoin_Objects() {         assertEquals("abc", StringUtils.join("a", "b", "c"));         assertEquals("a", StringUtils.join(null, "", "a"));         assertNull(StringUtils.join((Object[]) null));     }      @Test     public void testJoinWith() {         assertEquals("", StringUtils.joinWith(","));        // empty array         assertEquals("", StringUtils.joinWith(",", (Object[]) NULL_ARRAY_LIST));         assertEquals("null", StringUtils.joinWith(",", NULL_TO_STRING_LIST));   //toString method prints 'null'          assertEquals("a,b,c", StringUtils.joinWith(",", "a", "b", "c"));         assertEquals(",a,", StringUtils.joinWith(",", null, "a", ""));         assertEquals(",a,", StringUtils.joinWith(",", "", "a", ""));          assertEquals("ab", StringUtils.joinWith(null, "a", "b"));     }      @Test     public void testJoinWithThrowsException() {         assertThrows(IllegalArgumentException.class, () -> StringUtils.joinWith(",", (Object[]) null));     }      @Test     public void testLang623() {         assertEquals("t", StringUtils.replaceChars("\u00DE", '\u00DE', 't'));         assertEquals("t", StringUtils.replaceChars("\u00FE", '\u00FE', 't'));     }      @Test     public void testLANG666() {         assertEquals("12", StringUtils.stripEnd("120.00", ".0"));         assertEquals("121", StringUtils.stripEnd("121.00", ".0"));     }      //-----------------------------------------------------------------------     @Test     public void testLeftPad_StringInt() {         assertNull(StringUtils.leftPad(null, 5));         assertEquals("     ", StringUtils.leftPad("", 5));         assertEquals("  abc", StringUtils.leftPad("abc", 5));         assertEquals("abc", StringUtils.leftPad("abc", 2));     }      @Test     public void testLeftPad_StringIntChar() {         assertNull(StringUtils.leftPad(null, 5, ' '));         assertEquals("     ", StringUtils.leftPad("", 5, ' '));         assertEquals("  abc", StringUtils.leftPad("abc", 5, ' '));         assertEquals("xxabc", StringUtils.leftPad("abc", 5, 'x'));         assertEquals("\uffff\uffffabc", StringUtils.leftPad("abc", 5, '\uffff'));         assertEquals("abc", StringUtils.leftPad("abc", 2, ' '));         final String str = StringUtils.leftPad("aaa", 10000, 'a');  // bigger than pad length         assertEquals(10000, str.length());         assertTrue(StringUtils.containsOnly(str, 'a'));     }      @Test     public void testLeftPad_StringIntString() {         assertNull(StringUtils.leftPad(null, 5, "-+"));         assertNull(StringUtils.leftPad(null, 5, null));         assertEquals("     ", StringUtils.leftPad("", 5, " "));         assertEquals("-+-+abc", StringUtils.leftPad("abc", 7, "-+"));         assertEquals("-+~abc", StringUtils.leftPad("abc", 6, "-+~"));         assertEquals("-+abc", StringUtils.leftPad("abc", 5, "-+~"));         assertEquals("abc", StringUtils.leftPad("abc", 2, " "));         assertEquals("abc", StringUtils.leftPad("abc", -1, " "));         assertEquals("  abc", StringUtils.leftPad("abc", 5, null));         assertEquals("  abc", StringUtils.leftPad("abc", 5, ""));     }      @Test     public void testLength_CharBuffer() {         assertEquals(0, StringUtils.length(CharBuffer.wrap("")));         assertEquals(1, StringUtils.length(CharBuffer.wrap("A")));         assertEquals(1, StringUtils.length(CharBuffer.wrap(" ")));         assertEquals(8, StringUtils.length(CharBuffer.wrap("ABCDEFGH")));     }      @Test     public void testLengthString() {         assertEquals(0, StringUtils.length(null));         assertEquals(0, StringUtils.length(""));         assertEquals(0, StringUtils.length(StringUtils.EMPTY));         assertEquals(1, StringUtils.length("A"));         assertEquals(1, StringUtils.length(" "));         assertEquals(8, StringUtils.length("ABCDEFGH"));     }      @Test     public void testLengthStringBuffer() {         assertEquals(0, StringUtils.length(new StringBuffer("")));         assertEquals(0, StringUtils.length(new StringBuffer(StringUtils.EMPTY)));         assertEquals(1, StringUtils.length(new StringBuffer("A")));         assertEquals(1, StringUtils.length(new StringBuffer(" ")));         assertEquals(8, StringUtils.length(new StringBuffer("ABCDEFGH")));     }      @Test     public void testLengthStringBuilder() {         assertEquals(0, StringUtils.length(new StringBuilder("")));         assertEquals(0, StringUtils.length(new StringBuilder(StringUtils.EMPTY)));         assertEquals(1, StringUtils.length(new StringBuilder("A")));         assertEquals(1, StringUtils.length(new StringBuilder(" ")));         assertEquals(8, StringUtils.length(new StringBuilder("ABCDEFGH")));     }      @Test     public void testLowerCase() {         assertNull(StringUtils.lowerCase(null));         assertNull(StringUtils.lowerCase(null, Locale.ENGLISH));         assertEquals("foo test thing", StringUtils.lowerCase("fOo test THING"), "lowerCase(String) failed");         assertEquals("", StringUtils.lowerCase(""), "lowerCase(empty-string) failed");         assertEquals("foo test thing", StringUtils.lowerCase("fOo test THING", Locale.ENGLISH),                 "lowerCase(String, Locale) failed");         assertEquals("", StringUtils.lowerCase("", Locale.ENGLISH), "lowerCase(empty-string, Locale) failed");     }      @Test     public void testNormalizeSpace() {         // Java says a non-breaking whitespace is not a whitespace.         assertFalse(Character.isWhitespace('\u00A0'));         //         assertNull(StringUtils.normalizeSpace(null));         assertEquals("", StringUtils.normalizeSpace(""));         assertEquals("", StringUtils.normalizeSpace(" "));         assertEquals("", StringUtils.normalizeSpace("\t"));         assertEquals("", StringUtils.normalizeSpace("\n"));         assertEquals("", StringUtils.normalizeSpace("\u0009"));         assertEquals("", StringUtils.normalizeSpace("\u000B"));         assertEquals("", StringUtils.normalizeSpace("\u000C"));         assertEquals("", StringUtils.normalizeSpace("\u001C"));         assertEquals("", StringUtils.normalizeSpace("\u001D"));         assertEquals("", StringUtils.normalizeSpace("\u001E"));         assertEquals("", StringUtils.normalizeSpace("\u001F"));         assertEquals("", StringUtils.normalizeSpace("\f"));         assertEquals("", StringUtils.normalizeSpace("\r"));         assertEquals("a", StringUtils.normalizeSpace("  a  "));         assertEquals("a b c", StringUtils.normalizeSpace("  a  b   c  "));         assertEquals("a b c", StringUtils.normalizeSpace("a\t\f\r  b\u000B   c\n"));         assertEquals("a   b c", StringUtils.normalizeSpace("a\t\f\r  " + HARD_SPACE + HARD_SPACE + "b\u000B   c\n"));         assertEquals("b", StringUtils.normalizeSpace("\u0000b"));         assertEquals("b", StringUtils.normalizeSpace("b\u0000"));     }      @Test     public void testOverlay_StringStringIntInt() {         assertNull(StringUtils.overlay(null, null, 2, 4));         assertNull(StringUtils.overlay(null, null, -2, -4));          assertEquals("", StringUtils.overlay("", null, 0, 0));         assertEquals("", StringUtils.overlay("", "", 0, 0));         assertEquals("zzzz", StringUtils.overlay("", "zzzz", 0, 0));         assertEquals("zzzz", StringUtils.overlay("", "zzzz", 2, 4));         assertEquals("zzzz", StringUtils.overlay("", "zzzz", -2, -4));          assertEquals("abef", StringUtils.overlay("abcdef", null, 2, 4));         assertEquals("abef", StringUtils.overlay("abcdef", null, 4, 2));         assertEquals("abef", StringUtils.overlay("abcdef", "", 2, 4));         assertEquals("abef", StringUtils.overlay("abcdef", "", 4, 2));         assertEquals("abzzzzef", StringUtils.overlay("abcdef", "zzzz", 2, 4));         assertEquals("abzzzzef", StringUtils.overlay("abcdef", "zzzz", 4, 2));          assertEquals("zzzzef", StringUtils.overlay("abcdef", "zzzz", -1, 4));         assertEquals("zzzzef", StringUtils.overlay("abcdef", "zzzz", 4, -1));         assertEquals("zzzzabcdef", StringUtils.overlay("abcdef", "zzzz", -2, -1));         assertEquals("zzzzabcdef", StringUtils.overlay("abcdef", "zzzz", -1, -2));         assertEquals("abcdzzzz", StringUtils.overlay("abcdef", "zzzz", 4, 10));         assertEquals("abcdzzzz", StringUtils.overlay("abcdef", "zzzz", 10, 4));         assertEquals("abcdefzzzz", StringUtils.overlay("abcdef", "zzzz", 8, 10));         assertEquals("abcdefzzzz", StringUtils.overlay("abcdef", "zzzz", 10, 8));     }      /**      * Tests {@code prependIfMissing}.      */     @Test     public void testPrependIfMissing() {         assertNull(StringUtils.prependIfMissing(null, null), "prependIfMissing(null,null)");         assertEquals("abc", StringUtils.prependIfMissing("abc", null), "prependIfMissing(abc,null)");         assertEquals("xyz", StringUtils.prependIfMissing("", "xyz"), "prependIfMissing(\"\",xyz)");         assertEquals("xyzabc", StringUtils.prependIfMissing("abc", "xyz"), "prependIfMissing(abc,xyz)");         assertEquals("xyzabc", StringUtils.prependIfMissing("xyzabc", "xyz"), "prependIfMissing(xyzabc,xyz)");         assertEquals("xyzXYZabc", StringUtils.prependIfMissing("XYZabc", "xyz"), "prependIfMissing(XYZabc,xyz)");          assertNull(StringUtils.prependIfMissing(null, null, (CharSequence[]) null), "prependIfMissing(null,null null)");         assertEquals("abc", StringUtils.prependIfMissing("abc", null, (CharSequence[]) null), "prependIfMissing(abc,null,null)");         assertEquals("xyz", StringUtils.prependIfMissing("", "xyz", (CharSequence[]) null), "prependIfMissing(\"\",xyz,null)");         assertEquals("xyzabc", StringUtils.prependIfMissing("abc", "xyz", null), "prependIfMissing(abc,xyz,{null})");         assertEquals("abc", StringUtils.prependIfMissing("abc", "xyz", ""), "prependIfMissing(abc,xyz,\"\")");         assertEquals("xyzabc", StringUtils.prependIfMissing("abc", "xyz", "mno"), "prependIfMissing(abc,xyz,mno)");         assertEquals("xyzabc", StringUtils.prependIfMissing("xyzabc", "xyz", "mno"), "prependIfMissing(xyzabc,xyz,mno)");         assertEquals("mnoabc", StringUtils.prependIfMissing("mnoabc", "xyz", "mno"), "prependIfMissing(mnoabc,xyz,mno)");         assertEquals("xyzXYZabc", StringUtils.prependIfMissing("XYZabc", "xyz", "mno"), "prependIfMissing(XYZabc,xyz,mno)");         assertEquals("xyzMNOabc", StringUtils.prependIfMissing("MNOabc", "xyz", "mno"), "prependIfMissing(MNOabc,xyz,mno)");     }      /**      * Tests {@code prependIfMissingIgnoreCase}.      */     @Test     public void testPrependIfMissingIgnoreCase() {         assertNull(StringUtils.prependIfMissingIgnoreCase(null, null), "prependIfMissingIgnoreCase(null,null)");         assertEquals("abc", StringUtils.prependIfMissingIgnoreCase("abc", null), "prependIfMissingIgnoreCase(abc,null)");         assertEquals("xyz", StringUtils.prependIfMissingIgnoreCase("", "xyz"), "prependIfMissingIgnoreCase(\"\",xyz)");         assertEquals("xyzabc", StringUtils.prependIfMissingIgnoreCase("abc", "xyz"), "prependIfMissingIgnoreCase(abc,xyz)");         assertEquals("xyzabc", StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz"), "prependIfMissingIgnoreCase(xyzabc,xyz)");         assertEquals("XYZabc", StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz"), "prependIfMissingIgnoreCase(XYZabc,xyz)");          assertNull(StringUtils.prependIfMissingIgnoreCase(null, null, (CharSequence[]) null), "prependIfMissingIgnoreCase(null,null null)");         assertEquals("abc", StringUtils.prependIfMissingIgnoreCase("abc", null, (CharSequence[]) null), "prependIfMissingIgnoreCase(abc,null,null)");         assertEquals("xyz", StringUtils.prependIfMissingIgnoreCase("", "xyz", (CharSequence[]) null), "prependIfMissingIgnoreCase(\"\",xyz,null)");         assertEquals("xyzabc", StringUtils.prependIfMissingIgnoreCase("abc", "xyz", null), "prependIfMissingIgnoreCase(abc,xyz,{null})");         assertEquals("abc", StringUtils.prependIfMissingIgnoreCase("abc", "xyz", ""), "prependIfMissingIgnoreCase(abc,xyz,\"\")");         assertEquals("xyzabc", StringUtils.prependIfMissingIgnoreCase("abc", "xyz", "mno"), "prependIfMissingIgnoreCase(abc,xyz,mno)");         assertEquals("xyzabc", StringUtils.prependIfMissingIgnoreCase("xyzabc", "xyz", "mno"), "prependIfMissingIgnoreCase(xyzabc,xyz,mno)");         assertEquals("mnoabc", StringUtils.prependIfMissingIgnoreCase("mnoabc", "xyz", "mno"), "prependIfMissingIgnoreCase(mnoabc,xyz,mno)");         assertEquals("XYZabc", StringUtils.prependIfMissingIgnoreCase("XYZabc", "xyz", "mno"), "prependIfMissingIgnoreCase(XYZabc,xyz,mno)");         assertEquals("MNOabc", StringUtils.prependIfMissingIgnoreCase("MNOabc", "xyz", "mno"), "prependIfMissingIgnoreCase(MNOabc,xyz,mno)");     }      @Test     public void testReCapitalize() {         // reflection type of tests: Sentences.         assertEquals(SENTENCE_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(SENTENCE_UNCAP)),                 "uncapitalize(capitalize(String)) failed");         assertEquals(SENTENCE_CAP, StringUtils.capitalize(StringUtils.uncapitalize(SENTENCE_CAP)),                 "capitalize(uncapitalize(String)) failed");          // reflection type of tests: One word.         assertEquals(FOO_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(FOO_UNCAP)),                 "uncapitalize(capitalize(String)) failed");         assertEquals(FOO_CAP, StringUtils.capitalize(StringUtils.uncapitalize(FOO_CAP)),                 "capitalize(uncapitalize(String)) failed");     }      @Test     public void testRemove_char() {         // StringUtils.remove(null, *)       = null         assertNull(StringUtils.remove(null, 'a'));         assertNull(StringUtils.remove(null, 'a'));         assertNull(StringUtils.remove(null, 'a'));          // StringUtils.remove("", *)          = ""         assertEquals("", StringUtils.remove("", 'a'));         assertEquals("", StringUtils.remove("", 'a'));         assertEquals("", StringUtils.remove("", 'a'));          // StringUtils.remove("queued", 'u') = "qeed"         assertEquals("qeed", StringUtils.remove("queued", 'u'));          // StringUtils.remove("queued", 'z') = "queued"         assertEquals("queued", StringUtils.remove("queued", 'z'));     }      @Test     public void testRemove_String() {         // StringUtils.remove(null, *)        = null         assertNull(StringUtils.remove(null, null));         assertNull(StringUtils.remove(null, ""));         assertNull(StringUtils.remove(null, "a"));          // StringUtils.remove("", *)          = ""         assertEquals("", StringUtils.remove("", null));         assertEquals("", StringUtils.remove("", ""));         assertEquals("", StringUtils.remove("", "a"));          // StringUtils.remove(*, null)        = *         assertNull(StringUtils.remove(null, null));         assertEquals("", StringUtils.remove("", null));         assertEquals("a", StringUtils.remove("a", null));          // StringUtils.remove(*, "")          = *         assertNull(StringUtils.remove(null, ""));         assertEquals("", StringUtils.remove("", ""));         assertEquals("a", StringUtils.remove("a", ""));          // StringUtils.remove("queued", "ue") = "qd"         assertEquals("qd", StringUtils.remove("queued", "ue"));          // StringUtils.remove("queued", "zz") = "queued"         assertEquals("queued", StringUtils.remove("queued", "zz"));     }      @Test     public void testRemoveAll_StringString() {         assertNull(StringUtils.removeAll(null, ""));         assertEquals("any", StringUtils.removeAll("any", null));          assertEquals("any", StringUtils.removeAll("any", ""));         assertEquals("", StringUtils.removeAll("any", ".*"));         assertEquals("", StringUtils.removeAll("any", ".+"));         assertEquals("", StringUtils.removeAll("any", ".?"));          assertEquals("A\nB", StringUtils.removeAll("A<__>\n<__>B", "<.*>"));         assertEquals("AB", StringUtils.removeAll("A<__>\n<__>B", "(?s)<.*>"));         assertEquals("ABC123", StringUtils.removeAll("ABCabc123abc", "[a-z]"));          assertThrows(                 PatternSyntaxException.class,                 () -> StringUtils.removeAll("any", "{badRegexSyntax}"),                 "StringUtils.removeAll expecting PatternSyntaxException");     }      @Test     public void testRemoveEnd() {         // StringUtils.removeEnd("", *)        = ""         assertNull(StringUtils.removeEnd(null, null));         assertNull(StringUtils.removeEnd(null, ""));         assertNull(StringUtils.removeEnd(null, "a"));          // StringUtils.removeEnd(*, null)      = *         assertEquals(StringUtils.removeEnd("", null), "");         assertEquals(StringUtils.removeEnd("", ""), "");         assertEquals(StringUtils.removeEnd("", "a"), "");          // All others:         assertEquals(StringUtils.removeEnd("www.domain.com.", ".com"), "www.domain.com.");         assertEquals(StringUtils.removeEnd("www.domain.com", ".com"), "www.domain");         assertEquals(StringUtils.removeEnd("www.domain", ".com"), "www.domain");         assertEquals(StringUtils.removeEnd("domain.com", ""), "domain.com");         assertEquals(StringUtils.removeEnd("domain.com", null), "domain.com");     }      @Test     public void testRemoveEndIgnoreCase() {         // StringUtils.removeEndIgnoreCase("", *)        = ""         assertNull(StringUtils.removeEndIgnoreCase(null, null), "removeEndIgnoreCase(null, null)");         assertNull(StringUtils.removeEndIgnoreCase(null, ""), "removeEndIgnoreCase(null, \"\")");         assertNull(StringUtils.removeEndIgnoreCase(null, "a"), "removeEndIgnoreCase(null, \"a\")");          // StringUtils.removeEnd(*, null)      = *         assertEquals(StringUtils.removeEndIgnoreCase("", null), "", "removeEndIgnoreCase(\"\", null)");         assertEquals(StringUtils.removeEndIgnoreCase("", ""), "", "removeEndIgnoreCase(\"\", \"\")");         assertEquals(StringUtils.removeEndIgnoreCase("", "a"), "", "removeEndIgnoreCase(\"\", \"a\")");          // All others:         assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com.", ".com"), "www.domain.com.", "removeEndIgnoreCase(\"www.domain.com.\", \".com\")");         assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com", ".com"), "www.domain", "removeEndIgnoreCase(\"www.domain.com\", \".com\")");         assertEquals(StringUtils.removeEndIgnoreCase("www.domain", ".com"), "www.domain", "removeEndIgnoreCase(\"www.domain\", \".com\")");         assertEquals(StringUtils.removeEndIgnoreCase("domain.com", ""), "domain.com", "removeEndIgnoreCase(\"domain.com\", \"\")");         assertEquals(StringUtils.removeEndIgnoreCase("domain.com", null), "domain.com", "removeEndIgnoreCase(\"domain.com\", null)");          // Case insensitive:         assertEquals(StringUtils.removeEndIgnoreCase("www.domain.com", ".COM"), "www.domain", "removeEndIgnoreCase(\"www.domain.com\", \".COM\")");         assertEquals(StringUtils.removeEndIgnoreCase("www.domain.COM", ".com"), "www.domain", "removeEndIgnoreCase(\"www.domain.COM\", \".com\")");     }      @Test     public void testRemoveFirst_StringString() {         assertNull(StringUtils.removeFirst(null, ""));         assertEquals("any", StringUtils.removeFirst("any", null));          assertEquals("any", StringUtils.removeFirst("any", ""));         assertEquals("", StringUtils.removeFirst("any", ".*"));         assertEquals("", StringUtils.removeFirst("any", ".+"));         assertEquals("bc", StringUtils.removeFirst("abc", ".?"));          assertEquals("A\n<__>B", StringUtils.removeFirst("A<__>\n<__>B", "<.*>"));         assertEquals("AB", StringUtils.removeFirst("A<__>\n<__>B", "(?s)<.*>"));         assertEquals("ABCbc123", StringUtils.removeFirst("ABCabc123", "[a-z]"));         assertEquals("ABC123abc", StringUtils.removeFirst("ABCabc123abc", "[a-z]+"));          assertThrows(                 PatternSyntaxException.class,                 () -> StringUtils.removeFirst("any", "{badRegexSyntax}"),                 "StringUtils.removeFirst expecting PatternSyntaxException");     }      @Test     public void testRemoveIgnoreCase_String() {         // StringUtils.removeIgnoreCase(null, *) = null         assertNull(StringUtils.removeIgnoreCase(null, null));         assertNull(StringUtils.removeIgnoreCase(null, ""));         assertNull(StringUtils.removeIgnoreCase(null, "a"));          // StringUtils.removeIgnoreCase("", *) = ""         assertEquals("", StringUtils.removeIgnoreCase("", null));         assertEquals("", StringUtils.removeIgnoreCase("", ""));         assertEquals("", StringUtils.removeIgnoreCase("", "a"));          // StringUtils.removeIgnoreCase(*, null) = *         assertNull(StringUtils.removeIgnoreCase(null, null));         assertEquals("", StringUtils.removeIgnoreCase("", null));         assertEquals("a", StringUtils.removeIgnoreCase("a", null));          // StringUtils.removeIgnoreCase(*, "") = *         assertNull(StringUtils.removeIgnoreCase(null, ""));         assertEquals("", StringUtils.removeIgnoreCase("", ""));         assertEquals("a", StringUtils.removeIgnoreCase("a", ""));          // StringUtils.removeIgnoreCase("queued", "ue") = "qd"         assertEquals("qd", StringUtils.removeIgnoreCase("queued", "ue"));          // StringUtils.removeIgnoreCase("queued", "zz") = "queued"         assertEquals("queued", StringUtils.removeIgnoreCase("queued", "zz"));          // IgnoreCase         // StringUtils.removeIgnoreCase("quEUed", "UE") = "qd"         assertEquals("qd", StringUtils.removeIgnoreCase("quEUed", "UE"));          // StringUtils.removeIgnoreCase("queued", "zZ") = "queued"         assertEquals("queued", StringUtils.removeIgnoreCase("queued", "zZ"));          // StringUtils.removeIgnoreCase("\u0130x", "x") = "\u0130"         assertEquals("\u0130", StringUtils.removeIgnoreCase("\u0130x", "x"));          // LANG-1453         StringUtils.removeIgnoreCase("İa", "a");     }      @Test     public void testRemovePattern_StringString() {         assertNull(StringUtils.removePattern(null, ""));         assertEquals("any", StringUtils.removePattern("any", null));          assertEquals("", StringUtils.removePattern("", ""));         assertEquals("", StringUtils.removePattern("", ".*"));         assertEquals("", StringUtils.removePattern("", ".+"));          assertEquals("AB", StringUtils.removePattern("A<__>\n<__>B", "<.*>"));         assertEquals("AB", StringUtils.removePattern("A<__>\\n<__>B", "<.*>"));         assertEquals("", StringUtils.removePattern("<A>x\\ny</A>", "<A>.*</A>"));         assertEquals("", StringUtils.removePattern("<A>\nxy\n</A>", "<A>.*</A>"));          assertEquals("ABC123", StringUtils.removePattern("ABCabc123", "[a-z]"));     }      @Test     public void testRemoveStart() {         // StringUtils.removeStart("", *)        = ""         assertNull(StringUtils.removeStart(null, null));         assertNull(StringUtils.removeStart(null, ""));         assertNull(StringUtils.removeStart(null, "a"));          // StringUtils.removeStart(*, null)      = *         assertEquals(StringUtils.removeStart("", null), "");         assertEquals(StringUtils.removeStart("", ""), "");         assertEquals(StringUtils.removeStart("", "a"), "");          // All others:         assertEquals(StringUtils.removeStart("www.domain.com", "www."), "domain.com");         assertEquals(StringUtils.removeStart("domain.com", "www."), "domain.com");         assertEquals(StringUtils.removeStart("domain.com", ""), "domain.com");         assertEquals(StringUtils.removeStart("domain.com", null), "domain.com");     }      @Test     public void testRemoveStartIgnoreCase() {         // StringUtils.removeStart("", *)        = ""         assertNull(StringUtils.removeStartIgnoreCase(null, null), "removeStartIgnoreCase(null, null)");         assertNull(StringUtils.removeStartIgnoreCase(null, ""), "removeStartIgnoreCase(null, \"\")");         assertNull(StringUtils.removeStartIgnoreCase(null, "a"), "removeStartIgnoreCase(null, \"a\")");          // StringUtils.removeStart(*, null)      = *         assertEquals(StringUtils.removeStartIgnoreCase("", null), "", "removeStartIgnoreCase(\"\", null)");         assertEquals(StringUtils.removeStartIgnoreCase("", ""), "", "removeStartIgnoreCase(\"\", \"\")");         assertEquals(StringUtils.removeStartIgnoreCase("", "a"), "", "removeStartIgnoreCase(\"\", \"a\")");          // All others:         assertEquals(StringUtils.removeStartIgnoreCase("www.domain.com", "www."), "domain.com", "removeStartIgnoreCase(\"www.domain.com\", \"www.\")");         assertEquals(StringUtils.removeStartIgnoreCase("domain.com", "www."), "domain.com", "removeStartIgnoreCase(\"domain.com\", \"www.\")");         assertEquals(StringUtils.removeStartIgnoreCase("domain.com", ""), "domain.com", "removeStartIgnoreCase(\"domain.com\", \"\")");         assertEquals(StringUtils.removeStartIgnoreCase("domain.com", null), "domain.com", "removeStartIgnoreCase(\"domain.com\", null)");          // Case insensitive:         assertEquals(StringUtils.removeStartIgnoreCase("www.domain.com", "WWW."), "domain.com", "removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")");     }      @Test     public void testRepeat_CharInt() {         assertEquals("zzz", StringUtils.repeat('z', 3));         assertEquals("", StringUtils.repeat('z', 0));         assertEquals("", StringUtils.repeat('z', -2));     }      @Test     public void testRepeat_StringInt() {         assertNull(StringUtils.repeat(null, 2));         assertEquals("", StringUtils.repeat("ab", 0));         assertEquals("", StringUtils.repeat("", 3));         assertEquals("aaa", StringUtils.repeat("a", 3));         assertEquals("", StringUtils.repeat("a", -2));         assertEquals("ababab", StringUtils.repeat("ab", 3));         assertEquals("abcabcabc", StringUtils.repeat("abc", 3));         final String str = StringUtils.repeat("a", 10000);  // bigger than pad limit         assertEquals(10000, str.length());         assertTrue(StringUtils.containsOnly(str, 'a'));     }      @Test     public void testRepeat_StringStringInt() {         assertNull(StringUtils.repeat(null, null, 2));         assertNull(StringUtils.repeat(null, "x", 2));         assertEquals("", StringUtils.repeat("", null, 2));          assertEquals("", StringUtils.repeat("ab", "", 0));         assertEquals("", StringUtils.repeat("", "", 2));          assertEquals("xx", StringUtils.repeat("", "x", 3));          assertEquals("?, ?, ?", StringUtils.repeat("?", ", ", 3));     }      /**      * Test method for 'StringUtils.replaceEach(String, String[], String[])'      */     @Test     public void testReplace_StringStringArrayStringArray() {         //JAVADOC TESTS START         assertNull(StringUtils.replaceEach(null, new String[]{"a"}, new String[]{"b"}));         assertEquals(StringUtils.replaceEach("", new String[]{"a"}, new String[]{"b"}), "");         assertEquals(StringUtils.replaceEach("aba", null, null), "aba");         assertEquals(StringUtils.replaceEach("aba", new String[0], null), "aba");         assertEquals(StringUtils.replaceEach("aba", null, new String[0]), "aba");         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, null), "aba");          assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}), "b");         assertEquals(StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}), "aba");         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}), "wcte");         assertEquals(StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}), "dcte");         //JAVADOC TESTS END          assertEquals("bcc", StringUtils.replaceEach("abc", new String[]{"a", "b"}, new String[]{"b", "c"}));         assertEquals("q651.506bera", StringUtils.replaceEach("d216.102oren",                 new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",                         "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D",                         "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",                         "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"},                 new String[]{"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "a",                         "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "N", "O", "P", "Q",                         "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "A", "B", "C", "D", "E", "F", "G",                         "H", "I", "J", "K", "L", "M", "5", "6", "7", "8", "9", "1", "2", "3", "4"}));          // Test null safety inside arrays - LANG-552         assertEquals(StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{null}), "aba");         assertEquals(StringUtils.replaceEach("aba", new String[]{"a", "b"}, new String[]{"c", null}), "cbc");          assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.replaceEach("abba", new String[]{"a"}, new String[]{"b", "a"}),                 "StringUtils.replaceEach(String, String[], String[]) expecting IllegalArgumentException");     }      /**      * Test method for 'StringUtils.replaceEachRepeatedly(String, String[], String[])'      */     @Test     public void testReplace_StringStringArrayStringArrayBoolean() {         //JAVADOC TESTS START         assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{"a"}, new String[]{"b"}));         assertEquals("", StringUtils.replaceEachRepeatedly("", new String[]{"a"}, new String[]{"b"}));         assertEquals("aba", StringUtils.replaceEachRepeatedly("aba", null, null));         assertEquals("aba", StringUtils.replaceEachRepeatedly("aba", new String[0], null));         assertEquals("aba", StringUtils.replaceEachRepeatedly("aba", null, new String[0]));         assertEquals("aba", StringUtils.replaceEachRepeatedly("aba", new String[0], null));          assertEquals("b", StringUtils.replaceEachRepeatedly("aba", new String[]{"a"}, new String[]{""}));         assertEquals("aba", StringUtils.replaceEachRepeatedly("aba", new String[]{null}, new String[]{"a"}));         assertEquals("wcte", StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}));         assertEquals("tcte", StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}));         assertEquals("blaan", StringUtils.replaceEachRepeatedly("blllaan", new String[]{"llaan"}, new String[]{"laan"}) );          assertThrows(                 IllegalStateException.class,                 () -> StringUtils.replaceEachRepeatedly("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}),                 "Should be a circular reference");          //JAVADOC TESTS END     }      @Test     public void testReplace_StringStringString() {         assertNull(StringUtils.replace(null, null, null));         assertNull(StringUtils.replace(null, null, "any"));         assertNull(StringUtils.replace(null, "any", null));         assertNull(StringUtils.replace(null, "any", "any"));          assertEquals("", StringUtils.replace("", null, null));         assertEquals("", StringUtils.replace("", null, "any"));         assertEquals("", StringUtils.replace("", "any", null));         assertEquals("", StringUtils.replace("", "any", "any"));          assertEquals("FOO", StringUtils.replace("FOO", "", "any"));         assertEquals("FOO", StringUtils.replace("FOO", null, "any"));         assertEquals("FOO", StringUtils.replace("FOO", "F", null));         assertEquals("FOO", StringUtils.replace("FOO", null, null));          assertEquals("", StringUtils.replace("foofoofoo", "foo", ""));         assertEquals("barbarbar", StringUtils.replace("foofoofoo", "foo", "bar"));         assertEquals("farfarfar", StringUtils.replace("foofoofoo", "oo", "ar"));     }      @Test     public void testReplace_StringStringStringInt() {         assertNull(StringUtils.replace(null, null, null, 2));         assertNull(StringUtils.replace(null, null, "any", 2));         assertNull(StringUtils.replace(null, "any", null, 2));         assertNull(StringUtils.replace(null, "any", "any", 2));          assertEquals("", StringUtils.replace("", null, null, 2));         assertEquals("", StringUtils.replace("", null, "any", 2));         assertEquals("", StringUtils.replace("", "any", null, 2));         assertEquals("", StringUtils.replace("", "any", "any", 2));          final String str = new String(new char[]{'o', 'o', 'f', 'o', 'o'});         assertSame(str, StringUtils.replace(str, "x", "", -1));          assertEquals("f", StringUtils.replace("oofoo", "o", "", -1));         assertEquals("oofoo", StringUtils.replace("oofoo", "o", "", 0));         assertEquals("ofoo", StringUtils.replace("oofoo", "o", "", 1));         assertEquals("foo", StringUtils.replace("oofoo", "o", "", 2));         assertEquals("fo", StringUtils.replace("oofoo", "o", "", 3));         assertEquals("f", StringUtils.replace("oofoo", "o", "", 4));          assertEquals("f", StringUtils.replace("oofoo", "o", "", -5));         assertEquals("f", StringUtils.replace("oofoo", "o", "", 1000));     }      @Test     public void testReplaceAll_StringStringString() {         assertNull(StringUtils.replaceAll(null, "", ""));          assertEquals("any", StringUtils.replaceAll("any", null, ""));         assertEquals("any", StringUtils.replaceAll("any", "", null));          assertEquals("zzz", StringUtils.replaceAll("", "", "zzz"));         assertEquals("zzz", StringUtils.replaceAll("", ".*", "zzz"));         assertEquals("", StringUtils.replaceAll("", ".+", "zzz"));         assertEquals("ZZaZZbZZcZZ", StringUtils.replaceAll("abc", "", "ZZ"));          assertEquals("z\nz", StringUtils.replaceAll("<__>\n<__>", "<.*>", "z"));         assertEquals("z", StringUtils.replaceAll("<__>\n<__>", "(?s)<.*>", "z"));          assertEquals("ABC___123", StringUtils.replaceAll("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123", StringUtils.replaceAll("ABCabc123", "[^A-Z0-9]+", "_"));         assertEquals("ABC123", StringUtils.replaceAll("ABCabc123", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum_dolor_sit",                      StringUtils.replaceAll("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));          assertThrows(                 PatternSyntaxException.class,                 () -> StringUtils.replaceAll("any", "{badRegexSyntax}", ""),                 "StringUtils.replaceAll expecting PatternSyntaxException");     }      @Test     public void testReplaceChars_StringCharChar() {         assertNull(StringUtils.replaceChars(null, 'b', 'z'));         assertEquals("", StringUtils.replaceChars("", 'b', 'z'));         assertEquals("azcza", StringUtils.replaceChars("abcba", 'b', 'z'));         assertEquals("abcba", StringUtils.replaceChars("abcba", 'x', 'z'));     }      @Test     public void testReplaceChars_StringStringString() {         assertNull(StringUtils.replaceChars(null, null, null));         assertNull(StringUtils.replaceChars(null, "", null));         assertNull(StringUtils.replaceChars(null, "a", null));         assertNull(StringUtils.replaceChars(null, null, ""));         assertNull(StringUtils.replaceChars(null, null, "x"));          assertEquals("", StringUtils.replaceChars("", null, null));         assertEquals("", StringUtils.replaceChars("", "", null));         assertEquals("", StringUtils.replaceChars("", "a", null));         assertEquals("", StringUtils.replaceChars("", null, ""));         assertEquals("", StringUtils.replaceChars("", null, "x"));          assertEquals("abc", StringUtils.replaceChars("abc", null, null));         assertEquals("abc", StringUtils.replaceChars("abc", null, ""));         assertEquals("abc", StringUtils.replaceChars("abc", null, "x"));          assertEquals("abc", StringUtils.replaceChars("abc", "", null));         assertEquals("abc", StringUtils.replaceChars("abc", "", ""));         assertEquals("abc", StringUtils.replaceChars("abc", "", "x"));          assertEquals("ac", StringUtils.replaceChars("abc", "b", null));         assertEquals("ac", StringUtils.replaceChars("abc", "b", ""));         assertEquals("axc", StringUtils.replaceChars("abc", "b", "x"));          assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz"));         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y"));         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx"));          assertEquals("abcba", StringUtils.replaceChars("abcba", "z", "w"));         assertSame("abcba", StringUtils.replaceChars("abcba", "z", "w"));          // Javadoc examples:         assertEquals("jelly", StringUtils.replaceChars("hello", "ho", "jy"));         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yz"));         assertEquals("ayya", StringUtils.replaceChars("abcba", "bc", "y"));         assertEquals("ayzya", StringUtils.replaceChars("abcba", "bc", "yzx"));          // From https://issues.apache.org/bugzilla/show_bug.cgi?id=25454         assertEquals("bcc", StringUtils.replaceChars("abc", "ab", "bc"));         assertEquals("q651.506bera", StringUtils.replaceChars("d216.102oren",                 "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789",                 "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234"));     }      @Test     public void testReplaceFirst_StringStringString() {         assertNull(StringUtils.replaceFirst(null, "", ""));          assertEquals("any", StringUtils.replaceFirst("any", null, ""));         assertEquals("any", StringUtils.replaceFirst("any", "", null));          assertEquals("zzz", StringUtils.replaceFirst("", "", "zzz"));         assertEquals("zzz", StringUtils.replaceFirst("", ".*", "zzz"));         assertEquals("", StringUtils.replaceFirst("", ".+", "zzz"));         assertEquals("ZZabc", StringUtils.replaceFirst("abc", "", "ZZ"));          assertEquals("z\n<__>", StringUtils.replaceFirst("<__>\n<__>", "<.*>", "z"));         assertEquals("z", StringUtils.replaceFirst("<__>\n<__>", "(?s)<.*>", "z"));          assertEquals("ABC_bc123", StringUtils.replaceFirst("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123abc", StringUtils.replaceFirst("ABCabc123abc", "[^A-Z0-9]+", "_"));         assertEquals("ABC123abc", StringUtils.replaceFirst("ABCabc123abc", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum  dolor   sit",                      StringUtils.replaceFirst("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));          assertThrows(                 PatternSyntaxException.class,                 () -> StringUtils.replaceFirst("any", "{badRegexSyntax}", ""),                 "StringUtils.replaceFirst expecting PatternSyntaxException");     }      @Test     public void testReplaceIgnoreCase_StringStringString() {         assertNull(StringUtils.replaceIgnoreCase(null, null, null));         assertNull(StringUtils.replaceIgnoreCase(null, null, "any"));         assertNull(StringUtils.replaceIgnoreCase(null, "any", null));         assertNull(StringUtils.replaceIgnoreCase(null, "any", "any"));          assertEquals("", StringUtils.replaceIgnoreCase("", null, null));         assertEquals("", StringUtils.replaceIgnoreCase("", null, "any"));         assertEquals("", StringUtils.replaceIgnoreCase("", "any", null));         assertEquals("", StringUtils.replaceIgnoreCase("", "any", "any"));          assertEquals("FOO", StringUtils.replaceIgnoreCase("FOO", "", "any"));         assertEquals("FOO", StringUtils.replaceIgnoreCase("FOO", null, "any"));         assertEquals("FOO", StringUtils.replaceIgnoreCase("FOO", "F", null));         assertEquals("FOO", StringUtils.replaceIgnoreCase("FOO", null, null));          assertEquals("", StringUtils.replaceIgnoreCase("foofoofoo", "foo", ""));         assertEquals("barbarbar", StringUtils.replaceIgnoreCase("foofoofoo", "foo", "bar"));         assertEquals("farfarfar", StringUtils.replaceIgnoreCase("foofoofoo", "oo", "ar"));          // IgnoreCase         assertEquals("", StringUtils.replaceIgnoreCase("foofoofoo", "FOO", ""));         assertEquals("barbarbar", StringUtils.replaceIgnoreCase("fooFOOfoo", "foo", "bar"));         assertEquals("farfarfar", StringUtils.replaceIgnoreCase("foofOOfoo", "OO", "ar"));     }      @Test     public void testReplaceIgnoreCase_StringStringStringInt() {         assertNull(StringUtils.replaceIgnoreCase(null, null, null, 2));         assertNull(StringUtils.replaceIgnoreCase(null, null, "any", 2));         assertNull(StringUtils.replaceIgnoreCase(null, "any", null, 2));         assertNull(StringUtils.replaceIgnoreCase(null, "any", "any", 2));          assertEquals("", StringUtils.replaceIgnoreCase("", null, null, 2));         assertEquals("", StringUtils.replaceIgnoreCase("", null, "any", 2));         assertEquals("", StringUtils.replaceIgnoreCase("", "any", null, 2));         assertEquals("", StringUtils.replaceIgnoreCase("", "any", "any", 2));          final String str = new String(new char[] { 'o', 'o', 'f', 'o', 'o' });         assertSame(str, StringUtils.replaceIgnoreCase(str, "x", "", -1));          assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "o", "", -1));         assertEquals("oofoo", StringUtils.replaceIgnoreCase("oofoo", "o", "", 0));         assertEquals("ofoo", StringUtils.replaceIgnoreCase("oofoo", "o", "", 1));         assertEquals("foo", StringUtils.replaceIgnoreCase("oofoo", "o", "", 2));         assertEquals("fo", StringUtils.replaceIgnoreCase("oofoo", "o", "", 3));         assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "o", "", 4));          assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "o", "", -5));         assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "o", "", 1000));          // IgnoreCase         assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "O", "", -1));         assertEquals("oofoo", StringUtils.replaceIgnoreCase("oofoo", "O", "", 0));         assertEquals("ofoo", StringUtils.replaceIgnoreCase("oofoo", "O", "", 1));         assertEquals("foo", StringUtils.replaceIgnoreCase("oofoo", "O", "", 2));         assertEquals("fo", StringUtils.replaceIgnoreCase("oofoo", "O", "", 3));         assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "O", "", 4));          assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "O", "", -5));         assertEquals("f", StringUtils.replaceIgnoreCase("oofoo", "O", "", 1000));     }      @Test     public void testReplaceOnce_StringStringString() {         assertNull(StringUtils.replaceOnce(null, null, null));         assertNull(StringUtils.replaceOnce(null, null, "any"));         assertNull(StringUtils.replaceOnce(null, "any", null));         assertNull(StringUtils.replaceOnce(null, "any", "any"));          assertEquals("", StringUtils.replaceOnce("", null, null));         assertEquals("", StringUtils.replaceOnce("", null, "any"));         assertEquals("", StringUtils.replaceOnce("", "any", null));         assertEquals("", StringUtils.replaceOnce("", "any", "any"));          assertEquals("FOO", StringUtils.replaceOnce("FOO", "", "any"));         assertEquals("FOO", StringUtils.replaceOnce("FOO", null, "any"));         assertEquals("FOO", StringUtils.replaceOnce("FOO", "F", null));         assertEquals("FOO", StringUtils.replaceOnce("FOO", null, null));          assertEquals("foofoo", StringUtils.replaceOnce("foofoofoo", "foo", ""));     }      @Test     public void testReplaceOnceIgnoreCase_StringStringString() {         assertNull(StringUtils.replaceOnceIgnoreCase(null, null, null));         assertNull(StringUtils.replaceOnceIgnoreCase(null, null, "any"));         assertNull(StringUtils.replaceOnceIgnoreCase(null, "any", null));         assertNull(StringUtils.replaceOnceIgnoreCase(null, "any", "any"));          assertEquals("", StringUtils.replaceOnceIgnoreCase("", null, null));         assertEquals("", StringUtils.replaceOnceIgnoreCase("", null, "any"));         assertEquals("", StringUtils.replaceOnceIgnoreCase("", "any", null));         assertEquals("", StringUtils.replaceOnceIgnoreCase("", "any", "any"));          assertEquals("FOO", StringUtils.replaceOnceIgnoreCase("FOO", "", "any"));         assertEquals("FOO", StringUtils.replaceOnceIgnoreCase("FOO", null, "any"));         assertEquals("FOO", StringUtils.replaceOnceIgnoreCase("FOO", "F", null));         assertEquals("FOO", StringUtils.replaceOnceIgnoreCase("FOO", null, null));          assertEquals("foofoo", StringUtils.replaceOnceIgnoreCase("foofoofoo", "foo", ""));          // Ignore Case         assertEquals("Foofoo", StringUtils.replaceOnceIgnoreCase("FoOFoofoo", "foo", ""));     }      @Test     public void testReplacePattern_StringStringString() {         assertNull(StringUtils.replacePattern(null, "", ""));         assertEquals("any", StringUtils.replacePattern("any", null, ""));         assertEquals("any", StringUtils.replacePattern("any", "", null));          assertEquals("zzz", StringUtils.replacePattern("", "", "zzz"));         assertEquals("zzz", StringUtils.replacePattern("", ".*", "zzz"));         assertEquals("", StringUtils.replacePattern("", ".+", "zzz"));          assertEquals("z", StringUtils.replacePattern("<__>\n<__>", "<.*>", "z"));         assertEquals("z", StringUtils.replacePattern("<__>\\n<__>", "<.*>", "z"));         assertEquals("X", StringUtils.replacePattern("<A>\nxy\n</A>", "<A>.*</A>", "X"));          assertEquals("ABC___123", StringUtils.replacePattern("ABCabc123", "[a-z]", "_"));         assertEquals("ABC_123", StringUtils.replacePattern("ABCabc123", "[^A-Z0-9]+", "_"));         assertEquals("ABC123", StringUtils.replacePattern("ABCabc123", "[^A-Z0-9]+", ""));         assertEquals("Lorem_ipsum_dolor_sit",                      StringUtils.replacePattern("Lorem ipsum  dolor   sit", "( +)([a-z]+)", "_$2"));     }      //-----------------------------------------------------------------------     @Test     public void testReverse_String() {         assertNull(StringUtils.reverse(null));         assertEquals("", StringUtils.reverse(""));         assertEquals("sdrawkcab", StringUtils.reverse("backwards"));     }      @Test     public void testReverseDelimited_StringChar() {         assertNull(StringUtils.reverseDelimited(null, '.'));         assertEquals("", StringUtils.reverseDelimited("", '.'));         assertEquals("c.b.a", StringUtils.reverseDelimited("a.b.c", '.'));         assertEquals("a b c", StringUtils.reverseDelimited("a b c", '.'));         assertEquals("", StringUtils.reverseDelimited("", '.'));     }      //-----------------------------------------------------------------------     @Test     public void testRightPad_StringInt() {         assertNull(StringUtils.rightPad(null, 5));         assertEquals("     ", StringUtils.rightPad("", 5));         assertEquals("abc  ", StringUtils.rightPad("abc", 5));         assertEquals("abc", StringUtils.rightPad("abc", 2));         assertEquals("abc", StringUtils.rightPad("abc", -1));     }      @Test     public void testRightPad_StringIntChar() {         assertNull(StringUtils.rightPad(null, 5, ' '));         assertEquals("     ", StringUtils.rightPad("", 5, ' '));         assertEquals("abc  ", StringUtils.rightPad("abc", 5, ' '));         assertEquals("abc", StringUtils.rightPad("abc", 2, ' '));         assertEquals("abc", StringUtils.rightPad("abc", -1, ' '));         assertEquals("abcxx", StringUtils.rightPad("abc", 5, 'x'));         final String str = StringUtils.rightPad("aaa", 10000, 'a');  // bigger than pad length         assertEquals(10000, str.length());         assertTrue(StringUtils.containsOnly(str, 'a'));     }      @Test     public void testRightPad_StringIntString() {         assertNull(StringUtils.rightPad(null, 5, "-+"));         assertEquals("     ", StringUtils.rightPad("", 5, " "));         assertNull(StringUtils.rightPad(null, 8, null));         assertEquals("abc-+-+", StringUtils.rightPad("abc", 7, "-+"));         assertEquals("abc-+~", StringUtils.rightPad("abc", 6, "-+~"));         assertEquals("abc-+", StringUtils.rightPad("abc", 5, "-+~"));         assertEquals("abc", StringUtils.rightPad("abc", 2, " "));         assertEquals("abc", StringUtils.rightPad("abc", -1, " "));         assertEquals("abc  ", StringUtils.rightPad("abc", 5, null));         assertEquals("abc  ", StringUtils.rightPad("abc", 5, ""));     }      //-----------------------------------------------------------------------     @Test     public void testRotate_StringInt() {         assertNull(StringUtils.rotate(null, 1));         assertEquals("", StringUtils.rotate("", 1));         assertEquals("abcdefg", StringUtils.rotate("abcdefg", 0));         assertEquals("fgabcde", StringUtils.rotate("abcdefg", 2));         assertEquals("cdefgab", StringUtils.rotate("abcdefg", -2));         assertEquals("abcdefg", StringUtils.rotate("abcdefg", 7));         assertEquals("abcdefg", StringUtils.rotate("abcdefg", -7));         assertEquals("fgabcde", StringUtils.rotate("abcdefg", 9));         assertEquals("cdefgab", StringUtils.rotate("abcdefg", -9));         assertEquals("efgabcd", StringUtils.rotate("abcdefg", 17));         assertEquals("defgabc", StringUtils.rotate("abcdefg", -17));     }      @Test     public void testSplit_String() {         assertNull(StringUtils.split(null));         assertEquals(0, StringUtils.split("").length);          String str = "a b  .c";         String[] res = StringUtils.split(str);         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals(".c", res[2]);          str = " a ";         res = StringUtils.split(str);         assertEquals(1, res.length);         assertEquals("a", res[0]);          str = "a" + WHITESPACE + "b" + NON_WHITESPACE + "c";         res = StringUtils.split(str);         assertEquals(2, res.length);         assertEquals("a", res[0]);         assertEquals("b" + NON_WHITESPACE + "c", res[1]);     }      @Test     public void testSplit_StringChar() {         assertNull(StringUtils.split(null, '.'));         assertEquals(0, StringUtils.split("", '.').length);          String str = "a.b.. c";         String[] res = StringUtils.split(str, '.');         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals(" c", res[2]);          str = ".a.";         res = StringUtils.split(str, '.');         assertEquals(1, res.length);         assertEquals("a", res[0]);          str = "a b c";         res = StringUtils.split(str, ' ');         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals("c", res[2]);     }      @Test     public void testSplit_StringString_StringStringInt() {         assertNull(StringUtils.split(null, "."));         assertNull(StringUtils.split(null, ".", 3));          assertEquals(0, StringUtils.split("", ".").length);         assertEquals(0, StringUtils.split("", ".", 3).length);          innerTestSplit('.', ".", ' ');         innerTestSplit('.', ".", ',');         innerTestSplit('.', ".,", 'x');         for (int i = 0; i < WHITESPACE.length(); i++) {             for (int j = 0; j < NON_WHITESPACE.length(); j++) {                 innerTestSplit(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));                 innerTestSplit(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));             }         }          String[] results;         final String[] expectedResults = {"ab", "de fg"};         results = StringUtils.split("ab   de fg", null, 2);         assertEquals(expectedResults.length, results.length);         for (int i = 0; i < expectedResults.length; i++) {             assertEquals(expectedResults[i], results[i]);         }          final String[] expectedResults2 = {"ab", "cd:ef"};         results = StringUtils.split("ab:cd:ef", ":", 2);         assertEquals(expectedResults2.length, results.length);         for (int i = 0; i < expectedResults2.length; i++) {             assertEquals(expectedResults2[i], results[i]);         }     }      @Test     public void testSplitByCharacterType() {         assertNull(StringUtils.splitByCharacterType(null));         assertEquals(0, StringUtils.splitByCharacterType("").length);          assertTrue(Objects.deepEquals(new String[]{"ab", " ", "de", " ",                 "fg"}, StringUtils.splitByCharacterType("ab de fg")));          assertTrue(Objects.deepEquals(new String[]{"ab", "   ", "de", " ",                 "fg"}, StringUtils.splitByCharacterType("ab   de fg")));          assertTrue(Objects.deepEquals(new String[]{"ab", ":", "cd", ":",                 "ef"}, StringUtils.splitByCharacterType("ab:cd:ef")));          assertTrue(Objects.deepEquals(new String[]{"number", "5"},                 StringUtils.splitByCharacterType("number5")));          assertTrue(Objects.deepEquals(new String[]{"foo", "B", "ar"},                 StringUtils.splitByCharacterType("fooBar")));          assertTrue(Objects.deepEquals(new String[]{"foo", "200", "B", "ar"},                 StringUtils.splitByCharacterType("foo200Bar")));          assertTrue(Objects.deepEquals(new String[]{"ASFR", "ules"},                 StringUtils.splitByCharacterType("ASFRules")));     }      @Test     public void testSplitByCharacterTypeCamelCase() {         assertNull(StringUtils.splitByCharacterTypeCamelCase(null));         assertEquals(0, StringUtils.splitByCharacterTypeCamelCase("").length);          assertTrue(Objects.deepEquals(new String[]{"ab", " ", "de", " ",                 "fg"}, StringUtils.splitByCharacterTypeCamelCase("ab de fg")));          assertTrue(Objects.deepEquals(new String[]{"ab", "   ", "de", " ",                 "fg"}, StringUtils.splitByCharacterTypeCamelCase("ab   de fg")));          assertTrue(Objects.deepEquals(new String[]{"ab", ":", "cd", ":",                 "ef"}, StringUtils.splitByCharacterTypeCamelCase("ab:cd:ef")));          assertTrue(Objects.deepEquals(new String[]{"number", "5"},                 StringUtils.splitByCharacterTypeCamelCase("number5")));          assertTrue(Objects.deepEquals(new String[]{"foo", "Bar"},                 StringUtils.splitByCharacterTypeCamelCase("fooBar")));          assertTrue(Objects.deepEquals(new String[]{"foo", "200", "Bar"},                 StringUtils.splitByCharacterTypeCamelCase("foo200Bar")));          assertTrue(Objects.deepEquals(new String[]{"ASF", "Rules"},                 StringUtils.splitByCharacterTypeCamelCase("ASFRules")));     }      @Test     public void testSplitByWholeSeparatorPreserveAllTokens_StringString() {         assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, "."));          assertEquals(0, StringUtils.splitByWholeSeparatorPreserveAllTokens("", ".").length);          // test whitespace         String input = "ab   de fg";         String[] expected = new String[]{"ab", "", "", "de", "fg"};          String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, null);         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }          // test delimiter singlechar         input = "1::2:::3::::4";         expected = new String[]{"1", "", "2", "", "", "3", "", "", "", "4"};          actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, ":");         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }          // test delimiter multichar         input = "1::2:::3::::4";         expected = new String[]{"1", "2", ":3", "", "4"};          actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, "::");         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }     }      @Test     public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() {         assertArrayEquals(null, StringUtils.splitByWholeSeparatorPreserveAllTokens(null, ".", -1));          assertEquals(0, StringUtils.splitByWholeSeparatorPreserveAllTokens("", ".", -1).length);          // test whitespace         String input = "ab   de fg";         String[] expected = new String[]{"ab", "", "", "de", "fg"};          String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, null, -1);         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }          // test delimiter singlechar         input = "1::2:::3::::4";         expected = new String[]{"1", "", "2", "", "", "3", "", "", "", "4"};          actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, ":", -1);         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }          // test delimiter multichar         input = "1::2:::3::::4";         expected = new String[]{"1", "2", ":3", "", "4"};          actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, "::", -1);         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }          // test delimiter char with max         input = "1::2::3:4";         expected = new String[]{"1", "", "2", ":3:4"};          actual = StringUtils.splitByWholeSeparatorPreserveAllTokens(input, ":", 4);         assertEquals(expected.length, actual.length);         for (int i = 0; i < actual.length; i += 1) {             assertEquals(expected[i], actual[i]);         }     }      @Test     public void testSplitByWholeString_StringStringBoolean() {         assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, "."));          assertEquals(0, StringUtils.splitByWholeSeparator("", ".").length);          final String stringToSplitOnNulls = "ab   de fg";         final String[] splitOnNullExpectedResults = {"ab", "de", "fg"};          final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null);         assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length);         for (int i = 0; i < splitOnNullExpectedResults.length; i += 1) {             assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]);         }          final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiously";          final String[] splitOnStringExpectedResults = {"abstemiously", "abstemiously"};         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy");         assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length);         for (int i = 0; i < splitOnStringExpectedResults.length; i += 1) {             assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]);         }          final String[] splitWithMultipleSeparatorExpectedResults = {"ab", "cd", "ef"};         final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator("ab:cd::ef", ":");         assertEquals(splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length);         for (int i = 0; i < splitWithMultipleSeparatorExpectedResults.length; i++) {             assertEquals(splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i]);         }     }      @Test     public void testSplitByWholeString_StringStringBooleanInt() {         assertArrayEquals(null, StringUtils.splitByWholeSeparator(null, ".", 3));          assertEquals(0, StringUtils.splitByWholeSeparator("", ".", 3).length);          final String stringToSplitOnNulls = "ab   de fg";         final String[] splitOnNullExpectedResults = {"ab", "de fg"};         //String[] splitOnNullExpectedResults = { "ab", "de" } ;          final String[] splitOnNullResults = StringUtils.splitByWholeSeparator(stringToSplitOnNulls, null, 2);         assertEquals(splitOnNullExpectedResults.length, splitOnNullResults.length);         for (int i = 0; i < splitOnNullExpectedResults.length; i += 1) {             assertEquals(splitOnNullExpectedResults[i], splitOnNullResults[i]);         }          final String stringToSplitOnCharactersAndString = "abstemiouslyaeiouyabstemiouslyaeiouyabstemiously";          final String[] splitOnStringExpectedResults = {"abstemiously", "abstemiouslyaeiouyabstemiously"};         //String[] splitOnStringExpectedResults = { "abstemiously", "abstemiously" } ;         final String[] splitOnStringResults = StringUtils.splitByWholeSeparator(stringToSplitOnCharactersAndString, "aeiouy", 2);         assertEquals(splitOnStringExpectedResults.length, splitOnStringResults.length);         for (int i = 0; i < splitOnStringExpectedResults.length; i++) {             assertEquals(splitOnStringExpectedResults[i], splitOnStringResults[i]);         }     }      @Test     public void testSplitPreserveAllTokens_String() {         assertNull(StringUtils.splitPreserveAllTokens(null));         assertEquals(0, StringUtils.splitPreserveAllTokens("").length);          String str = "abc def";         String[] res = StringUtils.splitPreserveAllTokens(str);         assertEquals(2, res.length);         assertEquals("abc", res[0]);         assertEquals("def", res[1]);          str = "abc  def";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(3, res.length);         assertEquals("abc", res[0]);         assertEquals("", res[1]);         assertEquals("def", res[2]);          str = " abc ";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(3, res.length);         assertEquals("", res[0]);         assertEquals("abc", res[1]);         assertEquals("", res[2]);          str = "a b .c";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals(".c", res[2]);          str = " a b .c";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("b", res[2]);         assertEquals(".c", res[3]);          str = "a  b  .c";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(5, res.length);         assertEquals("a", res[0]);         assertEquals("", res[1]);         assertEquals("b", res[2]);         assertEquals("", res[3]);         assertEquals(".c", res[4]);          str = " a  ";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("", res[2]);         assertEquals("", res[3]);          str = " a  b";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("", res[2]);         assertEquals("b", res[3]);          str = "a" + WHITESPACE + "b" + NON_WHITESPACE + "c";         res = StringUtils.splitPreserveAllTokens(str);         assertEquals(WHITESPACE.length() + 1, res.length);         assertEquals("a", res[0]);         for (int i = 1; i < WHITESPACE.length() - 1; i++) {             assertEquals("", res[i]);         }         assertEquals("b" + NON_WHITESPACE + "c", res[WHITESPACE.length()]);     }      @Test     public void testSplitPreserveAllTokens_StringChar() {         assertNull(StringUtils.splitPreserveAllTokens(null, '.'));         assertEquals(0, StringUtils.splitPreserveAllTokens("", '.').length);          String str = "a.b. c";         String[] res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals(" c", res[2]);          str = "a.b.. c";         res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(4, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals("", res[2]);         assertEquals(" c", res[3]);          str = ".a.";         res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(3, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("", res[2]);          str = ".a..";         res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("", res[2]);         assertEquals("", res[3]);          str = "..a.";         res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("", res[1]);         assertEquals("a", res[2]);         assertEquals("", res[3]);          str = "..a";         res = StringUtils.splitPreserveAllTokens(str, '.');         assertEquals(3, res.length);         assertEquals("", res[0]);         assertEquals("", res[1]);         assertEquals("a", res[2]);          str = "a b c";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(3, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals("c", res[2]);          str = "a  b  c";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(5, res.length);         assertEquals("a", res[0]);         assertEquals("", res[1]);         assertEquals("b", res[2]);         assertEquals("", res[3]);         assertEquals("c", res[4]);          str = " a b c";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(4, res.length);         assertEquals("", res[0]);         assertEquals("a", res[1]);         assertEquals("b", res[2]);         assertEquals("c", res[3]);          str = "  a b c";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(5, res.length);         assertEquals("", res[0]);         assertEquals("", res[1]);         assertEquals("a", res[2]);         assertEquals("b", res[3]);         assertEquals("c", res[4]);          str = "a b c ";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(4, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals("c", res[2]);         assertEquals("", res[3]);          str = "a b c  ";         res = StringUtils.splitPreserveAllTokens(str, ' ');         assertEquals(5, res.length);         assertEquals("a", res[0]);         assertEquals("b", res[1]);         assertEquals("c", res[2]);         assertEquals("", res[3]);         assertEquals("", res[3]);          // Match example in javadoc         {             String[] results;             final String[] expectedResults = {"a", "", "b", "c"};             results = StringUtils.splitPreserveAllTokens("a..b.c", '.');             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }     }      @Test     public void testSplitPreserveAllTokens_StringString_StringStringInt() {         assertNull(StringUtils.splitPreserveAllTokens(null, "."));         assertNull(StringUtils.splitPreserveAllTokens(null, ".", 3));          assertEquals(0, StringUtils.splitPreserveAllTokens("", ".").length);         assertEquals(0, StringUtils.splitPreserveAllTokens("", ".", 3).length);          innerTestSplitPreserveAllTokens('.', ".", ' ');         innerTestSplitPreserveAllTokens('.', ".", ',');         innerTestSplitPreserveAllTokens('.', ".,", 'x');         for (int i = 0; i < WHITESPACE.length(); i++) {             for (int j = 0; j < NON_WHITESPACE.length(); j++) {                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));                 innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));             }         }          {             String[] results;             final String[] expectedResults = {"ab", "de fg"};             results = StringUtils.splitPreserveAllTokens("ab de fg", null, 2);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "  de fg"};             results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 2);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "::de:fg"};             results = StringUtils.splitPreserveAllTokens("ab:::de:fg", ":", 2);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "", " de fg"};             results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 3);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "", "", "de fg"};             results = StringUtils.splitPreserveAllTokens("ab   de fg", null, 4);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             final String[] expectedResults = {"ab", "cd:ef"};             String[] results;             results = StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 2);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", ":cd:ef"};             results = StringUtils.splitPreserveAllTokens("ab::cd:ef", ":", 2);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "", ":cd:ef"};             results = StringUtils.splitPreserveAllTokens("ab:::cd:ef", ":", 3);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"ab", "", "", "cd:ef"};             results = StringUtils.splitPreserveAllTokens("ab:::cd:ef", ":", 4);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"", "ab", "", "", "cd:ef"};             results = StringUtils.splitPreserveAllTokens(":ab:::cd:ef", ":", 5);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }          {             String[] results;             final String[] expectedResults = {"", "", "ab", "", "", "cd:ef"};             results = StringUtils.splitPreserveAllTokens("::ab:::cd:ef", ":", 6);             assertEquals(expectedResults.length, results.length);             for (int i = 0; i < expectedResults.length; i++) {                 assertEquals(expectedResults[i], results[i]);             }         }      }      // Methods on StringUtils that are immutable in spirit (i.e. calculate the length)     // should take a CharSequence parameter. Methods that are mutable in spirit (i.e. capitalize)     // should take a String or String[] parameter and return String or String[].     // This test enforces that this is done.     @Test     public void testStringUtilsCharSequenceContract() {         final Class<StringUtils> c = StringUtils.class;         // Methods that are expressly excluded from testStringUtilsCharSequenceContract()         final String[] excludeMethods = {             "public static int org.apache.commons.lang3.StringUtils.compare(java.lang.String,java.lang.String)",             "public static int org.apache.commons.lang3.StringUtils.compare(java.lang.String,java.lang.String,boolean)",             "public static int org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String,java.lang.String)",             "public static int org.apache.commons.lang3.StringUtils.compareIgnoreCase(java.lang.String,java.lang.String,boolean)",             "public static byte[] org.apache.commons.lang3.StringUtils.getBytes(java.lang.String,java.nio.charset.Charset)",             "public static byte[] org.apache.commons.lang3.StringUtils.getBytes(java.lang.String,java.lang.String) throws java.io.UnsupportedEncodingException"         };         final Method[] methods = c.getMethods();          for (final Method m : methods) {             final String methodStr = m.toString();             if (m.getReturnType() == String.class || m.getReturnType() == String[].class) {                 // Assume this is mutable and ensure the first parameter is not CharSequence.                 // It may be String or it may be something else (String[], Object, Object[]) so                 // don't actively test for that.                 final Class<?>[] params = m.getParameterTypes();                 if (params.length > 0 && (params[0] == CharSequence.class || params[0] == CharSequence[].class)) {                     assertTrue(!ArrayUtils.contains(excludeMethods, methodStr),                             "The method \"" + methodStr + "\" appears to be mutable in spirit and therefore must not accept a CharSequence");                 }             } else {                 // Assume this is immutable in spirit and ensure the first parameter is not String.                 // As above, it may be something other than CharSequence.                 final Class<?>[] params = m.getParameterTypes();                 if (params.length > 0 && (params[0] == String.class || params[0] == String[].class)) {                     assertTrue(ArrayUtils.contains(excludeMethods, methodStr),                             "The method \"" + methodStr + "\" appears to be immutable in spirit and therefore must not accept a String");                 }             }         }     }      @Test     public void testSwapCase_String() {         assertNull(StringUtils.swapCase(null));         assertEquals("", StringUtils.swapCase(""));         assertEquals("  ", StringUtils.swapCase("  "));          assertEquals("i", WordUtils.swapCase("I"));         assertEquals("I", WordUtils.swapCase("i"));         assertEquals("I AM HERE 123", StringUtils.swapCase("i am here 123"));         assertEquals("i aM hERE 123", StringUtils.swapCase("I Am Here 123"));         assertEquals("I AM here 123", StringUtils.swapCase("i am HERE 123"));         assertEquals("i am here 123", StringUtils.swapCase("I AM HERE 123"));          final String test = "This String contains a TitleCase character: \u01C8";         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9";         assertEquals(expect, WordUtils.swapCase(test));         assertEquals(expect, StringUtils.swapCase(test));     }      @Test     public void testToCodePoints() {         final int orphanedHighSurrogate = 0xD801;         final int orphanedLowSurrogate = 0xDC00;         final int supplementary = 0x2070E;          final int[] codePoints = {'a', orphanedHighSurrogate, 'b', 'c', supplementary,                 'd', orphanedLowSurrogate, 'e'};         final String s = new String(codePoints, 0, codePoints.length);         assertArrayEquals(codePoints, StringUtils.toCodePoints(s));          assertNull(StringUtils.toCodePoints(null));         assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, StringUtils.toCodePoints(""));     }      /**      * Tests {@link StringUtils#toEncodedString(byte[], Charset)}      *      * @see StringUtils#toEncodedString(byte[], Charset)      */     @Test     public void testToEncodedString() {         final String expectedString = "The quick brown fox jumps over the lazy dog.";         String encoding = SystemUtils.FILE_ENCODING;         byte[] expectedBytes = expectedString.getBytes(Charset.defaultCharset());         // sanity check start         assertArrayEquals(expectedBytes, expectedString.getBytes());         // sanity check end         assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.defaultCharset()));         assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.forName(encoding)));         encoding = "UTF-16";         expectedBytes = expectedString.getBytes(Charset.forName(encoding));         assertEquals(expectedString, StringUtils.toEncodedString(expectedBytes, Charset.forName(encoding)));     }      /**      * Tests {@link StringUtils#toString(byte[], String)}      *      * @throws java.io.UnsupportedEncodingException because the method under test max throw it      * @see StringUtils#toString(byte[], String)      */     @Test     public void testToString() throws UnsupportedEncodingException {         final String expectedString = "The quick brown fox jumps over the lazy dog.";         byte[] expectedBytes = expectedString.getBytes(Charset.defaultCharset());         // sanity check start         assertArrayEquals(expectedBytes, expectedString.getBytes());         // sanity check end         assertEquals(expectedString, StringUtils.toString(expectedBytes, null));         assertEquals(expectedString, StringUtils.toString(expectedBytes, SystemUtils.FILE_ENCODING));         final String encoding = "UTF-16";         expectedBytes = expectedString.getBytes(Charset.forName(encoding));         assertEquals(expectedString, StringUtils.toString(expectedBytes, encoding));     }      //-----------------------------------------------------------------------     @Test     public void testTruncate_StringInt() {         assertNull(StringUtils.truncate(null, 12));         assertThrows(                 IllegalArgumentException.class, () -> StringUtils.truncate(null, -1), "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class, () -> StringUtils.truncate(null, -10), "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate(null, Integer.MIN_VALUE),                 "maxWith cannot be negative");         assertEquals("", StringUtils.truncate("", 10));         assertEquals("", StringUtils.truncate("", 10));         assertEquals("abc", StringUtils.truncate("abcdefghij", 3));         assertEquals("abcdef", StringUtils.truncate("abcdefghij", 6));         assertEquals("", StringUtils.truncate("abcdefghij", 0));         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -1),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -100),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", Integer.MIN_VALUE),                 "maxWith cannot be negative");         assertEquals("abcdefghij", StringUtils.truncate("abcdefghijklmno", 10));         assertEquals("abcdefghijklmno", StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE));         assertEquals("abcde", StringUtils.truncate("abcdefghijklmno", 5));         assertEquals("abc", StringUtils.truncate("abcdefghijklmno", 3));     }      @Test     public void testTruncate_StringIntInt() {         assertNull(StringUtils.truncate(null, 0, 12));         assertThrows(                 IllegalArgumentException.class, () -> StringUtils.truncate(null, -1, 0), "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate(null, -10, -4),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate(null, Integer.MIN_VALUE, Integer.MIN_VALUE),                 "offset cannot be negative");         assertNull(StringUtils.truncate(null, 10, 12));         assertEquals("", StringUtils.truncate("", 0, 10));         assertEquals("", StringUtils.truncate("", 2, 10));         assertEquals("abc", StringUtils.truncate("abcdefghij", 0, 3));         assertEquals("fghij", StringUtils.truncate("abcdefghij", 5, 6));         assertEquals("", StringUtils.truncate("abcdefghij", 0, 0));         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", 0, -1),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", 0, -10),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", 0, -100),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", 1, -100),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", 0, Integer.MIN_VALUE),                 "maxWith cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -1, 0),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -10, 0),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -100, 1),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", Integer.MIN_VALUE, 0),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -1, -1),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -10, -10),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", -100, -100),                 "offset cannot be negative");         assertThrows(                 IllegalArgumentException.class,                 () -> StringUtils.truncate("abcdefghij", Integer.MIN_VALUE, Integer.MIN_VALUE),                 "offset cannot be negative");         final String raspberry = "raspberry peach";         assertEquals("peach", StringUtils.truncate(raspberry, 10, 15));         assertEquals("abcdefghij", StringUtils.truncate("abcdefghijklmno", 0, 10));         assertEquals("abcdefghijklmno", StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE));         assertEquals("bcdefghijk", StringUtils.truncate("abcdefghijklmno", 1, 10));         assertEquals("cdefghijkl", StringUtils.truncate("abcdefghijklmno", 2, 10));         assertEquals("defghijklm", StringUtils.truncate("abcdefghijklmno", 3, 10));         assertEquals("efghijklmn", StringUtils.truncate("abcdefghijklmno", 4, 10));         assertEquals("fghijklmno", StringUtils.truncate("abcdefghijklmno", 5, 10));         assertEquals("fghij", StringUtils.truncate("abcdefghijklmno", 5, 5));         assertEquals("fgh", StringUtils.truncate("abcdefghijklmno", 5, 3));         assertEquals("klm", StringUtils.truncate("abcdefghijklmno", 10, 3));         assertEquals("klmno", StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE));         assertEquals("n", StringUtils.truncate("abcdefghijklmno", 13, 1));         assertEquals("no", StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE));         assertEquals("o", StringUtils.truncate("abcdefghijklmno", 14, 1));         assertEquals("o", StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE));         assertEquals("", StringUtils.truncate("abcdefghijklmno", 15, 1));         assertEquals("", StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE));         assertEquals("", StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE));     }      // -----------------------------------------------------------------------      @Test     public void testUnCapitalize() {         assertNull(StringUtils.uncapitalize(null));          assertEquals(FOO_UNCAP, StringUtils.uncapitalize(FOO_CAP), "uncapitalize(String) failed");         assertEquals(FOO_UNCAP, StringUtils.uncapitalize(FOO_UNCAP), "uncapitalize(string) failed");         assertEquals("", StringUtils.uncapitalize(""), "uncapitalize(empty-string) failed");         assertEquals("x", StringUtils.uncapitalize("X"), "uncapitalize(single-char-string) failed");          // Examples from uncapitalize Javadoc         assertEquals("cat", StringUtils.uncapitalize("cat"));         assertEquals("cat", StringUtils.uncapitalize("Cat"));         assertEquals("cAT", StringUtils.uncapitalize("CAT"));     }      @Test     public void testUnescapeSurrogatePairs() {         assertEquals("\uD83D\uDE30", StringEscapeUtils.unescapeCsv("\uD83D\uDE30"));         // Examples from https://en.wikipedia.org/wiki/UTF-16         assertEquals("\uD800\uDC00", StringEscapeUtils.unescapeCsv("\uD800\uDC00"));         assertEquals("\uD834\uDD1E", StringEscapeUtils.unescapeCsv("\uD834\uDD1E"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeCsv("\uDBFF\uDFFD"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeHtml3("\uDBFF\uDFFD"));         assertEquals("\uDBFF\uDFFD", StringEscapeUtils.unescapeHtml4("\uDBFF\uDFFD"));     }      @Test     public void testUnwrap_StringChar() {         assertNull(StringUtils.unwrap(null, null));         assertNull(StringUtils.unwrap(null, CharUtils.NUL));         assertNull(StringUtils.unwrap(null, '1'));          assertEquals("abc", StringUtils.unwrap("abc", null));         assertEquals("a", StringUtils.unwrap("a", "a"));         assertEquals("", StringUtils.unwrap("aa", "a"));         assertEquals("abc", StringUtils.unwrap("\'abc\'", '\''));         assertEquals("abc", StringUtils.unwrap("AabcA", 'A'));         assertEquals("AabcA", StringUtils.unwrap("AAabcAA", 'A'));         assertEquals("abc", StringUtils.unwrap("abc", 'b'));         assertEquals("#A", StringUtils.unwrap("#A", '#'));         assertEquals("A#", StringUtils.unwrap("A#", '#'));         assertEquals("ABA", StringUtils.unwrap("AABAA", 'A'));     }      @Test     public void testUnwrap_StringString() {         assertNull(StringUtils.unwrap(null, null));         assertNull(StringUtils.unwrap(null, ""));         assertNull(StringUtils.unwrap(null, "1"));          assertEquals("abc", StringUtils.unwrap("abc", null));         assertEquals("abc", StringUtils.unwrap("abc", ""));         assertEquals("a", StringUtils.unwrap("a", "a"));         assertEquals("", StringUtils.unwrap("aa", "a"));         assertEquals("abc", StringUtils.unwrap("\'abc\'", "\'"));         assertEquals("abc", StringUtils.unwrap("\"abc\"", "\""));         assertEquals("abc\"xyz", StringUtils.unwrap("\"abc\"xyz\"", "\""));         assertEquals("abc\"xyz\"", StringUtils.unwrap("\"abc\"xyz\"\"", "\""));         assertEquals("abc\'xyz\'", StringUtils.unwrap("\"abc\'xyz\'\"", "\""));         assertEquals("\"abc\'xyz\'\"", StringUtils.unwrap("AA\"abc\'xyz\'\"AA", "AA"));         assertEquals("\"abc\'xyz\'\"", StringUtils.unwrap("123\"abc\'xyz\'\"123", "123"));         assertEquals("AA\"abc\'xyz\'\"", StringUtils.unwrap("AA\"abc\'xyz\'\"", "AA"));         assertEquals("AA\"abc\'xyz\'\"AA", StringUtils.unwrap("AAA\"abc\'xyz\'\"AAA", "A"));         assertEquals("\"abc\'xyz\'\"AA", StringUtils.unwrap("\"abc\'xyz\'\"AA", "AA"));     }      @Test     public void testUpperCase() {         assertNull(StringUtils.upperCase(null));         assertNull(StringUtils.upperCase(null, Locale.ENGLISH));         assertEquals("FOO TEST THING", StringUtils.upperCase("fOo test THING"), "upperCase(String) failed");         assertEquals("", StringUtils.upperCase(""), "upperCase(empty-string) failed");         assertEquals("FOO TEST THING", StringUtils.upperCase("fOo test THING", Locale.ENGLISH),                 "upperCase(String, Locale) failed");         assertEquals("", StringUtils.upperCase("", Locale.ENGLISH),                 "upperCase(empty-string, Locale) failed");     }      @Test     public void testWrap_StringChar() {         assertNull(StringUtils.wrap(null, CharUtils.NUL));         assertNull(StringUtils.wrap(null, '1'));          assertEquals("", StringUtils.wrap("", CharUtils.NUL));         assertEquals("xabx", StringUtils.wrap("ab", 'x'));         assertEquals("\"ab\"", StringUtils.wrap("ab", '\"'));         assertEquals("\"\"ab\"\"", StringUtils.wrap("\"ab\"", '\"'));         assertEquals("'ab'", StringUtils.wrap("ab", '\''));         assertEquals("''abcd''", StringUtils.wrap("'abcd'", '\''));         assertEquals("'\"abcd\"'", StringUtils.wrap("\"abcd\"", '\''));         assertEquals("\"'abcd'\"", StringUtils.wrap("'abcd'", '\"'));     }      @Test     public void testWrap_StringString() {         assertNull(StringUtils.wrap(null, null));         assertNull(StringUtils.wrap(null, ""));         assertNull(StringUtils.wrap(null, "1"));          assertNull(StringUtils.wrap(null, null));         assertEquals("", StringUtils.wrap("", ""));         assertEquals("ab", StringUtils.wrap("ab", null));         assertEquals("xabx", StringUtils.wrap("ab", "x"));         assertEquals("\"ab\"", StringUtils.wrap("ab", "\""));         assertEquals("\"\"ab\"\"", StringUtils.wrap("\"ab\"", "\""));         assertEquals("'ab'", StringUtils.wrap("ab", "'"));         assertEquals("''abcd''", StringUtils.wrap("'abcd'", "'"));         assertEquals("'\"abcd\"'", StringUtils.wrap("\"abcd\"", "'"));         assertEquals("\"'abcd'\"", StringUtils.wrap("'abcd'", "\""));     }      @Test     public void testWrapIfMissing_StringChar() {         assertNull(StringUtils.wrapIfMissing(null, CharUtils.NUL));         assertNull(StringUtils.wrapIfMissing(null, '1'));          assertEquals("", StringUtils.wrapIfMissing("", CharUtils.NUL));         assertEquals("xabx", StringUtils.wrapIfMissing("ab", 'x'));         assertEquals("\"ab\"", StringUtils.wrapIfMissing("ab", '\"'));         assertEquals("\"ab\"", StringUtils.wrapIfMissing("\"ab\"", '\"'));         assertEquals("'ab'", StringUtils.wrapIfMissing("ab", '\''));         assertEquals("'abcd'", StringUtils.wrapIfMissing("'abcd'", '\''));         assertEquals("'\"abcd\"'", StringUtils.wrapIfMissing("\"abcd\"", '\''));         assertEquals("\"'abcd'\"", StringUtils.wrapIfMissing("'abcd'", '\"'));         assertEquals("/x/", StringUtils.wrapIfMissing("x", '/'));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("x/y/z", '/'));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("/x/y/z", '/'));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("x/y/z/", '/'));          assertSame("/", StringUtils.wrapIfMissing("/", '/'));         assertSame("/x/", StringUtils.wrapIfMissing("/x/", '/'));     }      @Test     public void testWrapIfMissing_StringString() {         assertNull(StringUtils.wrapIfMissing(null, "\0"));         assertNull(StringUtils.wrapIfMissing(null, "1"));          assertEquals("", StringUtils.wrapIfMissing("", "\0"));         assertEquals("xabx", StringUtils.wrapIfMissing("ab", "x"));         assertEquals("\"ab\"", StringUtils.wrapIfMissing("ab", "\""));         assertEquals("\"ab\"", StringUtils.wrapIfMissing("\"ab\"", "\""));         assertEquals("'ab'", StringUtils.wrapIfMissing("ab", "\'"));         assertEquals("'abcd'", StringUtils.wrapIfMissing("'abcd'", "\'"));         assertEquals("'\"abcd\"'", StringUtils.wrapIfMissing("\"abcd\"", "\'"));         assertEquals("\"'abcd'\"", StringUtils.wrapIfMissing("'abcd'", "\""));         assertEquals("/x/", StringUtils.wrapIfMissing("x", "/"));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("x/y/z", "/"));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("/x/y/z", "/"));         assertEquals("/x/y/z/", StringUtils.wrapIfMissing("x/y/z/", "/"));         assertEquals("/", StringUtils.wrapIfMissing("/", "/"));         assertEquals("ab/ab", StringUtils.wrapIfMissing("/", "ab"));          assertSame("ab/ab", StringUtils.wrapIfMissing("ab/ab", "ab"));         assertSame("//x//", StringUtils.wrapIfMissing("//x//", "//"));     }      @Test     public void testToRootLowerCase() {         assertEquals(null, StringUtils.toRootLowerCase(null));         assertEquals("a", StringUtils.toRootLowerCase("A"));         assertEquals("a", StringUtils.toRootLowerCase("a"));         final Locale TURKISH = Locale.forLanguageTag("tr");         // Sanity checks:         assertNotEquals("title", "TITLE".toLowerCase(TURKISH));         assertEquals("title", "TITLE".toLowerCase(Locale.ROOT));         assertEquals("title", StringUtils.toRootLowerCase("TITLE"));         // Make sure we are not using the default Locale:         final Locale defaultLocale = Locale.getDefault();         try {             Locale.setDefault(TURKISH);             assertEquals("title", StringUtils.toRootLowerCase("TITLE"));         } finally {             Locale.setDefault(defaultLocale);         }     }      @Test     public void testToRootUpperCase() {         assertEquals(null, StringUtils.toRootUpperCase(null));         assertEquals("A", StringUtils.toRootUpperCase("a"));         assertEquals("A", StringUtils.toRootUpperCase("A"));         final Locale TURKISH = Locale.forLanguageTag("tr");         // Sanity checks:         assertNotEquals("TITLE", "title".toUpperCase(TURKISH));         assertEquals("TITLE", "title".toUpperCase(Locale.ROOT));         assertEquals("TITLE", StringUtils.toRootUpperCase("title"));         // Make sure we are not using the default Locale:         final Locale defaultLocale = Locale.getDefault();         try {             Locale.setDefault(TURKISH);             assertEquals("TITLE", StringUtils.toRootUpperCase("title"));         } finally {             Locale.setDefault(defaultLocale);         }     }      @Test     public void testGeorgianSample() {         final char[] arrayI = new char[]{                 //Latin Small Letter dotless I                 (char) 0x0131,                 //Greek Capital Letter Theta                 (char) 0x03F4         };         final char[] arrayJ = new char[]{                 //Latin Capital Letter I with dot above                 (char) 0x0130,                 //Greek Theta Symbol                 (char) 0x03D1         };         for (final char i : arrayI) {             for (final char j : arrayJ) {                 final String si = String.valueOf(i);                 final String sj = String.valueOf(j);                 final boolean res1 = si.equalsIgnoreCase(sj);                 final CharSequence ci = new StringBuilder(si);                 final CharSequence cj = new StringBuilder(sj);                 boolean res2 = StringUtils.startsWithIgnoreCase(ci, cj);                 assertEquals(res1, res2, "si : " + si + " sj : " + sj);                 res2 = StringUtils.endsWithIgnoreCase(ci, cj);                 assertEquals(res1, res2, "si : " + si + " sj : " + sj);                 res2 = StringUtils.compareIgnoreCase(ci.toString(), cj.toString()) == 0;                 assertEquals(res1, res2, "si : " + si + " sj : " + sj);                 res2 = StringUtils.indexOfIgnoreCase(ci.toString(), cj.toString()) == 0;                 assertEquals(res1, res2, "si : " + si + " sj : " + sj);                 res2 = StringUtils.lastIndexOfIgnoreCase(ci.toString(), cj.toString()) == 0;                 assertEquals(res1, res2, "si : " + si + " sj : " + sj);             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.event;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.beans.PropertyChangeEvent; import java.beans.PropertyVetoException; import java.beans.VetoableChangeListener; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Date; import java.util.List;  import org.easymock.EasyMock; import org.junit.jupiter.api.Test;  /**  * @since 3.0  */ public class EventListenerSupportTest {      @Test     public void testAddListenerNoDuplicates() {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);          final VetoableChangeListener[] listeners = listenerSupport.getListeners();         assertEquals(0, listeners.length);         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType());         final VetoableChangeListener[] empty = listeners;         //for fun, show that the same empty instance is used         assertSame(empty, listenerSupport.getListeners());          final VetoableChangeListener listener1 = EasyMock.createNiceMock(VetoableChangeListener.class);         listenerSupport.addListener(listener1);         assertEquals(1, listenerSupport.getListeners().length);         listenerSupport.addListener(listener1, false);         assertEquals(1, listenerSupport.getListeners().length);         listenerSupport.removeListener(listener1);         assertSame(empty, listenerSupport.getListeners());     }      @Test     public void testAddNullListener() {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);         assertThrows(NullPointerException.class, () -> listenerSupport.addListener(null));     }      @Test     public void testRemoveNullListener() {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);         assertThrows(NullPointerException.class, () -> listenerSupport.removeListener(null));     }      @Test     public void testEventDispatchOrder() throws PropertyVetoException {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);         final List<VetoableChangeListener> calledListeners = new ArrayList<>();          final VetoableChangeListener listener1 = createListener(calledListeners);         final VetoableChangeListener listener2 = createListener(calledListeners);         listenerSupport.addListener(listener1);         listenerSupport.addListener(listener2);         listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5));         assertEquals(calledListeners.size(), 2);         assertSame(calledListeners.get(0), listener1);         assertSame(calledListeners.get(1), listener2);     }      @Test     public void testCreateWithNonInterfaceParameter() {         assertThrows(IllegalArgumentException.class, () -> EventListenerSupport.create(String.class));     }      @Test     public void testCreateWithNullParameter() {         assertThrows(NullPointerException.class, () -> EventListenerSupport.create(null));     }      @Test     public void testRemoveListenerDuringEvent() throws PropertyVetoException {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);         for (int i = 0; i < 10; ++i) {             addDeregisterListener(listenerSupport);         }         assertEquals(listenerSupport.getListenerCount(), 10);         listenerSupport.fire().vetoableChange(new PropertyChangeEvent(new Date(), "Day", 4, 5));         assertEquals(listenerSupport.getListenerCount(), 0);     }      @Test     public void testGetListeners() {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);          final VetoableChangeListener[] listeners = listenerSupport.getListeners();         assertEquals(0, listeners.length);         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType());         final VetoableChangeListener[] empty = listeners;         //for fun, show that the same empty instance is used         assertSame(empty, listenerSupport.getListeners());          final VetoableChangeListener listener1 = EasyMock.createNiceMock(VetoableChangeListener.class);         listenerSupport.addListener(listener1);         assertEquals(1, listenerSupport.getListeners().length);         final VetoableChangeListener listener2 = EasyMock.createNiceMock(VetoableChangeListener.class);         listenerSupport.addListener(listener2);         assertEquals(2, listenerSupport.getListeners().length);         listenerSupport.removeListener(listener1);         assertEquals(1, listenerSupport.getListeners().length);         listenerSupport.removeListener(listener2);         assertSame(empty, listenerSupport.getListeners());     }      @Test     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException {         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);         listenerSupport.addListener(e -> {         });         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class));          //serialize:         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();         final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);          objectOutputStream.writeObject(listenerSupport);         objectOutputStream.close();          //deserialize:         @SuppressWarnings("unchecked")         final         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(                 new ByteArrayInputStream(outputStream.toByteArray())).readObject();          //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock         final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners();         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType());         assertEquals(1, listeners.length);          //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted         final VetoableChangeListener listener = listeners[0];         final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), "Day", 7, 9);         listener.vetoableChange(evt);         EasyMock.replay(listener);         deserializedListenerSupport.fire().vetoableChange(evt);         EasyMock.verify(listener);          //remove listener and verify we get an empty array of listeners         deserializedListenerSupport.removeListener(listener);         assertEquals(0, deserializedListenerSupport.getListeners().length);     }      @Test     public void testSubclassInvocationHandling() throws PropertyVetoException {          final         EventListenerSupport<VetoableChangeListener> eventListenerSupport = new EventListenerSupport<VetoableChangeListener>(                 VetoableChangeListener.class) {             private static final long serialVersionUID = 1L;              @Override             protected java.lang.reflect.InvocationHandler createInvocationHandler() {                 return new ProxyInvocationHandler() {                     /**                      * {@inheritDoc}                      */                     @Override                     public Object invoke(final Object proxy, final Method method, final Object[] args)                             throws Throwable {                         return "vetoableChange".equals(method.getName())                                 && "Hour".equals(((PropertyChangeEvent) args[0]).getPropertyName()) ? null                                 : super.invoke(proxy, method, args);                     }                 };             }         };          final VetoableChangeListener listener = EasyMock.createNiceMock(VetoableChangeListener.class);         eventListenerSupport.addListener(listener);         final Object source = new Date();         final PropertyChangeEvent ignore = new PropertyChangeEvent(source, "Hour", 5, 6);         final PropertyChangeEvent respond = new PropertyChangeEvent(source, "Day", 6, 7);         listener.vetoableChange(respond);         EasyMock.replay(listener);         eventListenerSupport.fire().vetoableChange(ignore);         eventListenerSupport.fire().vetoableChange(respond);         EasyMock.verify(listener);     }      private void addDeregisterListener(final EventListenerSupport<VetoableChangeListener> listenerSupport) {         listenerSupport.addListener(new VetoableChangeListener() {             @Override             public void vetoableChange(final PropertyChangeEvent e) {                 listenerSupport.removeListener(this);             }         });     }      private VetoableChangeListener createListener(final List<VetoableChangeListener> calledListeners) {         return new VetoableChangeListener() {             @Override             public void vetoableChange(final PropertyChangeEvent e) {                 calledListeners.add(this);             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.event;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.beans.VetoableChangeListener; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Proxy; import java.util.Date; import java.util.Map; import java.util.TreeMap;  import javax.naming.event.ObjectChangeListener;  import org.junit.jupiter.api.Test;  /**  * @since 3.0  */ public class EventUtilsTest {     @Test     public void testConstructor() {         assertNotNull(new EventUtils());         final Constructor<?>[] cons = EventUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(EventUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(EventUtils.class.getModifiers()));     }      @Test     public void testAddEventListener() {         final PropertyChangeSource src = new PropertyChangeSource();         final EventCountingInvocationHandler handler = new EventCountingInvocationHandler();         final PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class);         assertEquals(0, handler.getEventCount("propertyChange"));         EventUtils.addEventListener(src, PropertyChangeListener.class, listener);         assertEquals(0, handler.getEventCount("propertyChange"));         src.setProperty("newValue");         assertEquals(1, handler.getEventCount("propertyChange"));     }      @Test     public void testAddEventListenerWithNoAddMethod() {         final PropertyChangeSource src = new PropertyChangeSource();         final EventCountingInvocationHandler handler = new EventCountingInvocationHandler();         final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class);         final IllegalArgumentException e =                 assertThrows(IllegalArgumentException.class, () -> EventUtils.addEventListener(src, ObjectChangeListener.class, listener));         assertEquals("Class " + src.getClass().getName() + " does not have a public add" + ObjectChangeListener.class.getSimpleName() + " method which takes a parameter of type " + ObjectChangeListener.class.getName() + ".",                 e.getMessage());     }      @Test     public void testAddEventListenerThrowsException() {         final ExceptionEventSource src = new ExceptionEventSource();         assertThrows(RuntimeException.class, () ->             EventUtils.addEventListener(src, PropertyChangeListener.class, e -> {                 // Do nothing!             })         );     }      @Test     public void testAddEventListenerWithPrivateAddMethod() {         final PropertyChangeSource src = new PropertyChangeSource();         final EventCountingInvocationHandler handler = new EventCountingInvocationHandler();         final VetoableChangeListener listener = handler.createListener(VetoableChangeListener.class);         final IllegalArgumentException e =                 assertThrows(IllegalArgumentException.class, () -> EventUtils.addEventListener(src, VetoableChangeListener.class, listener));         assertEquals("Class " + src.getClass().getName() + " does not have a public add" + VetoableChangeListener.class.getSimpleName() + " method which takes a parameter of type " + VetoableChangeListener.class.getName() + ".",                 e.getMessage());     }      @Test     public void testBindEventsToMethod() {         final PropertyChangeSource src = new PropertyChangeSource();         final EventCounter counter = new EventCounter();         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class);         assertEquals(0, counter.getCount());         src.setProperty("newValue");         assertEquals(1, counter.getCount());     }       @Test     public void testBindEventsToMethodWithEvent() {         final PropertyChangeSource src = new PropertyChangeSource();         final EventCounterWithEvent counter = new EventCounterWithEvent();         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class);         assertEquals(0, counter.getCount());         src.setProperty("newValue");         assertEquals(1, counter.getCount());     }       @Test     public void testBindFilteredEventsToMethod() {         final MultipleEventSource src = new MultipleEventSource();         final EventCounter counter = new EventCounter();         EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1");         assertEquals(0, counter.getCount());         src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1)));         assertEquals(1, counter.getCount());         src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2)));         assertEquals(1, counter.getCount());     }      public interface MultipleEventListener {         void event1(PropertyChangeEvent e);          void event2(PropertyChangeEvent e);     }      public static class EventCounter {         private int count;          public void eventOccurred() {             count++;         }          public int getCount() {             return count;         }     }      public static class EventCounterWithEvent {         private int count;          public void eventOccurred(final PropertyChangeEvent e) {             count++;         }          public int getCount() {             return count;         }     }       private static class EventCountingInvocationHandler implements InvocationHandler {         private final Map<String, Integer> eventCounts = new TreeMap<>();          public <L> L createListener(final Class<L> listenerType) {             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                     new Class[]{listenerType},                     this));         }          public int getEventCount(final String eventName) {             final Integer count = eventCounts.get(eventName);             return count == null ? 0 : count.intValue();         }          @Override         public Object invoke(final Object proxy, final Method method, final Object[] args) {             final Integer count = eventCounts.get(method.getName());             if (count == null) {                 eventCounts.put(method.getName(), Integer.valueOf(1));             } else {                 eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1));             }             return null;         }     }      public static class MultipleEventSource {         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class);          public void addMultipleEventListener(final MultipleEventListener listener) {             listeners.addListener(listener);         }     }      public static class ExceptionEventSource {         public void addPropertyChangeListener(final PropertyChangeListener listener) {             throw new RuntimeException();         }     }      public static class PropertyChangeSource {         private final EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class);          private String property;          public void setProperty(final String property) {             final String oldValue = this.property;             this.property = property;             listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property));         }          protected void addVetoableChangeListener(final VetoableChangeListener listener) {             // Do nothing!         }          public void addPropertyChangeListener(final PropertyChangeListener listener) {             listeners.addListener(listener);         }          public void removePropertyChangeListener(final PropertyChangeListener listener) {             listeners.removeListener(listener);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.apache.commons.lang3.arch.Processor; import org.apache.commons.lang3.arch.Processor.Arch; import org.junit.jupiter.api.Test;  /**  * Test class for {@link ArchUtils}.  */ public class ArchUtilsTest {      private static final String IA64 = "ia64";     private static final String IA64_32 = "ia64_32";     private static final String PPC = "ppc";     private static final String PPC64 = "ppc64";     private static final String X86 = "x86";     private static final String X86_64 = "x86_64";      private void assertEqualsArchNotNull(final Processor.Arch arch, final Processor processor) {         assertNotNull(arch);         assertNotNull(processor);         assertEquals(arch, processor.getArch());     }      private void assertEqualsTypeNotNull(final Processor.Type type, final Processor processor) {         assertNotNull(type);         assertNotNull(processor);         assertEquals(type, processor.getType());     }      private void assertNotEqualsArchNotNull(final Processor.Arch arch, final Processor processor) {         assertNotNull(arch);         assertNotNull(processor);         assertNotEquals(arch, processor.getArch());     }      private void assertNotEqualsTypeNotNull(final Processor.Type type, final Processor processor) {         assertNotNull(type);         assertNotNull(processor);         assertNotEquals(type, processor.getType());     }      @Test     public void testArch() {         Processor processor = ArchUtils.getProcessor(X86);         assertEqualsTypeNotNull(Processor.Type.X86, processor);         assertTrue(processor.isX86());         assertNotEqualsTypeNotNull(Processor.Type.PPC, processor);         assertFalse(processor.isPPC());          processor = ArchUtils.getProcessor(X86_64);         assertEqualsTypeNotNull(Processor.Type.X86, processor);         assertTrue(processor.isX86());          processor = ArchUtils.getProcessor(IA64_32);         assertEqualsTypeNotNull(Processor.Type.IA_64, processor);         assertTrue(processor.isIA64());          processor = ArchUtils.getProcessor(IA64);         assertEqualsTypeNotNull(Processor.Type.IA_64, processor);         assertTrue(processor.isIA64());         assertNotEqualsTypeNotNull(Processor.Type.X86, processor);         assertFalse(processor.isX86());          processor = ArchUtils.getProcessor(PPC);         assertEqualsTypeNotNull(Processor.Type.PPC, processor);         assertTrue(processor.isPPC());         assertNotEqualsTypeNotNull(Processor.Type.IA_64, processor);         assertFalse(processor.isIA64());          processor = ArchUtils.getProcessor(PPC64);         assertEqualsTypeNotNull(Processor.Type.PPC, processor);         assertTrue(processor.isPPC());     }      @Test     public void testArchLabels() {         for (final Arch arch : Arch.values()) {             // Only test label presence.             assertFalse(arch.getLabel().isEmpty());         }     }      @Test     public void testGetProcessor() {         assertNotNull(ArchUtils.getProcessor(X86));         assertNull(ArchUtils.getProcessor("NA"));     }      @Test     public void testIs32BitJVM() {         Processor processor = ArchUtils.getProcessor(X86);         assertEqualsArchNotNull(Processor.Arch.BIT_32, processor);         assertTrue(processor.is32Bit());          processor = ArchUtils.getProcessor(IA64_32);         assertEqualsArchNotNull(Processor.Arch.BIT_32, processor);         assertTrue(processor.is32Bit());          processor = ArchUtils.getProcessor(PPC);         assertEqualsArchNotNull(Processor.Arch.BIT_32, processor);         processor.is32Bit();          processor = ArchUtils.getProcessor(X86_64);         assertNotEqualsArchNotNull(Processor.Arch.BIT_32, processor);         assertFalse(processor.is32Bit());          processor = ArchUtils.getProcessor(PPC64);         assertNotEqualsArchNotNull(Processor.Arch.BIT_32, processor);         assertFalse(processor.is32Bit());          processor = ArchUtils.getProcessor(IA64);         assertNotEqualsArchNotNull(Processor.Arch.BIT_32, processor);         assertFalse(processor.is32Bit());     }      @Test     public void testIs64BitJVM() {         Processor processor = ArchUtils.getProcessor(X86_64);         assertEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertTrue(processor.is64Bit());          processor = ArchUtils.getProcessor(PPC64);         assertEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertTrue(processor.is64Bit());          processor = ArchUtils.getProcessor(IA64);         assertEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertTrue(processor.is64Bit());          processor = ArchUtils.getProcessor(X86);         assertNotEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertFalse(processor.is64Bit());          processor = ArchUtils.getProcessor(PPC);         assertNotEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertFalse(processor.is64Bit());          processor = ArchUtils.getProcessor(IA64_32);         assertNotEqualsArchNotNull(Processor.Arch.BIT_64, processor);         assertFalse(processor.is64Bit());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Comparator;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * <p>  * Tests the methods in the {@link org.apache.commons.lang3.Range} class.  * </p>  */ @SuppressWarnings("boxing") public class RangeTest {      private Range<Byte> byteRange;     private Range<Byte> byteRange2;     private Range<Byte> byteRange3;      private Range<Double> doubleRange;     private Range<Float> floatRange;     private Range<Integer> intRange;     private Range<Long> longRange;      @BeforeEach     public void setUp() {         byteRange = Range.between((byte) 0, (byte) 5);         byteRange2 = Range.between((byte) 0, (byte) 5);         byteRange3 = Range.between((byte) 0, (byte) 10);          intRange = Range.between(10, 20);         longRange = Range.between(10L, 20L);         floatRange = Range.between((float) 10, (float) 20);         doubleRange = Range.between((double) 10, (double) 20);     }      @Test     public void testBetweenWithCompare() {         // all integers are equal         final Comparator<Integer> c = (o1, o2) -> 0;         final Comparator<String> lengthComp = Comparator.comparingInt(String::length);         Range<Integer> rb = Range.between(-10, 20);         assertFalse(rb.contains(null), "should not contain null");         assertTrue(rb.contains(10), "should contain 10");         assertTrue(rb.contains(-10), "should contain -10");         assertFalse(rb.contains(21), "should not contain 21");         assertFalse(rb.contains(-11), "should not contain -11");         rb = Range.between(-10, 20, c);         assertFalse(rb.contains(null), "should not contain null");         assertTrue(rb.contains(10), "should contain 10");         assertTrue(rb.contains(-10), "should contain -10");         assertTrue(rb.contains(21), "should contain 21");         assertTrue(rb.contains(-11), "should contain -11");         Range<String> rbstr = Range.between("house", "i");         assertFalse(rbstr.contains(null), "should not contain null");         assertTrue(rbstr.contains("house"), "should contain house");         assertTrue(rbstr.contains("i"), "should contain i");         assertFalse(rbstr.contains("hose"), "should not contain hose");         assertFalse(rbstr.contains("ice"), "should not contain ice");         rbstr = Range.between("house", "i", lengthComp);         assertFalse(rbstr.contains(null), "should not contain null");         assertTrue(rbstr.contains("house"), "should contain house");         assertTrue(rbstr.contains("i"), "should contain i");         assertFalse(rbstr.contains("houses"), "should not contain houses");         assertFalse(rbstr.contains(""), "should not contain ''");     }      // -----------------------------------------------------------------------     @SuppressWarnings({ "rawtypes", "unchecked" })     @Test     public void testComparableConstructors() {         final Comparable c = other -> 1;         final Range r1 = Range.is(c);         final Range r2 = Range.between(c, c);         assertTrue(r1.isNaturalOrdering());         assertTrue(r2.isNaturalOrdering());     }      @Test     public void testContains() {         assertFalse(intRange.contains(null));          assertFalse(intRange.contains(5));         assertTrue(intRange.contains(10));         assertTrue(intRange.contains(15));         assertTrue(intRange.contains(20));         assertFalse(intRange.contains(25));     }      // -----------------------------------------------------------------------     @Test     public void testContainsRange() {          // null handling         assertFalse(intRange.containsRange(null));          // easy inside range         assertTrue(intRange.containsRange(Range.between(12, 18)));          // outside range on each side         assertFalse(intRange.containsRange(Range.between(32, 45)));         assertFalse(intRange.containsRange(Range.between(2, 8)));          // equals range         assertTrue(intRange.containsRange(Range.between(10, 20)));          // overlaps         assertFalse(intRange.containsRange(Range.between(9, 14)));         assertFalse(intRange.containsRange(Range.between(16, 21)));          // touches lower boundary         assertTrue(intRange.containsRange(Range.between(10, 19)));         assertFalse(intRange.containsRange(Range.between(10, 21)));          // touches upper boundary         assertTrue(intRange.containsRange(Range.between(11, 20)));         assertFalse(intRange.containsRange(Range.between(9, 20)));          // negative         assertFalse(intRange.containsRange(Range.between(-11, -18)));     }      @Test     public void testElementCompareTo() {         assertThrows(NullPointerException.class, () -> intRange.elementCompareTo(null));          assertEquals(-1, intRange.elementCompareTo(5));         assertEquals(0, intRange.elementCompareTo(10));         assertEquals(0, intRange.elementCompareTo(15));         assertEquals(0, intRange.elementCompareTo(20));         assertEquals(1, intRange.elementCompareTo(25));     }      // -----------------------------------------------------------------------     @Test     public void testEqualsObject() {         assertEquals(byteRange, byteRange);         assertEquals(byteRange, byteRange2);         assertEquals(byteRange2, byteRange2);         assertEquals(byteRange, byteRange);         assertEquals(byteRange2, byteRange2);         assertEquals(byteRange3, byteRange3);         assertNotEquals(byteRange2, byteRange3);         assertNotEquals(null, byteRange2);         assertNotEquals("Ni!", byteRange2);     }      @Test     public void testFit() {         assertEquals(intRange.getMinimum(), intRange.fit(Integer.MIN_VALUE));         assertEquals(intRange.getMinimum(), intRange.fit(intRange.getMinimum()));         assertEquals(intRange.getMaximum(), intRange.fit(Integer.MAX_VALUE));         assertEquals(intRange.getMaximum(), intRange.fit(intRange.getMaximum()));         assertEquals(15, intRange.fit(15));     }      @Test     public void testFitNull() {         assertThrows(NullPointerException.class, () -> {             intRange.fit(null);         });     }      @Test     public void testGetMaximum() {         assertEquals(20, (int) intRange.getMaximum());         assertEquals(20L, (long) longRange.getMaximum());         assertEquals(20f, floatRange.getMaximum(), 0.00001f);         assertEquals(20d, doubleRange.getMaximum(), 0.00001d);     }      // -----------------------------------------------------------------------     @Test     public void testGetMinimum() {         assertEquals(10, (int) intRange.getMinimum());         assertEquals(10L, (long) longRange.getMinimum());         assertEquals(10f, floatRange.getMinimum(), 0.00001f);         assertEquals(10d, doubleRange.getMinimum(), 0.00001d);     }      @Test     public void testHashCode() {         assertEquals(byteRange.hashCode(), byteRange2.hashCode());         assertNotEquals(byteRange.hashCode(), byteRange3.hashCode());          assertEquals(intRange.hashCode(), intRange.hashCode());         assertTrue(intRange.hashCode() != 0);     }      @Test     public void testIntersectionWith() {         assertSame(intRange, intRange.intersectionWith(intRange));         assertSame(byteRange, byteRange.intersectionWith(byteRange));         assertSame(longRange, longRange.intersectionWith(longRange));         assertSame(floatRange, floatRange.intersectionWith(floatRange));         assertSame(doubleRange, doubleRange.intersectionWith(doubleRange));          assertEquals(Range.between(10, 15), intRange.intersectionWith(Range.between(5, 15)));     }      @Test     public void testIntersectionWithNonOverlapping() {         assertThrows(IllegalArgumentException.class, () -> intRange.intersectionWith(Range.between(0, 9)));     }      @Test     public void testIntersectionWithNull() {         assertThrows(IllegalArgumentException.class, () -> intRange.intersectionWith(null));     }      @Test     public void testIsAfter() {         assertFalse(intRange.isAfter(null));          assertTrue(intRange.isAfter(5));         assertFalse(intRange.isAfter(10));         assertFalse(intRange.isAfter(15));         assertFalse(intRange.isAfter(20));         assertFalse(intRange.isAfter(25));     }      @Test     public void testIsAfterRange() {         assertFalse(intRange.isAfterRange(null));          assertTrue(intRange.isAfterRange(Range.between(5, 9)));          assertFalse(intRange.isAfterRange(Range.between(5, 10)));         assertFalse(intRange.isAfterRange(Range.between(5, 20)));         assertFalse(intRange.isAfterRange(Range.between(5, 25)));         assertFalse(intRange.isAfterRange(Range.between(15, 25)));          assertFalse(intRange.isAfterRange(Range.between(21, 25)));          assertFalse(intRange.isAfterRange(Range.between(10, 20)));     }      @Test     public void testIsBefore() {         assertFalse(intRange.isBefore(null));          assertFalse(intRange.isBefore(5));         assertFalse(intRange.isBefore(10));         assertFalse(intRange.isBefore(15));         assertFalse(intRange.isBefore(20));         assertTrue(intRange.isBefore(25));     }      @Test     public void testIsBeforeRange() {         assertFalse(intRange.isBeforeRange(null));          assertFalse(intRange.isBeforeRange(Range.between(5, 9)));          assertFalse(intRange.isBeforeRange(Range.between(5, 10)));         assertFalse(intRange.isBeforeRange(Range.between(5, 20)));         assertFalse(intRange.isBeforeRange(Range.between(5, 25)));         assertFalse(intRange.isBeforeRange(Range.between(15, 25)));          assertTrue(intRange.isBeforeRange(Range.between(21, 25)));          assertFalse(intRange.isBeforeRange(Range.between(10, 20)));     }      @Test     public void testIsEndedBy() {         assertFalse(intRange.isEndedBy(null));          assertFalse(intRange.isEndedBy(5));         assertFalse(intRange.isEndedBy(10));         assertFalse(intRange.isEndedBy(15));         assertTrue(intRange.isEndedBy(20));         assertFalse(intRange.isEndedBy(25));     }      @Test     public void testIsOverlappedBy() {          // null handling         assertFalse(intRange.isOverlappedBy(null));          // easy inside range         assertTrue(intRange.isOverlappedBy(Range.between(12, 18)));          // outside range on each side         assertFalse(intRange.isOverlappedBy(Range.between(32, 45)));         assertFalse(intRange.isOverlappedBy(Range.between(2, 8)));          // equals range         assertTrue(intRange.isOverlappedBy(Range.between(10, 20)));          // overlaps         assertTrue(intRange.isOverlappedBy(Range.between(9, 14)));         assertTrue(intRange.isOverlappedBy(Range.between(16, 21)));          // touches lower boundary         assertTrue(intRange.isOverlappedBy(Range.between(10, 19)));         assertTrue(intRange.isOverlappedBy(Range.between(10, 21)));          // touches upper boundary         assertTrue(intRange.isOverlappedBy(Range.between(11, 20)));         assertTrue(intRange.isOverlappedBy(Range.between(9, 20)));          // negative         assertFalse(intRange.isOverlappedBy(Range.between(-11, -18)));     }      @Test     public void testIsStartedBy() {         assertFalse(intRange.isStartedBy(null));          assertFalse(intRange.isStartedBy(5));         assertTrue(intRange.isStartedBy(10));         assertFalse(intRange.isStartedBy(15));         assertFalse(intRange.isStartedBy(20));         assertFalse(intRange.isStartedBy(25));     }      @Test     public void testIsWithCompare() {         // all integers are equal         final Comparator<Integer> c = (o1, o2) -> 0;         Range<Integer> ri = Range.is(10);         assertFalse(ri.contains(null), "should not contain null");         assertTrue(ri.contains(10), "should contain 10");         assertFalse(ri.contains(11), "should not contain 11");         ri = Range.is(10, c);         assertFalse(ri.contains(null), "should not contain null");         assertTrue(ri.contains(10), "should contain 10");         assertTrue(ri.contains(11), "should contain 11");     }      // -----------------------------------------------------------------------     @Test     public void testRangeOfChars() {         final Range<Character> chars = Range.between('a', 'z');         assertTrue(chars.contains('b'));         assertFalse(chars.contains('B'));     }      // -----------------------------------------------------------------------     @Test     public void testSerializing() {         SerializationUtils.clone(intRange);     }      @Test     public void testToString() {         assertNotNull(byteRange.toString());          final String str = intRange.toString();         assertEquals("[10..20]", str);         assertEquals("[-20..-10]", Range.between(-20, -10).toString());     }      @Test     public void testToStringFormat() {         final String str = intRange.toString("From %1$s to %2$s");         assertEquals("From 10 to 20", str);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.ScheduledThreadPoolExecutor; import java.util.concurrent.TimeUnit;  import org.easymock.EasyMock; import org.junit.jupiter.api.Test;  /**  * Test class for TimedSemaphore.  */ public class TimedSemaphoreTest {     /** Constant for the time period. */     private static final long PERIOD = 500;      /** Constant for the time unit. */     private static final TimeUnit UNIT = TimeUnit.MILLISECONDS;      /** Constant for the default limit. */     private static final int LIMIT = 10;      /**      * Tests creating a new instance.      */     @Test     public void testInit() {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         EasyMock.replay(service);         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,                 LIMIT);         EasyMock.verify(service);         assertEquals(service, semaphore.getExecutorService(), "Wrong service");         assertEquals(PERIOD, semaphore.getPeriod(), "Wrong period");         assertEquals(UNIT, semaphore.getUnit(), "Wrong unit");         assertEquals(0, semaphore.getLastAcquiresPerPeriod(), "Statistic available");         assertEquals(0.0, semaphore.getAverageCallsPerPeriod(), .05, "Average available");         assertFalse(semaphore.isShutdown(), "Already shutdown");         assertEquals(LIMIT, semaphore.getLimit(), "Wrong limit");     }      /**      * Tries to create an instance with a negative period. This should cause an      * exception.      */     @Test     public void testInitInvalidPeriod() {         assertThrows(IllegalArgumentException.class, () -> new TimedSemaphore(0L, UNIT, LIMIT));     }      /**      * Tests whether a default executor service is created if no service is      * provided.      */     @Test     public void testInitDefaultService() {         final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);         final ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore                 .getExecutorService();         assertFalse(exec.getContinueExistingPeriodicTasksAfterShutdownPolicy(), "Wrong periodic task policy");         assertFalse(exec.getExecuteExistingDelayedTasksAfterShutdownPolicy(), "Wrong delayed task policy");         assertFalse(exec.isShutdown(), "Already shutdown");         semaphore.shutdown();     }      /**      * Tests starting the timer.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testStartTimer() throws InterruptedException {         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD,                 UNIT, LIMIT);         final ScheduledFuture<?> future = semaphore.startTimer();         assertNotNull(future, "No future returned");         Thread.sleep(PERIOD);         final int trials = 10;         int count = 0;         do {             Thread.sleep(PERIOD);             assertFalse(count++ > trials, "endOfPeriod() not called!");         } while (semaphore.getPeriodEnds() <= 0);         semaphore.shutdown();     }      /**      * Tests the shutdown() method if the executor belongs to the semaphore. In      * this case it has to be shut down.      */     @Test     public void testShutdownOwnExecutor() {         final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);         semaphore.shutdown();         assertTrue(semaphore.isShutdown(), "Not shutdown");         assertTrue(semaphore.getExecutorService().isShutdown(), "Executor not shutdown");     }      /**      * Tests the shutdown() method for a shared executor service before a task      * was started. This should do pretty much nothing.      */     @Test     public void testShutdownSharedExecutorNoTask() {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         EasyMock.replay(service);         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,                 LIMIT);         semaphore.shutdown();         assertTrue(semaphore.isShutdown(), "Not shutdown");         EasyMock.verify(service);     }      /**      * Prepares an executor service mock to expect the start of the timer.      *      * @param service the mock      * @param future the future      */     private void prepareStartTimer(final ScheduledExecutorService service,             final ScheduledFuture<?> future) {         service.scheduleAtFixedRate((Runnable) EasyMock.anyObject(), EasyMock                 .eq(PERIOD), EasyMock.eq(PERIOD), EasyMock.eq(UNIT));         EasyMock.expectLastCall().andReturn(future);     }      /**      * Tests the shutdown() method for a shared executor after the task was      * started. In this case the task must be canceled.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testShutdownSharedExecutorTask() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);         EasyMock.replay(service, future);         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,                 PERIOD, UNIT, LIMIT);         semaphore.acquire();         semaphore.shutdown();         assertTrue(semaphore.isShutdown(), "Not shutdown");         EasyMock.verify(service, future);     }      /**      * Tests multiple invocations of the shutdown() method.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testShutdownMultipleTimes() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);         EasyMock.replay(service, future);         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,                 PERIOD, UNIT, LIMIT);         semaphore.acquire();         for (int i = 0; i < 10; i++) {             semaphore.shutdown();         }         EasyMock.verify(service, future);     }      /**      * Tests the acquire() method if a limit is set.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testAcquireLimit() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.replay(service, future);         final int count = 10;         final CountDownLatch latch = new CountDownLatch(count - 1);         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1);         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count,                 count - 1);         semaphore.setLimit(count - 1);          // start a thread that calls the semaphore count times         t.start();         latch.await();         // now the semaphore's limit should be reached and the thread blocked         assertEquals(count - 1, semaphore.getAcquireCount(), "Wrong semaphore count");          // this wakes up the thread, it should call the semaphore once more         semaphore.endOfPeriod();         t.join();         assertEquals(1, semaphore.getAcquireCount(), "Wrong semaphore count (2)");         assertEquals(count - 1, semaphore.getLastAcquiresPerPeriod(), "Wrong acquire() count");         EasyMock.verify(service, future);     }      /**      * Tests the acquire() method if more threads are involved than the limit.      * This method starts a number of threads that all invoke the semaphore. The      * semaphore's limit is set to 1, so in each period only a single thread can      * acquire the semaphore.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testAcquireMultipleThreads() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.replay(service, future);         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,                 PERIOD, UNIT, 1);         semaphore.latch = new CountDownLatch(1);         final int count = 10;         final SemaphoreThread[] threads = new SemaphoreThread[count];         for (int i = 0; i < count; i++) {             threads[i] = new SemaphoreThread(semaphore, null, 1, 0);             threads[i].start();         }         for (int i = 0; i < count; i++) {             semaphore.latch.await();             assertEquals(1, semaphore.getAcquireCount(), "Wrong count");             semaphore.latch = new CountDownLatch(1);             semaphore.endOfPeriod();             assertEquals(1, semaphore.getLastAcquiresPerPeriod(), "Wrong acquire count");         }         for (int i = 0; i < count; i++) {             threads[i].join();         }         EasyMock.verify(service, future);     }      /**      * Tests the acquire() method if no limit is set. A test thread is started      * that calls the semaphore a large number of times. Even if the semaphore's      * period does not end, the thread should never block.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testAcquireNoLimit() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.replay(service, future);         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,                 PERIOD, UNIT, TimedSemaphore.NO_LIMIT);         final int count = 1000;         final CountDownLatch latch = new CountDownLatch(count);         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);         t.start();         latch.await();         EasyMock.verify(service, future);     }      /**      * Tries to call acquire() after shutdown(). This should cause an exception.      */     @Test     public void testPassAfterShutdown() {         final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);         semaphore.shutdown();         assertThrows(IllegalStateException.class, semaphore::acquire);     }      /**      * Tests a bigger number of invocations that span multiple periods. The      * period is set to a very short time. A background thread calls the      * semaphore a large number of times. While it runs at last one end of a      * period should be reached.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testAcquireMultiplePeriods() throws InterruptedException {         final int count = 1000;         final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(                 PERIOD / 10, TimeUnit.MILLISECONDS, 1);         semaphore.setLimit(count / 4);         final CountDownLatch latch = new CountDownLatch(count);         final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);         t.start();         latch.await();         semaphore.shutdown();         assertTrue(semaphore.getPeriodEnds() > 0, "End of period not reached");     }      /**      * Tests the methods for statistics.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testGetAverageCallsPerPeriod() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.replay(service, future);         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,                 LIMIT);         semaphore.acquire();         semaphore.endOfPeriod();         assertEquals(1.0, semaphore.getAverageCallsPerPeriod(), .005, "Wrong average (1)");         semaphore.acquire();         semaphore.acquire();         semaphore.endOfPeriod();         assertEquals(1.5, semaphore.getAverageCallsPerPeriod(), .005, "Wrong average (2)");         EasyMock.verify(service, future);     }      /**      * Tests whether the available non-blocking calls can be queried.      *      * @throws java.lang.InterruptedException so we don't have to catch it      */     @Test     public void testGetAvailablePermits() throws InterruptedException {         final ScheduledExecutorService service = EasyMock                 .createMock(ScheduledExecutorService.class);         final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);         prepareStartTimer(service, future);         EasyMock.replay(service, future);         final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,                 LIMIT);         for (int i = 0; i < LIMIT; i++) {             assertEquals(LIMIT - i, semaphore.getAvailablePermits(), "Wrong available count at " + i);             semaphore.acquire();         }         semaphore.endOfPeriod();         assertEquals(LIMIT, semaphore.getAvailablePermits(), "Wrong available count in new period");         EasyMock.verify(service, future);     }      /**      * Tests the tryAcquire() method. It is checked whether the semaphore can be acquired      * by a bunch of threads the expected number of times and not more.      */     @Test     public void testTryAcquire() throws InterruptedException {         final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, TimeUnit.SECONDS,                 LIMIT);         final TryAcquireThread[] threads = new TryAcquireThread[3 * LIMIT];         final CountDownLatch latch = new CountDownLatch(1);         for (int i = 0; i < threads.length; i++) {             threads[i] = new TryAcquireThread(semaphore, latch);             threads[i].start();         }          latch.countDown();         int permits = 0;         for (final TryAcquireThread t : threads) {             t.join();             if (t.acquired) {                 permits++;             }         }         assertEquals(LIMIT, permits, "Wrong number of permits granted");     }      /**      * Tries to call tryAcquire() after shutdown(). This should cause an exception.      */     @Test     public void testTryAcquireAfterShutdown() {         final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);         semaphore.shutdown();         assertThrows(IllegalStateException.class, semaphore::tryAcquire);     }      /**      * A specialized implementation of {@code TimedSemaphore} that is easier to      * test.      */     private static class TimedSemaphoreTestImpl extends TimedSemaphore {         /** A mock scheduled future. */         ScheduledFuture<?> schedFuture;          /** A latch for synchronizing with the main thread. */         volatile CountDownLatch latch;          /** Counter for the endOfPeriod() invocations. */         private int periodEnds;          TimedSemaphoreTestImpl(final long timePeriod, final TimeUnit timeUnit,                 final int limit) {             super(timePeriod, timeUnit, limit);         }          TimedSemaphoreTestImpl(final ScheduledExecutorService service,                 final long timePeriod, final TimeUnit timeUnit, final int limit) {             super(service, timePeriod, timeUnit, limit);         }          /**          * Returns the number of invocations of the endOfPeriod() method.          *          * @return the endOfPeriod() invocations          */         int getPeriodEnds() {             synchronized (this) {                 return periodEnds;             }         }          /**          * Invokes the latch if one is set.          *          * @throws java.lang.InterruptedException because it is declared that way in TimedSemaphore          */         @Override         public synchronized void acquire() throws InterruptedException {             super.acquire();             if (latch != null) {                 latch.countDown();             }         }          /**          * Counts the number of invocations.          */         @Override         protected synchronized void endOfPeriod() {             super.endOfPeriod();             periodEnds++;         }          /**          * Either returns the mock future or calls the super method.          */         @Override         protected ScheduledFuture<?> startTimer() {             return schedFuture != null ? schedFuture : super.startTimer();         }     }      /**      * A test thread class that will be used by tests for triggering the      * semaphore. The thread calls the semaphore a configurable number of times.      * When this is done, it can notify the main thread.      */     private static class SemaphoreThread extends Thread {         /** The semaphore. */         private final TimedSemaphore semaphore;          /** A latch for communication with the main thread. */         private final CountDownLatch latch;          /** The number of acquire() calls. */         private final int count;          /** The number of invocations of the latch. */         private final int latchCount;          SemaphoreThread(final TimedSemaphore b, final CountDownLatch l, final int c, final int lc) {             semaphore = b;             latch = l;             count = c;             latchCount = lc;         }          /**          * Calls acquire() on the semaphore for the specified number of times.          * Optionally the latch will also be triggered to synchronize with the          * main test thread.          */         @Override         public void run() {             try {                 for (int i = 0; i < count; i++) {                     semaphore.acquire();                      if (i < latchCount) {                         latch.countDown();                     }                 }             } catch (final InterruptedException iex) {                 Thread.currentThread().interrupt();             }         }     }      /**      * A test thread class which invokes {@code tryAcquire()} on the test semaphore and      * records the return value.      */     private static class TryAcquireThread extends Thread {         /** The semaphore. */         private final TimedSemaphore semaphore;          /** A latch for communication with the main thread. */         private final CountDownLatch latch;          /** Flag whether a permit could be acquired. */         private boolean acquired;          TryAcquireThread(final TimedSemaphore s, final CountDownLatch l) {             semaphore = s;             latch = l;         }          @Override         public void run() {             try {                 if (latch.await(10, TimeUnit.SECONDS)) {                     acquired = semaphore.tryAcquire();                 }             } catch (final InterruptedException iex) {                 // ignore             }         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  /**  * Test class for {@code AtomicInitializer}.  */ public class AtomicInitializerTest extends AbstractConcurrentInitializerTest {     /**      * Returns the initializer to be tested.      *      * @return the {@code AtomicInitializer}      */     @Override     protected ConcurrentInitializer<Object> createInitializer() {         return new AtomicInitializer<Object>() {             @Override             protected Object initialize() {                 return new Object();             }         };     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.easymock.EasyMock; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  public class MemoizerTest {      private Computable<Integer, Integer> computable;      @BeforeEach     public void setUpComputableMock() {         computable = EasyMock.mock(Computable.class);     }      @Test     public void testOnlyCallComputableOnceIfDoesNotThrowException() throws Exception {         final Integer input = 1;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable);         expect(computable.compute(input)).andReturn(input);         replay(computable);          assertEquals(input, memoizer.compute(input), "Should call computable first time");         assertEquals(input, memoizer.compute(input), "Should not call the computable the second time");     }      @Test     public void testDefaultBehaviourNotToRecalculateExecutionExceptions() throws Exception {         final Integer input = 1;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable);         final InterruptedException interruptedException = new InterruptedException();         expect(computable.compute(input)).andThrow(interruptedException);         replay(computable);          assertThrows(Throwable.class, () -> memoizer.compute(input));         assertThrows(IllegalStateException.class, () -> memoizer.compute(input));     }      @Test     public void testDoesNotRecalculateWhenSetToFalse() throws Exception {         final Integer input = 1;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable, false);         final InterruptedException interruptedException = new InterruptedException();         expect(computable.compute(input)).andThrow(interruptedException);         replay(computable);          assertThrows(Throwable.class, () -> memoizer.compute(input));         assertThrows(IllegalStateException.class, () -> memoizer.compute(input));     }      @Test     public void testDoesRecalculateWhenSetToTrue() throws Exception {         final Integer input = 1;         final Integer answer = 3;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable, true);         final InterruptedException interruptedException = new InterruptedException();         expect(computable.compute(input)).andThrow(interruptedException).andReturn(answer);         replay(computable);          assertThrows(Throwable.class, () -> memoizer.compute(input));         assertEquals(answer, memoizer.compute(input));     }      @Test     public void testWhenComputableThrowsRuntimeException() throws Exception {         final Integer input = 1;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable);         final RuntimeException runtimeException = new RuntimeException("Some runtime exception");         expect(computable.compute(input)).andThrow(runtimeException);         replay(computable);          assertThrows(RuntimeException.class, () -> memoizer.compute(input));     }      @Test     public void testWhenComputableThrowsError() throws Exception {         final Integer input = 1;         final Memoizer<Integer, Integer> memoizer = new Memoizer<>(computable);         final Error error = new Error();         expect(computable.compute(input)).andThrow(error);         replay(computable);          assertThrows(Error.class, () -> memoizer.compute(input));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference;  import org.junit.jupiter.api.Test;  public class BackgroundInitializerTest {     /**      * Helper method for checking whether the initialize() method was correctly      * called. start() must already have been invoked.      *      * @param init the initializer to test      */     private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {         final Integer result = init.get();         assertEquals(1, result.intValue(), "Wrong result");         assertEquals(1, init.initializeCalls, "Wrong number of invocations");         assertNotNull(init.getFuture(), "No future");     }      /**      * Tests whether initialize() is invoked.      */     @Test     public void testInitialize() throws ConcurrentException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         init.start();         checkInitialize(init);     }      /**      * Tries to obtain the executor before start(). It should not have been      * initialized yet.      */     @Test     public void testGetActiveExecutorBeforeStart() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         assertNull(init.getActiveExecutor(), "Got an executor");     }      /**      * Tests whether an external executor is correctly detected.      */     @Test     public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {         final ExecutorService exec = Executors.newSingleThreadExecutor();         try {             final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(                     exec);             init.start();             assertSame(exec, init.getActiveExecutor(), "Wrong executor");             checkInitialize(init);         } finally {             exec.shutdown();             exec.awaitTermination(1, TimeUnit.SECONDS);         }     }      /**      * Tests getActiveExecutor() for a temporary executor.      */     @Test     public void testGetActiveExecutorTemp() throws ConcurrentException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         init.start();         assertNotNull(init.getActiveExecutor(), "No active executor");         checkInitialize(init);     }      /**      * Tests the execution of the background task if a temporary executor has to      * be created.      */     @Test     public void testInitializeTempExecutor() throws ConcurrentException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         assertTrue(init.start(), "Wrong result of start()");         checkInitialize(init);         assertTrue(init.getActiveExecutor().isShutdown(), "Executor not shutdown");     }      /**      * Tests whether an external executor can be set using the      * setExternalExecutor() method.      */     @Test     public void testSetExternalExecutor() throws ConcurrentException {         final ExecutorService exec = Executors.newCachedThreadPool();         try {             final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();             init.setExternalExecutor(exec);             assertEquals(exec, init.getExternalExecutor(), "Wrong executor service");             assertTrue(init.start(), "Wrong result of start()");             assertSame(exec, init.getActiveExecutor(), "Wrong active executor");             checkInitialize(init);             assertFalse(exec.isShutdown(), "Executor was shutdown");         } finally {             exec.shutdown();         }     }      /**      * Tests that setting an executor after start() causes an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it      */     @Test     public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         init.start();         final ExecutorService exec = Executors.newSingleThreadExecutor();         try {             assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));             init.get();         } finally {             exec.shutdown();             exec.awaitTermination(1, TimeUnit.SECONDS);         }     }      /**      * Tests invoking start() multiple times. Only the first invocation should      * have an effect.      */     @Test     public void testStartMultipleTimes() throws ConcurrentException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         assertTrue(init.start(), "Wrong result for start()");         for (int i = 0; i < 10; i++) {             assertFalse(init.start(), "Could start again");         }         checkInitialize(init);     }      /**      * Tests calling get() before start(). This should cause an exception.      */     @Test     public void testGetBeforeStart() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         assertThrows(IllegalStateException.class, init::get);     }      /**      * Tests the get() method if background processing causes a runtime      * exception.      */     @Test     public void testGetRuntimeException() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         final RuntimeException rex = new RuntimeException();         init.ex = rex;         init.start();         final Exception ex = assertThrows(Exception.class, init::get);         assertEquals(rex, ex, "Runtime exception not thrown");     }      /**      * Tests the get() method if background processing causes a checked      * exception.      */     @Test     public void testGetCheckedException() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         final Exception ex = new Exception();         init.ex = ex;         init.start();         final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);         assertEquals(ex, cex.getCause(), "Exception not thrown");     }      /**      * Tests the get() method if waiting for the initialization is interrupted.      *      * @throws java.lang.InterruptedException because we're making use of Java's concurrent API      */     @Test     public void testGetInterruptedException() throws InterruptedException {         final ExecutorService exec = Executors.newSingleThreadExecutor();         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(                 exec);         final CountDownLatch latch1 = new CountDownLatch(1);         init.shouldSleep = true;         init.start();         final AtomicReference<InterruptedException> iex = new AtomicReference<>();         final Thread getThread = new Thread() {             @Override             public void run() {                 try {                     init.get();                 } catch (final ConcurrentException cex) {                     if (cex.getCause() instanceof InterruptedException) {                         iex.set((InterruptedException) cex.getCause());                     }                 } finally {                     assertTrue(isInterrupted(), "Thread not interrupted");                     latch1.countDown();                 }             }         };         getThread.start();         getThread.interrupt();         latch1.await();         exec.shutdownNow();         exec.awaitTermination(1, TimeUnit.SECONDS);         assertNotNull(iex.get(), "No interrupted exception");     }      /**      * Tests isStarted() before start() was called.      */     @Test     public void testIsStartedFalse() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         assertFalse(init.isStarted(), "Already started");     }      /**      * Tests isStarted() after start().      */     @Test     public void testIsStartedTrue() {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         init.start();         assertTrue(init.isStarted(), "Not started");     }      /**      * Tests isStarted() after the background task has finished.      */     @Test     public void testIsStartedAfterGet() throws ConcurrentException {         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();         init.start();         checkInitialize(init);         assertTrue(init.isStarted(), "Not started");     }      /**      * A concrete implementation of BackgroundInitializer. It also overloads      * some methods that simplify testing.      */     private static class BackgroundInitializerTestImpl extends             BackgroundInitializer<Integer> {         /** An exception to be thrown by initialize(). */         Exception ex;          /** A flag whether the background task should sleep a while. */         boolean shouldSleep;          /** The number of invocations of initialize(). */         volatile int initializeCalls;          BackgroundInitializerTestImpl() {             super();         }          BackgroundInitializerTestImpl(final ExecutorService exec) {             super(exec);         }          /**          * Records this invocation. Optionally throws an exception or sleeps a          * while.          *          * @throws Exception in case of an error          */         @Override         protected Integer initialize() throws Exception {             if (ex != null) {                 throw ex;             }             if (shouldSleep) {                 Thread.sleep(60000L);             }             return Integer.valueOf(++initializeCalls);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Test;  /**  * Test class for {@code CallableBackgroundInitializer}  */ public class CallableBackgroundInitializerTest  {     /** Constant for the result of the call() invocation. */     private static final Integer RESULT = Integer.valueOf(42);      /**      * Tries to create an instance without a Callable. This should cause an      * exception.      */     @Test()     public void testInitNullCallable() {         assertThrows(NullPointerException.class, () -> new CallableBackgroundInitializer<>(null));     }      /**      * Tests whether the executor service is correctly passed to the super      * class.      */     @Test     public void testInitExecutor() throws InterruptedException {         final ExecutorService exec = Executors.newSingleThreadExecutor();         final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<>(                 new TestCallable(), exec);         assertEquals(exec, init.getExternalExecutor(), "Executor not set");         exec.shutdown();         exec.awaitTermination(1, TimeUnit.SECONDS);     }      /**      * Tries to pass a null Callable to the constructor that takes an executor.      * This should cause an exception.      */     @Test     public void testInitExecutorNullCallable() throws InterruptedException {         final ExecutorService exec = Executors.newSingleThreadExecutor();         try {             assertThrows(NullPointerException.class, () -> new CallableBackgroundInitializer<Integer>(null, exec));         } finally {             exec.shutdown();             exec.awaitTermination(1, TimeUnit.SECONDS);         }      }      /**      * Tests the implementation of initialize().      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testInitialize() throws Exception {         final TestCallable call = new TestCallable();         final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<>(                 call);         assertEquals(RESULT, init.initialize(), "Wrong result");         assertEquals(1, call.callCount, "Wrong number of invocations");     }      /**      * A test Callable implementation for checking the initializer's      * implementation of the initialize() method.      */     private static class TestCallable implements Callable<Integer> {         /** A counter for the number of call() invocations. */         int callCount;          /**          * Records this invocation and returns the test result.          */         @Override         public Integer call() {             callCount++;             return RESULT;         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  import java.util.concurrent.CountDownLatch;  import org.junit.jupiter.api.Test;  /**  * <p>  * An abstract base class for tests of concrete {@code ConcurrentInitializer}  * implementations.  * </p>  * <p>  * This class provides some basic tests for initializer implementations. Derived  * class have to create a {@link ConcurrentInitializer} object on which the  * tests are executed.  * </p>  */ public abstract class AbstractConcurrentInitializerTest {     /**      * Tests a simple invocation of the get() method.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the object under test may throw it      */     @Test     public void testGet() throws ConcurrentException {         assertNotNull(createInitializer().get(), "No managed object");     }      /**      * Tests whether sequential get() invocations always return the same      * instance.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the object under test may throw it      */     @Test     public void testGetMultipleTimes() throws ConcurrentException {         final ConcurrentInitializer<Object> initializer = createInitializer();         final Object obj = initializer.get();         for (int i = 0; i < 10; i++) {             assertEquals(obj, initializer.get(), "Got different object at " + i);         }     }      /**      * Tests whether get() can be invoked from multiple threads concurrently.      * Always the same object should be returned.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the object under test may throw it      * @throws java.lang.InterruptedException because the threading API my throw it      */     @Test     public void testGetConcurrent() throws ConcurrentException,             InterruptedException {         final ConcurrentInitializer<Object> initializer = createInitializer();         final int threadCount = 20;         final CountDownLatch startLatch = new CountDownLatch(1);         class GetThread extends Thread {             Object object;              @Override             public void run() {                 try {                     // wait until all threads are ready for maximum parallelism                     startLatch.await();                     // access the initializer                     object = initializer.get();                 } catch (final InterruptedException iex) {                     // ignore                 } catch (final ConcurrentException cex) {                     object = cex;                 }             }         }          final GetThread[] threads = new GetThread[threadCount];         for (int i = 0; i < threadCount; i++) {             threads[i] = new GetThread();             threads[i].start();         }          // fire all threads and wait until they are ready         startLatch.countDown();         for (final Thread t : threads) {             t.join();         }          // check results         final Object managedObject = initializer.get();         for (final GetThread t : threads) {             assertEquals(managedObject, t.object, "Wrong object");         }     }      /**      * Creates the {@link ConcurrentInitializer} object to be tested. This      * method is called whenever the test fixture needs to be obtained.      *      * @return the initializer object to be tested      */     protected abstract ConcurrentInitializer<Object> createInitializer(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.regex.Pattern;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test class for {@code ConstantInitializer}.  */ public class ConstantInitializerTest {     /** Constant for the object managed by the initializer. */     private static final Integer VALUE = 42;      /** The initializer to be tested. */     private ConstantInitializer<Integer> init;      @BeforeEach     public void setUp() {         init = new ConstantInitializer<>(VALUE);     }      /**      * Helper method for testing equals() and hashCode().      *      * @param obj the object to compare with the test instance      * @param expected the expected result      */     private void checkEquals(final Object obj, final boolean expected) {         assertEquals(expected, init.equals(obj), "Wrong result of equals");         if (obj != null) {             assertEquals(expected, obj.equals(init), "Not symmetric");             if (expected) {                 assertEquals(init.hashCode(), obj.hashCode(), "Different hash codes");             }         }     }      /**      * Tests whether the correct object is returned.      */     @Test     public void testGetObject() {         assertEquals(VALUE, init.getObject(), "Wrong object");     }      /**      * Tests whether get() returns the correct object.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testGet() throws ConcurrentException {         assertEquals(VALUE, init.get(), "Wrong object");     }      /**      * Tests equals() if the expected result is true.      */     @Test     public void testEqualsTrue() {         checkEquals(init, true);         ConstantInitializer<Integer> init2 = new ConstantInitializer<>(                 Integer.valueOf(VALUE.intValue()));         checkEquals(init2, true);         init = new ConstantInitializer<>(null);         init2 = new ConstantInitializer<>(null);         checkEquals(init2, true);     }      /**      * Tests equals() if the expected result is false.      */     @Test     public void testEqualsFalse() {         ConstantInitializer<Integer> init2 = new ConstantInitializer<>(                 null);         checkEquals(init2, false);         init2 = new ConstantInitializer<>(VALUE + 1);         checkEquals(init2, false);     }      /**      * Tests equals() with objects of other classes.      */     @Test     public void testEqualsWithOtherObjects() {         checkEquals(null, false);         checkEquals(this, false);         checkEquals(new ConstantInitializer<>("Test"), false);     }      /**      * Tests the string representation.      */     @Test     public void testToString() {         final String s = init.toString();         final Pattern pattern = Pattern                 .compile("ConstantInitializer@-?\\d+ \\[ object = " + VALUE                         + " \\]");         assertTrue(pattern.matcher(s).matches(), "Wrong string: " + s);     }      /**      * Tests the string representation if the managed object is null.      */     @Test     public void testToStringNull() {         final String s = new ConstantInitializer<>(null).toString();         assertTrue(s.indexOf("object = null") > 0, "Object not found: " + s);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import org.junit.jupiter.api.BeforeEach;  /**  * Test class for {@code LazyInitializer}.  */ public class LazyInitializerTest extends AbstractConcurrentInitializerTest {     /** The initializer to be tested. */     private LazyInitializerTestImpl initializer;      @BeforeEach     public void setUp() {         initializer = new LazyInitializerTestImpl();     }      /**      * Returns the initializer to be tested. This implementation returns the      * {@code LazyInitializer} created in the {@code setUp()} method.      *      * @return the initializer to be tested      */     @Override     protected ConcurrentInitializer<Object> createInitializer() {         return initializer;     }      /**      * A test implementation of LazyInitializer. This class creates a plain      * Object. As Object does not provide a specific equals() method, it is easy      * to check whether multiple instances were created.      */     private static class LazyInitializerTestImpl extends             LazyInitializer<Object> {         @Override         protected Object initialize() {             return new Object();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Test class for {@code ThresholdCircuitBreaker}.  */ public class ThresholdCircuitBreakerTest {      /**      * Threshold used in tests.      */     private static final long threshold = 10L;      private static final long zeroThreshold = 0L;      /**      * Tests that the threshold is working as expected when incremented and no exception is thrown.      */     @Test     public void testThreshold() {         final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);         circuit.incrementAndCheckState(9L);         assertFalse(circuit.incrementAndCheckState(1L), "Circuit opened before reaching the threshold");     }      /**      * Tests that exceeding the threshold raises an exception.      */     @Test     public void testThresholdCircuitBreakingException() {         final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);         circuit.incrementAndCheckState(9L);         assertTrue(circuit.incrementAndCheckState(2L), "The circuit was supposed to be open after increment above the threshold");     }      /**      * Test that when threshold is zero, the circuit breaker is always open.      */     @Test     public void testThresholdEqualsZero() {         final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(zeroThreshold);         assertTrue(circuit.incrementAndCheckState(0L), "When the threshold is zero, the circuit is supposed to be always open");     }      /**      * Tests that closing a {@code ThresholdCircuitBreaker} resets the internal counter.      */     @Test     public void testClosingThresholdCircuitBreaker() {         final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);         circuit.incrementAndCheckState(9L);         circuit.close();         // now the internal counter is back at zero, not 9 anymore. So it is safe to increment 9 again         assertFalse(circuit.incrementAndCheckState(9L), "Internal counter was not reset back to zero");     }      /**      * Tests that we can get the threshold value correctly.      */     @Test     public void testGettingThreshold() {         final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);         assertEquals(Long.valueOf(threshold), Long.valueOf(circuit.getThreshold()), "Wrong value of threshold");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent.locks;  import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.function.LongConsumer;  import org.apache.commons.lang3.concurrent.locks.LockingVisitors.LockVisitor; import org.apache.commons.lang3.concurrent.locks.LockingVisitors.StampedLockVisitor; import org.apache.commons.lang3.function.FailableConsumer; import org.junit.jupiter.api.Test;  public class LockingVisitorsTest {      private static final long DELAY_MILLIS = 1500;     private static final int NUMBER_OF_THREADS = 10;     private static final long TOTAL_DELAY_MILLIS = NUMBER_OF_THREADS * DELAY_MILLIS;      protected boolean containsTrue(final boolean[] booleanArray) {         synchronized (booleanArray) {             for (final boolean element : booleanArray) {                 if (element) {                     return true;                 }             }             return false;         }     }      private void runTest(final long delayMillis, final boolean exclusiveLock, final LongConsumer runTimeCheck,         final boolean[] booleanValues, final LockVisitor<boolean[], ?> visitor) throws InterruptedException {         final boolean[] runningValues = new boolean[10];          final long startTime = System.currentTimeMillis();         for (int i = 0; i < booleanValues.length; i++) {             final int index = i;             final FailableConsumer<boolean[], ?> consumer = b -> {                 b[index] = false;                 Thread.sleep(delayMillis);                 b[index] = true;                 set(runningValues, index, false);             };             final Thread t = new Thread(() -> {                 if (exclusiveLock) {                     visitor.acceptWriteLocked(consumer);                 } else {                     visitor.acceptReadLocked(consumer);                 }             });             set(runningValues, i, true);             t.start();         }         while (containsTrue(runningValues)) {             Thread.sleep(100);         }         final long endTime = System.currentTimeMillis();         for (final boolean booleanValue : booleanValues) {             assertTrue(booleanValue);         }         // WRONG assumption         // runTimeCheck.accept(endTime - startTime);     }      protected void set(final boolean[] booleanArray, final int offset, final boolean value) {         synchronized (booleanArray) {             booleanArray[offset] = value;         }     }      @Test     public void testReentrantReadWriteLockExclusive() throws Exception {          /*          * If our threads are running concurrently, then we expect to be no faster than running one after the other.          */         final boolean[] booleanValues = new boolean[10];         runTest(DELAY_MILLIS, true, l -> assertTrue(l >= TOTAL_DELAY_MILLIS), booleanValues,             LockingVisitors.reentrantReadWriteLockVisitor(booleanValues));     }      @Test     public void testReentrantReadWriteLockNotExclusive() throws Exception {          /*          * If our threads are running concurrently, then we expect to be faster than running one after the other.          */         final boolean[] booleanValues = new boolean[10];         runTest(DELAY_MILLIS, false, l -> assertTrue(l < TOTAL_DELAY_MILLIS), booleanValues,             LockingVisitors.reentrantReadWriteLockVisitor(booleanValues));     }      @Test     public void testResultValidation() {         final Object hidden = new Object();         final StampedLockVisitor<Object> lock = LockingVisitors.stampedLockVisitor(hidden);         final Object o1 = lock.applyReadLocked(h -> new Object());         assertNotNull(o1);         assertNotSame(hidden, o1);         final Object o2 = lock.applyWriteLocked(h -> new Object());         assertNotNull(o2);         assertNotSame(hidden, o2);     }      @Test     public void testStampedLockExclusive() throws Exception {          /*          * If our threads are running concurrently, then we expect to be no faster than running one after the other.          */         final boolean[] booleanValues = new boolean[10];         runTest(DELAY_MILLIS, true, l -> assertTrue(l >= TOTAL_DELAY_MILLIS), booleanValues,             LockingVisitors.stampedLockVisitor(booleanValues));     }      @Test     public void testStampedLockNotExclusive() throws Exception {          /*          * If our threads are running concurrently, then we expect to be faster than running one after the other.          */         final boolean[] booleanValues = new boolean[10];         runTest(DELAY_MILLIS, false, l -> assertTrue(l < TOTAL_DELAY_MILLIS), booleanValues,             LockingVisitors.stampedLockVisitor(booleanValues));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.util.ArrayList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Test;  /**  * Test class for {@code EventCountCircuitBreaker}.  */ public class EventCountCircuitBreakerTest {     /** Constant for the opening threshold. */     private static final int OPENING_THRESHOLD = 10;      /** Constant for the closing threshold. */     private static final int CLOSING_THRESHOLD = 5;      /** Constant for the factor for converting nanoseconds. */     private static final long NANO_FACTOR = 1000L * 1000L * 1000L;      /**      * Tests that time units are correctly taken into account by constructors.      */     @Test     public void testIntervalCalculation() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 2, TimeUnit.MILLISECONDS);         assertEquals(NANO_FACTOR, breaker.getOpeningInterval(), "Wrong opening interval");         assertEquals(2 * NANO_FACTOR / 1000, breaker.getClosingInterval(), "Wrong closing interval");     }      /**      * Tests that the closing interval is the same as the opening interval if it is not      * specified.      */     @Test     public void testDefaultClosingInterval() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS, CLOSING_THRESHOLD);         assertEquals(NANO_FACTOR, breaker.getClosingInterval(), "Wrong closing interval");     }      /**      * Tests that the closing threshold is the same as the opening threshold if not      * specified otherwise.      */     @Test     public void testDefaultClosingThreshold() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         assertEquals(NANO_FACTOR, breaker.getClosingInterval(), "Wrong closing interval");         assertEquals(OPENING_THRESHOLD, breaker.getClosingThreshold(), "Wrong closing threshold");     }      /**      * Tests that a circuit breaker is closed after its creation.      */     @Test     public void testInitiallyClosed() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         assertFalse(breaker.isOpen(), "Open");         assertTrue(breaker.isClosed(), "Not closed");     }      /**      * Tests whether the current time is correctly determined.      */     @Test     public void testNow() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         final long nowNanos = breaker.now();         final long deltaNanos = Math.abs(System.nanoTime() - nowNanos);         assertTrue(deltaNanos < 100_000, String.format("Delta %,d ns to current time too large", deltaNanos));     }      /**      * Tests that the circuit breaker stays closed if the number of received events stays      * below the threshold.      */     @Test     public void testNotOpeningUnderThreshold() {         long startTime = 1000;         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         for (int i = 0; i < OPENING_THRESHOLD - 1; i++) {             assertTrue(breaker.at(startTime).incrementAndCheckState(), "In open state");             startTime++;         }         assertTrue(breaker.isClosed(), "Not closed");     }      /**      * Tests that the circuit breaker stays closed if there are a number of received      * events, but not in a single check interval.      */     @Test     public void testNotOpeningCheckIntervalExceeded() {         long startTime = 0L;         final long timeIncrement = 3 * NANO_FACTOR / (2 * OPENING_THRESHOLD);         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         for (int i = 0; i < 5 * OPENING_THRESHOLD; i++) {             assertTrue(breaker.at(startTime).incrementAndCheckState(), "In open state");             startTime += timeIncrement;         }         assertTrue(breaker.isClosed(), "Not closed");     }      /**      * Tests that the circuit breaker opens if all conditions are met.      */     @Test     public void testOpeningWhenThresholdReached() {         long startTime = 0;         final long timeIncrement = NANO_FACTOR / OPENING_THRESHOLD - 1;         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         boolean open = false;         for (int i = 0; i < OPENING_THRESHOLD + 1; i++) {             open = !breaker.at(startTime).incrementAndCheckState();             startTime += timeIncrement;         }         assertTrue(open, "Not open");         assertFalse(breaker.isClosed(), "Closed");     }      /**      * Tests that the circuit breaker opens if all conditions are met when using      * {@link EventCountCircuitBreaker#incrementAndCheckState(Integer increment)}.      */     @Test     public void testOpeningWhenThresholdReachedThroughBatch() {         final long timeIncrement = NANO_FACTOR / OPENING_THRESHOLD - 1;         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 1,             TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         final long startTime = timeIncrement * (OPENING_THRESHOLD + 1);         final boolean open = !breaker.at(startTime).incrementAndCheckState(OPENING_THRESHOLD + 1);         assertTrue(open, "Not open");         assertFalse(breaker.isClosed(), "Closed");     }      /**      * Tests that an open circuit breaker does not close itself when the number of events      * received is over the threshold.      */     @Test     public void testNotClosingOverThreshold() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD,                 10, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         long startTime = 0;         breaker.open();         for (int i = 0; i <= CLOSING_THRESHOLD; i++) {             assertFalse(breaker.at(startTime).incrementAndCheckState(), "Not open");             startTime += 1000;         }         assertFalse(breaker.at(startTime + NANO_FACTOR).incrementAndCheckState(), "Closed in new interval");         assertTrue(breaker.isOpen(), "Not open at end");     }      /**      * Tests that the circuit breaker closes automatically if the number of events      * received goes under the closing threshold.      */     @Test     public void testClosingWhenThresholdReached() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD,                 10, TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         breaker.open();         breaker.at(1000).incrementAndCheckState();         assertFalse(breaker.at(2000).checkState(), "Already closed");         assertFalse(breaker.at(NANO_FACTOR).checkState(), "Closed at interval end");         assertTrue(breaker.at(NANO_FACTOR + 1).checkState(), "Not closed after interval end");         assertTrue(breaker.isClosed(), "Not closed at end");     }      /**      * Tests whether an explicit open operation fully initializes the internal check data      * object. Otherwise, the circuit breaker may close itself directly afterwards.      */     @Test     public void testOpenStartsNewCheckInterval() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         breaker.at(NANO_FACTOR - 1000).open();         assertTrue(breaker.isOpen(), "Not open");         assertFalse(breaker.at(NANO_FACTOR + 100).checkState(), "Already closed");     }      /**      * Tests whether a new check interval is started if the circuit breaker has a      * transition to open state.      */     @Test     public void testAutomaticOpenStartsNewCheckInterval() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         long time = 10 * NANO_FACTOR;         for (int i = 0; i <= OPENING_THRESHOLD; i++) {             breaker.at(time++).incrementAndCheckState();         }         assertTrue(breaker.isOpen(), "Not open");         time += NANO_FACTOR - 1000;         assertFalse(breaker.at(time).incrementAndCheckState(), "Already closed");         time += 1001;         assertTrue(breaker.at(time).checkState(), "Not closed in time interval");     }      /**      * Tests whether the circuit breaker can be closed explicitly.      */     @Test     public void testClose() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         long time = 0;         for (int i = 0; i <= OPENING_THRESHOLD; i++, time += 1000) {             breaker.at(time).incrementAndCheckState();         }         assertTrue(breaker.isOpen(), "Not open");         breaker.close();         assertTrue(breaker.isClosed(), "Not closed");         assertTrue(breaker.at(time + 1000).incrementAndCheckState(), "Open again");     }      /**      * Tests whether events are generated when the state is changed.      */     @Test     public void testChangeEvents() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         final ChangeListener listener = new ChangeListener(breaker);         breaker.addChangeListener(listener);         breaker.open();         breaker.close();         listener.verify(Boolean.TRUE, Boolean.FALSE);     }      /**      * Tests whether a change listener can be removed.      */     @Test     public void testRemoveChangeListener() {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         final ChangeListener listener = new ChangeListener(breaker);         breaker.addChangeListener(listener);         breaker.open();         breaker.removeChangeListener(listener);         breaker.close();         listener.verify(Boolean.TRUE);     }      /**      * Tests that a state transition triggered by multiple threads is handled correctly.      * Only the first transition should cause an event to be sent.      */     @Test     public void testStateTransitionGuarded() throws InterruptedException {         final EventCountCircuitBreaker breaker = new EventCountCircuitBreaker(OPENING_THRESHOLD, 1,                 TimeUnit.SECONDS);         final ChangeListener listener = new ChangeListener(breaker);         breaker.addChangeListener(listener);          final int threadCount = 128;         final CountDownLatch latch = new CountDownLatch(1);         final Thread[] threads = new Thread[threadCount];         for (int i = 0; i < threadCount; i++) {             threads[i] = new Thread() {                 @Override                 public void run() {                     try {                         latch.await();                     } catch (final InterruptedException iex) {                         // ignore                     }                     breaker.open();                 }             };             threads[i].start();         }         latch.countDown();         for (final Thread thread : threads) {             thread.join();         }         listener.verify(Boolean.TRUE);     }      /**      * Tests that automatic state transitions generate change events as well.      */     @Test     public void testChangeEventsGeneratedByAutomaticTransitions() {         final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2,                 TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);         final ChangeListener listener = new ChangeListener(breaker);         breaker.addChangeListener(listener);         long time = 0;         for (int i = 0; i <= OPENING_THRESHOLD; i++, time += 1000) {             breaker.at(time).incrementAndCheckState();         }         breaker.at(NANO_FACTOR + 1).checkState();         breaker.at(3 * NANO_FACTOR).checkState();         listener.verify(Boolean.TRUE, Boolean.FALSE);     }      /**      * A test implementation of {@code EventCountCircuitBreaker} which supports mocking the timer.      * This is useful for the creation of deterministic tests for switching the circuit      * breaker's state.      */     private static class EventCountCircuitBreakerTestImpl extends EventCountCircuitBreaker {         /** The current time in nanoseconds. */         private long currentTime;          EventCountCircuitBreakerTestImpl(final int openingThreshold, final long openingInterval,                                                 final TimeUnit openingUnit, final int closingThreshold, final long closingInterval,                                                 final TimeUnit closingUnit) {             super(openingThreshold, openingInterval, openingUnit, closingThreshold,                     closingInterval, closingUnit);         }          /**          * Sets the current time to be used by this test object for the next operation.          *          * @param time the time to set          * @return a reference to this object          */         public EventCountCircuitBreakerTestImpl at(final long time) {             currentTime = time;             return this;         }          /**          * {@inheritDoc} This implementation returns the value passed to the {@code at()}          * method.          */         @Override         long now() {             return currentTime;         }     }      /**      * A test change listener for checking whether correct change events are generated.      */     private static class ChangeListener implements PropertyChangeListener {         /** The expected event source. */         private final Object expectedSource;          /** A list with the updated values extracted from received change events. */         private final List<Boolean> changedValues;          /**          * Creates a new instance of {@code ChangeListener} and sets the expected event          * source.          *          * @param source the expected event source          */         ChangeListener(final Object source) {             expectedSource = source;             changedValues = new ArrayList<>();         }          @Override         public void propertyChange(final PropertyChangeEvent evt) {             assertEquals(expectedSource, evt.getSource(), "Wrong event source");             assertEquals("open", evt.getPropertyName(), "Wrong property name");             final Boolean newValue = (Boolean) evt.getNewValue();             final Boolean oldValue = (Boolean) evt.getOldValue();             assertNotEquals(newValue, oldValue, "Old and new value are equal");             changedValues.add(newValue);         }          /**          * Verifies that change events for the expected values have been received.          *          * @param values the expected values          */         public void verify(final Boolean... values) {             assertArrayEquals(values,                     changedValues.toArray(new Boolean[0]));         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit;  import org.easymock.EasyMock; import org.junit.jupiter.api.Test;  /**  * Test class for {@link ConcurrentUtils}.  */ public class ConcurrentUtilsTest {     /**      * Tests creating a ConcurrentException with a runtime exception as cause.      */     @Test     public void testConcurrentExceptionCauseUnchecked() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentException(new RuntimeException()));     }      /**      * Tests creating a ConcurrentException with an error as cause.      */     @Test     public void testConcurrentExceptionCauseError() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentException("An error", new Error()));     }      /**      * Tests creating a ConcurrentException with null as cause.      */     @Test     public void testConcurrentExceptionCauseNull() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentException(null));     }      /**      * Tries to create a ConcurrentRuntimeException with a runtime as cause.      */     @Test     public void testConcurrentRuntimeExceptionCauseUnchecked() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentRuntimeException(new RuntimeException()));     }      /**      * Tries to create a ConcurrentRuntimeException with an error as cause.      */     @Test     public void testConcurrentRuntimeExceptionCauseError() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentRuntimeException("An error", new Error()));     }      /**      * Tries to create a ConcurrentRuntimeException with null as cause.      */     @Test     public void testConcurrentRuntimeExceptionCauseNull() {         assertThrows(IllegalArgumentException.class, () -> new ConcurrentRuntimeException(null));     }      /**      * Tests extractCause() for a null exception.      */     @Test     public void testExtractCauseNull() {         assertNull(ConcurrentUtils.extractCause(null), "Non null result");     }      /**      * Tests extractCause() if the cause of the passed in exception is null.      */     @Test     public void testExtractCauseNullCause() {         assertNull(ConcurrentUtils.extractCause(new ExecutionException("Test", null)), "Non null result");     }      /**      * Tests extractCause() if the cause is an error.      */     @Test     public void testExtractCauseError() {         final Error err = new AssertionError("Test");         final AssertionError e =                 assertThrows(AssertionError.class, () -> ConcurrentUtils.extractCause(new ExecutionException(err)));         assertEquals(err, e, "Wrong error");     }      /**      * Tests extractCause() if the cause is an unchecked exception.      */     @Test     public void testExtractCauseUncheckedException() {         final RuntimeException rex = new RuntimeException("Test");         assertThrows(RuntimeException.class, () -> ConcurrentUtils.extractCause(new ExecutionException(rex)));     }      /**      * Tests extractCause() if the cause is a checked exception.      */     @Test     public void testExtractCauseChecked() {         final Exception ex = new Exception("Test");         final ConcurrentException cex = ConcurrentUtils                 .extractCause(new ExecutionException(ex));         assertSame(ex, cex.getCause(), "Wrong cause");     }      /**      * Tests extractCauseUnchecked() for a null exception.      */     @Test     public void testExtractCauseUncheckedNull() {         assertNull(ConcurrentUtils.extractCauseUnchecked(null), "Non null result");     }      /**      * Tests extractCauseUnchecked() if the cause of the passed in exception is null.      */     @Test     public void testExtractCauseUncheckedNullCause() {         assertNull(ConcurrentUtils.extractCauseUnchecked(new ExecutionException("Test", null)), "Non null result");     }      /**      * Tests extractCauseUnchecked() if the cause is an error.      */     @Test     public void testExtractCauseUncheckedError() {         final Error err = new AssertionError("Test");         final Error e = assertThrows(Error.class, () -> ConcurrentUtils.extractCauseUnchecked(new ExecutionException(err)));         assertEquals(err, e, "Wrong error");     }      /**      * Tests extractCauseUnchecked() if the cause is an unchecked exception.      */     @Test     public void testExtractCauseUncheckedUncheckedException() {         final RuntimeException rex = new RuntimeException("Test");         final RuntimeException r =                 assertThrows(RuntimeException.class, () -> ConcurrentUtils.extractCauseUnchecked(new ExecutionException(rex)));         assertEquals(rex, r, "Wrong exception");     }      /**      * Tests extractCauseUnchecked() if the cause is a checked exception.      */     @Test     public void testExtractCauseUncheckedChecked() {         final Exception ex = new Exception("Test");         final ConcurrentRuntimeException cex = ConcurrentUtils                 .extractCauseUnchecked(new ExecutionException(ex));         assertSame(ex, cex.getCause(), "Wrong cause");     }      /**      * Tests handleCause() if the cause is an error.      */     @Test     public void testHandleCauseError() {         final Error err = new AssertionError("Test");         final Error e = assertThrows(Error.class, () -> ConcurrentUtils.handleCause(new ExecutionException(err)));         assertEquals(err, e, "Wrong error");     }      /**      * Tests handleCause() if the cause is an unchecked exception.      */     @Test     public void testHandleCauseUncheckedException() {         final RuntimeException rex = new RuntimeException("Test");         final RuntimeException r =                 assertThrows(RuntimeException.class, () -> ConcurrentUtils.handleCause(new ExecutionException(rex)));         assertEquals(rex, r, "Wrong exception");     }      /**      * Tests handleCause() if the cause is a checked exception.      */     @Test     public void testHandleCauseChecked() {         final Exception ex = new Exception("Test");         final ConcurrentException cex =                 assertThrows(ConcurrentException.class, () -> ConcurrentUtils.handleCause(new ExecutionException(ex)));         assertEquals(ex, cex.getCause(), "Wrong cause");     }      /**      * Tests handleCause() for a null parameter or a null cause. In this case      * the method should do nothing. We can only test that no exception is      * thrown.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testHandleCauseNull() throws ConcurrentException {         ConcurrentUtils.handleCause(null);         ConcurrentUtils.handleCause(new ExecutionException("Test", null));     }      /**      * Tests handleCauseUnchecked() if the cause is an error.      */     @Test     public void testHandleCauseUncheckedError() {         final Error err = new AssertionError("Test");         final Error e = assertThrows(Error.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(err)));         assertEquals(err, e, "Wrong error");     }      /**      * Tests handleCauseUnchecked() if the cause is an unchecked exception.      */     @Test     public void testHandleCauseUncheckedUncheckedException() {         final RuntimeException rex = new RuntimeException("Test");         final RuntimeException r =                 assertThrows(RuntimeException.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(rex)));         assertEquals(rex, r, "Wrong exception");     }      /**      * Tests handleCauseUnchecked() if the cause is a checked exception.      */     @Test     public void testHandleCauseUncheckedChecked() {         final Exception ex = new Exception("Test");         final ConcurrentRuntimeException crex =                 assertThrows(ConcurrentRuntimeException.class, () -> ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex)));         assertEquals(ex, crex.getCause(), "Wrong cause");     }      /**      * Tests handleCauseUnchecked() for a null parameter or a null cause. In      * this case the method should do nothing. We can only test that no      * exception is thrown.      */     @Test     public void testHandleCauseUncheckedNull() {         ConcurrentUtils.handleCauseUnchecked(null);         ConcurrentUtils.handleCauseUnchecked(new ExecutionException("Test",                 null));     }      //-----------------------------------------------------------------------     /**      * Tests initialize() for a null argument.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeNull() throws ConcurrentException {         assertNull(ConcurrentUtils.initialize(null), "Got a result");     }      /**      * Tests a successful initialize() operation.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitialize() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Object> init = EasyMock                 .createMock(ConcurrentInitializer.class);         final Object result = new Object();         EasyMock.expect(init.get()).andReturn(result);         EasyMock.replay(init);         assertSame(result, ConcurrentUtils.initialize(init), "Wrong result object");         EasyMock.verify(init);     }      /**      * Tests initializeUnchecked() for a null argument.      */     @Test     public void testInitializeUncheckedNull() {         assertNull(ConcurrentUtils.initializeUnchecked(null), "Got a result");     }      /**      * Tests creating ConcurrentRuntimeException with no arguments.      */     @Test     public void testUninitializedConcurrentRuntimeException() {         assertNotNull(new ConcurrentRuntimeException(), "Error creating empty ConcurrentRuntimeException");     }      /**      * Tests a successful initializeUnchecked() operation.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeUnchecked() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Object> init = EasyMock                 .createMock(ConcurrentInitializer.class);         final Object result = new Object();         EasyMock.expect(init.get()).andReturn(result);         EasyMock.replay(init);         assertSame(result, ConcurrentUtils.initializeUnchecked(init), "Wrong result object");         EasyMock.verify(init);     }      /**      * Tests whether exceptions are correctly handled by initializeUnchecked().      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeUncheckedEx() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Object> init = EasyMock                 .createMock(ConcurrentInitializer.class);         final Exception cause = new Exception();         EasyMock.expect(init.get()).andThrow(new ConcurrentException(cause));         EasyMock.replay(init);         final ConcurrentRuntimeException crex =                 assertThrows(ConcurrentRuntimeException.class, () -> ConcurrentUtils.initializeUnchecked(init));         assertSame(cause, crex.getCause(), "Wrong cause");         EasyMock.verify(init);     }      //-----------------------------------------------------------------------     /**      * Tests constant future.      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testConstantFuture_Integer() throws Exception {         final Integer value = Integer.valueOf(5);         final Future<Integer> test = ConcurrentUtils.constantFuture(value);         assertTrue(test.isDone());         assertSame(value, test.get());         assertSame(value, test.get(1000, TimeUnit.SECONDS));         assertSame(value, test.get(1000, null));         assertFalse(test.isCancelled());         assertFalse(test.cancel(true));         assertFalse(test.cancel(false));     }      /**      * Tests constant future.      *      * @throws java.lang.Exception so we don't have to catch it      */     @Test     public void testConstantFuture_null() throws Exception {         final Integer value = null;         final Future<Integer> test = ConcurrentUtils.constantFuture(value);         assertTrue(test.isDone());         assertSame(value, test.get());         assertSame(value, test.get(1000, TimeUnit.SECONDS));         assertSame(value, test.get(1000, null));         assertFalse(test.isCancelled());         assertFalse(test.cancel(true));         assertFalse(test.cancel(false));     }      //-----------------------------------------------------------------------     /**      * Tests putIfAbsent() if the map contains the key in question.      */     @Test     public void testPutIfAbsentKeyPresent() {         final String key = "testKey";         final Integer value = 42;         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         map.put(key, value);         assertEquals(value, ConcurrentUtils.putIfAbsent(map, key, 0), "Wrong result");         assertEquals(value, map.get(key), "Wrong value in map");     }      /**      * Tests putIfAbsent() if the map does not contain the key in question.      */     @Test     public void testPutIfAbsentKeyNotPresent() {         final String key = "testKey";         final Integer value = 42;         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         assertEquals(value, ConcurrentUtils.putIfAbsent(map, key, value), "Wrong result");         assertEquals(value, map.get(key), "Wrong value in map");     }      /**      * Tests putIfAbsent() if a null map is passed in.      */     @Test     public void testPutIfAbsentNullMap() {         assertNull(ConcurrentUtils.putIfAbsent(null, "test", 100), "Wrong result");     }      /**      * Tests createIfAbsent() if the key is found in the map.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testCreateIfAbsentKeyPresent() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Integer> init = EasyMock                 .createMock(ConcurrentInitializer.class);         EasyMock.replay(init);         final String key = "testKey";         final Integer value = 42;         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         map.put(key, value);         assertEquals(value, ConcurrentUtils.createIfAbsent(map, key, init), "Wrong result");         assertEquals(value, map.get(key), "Wrong value in map");         EasyMock.verify(init);     }      /**      * Tests createIfAbsent() if the map does not contain the key in question.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testCreateIfAbsentKeyNotPresent() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Integer> init = EasyMock                 .createMock(ConcurrentInitializer.class);         final String key = "testKey";         final Integer value = 42;         EasyMock.expect(init.get()).andReturn(value);         EasyMock.replay(init);         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         assertEquals(value, ConcurrentUtils.createIfAbsent(map, key, init), "Wrong result");         assertEquals(value, map.get(key), "Wrong value in map");         EasyMock.verify(init);     }      /**      * Tests createIfAbsent() if a null map is passed in.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testCreateIfAbsentNullMap() throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Integer> init = EasyMock                 .createMock(ConcurrentInitializer.class);         EasyMock.replay(init);         assertNull(ConcurrentUtils.createIfAbsent(null, "test", init), "Wrong result");         EasyMock.verify(init);     }      /**      * Tests createIfAbsent() if a null initializer is passed in.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testCreateIfAbsentNullInit() throws ConcurrentException {         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         final String key = "testKey";         final Integer value = 42;         map.put(key, value);         assertNull(ConcurrentUtils.createIfAbsent(map, key, null), "Wrong result");         assertEquals(value, map.get(key), "Map was changed");     }      /**      * Tests createIfAbsentUnchecked() if no exception is thrown.      */     @Test     public void testCreateIfAbsentUncheckedSuccess() {         final String key = "testKey";         final Integer value = 42;         final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<>();         assertEquals(value, ConcurrentUtils.createIfAbsentUnchecked(map, key, new ConstantInitializer<>(value)),                 "Wrong result");         assertEquals(value, map.get(key), "Wrong value in map");     }      /**      * Tests createIfAbsentUnchecked() if an exception is thrown.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testCreateIfAbsentUncheckedException()             throws ConcurrentException {         @SuppressWarnings("unchecked")         final         ConcurrentInitializer<Integer> init = EasyMock                 .createMock(ConcurrentInitializer.class);         final Exception ex = new Exception();         EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex));         EasyMock.replay(init);         final ConcurrentRuntimeException crex =                 assertThrows(                         ConcurrentRuntimeException.class,                         () -> ConcurrentUtils.createIfAbsentUnchecked(new ConcurrentHashMap<>(), "test", init));         assertEquals(ex, crex.getCause(), "Wrong cause");         EasyMock.verify(init);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.concurrent.atomic.AtomicInteger;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test class for {@code AtomicSafeInitializer}.  */ public class AtomicSafeInitializerTest extends         AbstractConcurrentInitializerTest {     /** The instance to be tested. */     private AtomicSafeInitializerTestImpl initializer;      @BeforeEach     public void setUp() {         initializer = new AtomicSafeInitializerTestImpl();     }      /**      * Returns the initializer to be tested.      *      * @return the {@code AtomicSafeInitializer} under test      */     @Override     protected ConcurrentInitializer<Object> createInitializer() {         return initializer;     }      /**      * Tests that initialize() is called only once.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because {@link #testGetConcurrent()} may throw it      * @throws java.lang.InterruptedException because {@link #testGetConcurrent()} may throw it      */     @Test     public void testNumberOfInitializeInvocations() throws ConcurrentException,             InterruptedException {         testGetConcurrent();         assertEquals(1, initializer.initCounter.get(), "Wrong number of invocations");     }      /**      * A concrete test implementation of {@code AtomicSafeInitializer}. This      * implementation also counts the number of invocations of the initialize()      * method.      */     private static class AtomicSafeInitializerTestImpl extends             AtomicSafeInitializer<Object> {         /** A counter for initialize() invocations. */         final AtomicInteger initCounter = new AtomicInteger();          @Override         protected Object initialize() {             initCounter.incrementAndGet();             return new Object();         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.concurrent.ThreadFactory;  import org.easymock.EasyMock; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test class for {@code BasicThreadFactory}.  */ public class BasicThreadFactoryTest {     /** Constant for the test naming pattern. */     private static final String PATTERN = "testThread-%d";      /** The builder for creating a thread factory. */     private BasicThreadFactory.Builder builder;      @BeforeEach     public void setUp() {         builder = new BasicThreadFactory.Builder();     }      /**      * Tests the default options of a thread factory.      *      * @param factory the factory to be checked      */     private void checkFactoryDefaults(final BasicThreadFactory factory) {         assertNull(factory.getNamingPattern(), "Got a naming pattern");         assertNull(factory.getUncaughtExceptionHandler(), "Got an exception handler");         assertNull(factory.getPriority(), "Got a priority");         assertNull(factory.getDaemonFlag(), "Got a daemon flag");         assertNotNull(factory.getWrappedFactory(), "No wrapped factory");     }      /**      * Tests the default values used by the builder.      */     @Test     public void testBuildDefaults() {         final BasicThreadFactory factory = builder.build();         checkFactoryDefaults(factory);     }      /**      * Tries to set a null naming pattern.      */     @Test     public void testBuildNamingPatternNull() {         assertThrows(NullPointerException.class, () -> builder.namingPattern(null));     }      /**      * Tries to set a null wrapped factory.      */     @Test     public void testBuildWrappedFactoryNull() {         assertThrows(NullPointerException.class, () -> builder.wrappedFactory(null));     }      /**      * Tries to set a null exception handler.      */     @Test     public void testBuildUncaughtExceptionHandlerNull() {         assertThrows(NullPointerException.class, () -> builder.uncaughtExceptionHandler(null));     }      /**      * Tests the reset() method of the builder.      */     @Test     public void testBuilderReset() {         final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class);         final Thread.UncaughtExceptionHandler exHandler = EasyMock                 .createMock(Thread.UncaughtExceptionHandler.class);         EasyMock.replay(wrappedFactory, exHandler);         builder.namingPattern(PATTERN).daemon(true).priority(                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler)                 .wrappedFactory(wrappedFactory);         builder.reset();         final BasicThreadFactory factory = builder.build();         checkFactoryDefaults(factory);         assertNotSame(wrappedFactory, factory.getWrappedFactory(), "Wrapped factory not reset");         EasyMock.verify(wrappedFactory, exHandler);     }      /**      * Tests whether reset() is automatically called after build().      */     @Test     public void testBuilderResetAfterBuild() {         builder.wrappedFactory(EasyMock.createNiceMock(ThreadFactory.class))                 .namingPattern(PATTERN).daemon(true).build();         checkFactoryDefaults(builder.build());     }      /**      * Tests whether the naming pattern is applied to new threads.      */     @Test     public void testNewThreadNamingPattern() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final int count = 12;         for (int i = 0; i < count; i++) {             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread());         }         EasyMock.replay(wrapped, r);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped)                 .namingPattern(PATTERN).build();         for (int i = 0; i < count; i++) {             final Thread t = factory.newThread(r);             assertEquals(String.format(PATTERN, Long.valueOf(i + 1)), t.getName(), "Wrong thread name");             assertEquals(i + 1, factory.getThreadCount(), "Wrong thread count");         }         EasyMock.verify(wrapped, r);     }      /**      * Tests whether the thread name is not modified if no naming pattern is      * set.      */     @Test     public void testNewThreadNoNamingPattern() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final String name = "unchangedThreadName";         final Thread t = new Thread(name);         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(name, t.getName(), "Name was changed");         EasyMock.verify(wrapped, r);     }      /**      * Helper method for testing whether the daemon flag is taken into account.      *      * @param flag the value of the flag      */     private void checkDaemonFlag(final boolean flag) {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final Thread t = new Thread();         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon(                 flag).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(flag, t.isDaemon(), "Wrong daemon flag");         EasyMock.verify(wrapped, r);     }      /**      * Tests whether daemon threads can be created.      */     @Test     public void testNewThreadDaemonTrue() {         checkDaemonFlag(true);     }      /**      * Tests whether the daemon status of new threads can be turned off.      */     @Test     public void testNewThreadDaemonFalse() {         checkDaemonFlag(false);     }      /**      * Tests whether the daemon flag is not touched on newly created threads if      * it is not specified.      */     @Test     public void testNewThreadNoDaemonFlag() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r1 = EasyMock.createMock(Runnable.class);         final Runnable r2 = EasyMock.createMock(Runnable.class);         final Thread t1 = new Thread();         final Thread t2 = new Thread();         t1.setDaemon(true);         EasyMock.expect(wrapped.newThread(r1)).andReturn(t1);         EasyMock.expect(wrapped.newThread(r2)).andReturn(t2);         EasyMock.replay(wrapped, r1, r2);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();         assertSame(t1, factory.newThread(r1), "Wrong thread 1");         assertTrue(t1.isDaemon(), "No daemon thread");         assertSame(t2, factory.newThread(r2), "Wrong thread 2");         assertFalse(t2.isDaemon(), "A daemon thread");         EasyMock.verify(wrapped, r1, r2);     }      /**      * Tests whether the priority is set on newly created threads.      */     @Test     public void testNewThreadPriority() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final Thread t = new Thread();         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r);         final int priority = Thread.NORM_PRIORITY + 1;         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority(                 priority).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(priority, t.getPriority(), "Wrong priority");         EasyMock.verify(wrapped, r);     }      /**      * Tests whether the original priority is not changed if no priority is      * specified.      */     @Test     public void testNewThreadNoPriority() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final int orgPriority = Thread.NORM_PRIORITY + 1;         final Thread t = new Thread();         t.setPriority(orgPriority);         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(orgPriority, t.getPriority(), "Wrong priority");         EasyMock.verify(wrapped, r);     }      /**      * Tests whether the exception handler is set if one is provided.      */     @Test     public void testNewThreadExHandler() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final Thread.UncaughtExceptionHandler handler = EasyMock                 .createMock(Thread.UncaughtExceptionHandler.class);         final Thread t = new Thread();         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r, handler);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped)                 .uncaughtExceptionHandler(handler).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(handler, t.getUncaughtExceptionHandler(), "Wrong exception handler");         EasyMock.verify(wrapped, r, handler);     }      /**      * Tests whether the original exception handler is not touched if none is      * specified.      */     @Test     public void testNewThreadNoExHandler() {         final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);         final Runnable r = EasyMock.createMock(Runnable.class);         final Thread.UncaughtExceptionHandler handler = EasyMock                 .createMock(Thread.UncaughtExceptionHandler.class);         final Thread t = new Thread();         t.setUncaughtExceptionHandler(handler);         EasyMock.expect(wrapped.newThread(r)).andReturn(t);         EasyMock.replay(wrapped, r, handler);         final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();         assertSame(t, factory.newThread(r), "Wrong thread");         assertEquals(handler, t.getUncaughtExceptionHandler(), "Wrong exception handler");         EasyMock.verify(wrapped, r, handler);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Iterator; import java.util.NoSuchElementException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test class for {@link MultiBackgroundInitializer}.  */ public class MultiBackgroundInitializerTest {     /** Constant for the names of the child initializers. */     private static final String CHILD_INIT = "childInitializer";      /** The initializer to be tested. */     private MultiBackgroundInitializer initializer;      @BeforeEach     public void setUp() {         initializer = new MultiBackgroundInitializer();     }      /**      * Tests whether a child initializer has been executed. Optionally the      * expected executor service can be checked, too.      *      * @param child the child initializer      * @param expExec the expected executor service (null if the executor should      * not be checked)      * @throws ConcurrentException if an error occurs      */     private void checkChild(final BackgroundInitializer<?> child,             final ExecutorService expExec) throws ConcurrentException {         final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;         final Integer result = cinit.get();         assertEquals(1, result.intValue(), "Wrong result");         assertEquals(1, cinit.initializeCalls, "Wrong number of executions");         if (expExec != null) {             assertEquals(expExec, cinit.currentExecutor, "Wrong executor service");         }     }      /**      * Tests addInitializer() if a null name is passed in. This should cause an      * exception.      */     @Test     public void testAddInitializerNullName() {         assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));     }      /**      * Tests addInitializer() if a null initializer is passed in. This should      * cause an exception.      */     @Test     public void testAddInitializerNullInit() {         assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));     }      /**      * Tests the background processing if there are no child initializers.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeNoChildren() throws ConcurrentException {         assertTrue(initializer.start(), "Wrong result of start()");         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         assertTrue(res.initializerNames().isEmpty(), "Got child initializers");         assertTrue(initializer.getActiveExecutor().isShutdown(), "Executor not shutdown");     }      /**      * Helper method for testing the initialize() method. This method can      * operate with both an external and a temporary executor service.      *      * @return the result object produced by the initializer      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()             throws ConcurrentException {         final int count = 5;         for (int i = 0; i < count; i++) {             initializer.addInitializer(CHILD_INIT + i,                     new ChildBackgroundInitializer());         }         initializer.start();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         assertEquals(count, res.initializerNames().size(), "Wrong number of child initializers");         for (int i = 0; i < count; i++) {             final String key = CHILD_INIT + i;             assertTrue(res.initializerNames().contains(key), "Name not found: " + key);             assertEquals(Integer.valueOf(1), res.getResultObject(key), "Wrong result object");             assertFalse(res.isException(key), "Exception flag");             assertNull(res.getException(key), "Got an exception");             checkChild(res.getInitializer(key), initializer.getActiveExecutor());         }         return res;     }      /**      * Tests background processing if a temporary executor is used.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeTempExec() throws ConcurrentException {         checkInitialize();         assertTrue(initializer.getActiveExecutor().isShutdown(), "Executor not shutdown");     }      /**      * Tests background processing if an external executor service is provided.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {         final ExecutorService exec = Executors.newCachedThreadPool();         try {             initializer = new MultiBackgroundInitializer(exec);             checkInitialize();             assertEquals(exec, initializer.getActiveExecutor(), "Wrong executor");             assertFalse(exec.isShutdown(), "Executor was shutdown");         } finally {             exec.shutdown();             exec.awaitTermination(1, TimeUnit.SECONDS);         }     }      /**      * Tests the behavior of initialize() if a child initializer has a specific      * executor service. Then this service should not be overridden.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {         final String initExec = "childInitializerWithExecutor";         final ExecutorService exec = Executors.newSingleThreadExecutor();         try {             final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();             final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();             c2.setExternalExecutor(exec);             initializer.addInitializer(CHILD_INIT, c1);             initializer.addInitializer(initExec, c2);             initializer.start();             initializer.get();             checkChild(c1, initializer.getActiveExecutor());             checkChild(c2, exec);         } finally {             exec.shutdown();             exec.awaitTermination(1, TimeUnit.SECONDS);         }     }      /**      * Tries to add another child initializer after the start() method has been      * called. This should not be allowed.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testAddInitializerAfterStart() throws ConcurrentException {         initializer.start();         assertThrows(                 IllegalStateException.class,                 () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),                 "Could add initializer after start()!");         initializer.get();     }      /**      * Tries to query an unknown child initializer from the results object. This      * should cause an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testResultGetInitializerUnknown() throws ConcurrentException {         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();         assertThrows(NoSuchElementException.class, () -> res.getInitializer("unknown"));     }      /**      * Tries to query the results of an unknown child initializer from the      * results object. This should cause an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testResultGetResultObjectUnknown() throws ConcurrentException {         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();         assertThrows(NoSuchElementException.class, () -> res.getResultObject("unknown"));     }      /**      * Tries to query the exception of an unknown child initializer from the      * results object. This should cause an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testResultGetExceptionUnknown() throws ConcurrentException {         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();         assertThrows(NoSuchElementException.class, () -> res.getException("unknown"));     }      /**      * Tries to query the exception flag of an unknown child initializer from      * the results object. This should cause an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testResultIsExceptionUnknown() throws ConcurrentException {         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();         assertThrows(NoSuchElementException.class, () -> res.isException("unknown"));     }      /**      * Tests that the set with the names of the initializers cannot be modified.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testResultInitializerNamesModify() throws ConcurrentException {         checkInitialize();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         final Iterator<String> it = res.initializerNames().iterator();         it.next();         assertThrows(UnsupportedOperationException.class, it::remove);     }      /**      * Tests the behavior of the initializer if one of the child initializers      * throws a runtime exception.      */     @Test     public void testInitializeRuntimeEx() {         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();         child.ex = new RuntimeException();         initializer.addInitializer(CHILD_INIT, child);         initializer.start();         final Exception ex = assertThrows(Exception.class, initializer::get);         assertEquals(child.ex, ex, "Wrong exception");     }      /**      * Tests the behavior of the initializer if one of the child initializers      * throws a checked exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeEx() throws ConcurrentException {         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();         child.ex = new Exception();         initializer.addInitializer(CHILD_INIT, child);         initializer.start();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         assertTrue(res.isException(CHILD_INIT), "No exception flag");         assertNull(res.getResultObject(CHILD_INIT), "Got a results object");         final ConcurrentException cex = res.getException(CHILD_INIT);         assertEquals(child.ex, cex.getCause(), "Wrong cause");     }      /**      * Tests the isSuccessful() method of the result object if no child      * initializer has thrown an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeResultsIsSuccessfulTrue()             throws ConcurrentException {         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();         initializer.addInitializer(CHILD_INIT, child);         initializer.start();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         assertTrue(res.isSuccessful(), "Wrong success flag");     }      /**      * Tests the isSuccessful() method of the result object if at least one      * child initializer has thrown an exception.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeResultsIsSuccessfulFalse()             throws ConcurrentException {         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();         child.ex = new Exception();         initializer.addInitializer(CHILD_INIT, child);         initializer.start();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         assertFalse(res.isSuccessful(), "Wrong success flag");     }      /**      * Tests whether MultiBackgroundInitializers can be combined in a nested      * way.      *      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it      */     @Test     public void testInitializeNested() throws ConcurrentException {         final String nameMulti = "multiChildInitializer";         initializer                 .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());         final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();         final int count = 3;         for (int i = 0; i < count; i++) {             mi2                     .addInitializer(CHILD_INIT + i,                             new ChildBackgroundInitializer());         }         initializer.addInitializer(nameMulti, mi2);         initializer.start();         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer                 .get();         final ExecutorService exec = initializer.getActiveExecutor();         checkChild(res.getInitializer(CHILD_INIT), exec);         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res                 .getResultObject(nameMulti);         assertEquals(count, res2.initializerNames().size(), "Wrong number of initializers");         for (int i = 0; i < count; i++) {             checkChild(res2.getInitializer(CHILD_INIT + i), exec);         }         assertTrue(exec.isShutdown(), "Executor not shutdown");     }      /**      * A concrete implementation of {@code BackgroundInitializer} used for      * defining background tasks for {@code MultiBackgroundInitializer}.      */     private static class ChildBackgroundInitializer extends             BackgroundInitializer<Integer> {         /** Stores the current executor service. */         volatile ExecutorService currentExecutor;          /** A counter for the invocations of initialize(). */         volatile int initializeCalls;          /** An exception to be thrown by initialize(). */         Exception ex;          /**          * Records this invocation. Optionally throws an exception.          */         @Override         protected Integer initialize() throws Exception {             currentExecutor = getActiveExecutor();             initializeCalls++;              if (ex != null) {                 throw ex;             }              return Integer.valueOf(initializeCalls);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.concurrent;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.apache.commons.lang3.exception.AbstractExceptionTest; import org.junit.jupiter.api.Test;   /**  * JUnit tests for {@link CircuitBreakingException}.  */ public class CircuitBreakingExceptionTest extends AbstractExceptionTest {      @Test     public void testThrowingInformativeException() {         assertThrows(CircuitBreakingException.class, () -> {             throw new CircuitBreakingException(EXCEPTION_MESSAGE, generateCause());         });     }      @Test     public void testThrowingExceptionWithMessage() {         assertThrows(CircuitBreakingException.class, () -> {             throw new CircuitBreakingException(EXCEPTION_MESSAGE);         });     }      @Test     public void testThrowingExceptionWithCause() {         assertThrows(CircuitBreakingException.class, () -> {             throw new CircuitBreakingException(generateCause());         });     }      @Test     public void testThrowingEmptyException() {         assertThrows(CircuitBreakingException.class, () -> {             throw new CircuitBreakingException();         });     }      @Test     public void testWithCauseAndMessage() {         final Exception exception = new CircuitBreakingException(EXCEPTION_MESSAGE, generateCause());         assertNotNull(exception);         assertEquals(EXCEPTION_MESSAGE, exception.getMessage(), WRONG_EXCEPTION_MESSAGE);          final Throwable cause = exception.getCause();         assertNotNull(cause);         assertEquals(CAUSE_MESSAGE, cause.getMessage(), WRONG_CAUSE_MESSAGE);     }      @Test     public void testWithoutCause() {         final Exception exception = new CircuitBreakingException(EXCEPTION_MESSAGE);         assertNotNull(exception);         assertEquals(EXCEPTION_MESSAGE, exception.getMessage(), WRONG_EXCEPTION_MESSAGE);          final Throwable cause = exception.getCause();         assertNull(cause);     }      @Test     public void testWithoutMessage() {         final Exception exception = new CircuitBreakingException(generateCause());         assertNotNull(exception);         assertNotNull(exception.getMessage());          final Throwable cause = exception.getCause();         assertNotNull(cause);         assertEquals(CAUSE_MESSAGE, cause.getMessage(), WRONG_CAUSE_MESSAGE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.text.DecimalFormatSymbols; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Iterator;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.StrBuilder}.  */ @Deprecated public class StrBuilderAppendInsertTest {      /** The system line separator. */     private static final String SEP = System.lineSeparator();      /** Test subclass of Object, with a toString method. */     private static final Object FOO = new Object() {         @Override         public String toString() {             return "foo";         }     };      //-----------------------------------------------------------------------     @Test     public void testAppendNewLine() {         StrBuilder sb = new StrBuilder("---");         sb.appendNewLine().append("+++");         assertEquals("---" + SEP + "+++", sb.toString());          sb = new StrBuilder("---");         sb.setNewLineText("#").appendNewLine().setNewLineText(null).appendNewLine();         assertEquals("---#" + SEP, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendWithNullText() {         final StrBuilder sb = new StrBuilder();         sb.setNullText("NULL");         assertEquals("", sb.toString());          sb.appendNull();         assertEquals("NULL", sb.toString());          sb.append((Object) null);         assertEquals("NULLNULL", sb.toString());          sb.append(FOO);         assertEquals("NULLNULLfoo", sb.toString());          sb.append((String) null);         assertEquals("NULLNULLfooNULL", sb.toString());          sb.append("");         assertEquals("NULLNULLfooNULL", sb.toString());          sb.append("bar");         assertEquals("NULLNULLfooNULLbar", sb.toString());          sb.append((StringBuffer) null);         assertEquals("NULLNULLfooNULLbarNULL", sb.toString());          sb.append(new StringBuffer("baz"));         assertEquals("NULLNULLfooNULLbarNULLbaz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_Object() {         final StrBuilder sb = new StrBuilder();         sb.appendNull();         assertEquals("", sb.toString());          sb.append((Object) null);         assertEquals("", sb.toString());          sb.append(FOO);         assertEquals("foo", sb.toString());          sb.append((StringBuffer) null);         assertEquals("foo", sb.toString());          sb.append(new StringBuffer("baz"));         assertEquals("foobaz", sb.toString());          sb.append(new StrBuilder("yes"));         assertEquals("foobazyes", sb.toString());          sb.append((CharSequence) "Seq");         assertEquals("foobazyesSeq", sb.toString());          sb.append(new StringBuilder("bld")); // Check it supports StringBuilder         assertEquals("foobazyesSeqbld", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StringBuilder() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((String) null);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StringBuilder("foo"));         assertEquals("foo", sb.toString());          sb.append(new StringBuilder(""));         assertEquals("foo", sb.toString());          sb.append(new StringBuilder("bar"));         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_String() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((String) null);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append("foo");         assertEquals("foo", sb.toString());          sb.append("");         assertEquals("foo", sb.toString());          sb.append("bar");         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_String_int_int() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((String) null, 0, 1);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append("foo", 0, 3);         assertEquals("foo", sb.toString());          final StrBuilder sb1 = sb;         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", -1, 1),                 "append(char[], -1,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", 3, 1),                 "append(char[], 3,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", 1, -1),                 "append(char[],, -1) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", 1, 3),                 "append(char[], 1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", -1, 3),                 "append(char[], -1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append("bar", 4, 0),                 "append(char[], 4, 0) expected IndexOutOfBoundsException");          sb.append("bar", 3, 0);         assertEquals("foo", sb.toString());          sb.append("abcbardef", 3, 3);         assertEquals("foobar", sb.toString());          sb.append((CharSequence) "abcbardef", 4, 3);         assertEquals("foobarard", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StringBuilder_int_int() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((String) null, 0, 1);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StringBuilder("foo"), 0, 3);         assertEquals("foo", sb.toString());          final StrBuilder sb1 = sb;         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), -1, 1),                 "append(StringBuilder, -1,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), 3, 1),                 "append(StringBuilder, 3,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), 1, -1),                 "append(StringBuilder,, -1) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), 1, 3),                 "append(StringBuilder, 1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), -1, 3),                 "append(StringBuilder, -1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuilder("bar"), 4, 0),                 "append(StringBuilder, 4, 0) expected IndexOutOfBoundsException");          sb.append(new StringBuilder("bar"), 3, 0);         assertEquals("foo", sb.toString());          sb.append(new StringBuilder("abcbardef"), 3, 3);         assertEquals("foobar", sb.toString());          sb.append( new StringBuilder("abcbardef"), 4, 3);         assertEquals("foobarard", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StringBuffer() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((StringBuffer) null);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StringBuffer("foo"));         assertEquals("foo", sb.toString());          sb.append(new StringBuffer(""));         assertEquals("foo", sb.toString());          sb.append(new StringBuffer("bar"));         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StringBuffer_int_int() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((StringBuffer) null, 0, 1);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StringBuffer("foo"), 0, 3);         assertEquals("foo", sb.toString());          final StrBuilder sb1 = sb;         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), -1, 1),                 "append(char[], -1,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), 3, 1),                 "append(char[], 3,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), 1, -1),                 "append(char[],, -1) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), 1, 3),                 "append(char[], 1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), -1, 3),                 "append(char[], -1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StringBuffer("bar"), 4, 0),                 "append(char[], 4, 0) expected IndexOutOfBoundsException");          sb.append(new StringBuffer("bar"), 3, 0);         assertEquals("foo", sb.toString());          sb.append(new StringBuffer("abcbardef"), 3, 3);         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StrBuilder() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((StrBuilder) null);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StrBuilder("foo"));         assertEquals("foo", sb.toString());          sb.append(new StrBuilder(""));         assertEquals("foo", sb.toString());          sb.append(new StrBuilder("bar"));         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_StrBuilder_int_int() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((StrBuilder) null, 0, 1);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new StrBuilder("foo"), 0, 3);         assertEquals("foo", sb.toString());          final StrBuilder sb1 = sb;         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), -1, 1),                 "append(char[], -1,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), 3, 1),                 "append(char[], 3,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), 1, -1),                 "append(char[],, -1) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), 1, 3),                 "append(char[], 1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), -1, 3),                 "append(char[], -1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new StrBuilder("bar"), 4, 0),                 "append(char[], 4, 0) expected IndexOutOfBoundsException");          sb.append(new StrBuilder("bar"), 3, 0);         assertEquals("foo", sb.toString());          sb.append(new StrBuilder("abcbardef"), 3, 3);         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_CharArray() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((char[]) null);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new char[0]);         assertEquals("", sb.toString());          sb.append(new char[]{'f', 'o', 'o'});         assertEquals("foo", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_CharArray_int_int() {         StrBuilder sb = new StrBuilder();         sb.setNullText("NULL").append((char[]) null, 0, 1);         assertEquals("NULL", sb.toString());          sb = new StrBuilder();         sb.append(new char[]{'f', 'o', 'o'}, 0, 3);         assertEquals("foo", sb.toString());          final StrBuilder sb1 = sb;         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, -1, 1),                 "append(char[], -1,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, 3, 1),                 "append(char[], 3,) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, 1, -1),                 "append(char[],, -1) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, 1, 3),                 "append(char[], 1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, -1, 3),                 "append(char[], -1, 3) expected IndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.append(new char[]{'b', 'a', 'r'}, 4, 0),                 "append(char[], 4, 0) expected IndexOutOfBoundsException");          sb.append(new char[]{'b', 'a', 'r'}, 3, 0);         assertEquals("foo", sb.toString());          sb.append(new char[]{'a', 'b', 'c', 'b', 'a', 'r', 'd', 'e', 'f'}, 3, 3);         assertEquals("foobar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_Boolean() {         final StrBuilder sb = new StrBuilder();         sb.append(true);         assertEquals("true", sb.toString());          sb.append(false);         assertEquals("truefalse", sb.toString());          sb.append('!');         assertEquals("truefalse!", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_PrimitiveNumber() {         final StrBuilder sb = new StrBuilder();         sb.append(0);         assertEquals("0", sb.toString());          sb.append(1L);         assertEquals("01", sb.toString());          sb.append(2.3f);         assertEquals("012.3", sb.toString());          sb.append(4.5d);         assertEquals("012.34.5", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_FormattedString() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final String str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln("Hello %s", "Alice");         assertEquals("Hello Alice" + SEP, sb.toString());         assertEquals(2, count[0]);  // appendNewLine() calls append(String)         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_Object() {         final StrBuilder sb = new StrBuilder();         sb.appendln((Object) null);         assertEquals("" + SEP, sb.toString());          sb.appendln(FOO);         assertEquals(SEP + "foo" + SEP, sb.toString());          sb.appendln(Integer.valueOf(6));         assertEquals(SEP + "foo" + SEP + "6" + SEP, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_String() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final String str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln("foo");         assertEquals("foo" + SEP, sb.toString());         assertEquals(2, count[0]);  // appendNewLine() calls append(String)         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_String_int_int() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final String str, final int startIndex, final int length) {                 count[0]++;                 return super.append(str, startIndex, length);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln("foo", 0, 3);         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StringBuffer() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StringBuffer str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StringBuffer("foo"));         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StringBuilder() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StringBuilder str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StringBuilder("foo"));         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StringBuffer_int_int() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {                 count[0]++;                 return super.append(str, startIndex, length);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StringBuffer("foo"), 0, 3);         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StringBuilder_int_int() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {                 count[0]++;                 return super.append(str, startIndex, length);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StringBuilder("foo"), 0, 3);         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StrBuilder() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StrBuilder str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StrBuilder("foo"));         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_StrBuilder_int_int() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {                 count[0]++;                 return super.append(str, startIndex, length);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln(new StrBuilder("foo"), 0, 3);         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_CharArray() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final char[] str) {                 count[0]++;                 return super.append(str);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln("foo".toCharArray());         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_CharArray_int_int() {         final int[] count = new int[2];         final StrBuilder sb = new StrBuilder() {             private static final long serialVersionUID = 1L;              @Override             public StrBuilder append(final char[] str, final int startIndex, final int length) {                 count[0]++;                 return super.append(str, startIndex, length);             }             @Override             public StrBuilder appendNewLine() {                 count[1]++;                 return super.appendNewLine();             }         };         sb.appendln("foo".toCharArray(), 0, 3);         assertEquals("foo" + SEP, sb.toString());         assertEquals(1, count[0]);         assertEquals(1, count[1]);     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_Boolean() {         final StrBuilder sb = new StrBuilder();         sb.appendln(true);         assertEquals("true" + SEP, sb.toString());          sb.clear();         sb.appendln(false);         assertEquals("false" + SEP, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendln_PrimitiveNumber() {         final StrBuilder sb = new StrBuilder();         sb.appendln(0);         assertEquals("0" + SEP, sb.toString());          sb.clear();         sb.appendln(1L);         assertEquals("1" + SEP, sb.toString());          sb.clear();         sb.appendln(2.3f);         assertEquals("2.3" + SEP, sb.toString());          sb.clear();         sb.appendln(4.5d);         assertEquals("4.5" + SEP, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendPadding() {         final StrBuilder sb = new StrBuilder();         sb.append("foo");         assertEquals("foo", sb.toString());          sb.appendPadding(-1, '-');         assertEquals("foo", sb.toString());          sb.appendPadding(0, '-');         assertEquals("foo", sb.toString());          sb.appendPadding(1, '-');         assertEquals("foo-", sb.toString());          sb.appendPadding(16, '-');         assertEquals(20, sb.length());         //            12345678901234567890         assertEquals("foo-----------------", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendFixedWidthPadLeft() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadLeft("foo", -1, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 0, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 1, '-');         assertEquals("o", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 2, '-');         assertEquals("oo", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 3, '-');         assertEquals("foo", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 4, '-');         assertEquals("-foo", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft("foo", 10, '-');         assertEquals(10, sb.length());         //            1234567890         assertEquals("-------foo", sb.toString());          sb.clear();         sb.setNullText("null");         sb.appendFixedWidthPadLeft(null, 5, '-');         assertEquals("-null", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendFixedWidthPadLeft_int() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadLeft(123, -1, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 0, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 1, '-');         assertEquals("3", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 2, '-');         assertEquals("23", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 3, '-');         assertEquals("123", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 4, '-');         assertEquals("-123", sb.toString());          sb.clear();         sb.appendFixedWidthPadLeft(123, 10, '-');         assertEquals(10, sb.length());         //            1234567890         assertEquals("-------123", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendFixedWidthPadRight() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadRight("foo", -1, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 0, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 1, '-');         assertEquals("f", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 2, '-');         assertEquals("fo", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 3, '-');         assertEquals("foo", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 4, '-');         assertEquals("foo-", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight("foo", 10, '-');         assertEquals(10, sb.length());         //            1234567890         assertEquals("foo-------", sb.toString());          sb.clear();         sb.setNullText("null");         sb.appendFixedWidthPadRight(null, 5, '-');         assertEquals("null-", sb.toString());     }      // See: https://issues.apache.org/jira/browse/LANG-299     @Test     public void testLang299() {         final StrBuilder sb = new StrBuilder(1);         sb.appendFixedWidthPadRight("foo", 1, '-');         assertEquals("f", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendFixedWidthPadRight_int() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadRight(123, -1, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 0, '-');         assertEquals("", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 1, '-');         assertEquals("1", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 2, '-');         assertEquals("12", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 3, '-');         assertEquals("123", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 4, '-');         assertEquals("123-", sb.toString());          sb.clear();         sb.appendFixedWidthPadRight(123, 10, '-');         assertEquals(10, sb.length());         //            1234567890         assertEquals("123-------", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppend_FormattedString() {         StrBuilder sb;          sb = new StrBuilder();         sb.append("Hi", (Object[]) null);         assertEquals("Hi", sb.toString());          sb = new StrBuilder();         sb.append("Hi", "Alice");         assertEquals("Hi", sb.toString());          sb = new StrBuilder();         sb.append("Hi %s", "Alice");         assertEquals("Hi Alice", sb.toString());          sb = new StrBuilder();         sb.append("Hi %s %,d", "Alice", 5000);         // group separator depends on system locale         final char groupingSeparator = DecimalFormatSymbols.getInstance().getGroupingSeparator();         final String expected = "Hi Alice 5" + groupingSeparator + "000";         assertEquals(expected, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendAll_Array() {         final StrBuilder sb = new StrBuilder();         sb.appendAll((Object[]) null);         assertEquals("", sb.toString());          sb.clear();         sb.appendAll();         assertEquals("", sb.toString());          sb.clear();         sb.appendAll("foo", "bar", "baz");         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.appendAll("foo", "bar", "baz");         assertEquals("foobarbaz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendAll_Collection() {         final StrBuilder sb = new StrBuilder();         sb.appendAll((Collection<?>) null);         assertEquals("", sb.toString());          sb.clear();         sb.appendAll(Collections.EMPTY_LIST);         assertEquals("", sb.toString());          sb.clear();         sb.appendAll(Arrays.asList("foo", "bar", "baz"));         assertEquals("foobarbaz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendAll_Iterator() {         final StrBuilder sb = new StrBuilder();         sb.appendAll((Iterator<?>) null);         assertEquals("", sb.toString());          sb.clear();         sb.appendAll(Collections.EMPTY_LIST.iterator());         assertEquals("", sb.toString());          sb.clear();         sb.appendAll(Arrays.asList("foo", "bar", "baz").iterator());         assertEquals("foobarbaz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendWithSeparators_Array() {         final StrBuilder sb = new StrBuilder();         sb.appendWithSeparators((Object[]) null, ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(new Object[0], ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, ",");         assertEquals("foo,bar,baz", sb.toString());          sb.clear();         sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, null);         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ",");         assertEquals("foo,,baz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendWithSeparators_Collection() {         final StrBuilder sb = new StrBuilder();         sb.appendWithSeparators((Collection<?>) null, ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(Collections.EMPTY_LIST, ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", "bar", "baz"), ",");         assertEquals("foo,bar,baz", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", "bar", "baz"), null);         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", null, "baz"), ",");         assertEquals("foo,,baz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendWithSeparators_Iterator() {         final StrBuilder sb = new StrBuilder();         sb.appendWithSeparators((Iterator<?>) null, ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ",");         assertEquals("", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", "bar", "baz").iterator(), ",");         assertEquals("foo,bar,baz", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", "bar", "baz").iterator(), null);         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", null, "baz").iterator(), ",");         assertEquals("foo,,baz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendWithSeparatorsWithNullText() {         final StrBuilder sb = new StrBuilder();         sb.setNullText("null");         sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ",");         assertEquals("foo,null,baz", sb.toString());          sb.clear();         sb.appendWithSeparators(Arrays.asList("foo", null, "baz"), ",");         assertEquals("foo,null,baz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendSeparator_String() {         final StrBuilder sb = new StrBuilder();         sb.appendSeparator(",");  // no effect         assertEquals("", sb.toString());         sb.append("foo");         assertEquals("foo", sb.toString());         sb.appendSeparator(",");         assertEquals("foo,", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendSeparator_String_String() {         final StrBuilder sb = new StrBuilder();         final String startSeparator = "order by ";         final String standardSeparator = ",";         final String foo = "foo";         sb.appendSeparator(null, null);         assertEquals("", sb.toString());         sb.appendSeparator(standardSeparator, null);         assertEquals("", sb.toString());         sb.appendSeparator(standardSeparator, startSeparator);         assertEquals(startSeparator, sb.toString());         sb.appendSeparator(null, null);         assertEquals(startSeparator, sb.toString());         sb.appendSeparator(null, startSeparator);         assertEquals(startSeparator, sb.toString());         sb.append(foo);         assertEquals(startSeparator + foo, sb.toString());         sb.appendSeparator(standardSeparator, startSeparator);         assertEquals(startSeparator + foo + standardSeparator, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendSeparator_char() {         final StrBuilder sb = new StrBuilder();         sb.appendSeparator(',');  // no effect         assertEquals("", sb.toString());         sb.append("foo");         assertEquals("foo", sb.toString());         sb.appendSeparator(',');         assertEquals("foo,", sb.toString());     }     @Test     public void testAppendSeparator_char_char() {         final StrBuilder sb = new StrBuilder();         final char startSeparator = ':';         final char standardSeparator = ',';         final String foo = "foo";         sb.appendSeparator(standardSeparator, startSeparator);  // no effect         assertEquals(String.valueOf(startSeparator), sb.toString());         sb.append(foo);         assertEquals(String.valueOf(startSeparator) + foo, sb.toString());         sb.appendSeparator(standardSeparator, startSeparator);         assertEquals(String.valueOf(startSeparator) + foo + standardSeparator, sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendSeparator_String_int() {         final StrBuilder sb = new StrBuilder();         sb.appendSeparator(",", 0);  // no effect         assertEquals("", sb.toString());         sb.append("foo");         assertEquals("foo", sb.toString());         sb.appendSeparator(",", 1);         assertEquals("foo,", sb.toString());          sb.appendSeparator(",", -1);  // no effect         assertEquals("foo,", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendSeparator_char_int() {         final StrBuilder sb = new StrBuilder();         sb.appendSeparator(',', 0);  // no effect         assertEquals("", sb.toString());         sb.append("foo");         assertEquals("foo", sb.toString());         sb.appendSeparator(',', 1);         assertEquals("foo,", sb.toString());          sb.appendSeparator(',', -1);  // no effect         assertEquals("foo,", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testInsert() {          final StrBuilder sb = new StrBuilder();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, FOO),                 "insert(-1, Object) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, FOO),                 "insert(7, Object) expected StringIndexOutOfBoundsException");          sb.insert(0, (Object) null);         assertEquals("barbaz", sb.toString());          sb.insert(0, FOO);         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, "foo"),                 "insert(-1, String) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, "foo"),                 "insert(7, String) expected StringIndexOutOfBoundsException");          sb.insert(0, (String) null);         assertEquals("barbaz", sb.toString());          sb.insert(0, "foo");         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, new char[]{'f', 'o', 'o'}),                 "insert(-1, char[]) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, new char[]{'f', 'o', 'o'}),                 "insert(7, char[]) expected StringIndexOutOfBoundsException");          sb.insert(0, (char[]) null);         assertEquals("barbaz", sb.toString());          sb.insert(0, new char[0]);         assertEquals("barbaz", sb.toString());          sb.insert(0, new char[]{'f', 'o', 'o'});         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3),                 "insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3),                 "insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException");          sb.insert(0, null, 0, 0);         assertEquals("barbaz", sb.toString());          sb.insert(0, new char[0], 0, 0);         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3),                 "insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3),                 "insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1),                 "insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10),                 "insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException");          sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0);         assertEquals("barbaz", sb.toString());          sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);         assertEquals("foobarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, true),                 "insert(-1, boolean) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, true),                 "insert(7, boolean) expected StringIndexOutOfBoundsException");          sb.insert(0, true);         assertEquals("truebarbaz", sb.toString());          sb.insert(0, false);         assertEquals("falsetruebarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, '!'),                 "insert(-1, char) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, '!'),                 "insert(7, char) expected StringIndexOutOfBoundsException");          sb.insert(0, '!');         assertEquals("!barbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, 0),                 "insert(-1, int) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, 0),                 "insert(7, int) expected StringIndexOutOfBoundsException");          sb.insert(0, '0');         assertEquals("0barbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, 1L),                 "insert(-1, long) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, 1L),                 "insert(7, long) expected StringIndexOutOfBoundsException");          sb.insert(0, 1L);         assertEquals("1barbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, 2.3F),                 "insert(-1, float) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, 2.3F),                 "insert(7, float) expected StringIndexOutOfBoundsException");          sb.insert(0, 2.3F);         assertEquals("2.3barbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, 4.5D),                 "insert(-1, double) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, 4.5D),                 "insert(7, double) expected StringIndexOutOfBoundsException");          sb.insert(0, 4.5D);         assertEquals("4.5barbaz", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testInsertWithNullText() {         final StrBuilder sb = new StrBuilder();         sb.setNullText("null");         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, FOO),                 "insert(-1, Object) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, FOO),                 "insert(7, Object) expected StringIndexOutOfBoundsException");          sb.insert(0, (Object) null);         assertEquals("nullbarbaz", sb.toString());          sb.insert(0, FOO);         assertEquals("foonullbarbaz", sb.toString());          sb.clear();         sb.append("barbaz");         assertEquals("barbaz", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(-1, "foo"),                 "insert(-1, String) expected StringIndexOutOfBoundsException");          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.insert(7, "foo"),                 "insert(7, String) expected StringIndexOutOfBoundsException");          sb.insert(0, (String) null);         assertEquals("nullbarbaz", sb.toString());          sb.insert(0, "foo");         assertEquals("foonullbarbaz", sb.toString());          sb.insert(0, (char[]) null);         assertEquals("nullfoonullbarbaz", sb.toString());          sb.insert(0, null, 0, 0);         assertEquals("nullnullfoonullbarbaz", sb.toString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.IOException; import java.io.Reader; import java.io.StringReader; import java.io.StringWriter; import java.io.Writer; import java.nio.CharBuffer;  import org.apache.commons.lang3.ArrayUtils; import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.StrBuilder}.  */ @Deprecated public class StrBuilderTest {      //-----------------------------------------------------------------------     @Test     public void testConstructors() {         final StrBuilder sb0 = new StrBuilder();         assertEquals(32, sb0.capacity());         assertEquals(0, sb0.length());         assertEquals(0, sb0.size());          final StrBuilder sb1 = new StrBuilder(32);         assertEquals(32, sb1.capacity());         assertEquals(0, sb1.length());         assertEquals(0, sb1.size());          final StrBuilder sb2 = new StrBuilder(0);         assertEquals(32, sb2.capacity());         assertEquals(0, sb2.length());         assertEquals(0, sb2.size());          final StrBuilder sb3 = new StrBuilder(-1);         assertEquals(32, sb3.capacity());         assertEquals(0, sb3.length());         assertEquals(0, sb3.size());          final StrBuilder sb4 = new StrBuilder(1);         assertEquals(1, sb4.capacity());         assertEquals(0, sb4.length());         assertEquals(0, sb4.size());          final StrBuilder sb5 = new StrBuilder(null);         assertEquals(32, sb5.capacity());         assertEquals(0, sb5.length());         assertEquals(0, sb5.size());          final StrBuilder sb6 = new StrBuilder("");         assertEquals(32, sb6.capacity());         assertEquals(0, sb6.length());         assertEquals(0, sb6.size());          final StrBuilder sb7 = new StrBuilder("foo");         assertEquals(35, sb7.capacity());         assertEquals(3, sb7.length());         assertEquals(3, sb7.size());     }      //-----------------------------------------------------------------------     @Test     public void testChaining() {         final StrBuilder sb = new StrBuilder();         assertSame(sb, sb.setNewLineText(null));         assertSame(sb, sb.setNullText(null));         assertSame(sb, sb.setLength(1));         assertSame(sb, sb.setCharAt(0, 'a'));         assertSame(sb, sb.ensureCapacity(0));         assertSame(sb, sb.minimizeCapacity());         assertSame(sb, sb.clear());         assertSame(sb, sb.reverse());         assertSame(sb, sb.trim());     }      //-----------------------------------------------------------------------     @Test     public void testReadFromReader() throws Exception {         String s = "";         for (int i = 0; i < 100; ++i) {             final StrBuilder sb = new StrBuilder();             final int len = sb.readFrom(new StringReader(s));              assertEquals(s.length(), len);             assertEquals(s, sb.toString());              s += Integer.toString(i);         }     }      @Test     public void testReadFromReaderAppendsToEnd() throws Exception {         final StrBuilder sb = new StrBuilder("Test");         sb.readFrom(new StringReader(" 123"));         assertEquals("Test 123", sb.toString());     }      @Test     public void testReadFromCharBuffer() throws Exception {         String s = "";         for (int i = 0; i < 100; ++i) {             final StrBuilder sb = new StrBuilder();             final int len = sb.readFrom(CharBuffer.wrap(s));              assertEquals(s.length(), len);             assertEquals(s, sb.toString());              s += Integer.toString(i);         }     }      @Test     public void testReadFromCharBufferAppendsToEnd() throws Exception {         final StrBuilder sb = new StrBuilder("Test");         sb.readFrom(CharBuffer.wrap(" 123"));         assertEquals("Test 123", sb.toString());     }      @Test     public void testReadFromReadable() throws Exception {         String s = "";         for (int i = 0; i < 100; ++i) {             final StrBuilder sb = new StrBuilder();             final int len = sb.readFrom(new MockReadable(s));              assertEquals(s.length(), len);             assertEquals(s, sb.toString());              s += Integer.toString(i);         }     }      @Test     public void testReadFromReadableAppendsToEnd() throws Exception {         final StrBuilder sb = new StrBuilder("Test");         sb.readFrom(new MockReadable(" 123"));         assertEquals("Test 123", sb.toString());     }      private static class MockReadable implements Readable {          private final CharBuffer src;          MockReadable(final String src) {             this.src = CharBuffer.wrap(src);         }          @Override         public int read(final CharBuffer cb) throws IOException {             return src.read(cb);         }     }      //-----------------------------------------------------------------------     @Test     public void testGetSetNewLineText() {         final StrBuilder sb = new StrBuilder();         assertNull(sb.getNewLineText());          sb.setNewLineText("#");         assertEquals("#", sb.getNewLineText());          sb.setNewLineText("");         assertEquals("", sb.getNewLineText());          sb.setNewLineText(null);         assertNull(sb.getNewLineText());     }      //-----------------------------------------------------------------------     @Test     public void testGetSetNullText() {         final StrBuilder sb = new StrBuilder();         assertNull(sb.getNullText());          sb.setNullText("null");         assertEquals("null", sb.getNullText());          sb.setNullText("");         assertNull(sb.getNullText());          sb.setNullText("NULL");         assertEquals("NULL", sb.getNullText());          sb.setNullText(null);         assertNull(sb.getNullText());     }      //-----------------------------------------------------------------------     @Test     public void testCapacityAndLength() {         final StrBuilder sb = new StrBuilder();         assertEquals(32, sb.capacity());         assertEquals(0, sb.length());         assertEquals(0, sb.size());         assertTrue(sb.isEmpty());          sb.minimizeCapacity();         assertEquals(0, sb.capacity());         assertEquals(0, sb.length());         assertEquals(0, sb.size());         assertTrue(sb.isEmpty());          sb.ensureCapacity(32);         assertTrue(sb.capacity() >= 32);         assertEquals(0, sb.length());         assertEquals(0, sb.size());         assertTrue(sb.isEmpty());          sb.append("foo");         assertTrue(sb.capacity() >= 32);         assertEquals(3, sb.length());         assertEquals(3, sb.size());         assertFalse(sb.isEmpty());          sb.clear();         assertTrue(sb.capacity() >= 32);         assertEquals(0, sb.length());         assertEquals(0, sb.size());         assertTrue(sb.isEmpty());          sb.append("123456789012345678901234567890123");         assertTrue(sb.capacity() > 32);         assertEquals(33, sb.length());         assertEquals(33, sb.size());         assertFalse(sb.isEmpty());          sb.ensureCapacity(16);         assertTrue(sb.capacity() > 16);         assertEquals(33, sb.length());         assertEquals(33, sb.size());         assertFalse(sb.isEmpty());          sb.minimizeCapacity();         assertEquals(33, sb.capacity());         assertEquals(33, sb.length());         assertEquals(33, sb.size());         assertFalse(sb.isEmpty());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.setLength(-1),                 "setLength(-1) expected StringIndexOutOfBoundsException");          sb.setLength(33);         assertEquals(33, sb.capacity());         assertEquals(33, sb.length());         assertEquals(33, sb.size());         assertFalse(sb.isEmpty());          sb.setLength(16);         assertTrue(sb.capacity() >= 16);         assertEquals(16, sb.length());         assertEquals(16, sb.size());         assertEquals("1234567890123456", sb.toString());         assertFalse(sb.isEmpty());          sb.setLength(32);         assertTrue(sb.capacity() >= 32);         assertEquals(32, sb.length());         assertEquals(32, sb.size());         assertEquals("1234567890123456\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", sb.toString());         assertFalse(sb.isEmpty());          sb.setLength(0);         assertTrue(sb.capacity() >= 32);         assertEquals(0, sb.length());         assertEquals(0, sb.size());         assertTrue(sb.isEmpty());     }      //-----------------------------------------------------------------------     @Test     public void testLength() {         final StrBuilder sb = new StrBuilder();         assertEquals(0, sb.length());          sb.append("Hello");         assertEquals(5, sb.length());     }      @Test     public void testSetLength() {         final StrBuilder sb = new StrBuilder();         sb.append("Hello");         sb.setLength(2);  // shorten         assertEquals("He", sb.toString());         sb.setLength(2);  // no change         assertEquals("He", sb.toString());         sb.setLength(3);  // lengthen         assertEquals("He\0", sb.toString());          assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.setLength(-1),                 "setLength(-1) expected StringIndexOutOfBoundsException");     }      //-----------------------------------------------------------------------     @Test     public void testCapacity() {         final StrBuilder sb = new StrBuilder();         assertEquals(sb.buffer.length, sb.capacity());          sb.append("HelloWorldHelloWorldHelloWorldHelloWorld");         assertEquals(sb.buffer.length, sb.capacity());     }      @Test     public void testEnsureCapacity() {         final StrBuilder sb = new StrBuilder();         sb.ensureCapacity(2);         assertTrue(sb.capacity() >= 2);          sb.ensureCapacity(-1);         assertTrue(sb.capacity() >= 0);          sb.append("HelloWorld");         sb.ensureCapacity(40);         assertTrue(sb.capacity() >= 40);     }      @Test     public void testMinimizeCapacity() {         final StrBuilder sb = new StrBuilder();         sb.minimizeCapacity();         assertEquals(0, sb.capacity());          sb.append("HelloWorld");         sb.minimizeCapacity();         assertEquals(10, sb.capacity());     }      //-----------------------------------------------------------------------     @Test     public void testSize() {         final StrBuilder sb = new StrBuilder();         assertEquals(0, sb.size());          sb.append("Hello");         assertEquals(5, sb.size());     }      @Test     public void testIsEmpty() {         final StrBuilder sb = new StrBuilder();         assertTrue(sb.isEmpty());          sb.append("Hello");         assertFalse(sb.isEmpty());          sb.clear();         assertTrue(sb.isEmpty());     }      @Test     public void testClear() {         final StrBuilder sb = new StrBuilder();         sb.append("Hello");         sb.clear();         assertEquals(0, sb.length());         assertTrue(sb.buffer.length >= 5);     }      //-----------------------------------------------------------------------     @Test     public void testCharAt() {         final StrBuilder sb = new StrBuilder();         assertThrows(                 IndexOutOfBoundsException.class, () -> sb.charAt(0), "charAt(0) expected IndexOutOfBoundsException");         assertThrows(                 IndexOutOfBoundsException.class, () -> sb.charAt(-1), "charAt(-1) expected IndexOutOfBoundsException");         sb.append("foo");         assertEquals('f', sb.charAt(0));         assertEquals('o', sb.charAt(1));         assertEquals('o', sb.charAt(2));         assertThrows(                 IndexOutOfBoundsException.class, () -> sb.charAt(-1), "charAt(-1) expected IndexOutOfBoundsException");         assertThrows(                 IndexOutOfBoundsException.class, () -> sb.charAt(3), "charAt(3) expected IndexOutOfBoundsException");     }      //-----------------------------------------------------------------------     @Test     public void testSetCharAt() {         final StrBuilder sb = new StrBuilder();         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.setCharAt(0, 'f'),                 "setCharAt(0, ) expected IndexOutOfBoundsException");         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.setCharAt(-1, 'f'),                 "setCharAt(-1, ) expected IndexOutOfBoundsException");         sb.append("foo");         sb.setCharAt(0, 'b');         sb.setCharAt(1, 'a');         sb.setCharAt(2, 'r');         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb.setCharAt(3, '!'),                 "setCharAt(3, ) expected IndexOutOfBoundsException");         assertEquals("bar", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testDeleteCharAt() {         final StrBuilder sb = new StrBuilder("abc");         sb.deleteCharAt(0);         assertEquals("bc", sb.toString());          assertThrows(IndexOutOfBoundsException.class, () -> sb.deleteCharAt(1000));     }      //-----------------------------------------------------------------------     @Test     public void testToCharArray() {         final StrBuilder sb = new StrBuilder();         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray());          char[] a = sb.toCharArray();         assertNotNull(a, "toCharArray() result is null");         assertEquals(0, a.length, "toCharArray() result is too large");          sb.append("junit");         a = sb.toCharArray();         assertEquals(5, a.length, "toCharArray() result incorrect length");         assertArrayEquals("junit".toCharArray(), a, "toCharArray() result does not match");     }      @Test     public void testToCharArrayIntInt() {         final StrBuilder sb = new StrBuilder();         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0));          sb.append("junit");         char[] a = sb.toCharArray(0, 20); // too large test         assertEquals(5, a.length, "toCharArray(int, int) result incorrect length");         assertArrayEquals("junit".toCharArray(), a, "toCharArray(int, int) result does not match");          a = sb.toCharArray(0, 4);         assertEquals(4, a.length, "toCharArray(int, int) result incorrect length");         assertArrayEquals("juni".toCharArray(), a, "toCharArray(int, int) result does not match");          a = sb.toCharArray(0, 4);         assertEquals(4, a.length, "toCharArray(int, int) result incorrect length");         assertArrayEquals("juni".toCharArray(), a, "toCharArray(int, int) result does not match");          a = sb.toCharArray(0, 1);         assertNotNull(a, "toCharArray(int, int) result is null");          assertThrows(                 IndexOutOfBoundsException.class, () -> sb.toCharArray(-1, 5), "no string index out of bound on -1");          assertThrows(                 IndexOutOfBoundsException.class, () -> sb.toCharArray(6, 5), "no string index out of bound on -1");     }      @Test     public void testGetChars ( ) {         final StrBuilder sb = new StrBuilder();          char[] input = new char[10];         char[] a = sb.getChars(input);         assertSame (input, a);         assertArrayEquals(new char[10], a);          sb.append("junit");         a = sb.getChars(input);         assertSame(input, a);         assertArrayEquals(new char[]{'j', 'u', 'n', 'i', 't', 0, 0, 0, 0, 0}, a);          a = sb.getChars(null);         assertNotSame(input, a);         assertEquals(5, a.length);         assertArrayEquals("junit".toCharArray(), a);          input = new char[5];         a = sb.getChars(input);         assertSame(input, a);          input = new char[4];         a = sb.getChars(input);         assertNotSame(input, a);     }      @Test     public void testGetCharsIntIntCharArrayInt( ) {         final StrBuilder sb = new StrBuilder();          sb.append("junit");         final char[] a = new char[5];         sb.getChars(0, 5, a, 0);         assertArrayEquals(new char[]{'j', 'u', 'n', 'i', 't'}, a);          final char[] b = new char[5];         sb.getChars(0, 2, b, 3);         assertArrayEquals(new char[]{0, 0, 0, 'j', 'u'}, b);          assertThrows(IndexOutOfBoundsException.class, () -> sb.getChars(-1, 0, b, 0));         assertThrows(IndexOutOfBoundsException.class, () -> sb.getChars(0, -1, b, 0));         assertThrows(IndexOutOfBoundsException.class, () -> sb.getChars(0, 20, b, 0));         assertThrows(IndexOutOfBoundsException.class, () -> sb.getChars(4, 2, b, 0));     }      //-----------------------------------------------------------------------     @Test     public void testDeleteIntInt() {         final StrBuilder sb = new StrBuilder("abc");         sb.delete(0, 1);         assertEquals("bc", sb.toString());         sb.delete(1, 2);         assertEquals("b", sb.toString());         sb.delete(0, 1);         assertEquals("", sb.toString());         sb.delete(0, 1000);         assertEquals("", sb.toString());          assertThrows(IndexOutOfBoundsException.class, () -> sb.delete(1, 2));         assertThrows(IndexOutOfBoundsException.class, () -> sb.delete(-1, 1));         assertThrows(IndexOutOfBoundsException.class, () -> new StrBuilder("anything").delete(2, 1));     }      //-----------------------------------------------------------------------     @Test     public void testDeleteAll_char() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.deleteAll('X');         assertEquals("abcbccba", sb.toString());         sb.deleteAll('a');         assertEquals("bcbccb", sb.toString());         sb.deleteAll('c');         assertEquals("bbb", sb.toString());         sb.deleteAll('b');         assertEquals("", sb.toString());          sb = new StrBuilder("");         sb.deleteAll('b');         assertEquals("", sb.toString());     }      @Test     public void testDeleteFirst_char() {         StrBuilder sb = new StrBuilder("abcba");         sb.deleteFirst('X');         assertEquals("abcba", sb.toString());         sb.deleteFirst('a');         assertEquals("bcba", sb.toString());         sb.deleteFirst('c');         assertEquals("bba", sb.toString());         sb.deleteFirst('b');         assertEquals("ba", sb.toString());          sb = new StrBuilder("");         sb.deleteFirst('b');         assertEquals("", sb.toString());     }      // -----------------------------------------------------------------------     @Test     public void testDeleteAll_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.deleteAll((String) null);         assertEquals("abcbccba", sb.toString());         sb.deleteAll("");         assertEquals("abcbccba", sb.toString());          sb.deleteAll("X");         assertEquals("abcbccba", sb.toString());         sb.deleteAll("a");         assertEquals("bcbccb", sb.toString());         sb.deleteAll("c");         assertEquals("bbb", sb.toString());         sb.deleteAll("b");         assertEquals("", sb.toString());          sb = new StrBuilder("abcbccba");         sb.deleteAll("bc");         assertEquals("acba", sb.toString());          sb = new StrBuilder("");         sb.deleteAll("bc");         assertEquals("", sb.toString());     }      @Test     public void testDeleteFirst_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.deleteFirst((String) null);         assertEquals("abcbccba", sb.toString());         sb.deleteFirst("");         assertEquals("abcbccba", sb.toString());          sb.deleteFirst("X");         assertEquals("abcbccba", sb.toString());         sb.deleteFirst("a");         assertEquals("bcbccba", sb.toString());         sb.deleteFirst("c");         assertEquals("bbccba", sb.toString());         sb.deleteFirst("b");         assertEquals("bccba", sb.toString());          sb = new StrBuilder("abcbccba");         sb.deleteFirst("bc");         assertEquals("abccba", sb.toString());          sb = new StrBuilder("");         sb.deleteFirst("bc");         assertEquals("", sb.toString());     }      // -----------------------------------------------------------------------     @Test     public void testDeleteAll_StrMatcher() {         StrBuilder sb = new StrBuilder("A0xA1A2yA3");         sb.deleteAll((StrMatcher) null);         assertEquals("A0xA1A2yA3", sb.toString());         sb.deleteAll(A_NUMBER_MATCHER);         assertEquals("xy", sb.toString());          sb = new StrBuilder("Ax1");         sb.deleteAll(A_NUMBER_MATCHER);         assertEquals("Ax1", sb.toString());          sb = new StrBuilder("");         sb.deleteAll(A_NUMBER_MATCHER);         assertEquals("", sb.toString());     }      @Test     public void testDeleteFirst_StrMatcher() {         StrBuilder sb = new StrBuilder("A0xA1A2yA3");         sb.deleteFirst((StrMatcher) null);         assertEquals("A0xA1A2yA3", sb.toString());         sb.deleteFirst(A_NUMBER_MATCHER);         assertEquals("xA1A2yA3", sb.toString());          sb = new StrBuilder("Ax1");         sb.deleteFirst(A_NUMBER_MATCHER);         assertEquals("Ax1", sb.toString());          sb = new StrBuilder("");         sb.deleteFirst(A_NUMBER_MATCHER);         assertEquals("", sb.toString());     }      // -----------------------------------------------------------------------     @Test     public void testReplace_int_int_String() {         final StrBuilder sb = new StrBuilder("abc");         sb.replace(0, 1, "d");         assertEquals("dbc", sb.toString());         sb.replace(0, 1, "aaa");         assertEquals("aaabc", sb.toString());         sb.replace(0, 3, "");         assertEquals("bc", sb.toString());         sb.replace(1, 2, null);         assertEquals("b", sb.toString());         sb.replace(1, 1000, "text");         assertEquals("btext", sb.toString());         sb.replace(0, 1000, "text");         assertEquals("text", sb.toString());          final StrBuilder sb1 = new StrBuilder("atext");         sb1.replace(1, 1, "ny");         assertEquals("anytext", sb1.toString());         assertThrows(IndexOutOfBoundsException.class, () -> sb1.replace(2, 1, "anything"));          final StrBuilder sb2 = new StrBuilder();         assertThrows(IndexOutOfBoundsException.class, () -> sb2.replace(1, 2, "anything"));         assertThrows(IndexOutOfBoundsException.class, () -> sb2.replace(-1, 1, "anything"));     }      //-----------------------------------------------------------------------     @Test     public void testReplaceAll_char_char() {         final StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceAll('x', 'y');         assertEquals("abcbccba", sb.toString());         sb.replaceAll('a', 'd');         assertEquals("dbcbccbd", sb.toString());         sb.replaceAll('b', 'e');         assertEquals("dececced", sb.toString());         sb.replaceAll('c', 'f');         assertEquals("defeffed", sb.toString());         sb.replaceAll('d', 'd');         assertEquals("defeffed", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testReplaceFirst_char_char() {         final StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceFirst('x', 'y');         assertEquals("abcbccba", sb.toString());         sb.replaceFirst('a', 'd');         assertEquals("dbcbccba", sb.toString());         sb.replaceFirst('b', 'e');         assertEquals("decbccba", sb.toString());         sb.replaceFirst('c', 'f');         assertEquals("defbccba", sb.toString());         sb.replaceFirst('d', 'd');         assertEquals("defbccba", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testReplaceAll_String_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceAll((String) null, null);         assertEquals("abcbccba", sb.toString());         sb.replaceAll((String) null, "anything");         assertEquals("abcbccba", sb.toString());         sb.replaceAll("", null);         assertEquals("abcbccba", sb.toString());         sb.replaceAll("", "anything");         assertEquals("abcbccba", sb.toString());          sb.replaceAll("x", "y");         assertEquals("abcbccba", sb.toString());         sb.replaceAll("a", "d");         assertEquals("dbcbccbd", sb.toString());         sb.replaceAll("d", null);         assertEquals("bcbccb", sb.toString());         sb.replaceAll("cb", "-");         assertEquals("b-c-", sb.toString());          sb = new StrBuilder("abcba");         sb.replaceAll("b", "xbx");         assertEquals("axbxcxbxa", sb.toString());          sb = new StrBuilder("bb");         sb.replaceAll("b", "xbx");         assertEquals("xbxxbx", sb.toString());     }      @Test     public void testReplaceFirst_String_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceFirst((String) null, null);         assertEquals("abcbccba", sb.toString());         sb.replaceFirst((String) null, "anything");         assertEquals("abcbccba", sb.toString());         sb.replaceFirst("", null);         assertEquals("abcbccba", sb.toString());         sb.replaceFirst("", "anything");         assertEquals("abcbccba", sb.toString());          sb.replaceFirst("x", "y");         assertEquals("abcbccba", sb.toString());         sb.replaceFirst("a", "d");         assertEquals("dbcbccba", sb.toString());         sb.replaceFirst("d", null);         assertEquals("bcbccba", sb.toString());         sb.replaceFirst("cb", "-");         assertEquals("b-ccba", sb.toString());          sb = new StrBuilder("abcba");         sb.replaceFirst("b", "xbx");         assertEquals("axbxcba", sb.toString());          sb = new StrBuilder("bb");         sb.replaceFirst("b", "xbx");         assertEquals("xbxb", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testReplaceAll_StrMatcher_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceAll((StrMatcher) null, null);         assertEquals("abcbccba", sb.toString());         sb.replaceAll((StrMatcher) null, "anything");         assertEquals("abcbccba", sb.toString());         sb.replaceAll(StrMatcher.noneMatcher(), null);         assertEquals("abcbccba", sb.toString());         sb.replaceAll(StrMatcher.noneMatcher(), "anything");         assertEquals("abcbccba", sb.toString());          sb.replaceAll(StrMatcher.charMatcher('x'), "y");         assertEquals("abcbccba", sb.toString());         sb.replaceAll(StrMatcher.charMatcher('a'), "d");         assertEquals("dbcbccbd", sb.toString());         sb.replaceAll(StrMatcher.charMatcher('d'), null);         assertEquals("bcbccb", sb.toString());         sb.replaceAll(StrMatcher.stringMatcher("cb"), "-");         assertEquals("b-c-", sb.toString());          sb = new StrBuilder("abcba");         sb.replaceAll(StrMatcher.charMatcher('b'), "xbx");         assertEquals("axbxcxbxa", sb.toString());          sb = new StrBuilder("bb");         sb.replaceAll(StrMatcher.charMatcher('b'), "xbx");         assertEquals("xbxxbx", sb.toString());          sb = new StrBuilder("A1-A2A3-A4");         sb.replaceAll(A_NUMBER_MATCHER, "***");         assertEquals("***-******-***", sb.toString());          sb = new StrBuilder("Dear X, hello X.");         sb.replaceAll(StrMatcher.stringMatcher("X"), "012345678901234567");         assertEquals("Dear 012345678901234567, hello 012345678901234567.", sb.toString());     }      @Test     public void testReplaceFirst_StrMatcher_String() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replaceFirst((StrMatcher) null, null);         assertEquals("abcbccba", sb.toString());         sb.replaceFirst((StrMatcher) null, "anything");         assertEquals("abcbccba", sb.toString());         sb.replaceFirst(StrMatcher.noneMatcher(), null);         assertEquals("abcbccba", sb.toString());         sb.replaceFirst(StrMatcher.noneMatcher(), "anything");         assertEquals("abcbccba", sb.toString());          sb.replaceFirst(StrMatcher.charMatcher('x'), "y");         assertEquals("abcbccba", sb.toString());         sb.replaceFirst(StrMatcher.charMatcher('a'), "d");         assertEquals("dbcbccba", sb.toString());         sb.replaceFirst(StrMatcher.charMatcher('d'), null);         assertEquals("bcbccba", sb.toString());         sb.replaceFirst(StrMatcher.stringMatcher("cb"), "-");         assertEquals("b-ccba", sb.toString());          sb = new StrBuilder("abcba");         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx");         assertEquals("axbxcba", sb.toString());          sb = new StrBuilder("bb");         sb.replaceFirst(StrMatcher.charMatcher('b'), "xbx");         assertEquals("xbxb", sb.toString());          sb = new StrBuilder("A1-A2A3-A4");         sb.replaceFirst(A_NUMBER_MATCHER, "***");         assertEquals("***-A2A3-A4", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testReplace_StrMatcher_String_int_int_int_VaryMatcher() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replace(null, "x", 0, sb.length(), -1);         assertEquals("abcbccba", sb.toString());          sb.replace(StrMatcher.charMatcher('a'), "x", 0, sb.length(), -1);         assertEquals("xbcbccbx", sb.toString());          sb.replace(StrMatcher.stringMatcher("cb"), "x", 0, sb.length(), -1);         assertEquals("xbxcxx", sb.toString());          sb = new StrBuilder("A1-A2A3-A4");         sb.replace(A_NUMBER_MATCHER, "***", 0, sb.length(), -1);         assertEquals("***-******-***", sb.toString());          sb = new StrBuilder();         sb.replace(A_NUMBER_MATCHER, "***", 0, sb.length(), -1);         assertEquals("", sb.toString());     }      @Test     public void testReplace_StrMatcher_String_int_int_int_VaryReplace() {         StrBuilder sb = new StrBuilder("abcbccba");         sb.replace(StrMatcher.stringMatcher("cb"), "cb", 0, sb.length(), -1);         assertEquals("abcbccba", sb.toString());          sb = new StrBuilder("abcbccba");         sb.replace(StrMatcher.stringMatcher("cb"), "-", 0, sb.length(), -1);         assertEquals("ab-c-a", sb.toString());          sb = new StrBuilder("abcbccba");         sb.replace(StrMatcher.stringMatcher("cb"), "+++", 0, sb.length(), -1);         assertEquals("ab+++c+++a", sb.toString());          sb = new StrBuilder("abcbccba");         sb.replace(StrMatcher.stringMatcher("cb"), "", 0, sb.length(), -1);         assertEquals("abca", sb.toString());          sb = new StrBuilder("abcbccba");         sb.replace(StrMatcher.stringMatcher("cb"), null, 0, sb.length(), -1);         assertEquals("abca", sb.toString());     }      @Test     public void testReplace_StrMatcher_String_int_int_int_VaryStartIndex() {         StrBuilder sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, sb.length(), -1);         assertEquals("-x--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 1, sb.length(), -1);         assertEquals("aax--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 2, sb.length(), -1);         assertEquals("aax--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 3, sb.length(), -1);         assertEquals("aax--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 4, sb.length(), -1);         assertEquals("aaxa-ay-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 5, sb.length(), -1);         assertEquals("aaxaa-y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 6, sb.length(), -1);         assertEquals("aaxaaaay-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 7, sb.length(), -1);         assertEquals("aaxaaaay-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 8, sb.length(), -1);         assertEquals("aaxaaaay-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 9, sb.length(), -1);         assertEquals("aaxaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 10, sb.length(), -1);         assertEquals("aaxaaaayaa", sb.toString());          final StrBuilder sb1 = new StrBuilder("aaxaaaayaa");         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.replace(StrMatcher.stringMatcher("aa"), "-", 11, sb1.length(), -1));         assertEquals("aaxaaaayaa", sb1.toString());          final StrBuilder sb2 = new StrBuilder("aaxaaaayaa");         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb2.replace(StrMatcher.stringMatcher("aa"), "-", -1, sb2.length(), -1));         assertEquals("aaxaaaayaa", sb2.toString());     }      @Test     public void testReplace_StrMatcher_String_int_int_int_VaryEndIndex() {         StrBuilder sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 0, -1);         assertEquals("aaxaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 2, -1);         assertEquals("-xaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 3, -1);         assertEquals("-xaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 4, -1);         assertEquals("-xaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 5, -1);         assertEquals("-x-aayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 6, -1);         assertEquals("-x-aayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 7, -1);         assertEquals("-x--yaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 8, -1);         assertEquals("-x--yaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 9, -1);         assertEquals("-x--yaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, -1);         assertEquals("-x--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 1000, -1);         assertEquals("-x--y-", sb.toString());          final StrBuilder sb1 = new StrBuilder("aaxaaaayaa");         assertThrows(                 IndexOutOfBoundsException.class,                 () -> sb1.replace(StrMatcher.stringMatcher("aa"), "-", 2, 1, -1));         assertEquals("aaxaaaayaa", sb1.toString());     }      @Test     public void testReplace_StrMatcher_String_int_int_int_VaryCount() {         StrBuilder sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, -1);         assertEquals("-x--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 0);         assertEquals("aaxaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 1);         assertEquals("-xaaaayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 2);         assertEquals("-x-aayaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 3);         assertEquals("-x--yaa", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 4);         assertEquals("-x--y-", sb.toString());          sb = new StrBuilder("aaxaaaayaa");         sb.replace(StrMatcher.stringMatcher("aa"), "-", 0, 10, 5);         assertEquals("-x--y-", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testReverse() {         final StrBuilder sb = new StrBuilder();         assertEquals("", sb.reverse().toString());          sb.clear().append(true);         assertEquals("eurt", sb.reverse().toString());         assertEquals("true", sb.reverse().toString());     }      //-----------------------------------------------------------------------     @Test     public void testTrim() {         final StrBuilder sb = new StrBuilder();         assertEquals("", sb.reverse().toString());          sb.clear().append(" \u0000 ");         assertEquals("", sb.trim().toString());          sb.clear().append(" \u0000 a b c");         assertEquals("a b c", sb.trim().toString());          sb.clear().append("a b c \u0000 ");         assertEquals("a b c", sb.trim().toString());          sb.clear().append(" \u0000 a b c \u0000 ");         assertEquals("a b c", sb.trim().toString());          sb.clear().append("a b c");         assertEquals("a b c", sb.trim().toString());     }      //-----------------------------------------------------------------------     @Test     public void testStartsWith() {         final StrBuilder sb = new StrBuilder();         assertFalse(sb.startsWith("a"));         assertFalse(sb.startsWith(null));         assertTrue(sb.startsWith(""));         sb.append("abc");         assertTrue(sb.startsWith("a"));         assertTrue(sb.startsWith("ab"));         assertTrue(sb.startsWith("abc"));         assertFalse(sb.startsWith("cba"));     }      @Test     public void testEndsWith() {         final StrBuilder sb = new StrBuilder();         assertFalse(sb.endsWith("a"));         assertFalse(sb.endsWith("c"));         assertTrue(sb.endsWith(""));         assertFalse(sb.endsWith(null));         sb.append("abc");         assertTrue(sb.endsWith("c"));         assertTrue(sb.endsWith("bc"));         assertTrue(sb.endsWith("abc"));         assertFalse(sb.endsWith("cba"));         assertFalse(sb.endsWith("abcd"));         assertFalse(sb.endsWith(" abc"));         assertFalse(sb.endsWith("abc "));     }      //-----------------------------------------------------------------------     @Test     public void testSubSequenceIntInt() {        final StrBuilder sb = new StrBuilder ("hello goodbye");        // Start index is negative         assertThrows(IndexOutOfBoundsException.class, () -> sb.subSequence(-1, 5));          // End index is negative         assertThrows(IndexOutOfBoundsException.class, () -> sb.subSequence(2, -1));          // End index greater than length()         assertThrows(IndexOutOfBoundsException.class, () -> sb.subSequence(2, sb.length() + 1));          // Start index greater then end index         assertThrows(IndexOutOfBoundsException.class, () -> sb.subSequence(3, 2));          // Normal cases         assertEquals ("hello", sb.subSequence(0, 5));         assertEquals ("hello goodbye".subSequence(0, 6), sb.subSequence(0, 6));         assertEquals ("goodbye", sb.subSequence(6, 13));         assertEquals ("hello goodbye".subSequence(6, 13), sb.subSequence(6, 13));     }      @Test     public void testSubstringInt() {         final StrBuilder sb = new StrBuilder ("hello goodbye");         assertEquals ("goodbye", sb.substring(6));         assertEquals ("hello goodbye".substring(6), sb.substring(6));         assertEquals ("hello goodbye", sb.substring(0));         assertEquals ("hello goodbye".substring(0), sb.substring(0));         assertThrows(IndexOutOfBoundsException.class, () -> sb.substring(-1));          assertThrows(IndexOutOfBoundsException.class, () -> sb.substring(15));     }      @Test     public void testSubstringIntInt() {         final StrBuilder sb = new StrBuilder ("hello goodbye");         assertEquals ("hello", sb.substring(0, 5));         assertEquals ("hello goodbye".substring(0, 6), sb.substring(0, 6));          assertEquals ("goodbye", sb.substring(6, 13));         assertEquals ("hello goodbye".substring(6, 13), sb.substring(6, 13));          assertEquals ("goodbye", sb.substring(6, 20));          assertThrows(IndexOutOfBoundsException.class, () -> sb.substring(-1, 5));         assertThrows(IndexOutOfBoundsException.class, () -> sb.substring(15, 20));     }      // -----------------------------------------------------------------------     @Test     public void testMidString() {         final StrBuilder sb = new StrBuilder("hello goodbye hello");         assertEquals("goodbye", sb.midString(6, 7));         assertEquals("hello", sb.midString(0, 5));         assertEquals("hello", sb.midString(-5, 5));         assertEquals("", sb.midString(0, -1));         assertEquals("", sb.midString(20, 2));         assertEquals("hello", sb.midString(14, 22));     }      @Test     public void testRightString() {         final StrBuilder sb = new StrBuilder("left right");         assertEquals("right", sb.rightString(5));         assertEquals("", sb.rightString(0));         assertEquals("", sb.rightString(-5));         assertEquals("left right", sb.rightString(15));     }      @Test     public void testLeftString() {         final StrBuilder sb = new StrBuilder("left right");         assertEquals("left", sb.leftString(4));         assertEquals("", sb.leftString(0));         assertEquals("", sb.leftString(-5));         assertEquals("left right", sb.leftString(15));     }      // -----------------------------------------------------------------------     @Test     public void testContains_char() {         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz");         assertTrue(sb.contains('a'));         assertTrue(sb.contains('o'));         assertTrue(sb.contains('z'));         assertFalse(sb.contains('1'));     }      @Test     public void testContains_String() {         final StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz");         assertTrue(sb.contains("a"));         assertTrue(sb.contains("pq"));         assertTrue(sb.contains("z"));         assertFalse(sb.contains("zyx"));         assertFalse(sb.contains((String) null));     }      @Test     public void testContains_StrMatcher() {         StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz");         assertTrue(sb.contains(StrMatcher.charMatcher('a')));         assertTrue(sb.contains(StrMatcher.stringMatcher("pq")));         assertTrue(sb.contains(StrMatcher.charMatcher('z')));         assertFalse(sb.contains(StrMatcher.stringMatcher("zy")));         assertFalse(sb.contains((StrMatcher) null));          sb = new StrBuilder();         assertFalse(sb.contains(A_NUMBER_MATCHER));         sb.append("B A1 C");         assertTrue(sb.contains(A_NUMBER_MATCHER));     }      // -----------------------------------------------------------------------     @Test     public void testIndexOf_char() {         final StrBuilder sb = new StrBuilder("abab");         assertEquals(0, sb.indexOf('a'));          // should work like String#indexOf         assertEquals("abab".indexOf('a'), sb.indexOf('a'));          assertEquals(1, sb.indexOf('b'));         assertEquals("abab".indexOf('b'), sb.indexOf('b'));          assertEquals(-1, sb.indexOf('z'));     }      @Test     public void testIndexOf_char_int() {         StrBuilder sb = new StrBuilder("abab");         assertEquals(0, sb.indexOf('a', -1));         assertEquals(0, sb.indexOf('a', 0));         assertEquals(2, sb.indexOf('a', 1));         assertEquals(-1, sb.indexOf('a', 4));         assertEquals(-1, sb.indexOf('a', 5));          // should work like String#indexOf         assertEquals("abab".indexOf('a', 1), sb.indexOf('a', 1));          assertEquals(3, sb.indexOf('b', 2));         assertEquals("abab".indexOf('b', 2), sb.indexOf('b', 2));          assertEquals(-1, sb.indexOf('z', 2));          sb = new StrBuilder("xyzabc");         assertEquals(2, sb.indexOf('z', 0));         assertEquals(-1, sb.indexOf('z', 3));     }      @Test     public void testLastIndexOf_char() {         final StrBuilder sb = new StrBuilder("abab");          assertEquals (2, sb.lastIndexOf('a'));         //should work like String#lastIndexOf         assertEquals ("abab".lastIndexOf('a'), sb.lastIndexOf('a'));          assertEquals(3, sb.lastIndexOf('b'));         assertEquals ("abab".lastIndexOf('b'), sb.lastIndexOf('b'));          assertEquals (-1, sb.lastIndexOf('z'));     }      @Test     public void testLastIndexOf_char_int() {         StrBuilder sb = new StrBuilder("abab");         assertEquals(-1, sb.lastIndexOf('a', -1));         assertEquals(0, sb.lastIndexOf('a', 0));         assertEquals(0, sb.lastIndexOf('a', 1));          // should work like String#lastIndexOf         assertEquals("abab".lastIndexOf('a', 1), sb.lastIndexOf('a', 1));          assertEquals(1, sb.lastIndexOf('b', 2));         assertEquals("abab".lastIndexOf('b', 2), sb.lastIndexOf('b', 2));          assertEquals(-1, sb.lastIndexOf('z', 2));          sb = new StrBuilder("xyzabc");         assertEquals(2, sb.lastIndexOf('z', sb.length()));         assertEquals(-1, sb.lastIndexOf('z', 1));     }      // -----------------------------------------------------------------------     @Test     public void testIndexOf_String() {         final StrBuilder sb = new StrBuilder("abab");          assertEquals(0, sb.indexOf("a"));         //should work like String#indexOf         assertEquals("abab".indexOf("a"), sb.indexOf("a"));          assertEquals(0, sb.indexOf("ab"));         //should work like String#indexOf         assertEquals("abab".indexOf("ab"), sb.indexOf("ab"));          assertEquals(1, sb.indexOf("b"));         assertEquals("abab".indexOf("b"), sb.indexOf("b"));          assertEquals(1, sb.indexOf("ba"));         assertEquals("abab".indexOf("ba"), sb.indexOf("ba"));          assertEquals(-1, sb.indexOf("z"));          assertEquals(-1, sb.indexOf((String) null));     }      @Test     public void testIndexOf_String_int() {         StrBuilder sb = new StrBuilder("abab");         assertEquals(0, sb.indexOf("a", -1));         assertEquals(0, sb.indexOf("a", 0));         assertEquals(2, sb.indexOf("a", 1));         assertEquals(2, sb.indexOf("a", 2));         assertEquals(-1, sb.indexOf("a", 3));         assertEquals(-1, sb.indexOf("a", 4));         assertEquals(-1, sb.indexOf("a", 5));          assertEquals(-1, sb.indexOf("abcdef", 0));         assertEquals(0, sb.indexOf("", 0));         assertEquals(1, sb.indexOf("", 1));          //should work like String#indexOf         assertEquals ("abab".indexOf("a", 1), sb.indexOf("a", 1));          assertEquals(2, sb.indexOf("ab", 1));         //should work like String#indexOf         assertEquals("abab".indexOf("ab", 1), sb.indexOf("ab", 1));          assertEquals(3, sb.indexOf("b", 2));         assertEquals("abab".indexOf("b", 2), sb.indexOf("b", 2));          assertEquals(1, sb.indexOf("ba", 1));         assertEquals("abab".indexOf("ba", 2), sb.indexOf("ba", 2));          assertEquals(-1, sb.indexOf("z", 2));          sb = new StrBuilder("xyzabc");         assertEquals(2, sb.indexOf("za", 0));         assertEquals(-1, sb.indexOf("za", 3));          assertEquals(-1, sb.indexOf((String) null, 2));     }      @Test     public void testLastIndexOf_String() {         final StrBuilder sb = new StrBuilder("abab");          assertEquals(2, sb.lastIndexOf("a"));         //should work like String#lastIndexOf         assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a"));          assertEquals(2, sb.lastIndexOf("ab"));         //should work like String#lastIndexOf         assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab"));          assertEquals(3, sb.lastIndexOf("b"));         assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b"));          assertEquals(1, sb.lastIndexOf("ba"));         assertEquals("abab".lastIndexOf("ba"), sb.lastIndexOf("ba"));          assertEquals(-1, sb.lastIndexOf("z"));          assertEquals(-1, sb.lastIndexOf((String) null));     }      @Test     public void testLastIndexOf_String_int() {         StrBuilder sb = new StrBuilder("abab");         assertEquals(-1, sb.lastIndexOf("a", -1));         assertEquals(0, sb.lastIndexOf("a", 0));         assertEquals(0, sb.lastIndexOf("a", 1));         assertEquals(2, sb.lastIndexOf("a", 2));         assertEquals(2, sb.lastIndexOf("a", 3));         assertEquals(2, sb.lastIndexOf("a", 4));         assertEquals(2, sb.lastIndexOf("a", 5));          assertEquals(-1, sb.lastIndexOf("abcdef", 3));         assertEquals("abab".lastIndexOf("", 3), sb.lastIndexOf("", 3));         assertEquals("abab".lastIndexOf("", 1), sb.lastIndexOf("", 1));          //should work like String#lastIndexOf         assertEquals("abab".lastIndexOf("a", 1), sb.lastIndexOf("a", 1));          assertEquals(0, sb.lastIndexOf("ab", 1));         //should work like String#lastIndexOf         assertEquals("abab".lastIndexOf("ab", 1), sb.lastIndexOf("ab", 1));          assertEquals(1, sb.lastIndexOf("b", 2));         assertEquals("abab".lastIndexOf("b", 2), sb.lastIndexOf("b", 2));          assertEquals(1, sb.lastIndexOf("ba", 2));         assertEquals("abab".lastIndexOf("ba", 2), sb.lastIndexOf("ba", 2));          assertEquals(-1, sb.lastIndexOf("z", 2));          sb = new StrBuilder("xyzabc");         assertEquals(2, sb.lastIndexOf("za", sb.length()));         assertEquals(-1, sb.lastIndexOf("za", 1));          assertEquals(-1, sb.lastIndexOf((String) null, 2));     }      // -----------------------------------------------------------------------     @Test     public void testIndexOf_StrMatcher() {         final StrBuilder sb = new StrBuilder();         assertEquals(-1, sb.indexOf((StrMatcher) null));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a')));          sb.append("ab bd");         assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a')));         assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b')));         assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher()));         assertEquals(4, sb.indexOf(StrMatcher.charMatcher('d')));         assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher()));         assertEquals(-1, sb.indexOf((StrMatcher) null));          sb.append(" A1 junction");         assertEquals(6, sb.indexOf(A_NUMBER_MATCHER));     }      @Test     public void testIndexOf_StrMatcher_int() {         final StrBuilder sb = new StrBuilder();         assertEquals(-1, sb.indexOf((StrMatcher) null, 2));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 0));          sb.append("ab bd");         assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), -2));         assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), 0));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 20));          assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), -1));         assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 0));         assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 1));         assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 2));         assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 3));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 4));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 5));         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 6));          assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), -2));         assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 0));         assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 2));         assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 4));         assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 20));          assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher(), 0));         assertEquals(-1, sb.indexOf((StrMatcher) null, 0));          sb.append(" A1 junction with A2");         assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 5));         assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 6));         assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 7));         assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 22));         assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 23));         assertEquals(-1, sb.indexOf(A_NUMBER_MATCHER, 24));     }      @Test     public void testLastIndexOf_StrMatcher() {         final StrBuilder sb = new StrBuilder();         assertEquals(-1, sb.lastIndexOf((StrMatcher) null));         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a')));          sb.append("ab bd");         assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a')));         assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b')));         assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher()));         assertEquals(4, sb.lastIndexOf(StrMatcher.charMatcher('d')));         assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher()));         assertEquals(-1, sb.lastIndexOf((StrMatcher) null));          sb.append(" A1 junction");         assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER));     }      @Test     public void testLastIndexOf_StrMatcher_int() {         final StrBuilder sb = new StrBuilder();         assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 2));         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -1));          sb.append("ab bd");         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -2));         assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));         assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));         assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 20));          assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), -1));         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 0));         assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 1));         assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 2));         assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 3));         assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 4));         assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 5));         assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 6));          assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), -2));         assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), 0));         assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 2));         assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 4));         assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 20));          assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher(), 0));         assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 0));          sb.append(" A1 junction with A2");         assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 5));         assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 6)); // A matches, 1 is outside bounds         assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 7));         assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 22));         assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 23)); // A matches, 2 is outside bounds         assertEquals(23, sb.lastIndexOf(A_NUMBER_MATCHER, 24));     }      static final StrMatcher A_NUMBER_MATCHER = new StrMatcher() {         @Override         public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) {             if (buffer[pos] == 'A') {                 pos++;                 if (pos < bufferEnd && buffer[pos] >= '0' && buffer[pos] <= '9') {                     return 2;                 }             }             return 0;         }     };      //-----------------------------------------------------------------------     @Test     public void testAsTokenizer() {         // from Javadoc         final StrBuilder b = new StrBuilder();         b.append("a b ");         final StrTokenizer t = b.asTokenizer();          final String[] tokens1 = t.getTokenArray();         assertEquals(2, tokens1.length);         assertEquals("a", tokens1[0]);         assertEquals("b", tokens1[1]);         assertEquals(2, t.size());          b.append("c d ");         final String[] tokens2 = t.getTokenArray();         assertEquals(2, tokens2.length);         assertEquals("a", tokens2[0]);         assertEquals("b", tokens2[1]);         assertEquals(2, t.size());         assertEquals("a", t.next());         assertEquals("b", t.next());          t.reset();         final String[] tokens3 = t.getTokenArray();         assertEquals(4, tokens3.length);         assertEquals("a", tokens3[0]);         assertEquals("b", tokens3[1]);         assertEquals("c", tokens3[2]);         assertEquals("d", tokens3[3]);         assertEquals(4, t.size());         assertEquals("a", t.next());         assertEquals("b", t.next());         assertEquals("c", t.next());         assertEquals("d", t.next());          assertEquals("a b c d ", t.getContent());     }      // -----------------------------------------------------------------------     @Test     public void testAsReader() throws Exception {         final StrBuilder sb = new StrBuilder("some text");         Reader reader = sb.asReader();         assertTrue(reader.ready());         final char[] buf = new char[40];         assertEquals(9, reader.read(buf));         assertEquals("some text", new String(buf, 0, 9));          assertEquals(-1, reader.read());         assertFalse(reader.ready());         assertEquals(0, reader.skip(2));         assertEquals(0, reader.skip(-1));          assertTrue(reader.markSupported());         reader = sb.asReader();         assertEquals('s', reader.read());         reader.mark(-1);         char[] array = new char[3];         assertEquals(3, reader.read(array, 0, 3));         assertEquals('o', array[0]);         assertEquals('m', array[1]);         assertEquals('e', array[2]);         reader.reset();         assertEquals(1, reader.read(array, 1, 1));         assertEquals('o', array[0]);         assertEquals('o', array[1]);         assertEquals('e', array[2]);         assertEquals(2, reader.skip(2));         assertEquals(' ', reader.read());          assertTrue(reader.ready());         reader.close();         assertTrue(reader.ready());          final Reader r = sb.asReader();         final char[] arr = new char[3];         assertThrows(IndexOutOfBoundsException.class, () -> r.read(arr, -1, 0));         assertThrows(IndexOutOfBoundsException.class, () -> r.read(arr, 0, -1));         assertThrows(IndexOutOfBoundsException.class, () -> r.read(arr, 100, 1));         assertThrows(IndexOutOfBoundsException.class, () -> r.read(arr, 0, 100));         assertThrows(IndexOutOfBoundsException.class, () -> r.read(arr, Integer.MAX_VALUE, Integer.MAX_VALUE));          assertEquals(0, r.read(arr, 0, 0));         assertEquals(0, arr[0]);         assertEquals(0, arr[1]);         assertEquals(0, arr[2]);          r.skip(9);         assertEquals(-1, r.read(arr, 0, 1));          r.reset();         array = new char[30];         assertEquals(9, r.read(array, 0, 30));     }      //-----------------------------------------------------------------------     @Test     public void testAsWriter() throws Exception {         final StrBuilder sb = new StrBuilder("base");         final Writer writer = sb.asWriter();          writer.write('l');         assertEquals("basel", sb.toString());          writer.write(new char[] {'i', 'n'});         assertEquals("baselin", sb.toString());          writer.write(new char[] {'n', 'e', 'r'}, 1, 2);         assertEquals("baseliner", sb.toString());          writer.write(" rout");         assertEquals("baseliner rout", sb.toString());          writer.write("ping that server", 1, 3);         assertEquals("baseliner routing", sb.toString());          writer.flush();  // no effect         assertEquals("baseliner routing", sb.toString());          writer.close();  // no effect         assertEquals("baseliner routing", sb.toString());          writer.write(" hi");  // works after close         assertEquals("baseliner routing hi", sb.toString());          sb.setLength(4);  // mix and match         writer.write('d');         assertEquals("based", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testEqualsIgnoreCase() {         final StrBuilder sb1 = new StrBuilder();         final StrBuilder sb2 = new StrBuilder();         assertTrue(sb1.equalsIgnoreCase(sb1));         assertTrue(sb1.equalsIgnoreCase(sb2));         assertTrue(sb2.equalsIgnoreCase(sb2));          sb1.append("abc");         assertFalse(sb1.equalsIgnoreCase(sb2));          sb2.append("ABC");         assertTrue(sb1.equalsIgnoreCase(sb2));          sb2.clear().append("abc");         assertTrue(sb1.equalsIgnoreCase(sb2));         assertTrue(sb1.equalsIgnoreCase(sb1));         assertTrue(sb2.equalsIgnoreCase(sb2));          sb2.clear().append("aBc");         assertTrue(sb1.equalsIgnoreCase(sb2));     }      //-----------------------------------------------------------------------     @Test     public void testEquals() {         final StrBuilder sb1 = new StrBuilder();         final StrBuilder sb2 = new StrBuilder();         assertTrue(sb1.equals(sb2));         assertTrue(sb1.equals(sb1));         assertTrue(sb2.equals(sb2));         assertEquals(sb1, (Object) sb2);          sb1.append("abc");         assertFalse(sb1.equals(sb2));         assertNotEquals(sb1, (Object) sb2);          sb2.append("ABC");         assertFalse(sb1.equals(sb2));         assertNotEquals(sb1, (Object) sb2);          sb2.clear().append("abc");         assertTrue(sb1.equals(sb2));         assertEquals(sb1, (Object) sb2);          assertNotEquals(sb1, Integer.valueOf(1));         assertNotEquals("abc", sb1);     }      @Test     public void test_LANG_1131_EqualsWithNullStrBuilder() {         final StrBuilder sb = new StrBuilder();         final StrBuilder other = null;         assertFalse(sb.equals(other));     }      //-----------------------------------------------------------------------     @Test     public void testHashCode() {         final StrBuilder sb = new StrBuilder();         final int hc1a = sb.hashCode();         final int hc1b = sb.hashCode();         assertEquals(0, hc1a);         assertEquals(hc1a, hc1b);          sb.append("abc");         final int hc2a = sb.hashCode();         final int hc2b = sb.hashCode();         assertTrue(hc2a != 0);         assertEquals(hc2a, hc2b);     }      //-----------------------------------------------------------------------     @Test     public void testToString() {         final StrBuilder sb = new StrBuilder("abc");         assertEquals("abc", sb.toString());     }      //-----------------------------------------------------------------------     @Test     public void testToStringBuffer() {         final StrBuilder sb = new StrBuilder();         assertEquals(new StringBuffer().toString(), sb.toStringBuffer().toString());          sb.append("junit");         assertEquals(new StringBuffer("junit").toString(), sb.toStringBuffer().toString());     }      //-----------------------------------------------------------------------     @Test     public void testToStringBuilder() {         final StrBuilder sb = new StrBuilder();         assertEquals(new StringBuilder().toString(), sb.toStringBuilder().toString());          sb.append("junit");         assertEquals(new StringBuilder("junit").toString(), sb.toStringBuilder().toString());     }      //-----------------------------------------------------------------------     @Test     public void testLang294() {         final StrBuilder sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString());     }      @Test     public void testIndexOfLang294() {         final StrBuilder sb = new StrBuilder("onetwothree");         sb.deleteFirst("three");         assertEquals(-1, sb.indexOf("three"));     }      //-----------------------------------------------------------------------     @Test     public void testLang295() {         final StrBuilder sb = new StrBuilder("onetwothree");         sb.deleteFirst("three");         assertFalse(sb.contains('h'), "The contains(char) method is looking beyond the end of the string");         assertEquals(-1, sb.indexOf('h'), "The indexOf(char) method is looking beyond the end of the string");     }      //-----------------------------------------------------------------------     @Test     public void testLang412Right() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadRight(null, 10, '*');         assertEquals("**********", sb.toString(), "Failed to invoke appendFixedWidthPadRight correctly");     }      @Test     public void testLang412Left() {         final StrBuilder sb = new StrBuilder();         sb.appendFixedWidthPadLeft(null, 10, '*');         assertEquals("**********", sb.toString(), "Failed to invoke appendFixedWidthPadLeft correctly");     }      @Test     public void testAsBuilder() {         final StrBuilder sb = new StrBuilder().appendAll("Lorem", " ", "ipsum", " ", "dolor");         assertEquals(sb.toString(), sb.build());     }      //-----------------------------------------------------------------------     @Test     public void testAppendCharBuffer() {         final StrBuilder sb1 = new StrBuilder();         final CharBuffer buf = CharBuffer.allocate(10);         buf.append("0123456789");         buf.flip();         sb1.append(buf);         assertEquals("0123456789", sb1.toString());          final StrBuilder sb2 = new StrBuilder();         sb2.append(buf, 1, 8);         assertEquals("12345678", sb2.toString());     }      //-----------------------------------------------------------------------     @Test     public void testAppendToWriter() throws Exception {         final StrBuilder sb = new StrBuilder("1234567890");         final StringWriter writer = new StringWriter();         writer.append("Test ");          sb.appendTo(writer);          assertEquals("Test 1234567890", writer.toString());     }      @Test     public void testAppendToStringBuilder() throws Exception {         final StrBuilder sb = new StrBuilder("1234567890");         final StringBuilder builder = new StringBuilder("Test ");          sb.appendTo(builder);          assertEquals("Test 1234567890", builder.toString());     }      @Test     public void testAppendToStringBuffer() throws Exception {         final StrBuilder sb = new StrBuilder("1234567890");         final StringBuffer buffer = new StringBuffer("Test ");          sb.appendTo(buffer);          assertEquals("Test 1234567890", buffer.toString());     }      @Test     public void testAppendToCharBuffer() throws Exception {         final StrBuilder sb = new StrBuilder("1234567890");         final String text = "Test ";         final CharBuffer buffer = CharBuffer.allocate(sb.size() + text.length());         buffer.put(text);          sb.appendTo(buffer);          buffer.flip();         assertEquals("Test 1234567890", buffer.toString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.text;  import static java.util.FormattableFlags.LEFT_JUSTIFY; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.Formatter;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link FormattableUtils}.  */ @Deprecated public class FormattableUtilsTest {      @Test     public void testDefaultAppend() {         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1).toString());         assertEquals("fo", FormattableUtils.append("foo", new Formatter(), 0, -1, 2).toString());         assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1).toString());         assertEquals("   foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1).toString());         assertEquals(" fo", FormattableUtils.append("foo", new Formatter(), 0, 3, 2).toString());         assertEquals("   fo", FormattableUtils.append("foo", new Formatter(), 0, 5, 2).toString());         assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1).toString());         assertEquals("foo   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1).toString());         assertEquals("fo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2).toString());         assertEquals("fo   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2).toString());     }      @Test     public void testAlternatePadCharacter() {         final char pad='_';         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, pad).toString());         assertEquals("fo", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, pad).toString());         assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, pad).toString());         assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, pad).toString());         assertEquals("_fo", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, pad).toString());         assertEquals("___fo", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, pad).toString());         assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, pad).toString());         assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, pad).toString());         assertEquals("fo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, pad).toString());         assertEquals("fo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, pad).toString());     }      @Test     public void testEllipsis() {         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, "*").toString());         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, "*").toString());         assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, "*").toString());         assertEquals("   foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, "*").toString());         assertEquals(" f*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, "*").toString());         assertEquals("   f*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, "*").toString());         assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, "*").toString());         assertEquals("foo   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, "*").toString());         assertEquals("f* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, "*").toString());         assertEquals("f*   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, "*").toString());          assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, "+*").toString());         assertEquals("+*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, "+*").toString());         assertEquals(" foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, "+*").toString());         assertEquals("   foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, "+*").toString());         assertEquals(" +*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, "+*").toString());         assertEquals("   +*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, "+*").toString());         assertEquals("foo ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, "+*").toString());         assertEquals("foo   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, "+*").toString());         assertEquals("+* ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, "+*").toString());         assertEquals("+*   ", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, "+*").toString());     }      @Test     public void testIllegalEllipsis() {         assertThrows(IllegalArgumentException.class, () -> FormattableUtils.append("foo", new Formatter(), 0, -1, 1, "xx"));     }      @Test     public void testAlternatePadCharAndEllipsis() {         assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '_', "*").toString());         assertEquals("f*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, '_', "*").toString());         assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, '_', "*").toString());         assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, '_', "*").toString());         assertEquals("_f*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, '_', "*").toString());         assertEquals("___f*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, '_', "*").toString());         assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, '_', "*").toString());         assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, '_', "*").toString());         assertEquals("f*_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, '_', "*").toString());         assertEquals("f*___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, '_', "*").toString());          assertEquals("foo", FormattableUtils.append("foo", new Formatter(), 0, -1, -1, '_', "+*").toString());         assertEquals("+*", FormattableUtils.append("foo", new Formatter(), 0, -1, 2, '_', "+*").toString());         assertEquals("_foo", FormattableUtils.append("foo", new Formatter(), 0, 4, -1, '_', "+*").toString());         assertEquals("___foo", FormattableUtils.append("foo", new Formatter(), 0, 6, -1, '_', "+*").toString());         assertEquals("_+*", FormattableUtils.append("foo", new Formatter(), 0, 3, 2, '_', "+*").toString());         assertEquals("___+*", FormattableUtils.append("foo", new Formatter(), 0, 5, 2, '_', "+*").toString());         assertEquals("foo_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 4, -1, '_', "+*").toString());         assertEquals("foo___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 6, -1, '_', "+*").toString());         assertEquals("+*_", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 3, 2, '_', "+*").toString());         assertEquals("+*___", FormattableUtils.append("foo", new Formatter(), LEFT_JUSTIFY, 5, 2, '_', "+*").toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.text.FieldPosition; import java.text.Format; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Locale;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.CompositeFormat}.  */ @Deprecated public class CompositeFormatTest {      /**      * Ensures that the parse/format separation is correctly maintained.      */     @Test     public void testCompositeFormat() {          final Format parser = new Format() {             private static final long serialVersionUID = 1L;              @Override             public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {                 throw new UnsupportedOperationException("Not implemented");             }              @Override             public Object parseObject(final String source, final ParsePosition pos) {                 return null;    // do nothing             }         };          final Format formatter = new Format() {             private static final long serialVersionUID = 1L;              @Override             public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {                 return null;    // do nothing             }              @Override             public Object parseObject(final String source, final ParsePosition pos) {                 throw new UnsupportedOperationException("Not implemented");             }         };          final CompositeFormat composite = new CompositeFormat(parser, formatter);          composite.parseObject("", null);         composite.format(new Object(), new StringBuffer(), null);         assertEquals(parser, composite.getParser(), "Parser get method incorrectly implemented");         assertEquals(formatter, composite.getFormatter(), "Formatter get method incorrectly implemented");     }      @Test     public void testUsage() throws Exception {         final Format f1 = new SimpleDateFormat("MMddyyyy", Locale.ENGLISH);         final Format f2 = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH);         final CompositeFormat c = new CompositeFormat(f1, f2);         final String testString = "January 3, 2005";         assertEquals(testString, c.format(c.parseObject("01032005")));         assertEquals(testString, c.reformat("01032005"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.StrMatcher}.  */ @Deprecated public class StrMatcherTest  {      private static final char[] BUFFER1 = "0,1\t2 3\n\r\f\u0000'\"".toCharArray();      private static final char[] BUFFER2 = "abcdef".toCharArray();       //-----------------------------------------------------------------------     @Test     public void testCommaMatcher() {         final StrMatcher matcher = StrMatcher.commaMatcher();         assertSame(matcher, StrMatcher.commaMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 0));         assertEquals(1, matcher.isMatch(BUFFER1, 1));         assertEquals(0, matcher.isMatch(BUFFER1, 2));     }      //-----------------------------------------------------------------------     @Test     public void testTabMatcher() {         final StrMatcher matcher = StrMatcher.tabMatcher();         assertSame(matcher, StrMatcher.tabMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 2));         assertEquals(1, matcher.isMatch(BUFFER1, 3));         assertEquals(0, matcher.isMatch(BUFFER1, 4));     }      //-----------------------------------------------------------------------     @Test     public void testSpaceMatcher() {         final StrMatcher matcher = StrMatcher.spaceMatcher();         assertSame(matcher, StrMatcher.spaceMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 4));         assertEquals(1, matcher.isMatch(BUFFER1, 5));         assertEquals(0, matcher.isMatch(BUFFER1, 6));     }      //-----------------------------------------------------------------------     @Test     public void testSplitMatcher() {         final StrMatcher matcher = StrMatcher.splitMatcher();         assertSame(matcher, StrMatcher.splitMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 2));         assertEquals(1, matcher.isMatch(BUFFER1, 3));         assertEquals(0, matcher.isMatch(BUFFER1, 4));         assertEquals(1, matcher.isMatch(BUFFER1, 5));         assertEquals(0, matcher.isMatch(BUFFER1, 6));         assertEquals(1, matcher.isMatch(BUFFER1, 7));         assertEquals(1, matcher.isMatch(BUFFER1, 8));         assertEquals(1, matcher.isMatch(BUFFER1, 9));         assertEquals(0, matcher.isMatch(BUFFER1, 10));     }      //-----------------------------------------------------------------------     @Test     public void testTrimMatcher() {         final StrMatcher matcher = StrMatcher.trimMatcher();         assertSame(matcher, StrMatcher.trimMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 2));         assertEquals(1, matcher.isMatch(BUFFER1, 3));         assertEquals(0, matcher.isMatch(BUFFER1, 4));         assertEquals(1, matcher.isMatch(BUFFER1, 5));         assertEquals(0, matcher.isMatch(BUFFER1, 6));         assertEquals(1, matcher.isMatch(BUFFER1, 7));         assertEquals(1, matcher.isMatch(BUFFER1, 8));         assertEquals(1, matcher.isMatch(BUFFER1, 9));         assertEquals(1, matcher.isMatch(BUFFER1, 10));     }      //-----------------------------------------------------------------------     @Test     public void testSingleQuoteMatcher() {         final StrMatcher matcher = StrMatcher.singleQuoteMatcher();         assertSame(matcher, StrMatcher.singleQuoteMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 10));         assertEquals(1, matcher.isMatch(BUFFER1, 11));         assertEquals(0, matcher.isMatch(BUFFER1, 12));     }      //-----------------------------------------------------------------------     @Test     public void testDoubleQuoteMatcher() {         final StrMatcher matcher = StrMatcher.doubleQuoteMatcher();         assertSame(matcher, StrMatcher.doubleQuoteMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 11));         assertEquals(1, matcher.isMatch(BUFFER1, 12));     }      //-----------------------------------------------------------------------     @Test     public void testQuoteMatcher() {         final StrMatcher matcher = StrMatcher.quoteMatcher();         assertSame(matcher, StrMatcher.quoteMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 10));         assertEquals(1, matcher.isMatch(BUFFER1, 11));         assertEquals(1, matcher.isMatch(BUFFER1, 12));     }      //-----------------------------------------------------------------------     @Test     public void testNoneMatcher() {         final StrMatcher matcher = StrMatcher.noneMatcher();         assertSame(matcher, StrMatcher.noneMatcher());         assertEquals(0, matcher.isMatch(BUFFER1, 0));         assertEquals(0, matcher.isMatch(BUFFER1, 1));         assertEquals(0, matcher.isMatch(BUFFER1, 2));         assertEquals(0, matcher.isMatch(BUFFER1, 3));         assertEquals(0, matcher.isMatch(BUFFER1, 4));         assertEquals(0, matcher.isMatch(BUFFER1, 5));         assertEquals(0, matcher.isMatch(BUFFER1, 6));         assertEquals(0, matcher.isMatch(BUFFER1, 7));         assertEquals(0, matcher.isMatch(BUFFER1, 8));         assertEquals(0, matcher.isMatch(BUFFER1, 9));         assertEquals(0, matcher.isMatch(BUFFER1, 10));         assertEquals(0, matcher.isMatch(BUFFER1, 11));         assertEquals(0, matcher.isMatch(BUFFER1, 12));     }      //-----------------------------------------------------------------------     @Test     public void testCharMatcher_char() {         final StrMatcher matcher = StrMatcher.charMatcher('c');         assertEquals(0, matcher.isMatch(BUFFER2, 0));         assertEquals(0, matcher.isMatch(BUFFER2, 1));         assertEquals(1, matcher.isMatch(BUFFER2, 2));         assertEquals(0, matcher.isMatch(BUFFER2, 3));         assertEquals(0, matcher.isMatch(BUFFER2, 4));         assertEquals(0, matcher.isMatch(BUFFER2, 5));     }      //-----------------------------------------------------------------------     @Test     public void testCharSetMatcher_String() {         final StrMatcher matcher = StrMatcher.charSetMatcher("ace");         assertEquals(1, matcher.isMatch(BUFFER2, 0));         assertEquals(0, matcher.isMatch(BUFFER2, 1));         assertEquals(1, matcher.isMatch(BUFFER2, 2));         assertEquals(0, matcher.isMatch(BUFFER2, 3));         assertEquals(1, matcher.isMatch(BUFFER2, 4));         assertEquals(0, matcher.isMatch(BUFFER2, 5));         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(""));         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null));         assertTrue(StrMatcher.charSetMatcher("a") instanceof StrMatcher.CharMatcher);     }      //-----------------------------------------------------------------------     @Test     public void testCharSetMatcher_charArray() {         final StrMatcher matcher = StrMatcher.charSetMatcher("ace".toCharArray());         assertEquals(1, matcher.isMatch(BUFFER2, 0));         assertEquals(0, matcher.isMatch(BUFFER2, 1));         assertEquals(1, matcher.isMatch(BUFFER2, 2));         assertEquals(0, matcher.isMatch(BUFFER2, 3));         assertEquals(1, matcher.isMatch(BUFFER2, 4));         assertEquals(0, matcher.isMatch(BUFFER2, 5));         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher());         assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null));         assertTrue(StrMatcher.charSetMatcher("a".toCharArray()) instanceof StrMatcher.CharMatcher);     }      //-----------------------------------------------------------------------     @Test     public void testStringMatcher_String() {         final StrMatcher matcher = StrMatcher.stringMatcher("bc");         assertEquals(0, matcher.isMatch(BUFFER2, 0));         assertEquals(2, matcher.isMatch(BUFFER2, 1));         assertEquals(0, matcher.isMatch(BUFFER2, 2));         assertEquals(0, matcher.isMatch(BUFFER2, 3));         assertEquals(0, matcher.isMatch(BUFFER2, 4));         assertEquals(0, matcher.isMatch(BUFFER2, 5));         assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher(""));         assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher(null));     }      //-----------------------------------------------------------------------     @Test     public void testMatcherIndices() {         // remember that the API contract is tight for the isMatch() method         // all the onus is on the caller, so invalid inputs are not         // the concern of StrMatcher, and are not bugs         final StrMatcher matcher = StrMatcher.stringMatcher("bc");         assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length));         assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3));         assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.HashMap; import java.util.Map; import java.util.Properties;  import org.apache.commons.lang3.mutable.MutableObject; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test class for StrSubstitutor.  */ @Deprecated public class StrSubstitutorTest {      private Map<String, String> values;      @BeforeEach     public void setUp() {         values = new HashMap<>();         values.put("animal", "quick brown fox");         values.put("target", "lazy dog");     }      @AfterEach     public void tearDown() {         values = null;     }      //-----------------------------------------------------------------------     /**      * Tests simple key replace.      */     @Test     public void testReplaceSimple() {         doTestReplace("The quick brown fox jumps over the lazy dog.", "The ${animal} jumps over the ${target}.", true);     }      /**      * Tests simple key replace.      */     @Test     public void testReplaceSolo() {         doTestReplace("quick brown fox", "${animal}", false);     }      /**      * Tests replace with no variables.      */     @Test     public void testReplaceNoVariables() {         doTestNoReplace("The balloon arrived.");     }      /**      * Tests replace with null.      */     @Test     public void testReplaceNull() {         doTestNoReplace(null);     }      /**      * Tests replace with null.      */     @Test     public void testReplaceEmpty() {         doTestNoReplace("");     }      /**      * Tests key replace changing map after initialization (not recommended).      */     @Test     public void testReplaceChangedMap() {         final StrSubstitutor sub = new StrSubstitutor(values);         values.put("target", "moon");         assertEquals("The quick brown fox jumps over the moon.", sub.replace("The ${animal} jumps over the ${target}."));     }      /**      * Tests unknown key replace.      */     @Test     public void testReplaceUnknownKey() {         doTestReplace("The ${person} jumps over the lazy dog.", "The ${person} jumps over the ${target}.", true);         doTestReplace("The ${person} jumps over the lazy dog. 1234567890.", "The ${person} jumps over the ${target}. ${undefined.number:-1234567890}.", true);     }      /**      * Tests adjacent keys.      */     @Test     public void testReplaceAdjacentAtStart() {         values.put("code", "GBP");         values.put("amount", "12.50");         final StrSubstitutor sub = new StrSubstitutor(values);         assertEquals("GBP12.50 charged", sub.replace("${code}${amount} charged"));     }      /**      * Tests adjacent keys.      */     @Test     public void testReplaceAdjacentAtEnd() {         values.put("code", "GBP");         values.put("amount", "12.50");         final StrSubstitutor sub = new StrSubstitutor(values);         assertEquals("Amount is GBP12.50", sub.replace("Amount is ${code}${amount}"));     }      /**      * Tests simple recursive replace.      */     @Test     public void testReplaceRecursive() {         values.put("animal", "${critter}");         values.put("target", "${pet}");         values.put("pet", "${petCharacteristic} dog");         values.put("petCharacteristic", "lazy");         values.put("critter", "${critterSpeed} ${critterColor} ${critterType}");         values.put("critterSpeed", "quick");         values.put("critterColor", "brown");         values.put("critterType", "fox");         doTestReplace("The quick brown fox jumps over the lazy dog.", "The ${animal} jumps over the ${target}.", true);          values.put("pet", "${petCharacteristicUnknown:-lazy} dog");         doTestReplace("The quick brown fox jumps over the lazy dog.", "The ${animal} jumps over the ${target}.", true);     }      /**      * Tests escaping.      */     @Test     public void testReplaceEscaping() {         doTestReplace("The ${animal} jumps over the lazy dog.", "The $${animal} jumps over the ${target}.", true);     }      /**      * Tests escaping.      */     @Test     public void testReplaceSoloEscaping() {         doTestReplace("${animal}", "$${animal}", false);     }      /**      * Tests complex escaping.      */     @Test     public void testReplaceComplexEscaping() {         doTestReplace("The ${quick brown fox} jumps over the lazy dog.", "The $${${animal}} jumps over the ${target}.", true);         doTestReplace("The ${quick brown fox} jumps over the lazy dog. ${1234567890}.", "The $${${animal}} jumps over the ${target}. $${${undefined.number:-1234567890}}.", true);     }      /**      * Tests when no prefix or suffix.      */     @Test     public void testReplaceNoPrefixNoSuffix() {         doTestReplace("The animal jumps over the lazy dog.", "The animal jumps over the ${target}.", true);     }      /**      * Tests when no incomplete prefix.      */     @Test     public void testReplaceIncompletePrefix() {         doTestReplace("The {animal} jumps over the lazy dog.", "The {animal} jumps over the ${target}.", true);     }      /**      * Tests when prefix but no suffix.      */     @Test     public void testReplacePrefixNoSuffix() {         doTestReplace("The ${animal jumps over the ${target} lazy dog.", "The ${animal jumps over the ${target} ${target}.", true);     }      /**      * Tests when suffix but no prefix.      */     @Test     public void testReplaceNoPrefixSuffix() {         doTestReplace("The animal} jumps over the lazy dog.", "The animal} jumps over the ${target}.", true);     }      /**      * Tests when no variable name.      */     @Test     public void testReplaceEmptyKeys() {         doTestReplace("The ${} jumps over the lazy dog.", "The ${} jumps over the ${target}.", true);         doTestReplace("The animal jumps over the lazy dog.", "The ${:-animal} jumps over the ${target}.", true);     }      /**      * Tests replace creates output same as input.      */     @Test     public void testReplaceToIdentical() {         values.put("animal", "$${${thing}}");         values.put("thing", "animal");         doTestReplace("The ${animal} jumps.", "The ${animal} jumps.", true);     }      /**      * Tests a cyclic replace operation.      * The cycle should be detected and cause an exception to be thrown.      */     @Test     public void testCyclicReplacement() {         final Map<String, String> map = new HashMap<>();         map.put("animal", "${critter}");         map.put("target", "${pet}");         map.put("pet", "${petCharacteristic} dog");         map.put("petCharacteristic", "lazy");         map.put("critter", "${critterSpeed} ${critterColor} ${critterType}");         map.put("critterSpeed", "quick");         map.put("critterColor", "brown");         map.put("critterType", "${animal}");         final StrSubstitutor sub = new StrSubstitutor(map);         assertThrows(                 IllegalStateException.class,                 () -> sub.replace("The ${animal} jumps over the ${target}."),                 "Cyclic replacement was not detected!");          // also check even when default value is set.         map.put("critterType", "${animal:-fox}");         final StrSubstitutor sub2 = new StrSubstitutor(map);         assertThrows(                 IllegalStateException.class,                 () -> sub2.replace("The ${animal} jumps over the ${target}."),                 "Cyclic replacement was not detected!");     }      /**      * Tests interpolation with weird boundary patterns.      */     @Test     public void testReplaceWeirdPattens() {         doTestNoReplace("");         doTestNoReplace("${}");         doTestNoReplace("${ }");         doTestNoReplace("${\t}");         doTestNoReplace("${\n}");         doTestNoReplace("${\b}");         doTestNoReplace("${");         doTestNoReplace("$}");         doTestNoReplace("}");         doTestNoReplace("${}$");         doTestNoReplace("${${");         doTestNoReplace("${${}}");         doTestNoReplace("${$${}}");         doTestNoReplace("${$$${}}");         doTestNoReplace("${$$${$}}");         doTestNoReplace("${${}}");         doTestNoReplace("${${ }}");     }      /**      * Tests simple key replace.      */     @Test     public void testReplacePartialString_noReplace() {         final StrSubstitutor sub = new StrSubstitutor();         assertEquals("${animal} jumps", sub.replace("The ${animal} jumps over the ${target}.", 4, 15));     }      /**      * Tests whether a variable can be replaced in a variable name.      */     @Test     public void testReplaceInVariable() {         values.put("animal.1", "fox");         values.put("animal.2", "mouse");         values.put("species", "2");         final StrSubstitutor sub = new StrSubstitutor(values);         sub.setEnableSubstitutionInVariables(true);         assertEquals(                 "The mouse jumps over the lazy dog.",                 sub.replace("The ${animal.${species}} jumps over the ${target}."),                 "Wrong result (1)");         values.put("species", "1");         assertEquals(                 "The fox jumps over the lazy dog.",                 sub.replace("The ${animal.${species}} jumps over the ${target}."),                 "Wrong result (2)");         assertEquals(                 "The fox jumps over the lazy dog.",                 sub.replace("The ${unknown.animal.${unknown.species:-1}:-fox} jumps over the ${unknown.target:-lazy dog}."),                 "Wrong result (3)");     }      /**      * Tests whether substitution in variable names is disabled per default.      */     @Test     public void testReplaceInVariableDisabled() {         values.put("animal.1", "fox");         values.put("animal.2", "mouse");         values.put("species", "2");         final StrSubstitutor sub = new StrSubstitutor(values);         assertEquals(                 "The ${animal.${species}} jumps over the lazy dog.",                 sub.replace("The ${animal.${species}} jumps over the ${target}."),                 "Wrong result (1)");         assertEquals(                 "The ${animal.${species:-1}} jumps over the lazy dog.",                 sub.replace("The ${animal.${species:-1}} jumps over the ${target}."),                 "Wrong result (2)");     }      /**      * Tests complex and recursive substitution in variable names.      */     @Test     public void testReplaceInVariableRecursive() {         values.put("animal.2", "brown fox");         values.put("animal.1", "white mouse");         values.put("color", "white");         values.put("species.white", "1");         values.put("species.brown", "2");         final StrSubstitutor sub = new StrSubstitutor(values);         sub.setEnableSubstitutionInVariables(true);         assertEquals(                 "The white mouse jumps over the lazy dog.",                 sub.replace("The ${animal.${species.${color}}} jumps over the ${target}."),                 "Wrong result (1)");         assertEquals(                 "The brown fox jumps over the lazy dog.",                 sub.replace("The ${animal.${species.${unknownColor:-brown}}} jumps over the ${target}."),                 "Wrong result (2)");     }      @Test     public void testDefaultValueDelimiters() {         final Map<String, String> map = new HashMap<>();         map.put("animal", "fox");         map.put("target", "dog");          StrSubstitutor sub = new StrSubstitutor(map, "${", "}", '$');         assertEquals("The fox jumps over the lazy dog. 1234567890.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number:-1234567890}."));          sub = new StrSubstitutor(map, "${", "}", '$', "?:");         assertEquals("The fox jumps over the lazy dog. 1234567890.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number?:1234567890}."));          sub = new StrSubstitutor(map, "${", "}", '$', "||");         assertEquals("The fox jumps over the lazy dog. 1234567890.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number||1234567890}."));          sub = new StrSubstitutor(map, "${", "}", '$', "!");         assertEquals("The fox jumps over the lazy dog. 1234567890.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number!1234567890}."));          sub = new StrSubstitutor(map, "${", "}", '$', "");         sub.setValueDelimiterMatcher(null);         assertEquals("The fox jumps over the lazy dog. ${undefined.number!1234567890}.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number!1234567890}."));          sub = new StrSubstitutor(map, "${", "}", '$');         sub.setValueDelimiterMatcher(null);         assertEquals("The fox jumps over the lazy dog. ${undefined.number!1234567890}.",                 sub.replace("The ${animal} jumps over the lazy ${target}. ${undefined.number!1234567890}."));     }      //-----------------------------------------------------------------------     /**      * Tests protected.      */     @Test     public void testResolveVariable() {         final StrBuilder builder = new StrBuilder("Hi ${name}!");         final Map<String, String> map = new HashMap<>();         map.put("name", "commons");         final StrSubstitutor sub = new StrSubstitutor(map) {             @Override             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {                 assertEquals("name", variableName);                 assertSame(builder, buf);                 assertEquals(3, startPos);                 assertEquals(10, endPos);                 return "jakarta";             }         };         sub.replaceIn(builder);         assertEquals("Hi jakarta!", builder.toString());     }      //-----------------------------------------------------------------------     /**      * Tests constructor.      */     @Test     public void testConstructorNoArgs() {         final StrSubstitutor sub = new StrSubstitutor();         assertEquals("Hi ${name}", sub.replace("Hi ${name}"));     }      /**      * Tests constructor.      */     @Test     public void testConstructorMapPrefixSuffix() {         final Map<String, String> map = new HashMap<>();         map.put("name", "commons");         final StrSubstitutor sub = new StrSubstitutor(map, "<", ">");         assertEquals("Hi < commons", sub.replace("Hi $< <name>"));     }      /**      * Tests constructor.      */     @Test     public void testConstructorMapFull() {         final Map<String, String> map = new HashMap<>();         map.put("name", "commons");         StrSubstitutor sub = new StrSubstitutor(map, "<", ">", '!');         assertEquals("Hi < commons", sub.replace("Hi !< <name>"));         sub = new StrSubstitutor(map, "<", ">", '!', "||");         assertEquals("Hi < commons", sub.replace("Hi !< <name2||commons>"));     }      //-----------------------------------------------------------------------     /**      * Tests get set.      */     @Test     public void testGetSetEscape() {         final StrSubstitutor sub = new StrSubstitutor();         assertEquals('$', sub.getEscapeChar());         sub.setEscapeChar('<');         assertEquals('<', sub.getEscapeChar());     }      /**      * Tests get set.      */     @Test     public void testGetSetPrefix() {         final StrSubstitutor sub = new StrSubstitutor();         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);         sub.setVariablePrefix('<');         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);          sub.setVariablePrefix("<<");         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);         assertThrows(IllegalArgumentException.class, () -> sub.setVariablePrefix(null));         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);          final StrMatcher matcher = StrMatcher.commaMatcher();         sub.setVariablePrefixMatcher(matcher);         assertSame(matcher, sub.getVariablePrefixMatcher());         assertThrows(IllegalArgumentException.class, () -> sub.setVariablePrefixMatcher(null));         assertSame(matcher, sub.getVariablePrefixMatcher());     }      /**      * Tests get set.      */     @Test     public void testGetSetSuffix() {         final StrSubstitutor sub = new StrSubstitutor();         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);         sub.setVariableSuffix('<');         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);          sub.setVariableSuffix("<<");         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);         assertThrows(IllegalArgumentException.class, () -> sub.setVariableSuffix(null));         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);          final StrMatcher matcher = StrMatcher.commaMatcher();         sub.setVariableSuffixMatcher(matcher);         assertSame(matcher, sub.getVariableSuffixMatcher());         assertThrows(IllegalArgumentException.class, () -> sub.setVariableSuffixMatcher(null));         assertSame(matcher, sub.getVariableSuffixMatcher());     }      /**      * Tests get set.      */     @Test     public void testGetSetValueDelimiter() {         final StrSubstitutor sub = new StrSubstitutor();         assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.StringMatcher);         sub.setValueDelimiter(':');         assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.CharMatcher);          sub.setValueDelimiter("||");         assertTrue(sub.getValueDelimiterMatcher() instanceof StrMatcher.StringMatcher);         sub.setValueDelimiter(null);         assertNull(sub.getValueDelimiterMatcher());          final StrMatcher matcher = StrMatcher.commaMatcher();         sub.setValueDelimiterMatcher(matcher);         assertSame(matcher, sub.getValueDelimiterMatcher());         sub.setValueDelimiterMatcher(null);         assertNull(sub.getValueDelimiterMatcher());     }      //-----------------------------------------------------------------------     /**      * Tests static.      */     @Test     public void testStaticReplace() {         final Map<String, String> map = new HashMap<>();         map.put("name", "commons");         assertEquals("Hi commons!", StrSubstitutor.replace("Hi ${name}!", map));     }      /**      * Tests static.      */     @Test     public void testStaticReplacePrefixSuffix() {         final Map<String, String> map = new HashMap<>();         map.put("name", "commons");         assertEquals("Hi commons!", StrSubstitutor.replace("Hi <name>!", map, "<", ">"));     }      /**      * Tests interpolation with system properties.      */     @Test     public void testStaticReplaceSystemProperties() {         final StrBuilder buf = new StrBuilder();         buf.append("Hi ").append(System.getProperty("user.name"));         buf.append(", you are working with ");         buf.append(System.getProperty("os.name"));         buf.append(", your home directory is ");         buf.append(System.getProperty("user.home")).append('.');         assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties("Hi ${user.name}, you are "             + "working with ${os.name}, your home "             + "directory is ${user.home}."));     }      /**      * Test for LANG-1055: StrSubstitutor.replaceSystemProperties does not work consistently      */     @Test     public void testLANG1055() {         System.setProperty("test_key",  "test_value");          final String expected = StrSubstitutor.replace("test_key=${test_key}", System.getProperties());         final String actual = StrSubstitutor.replaceSystemProperties("test_key=${test_key}");         assertEquals(expected, actual);     }      /**      * Test the replace of a properties object      */     @Test     public void testSubstituteDefaultProperties() {         final String org = "${doesnotwork}";         System.setProperty("doesnotwork", "It works!");          // create a new Properties object with the System.getProperties as default         final Properties props = new Properties(System.getProperties());          assertEquals("It works!", StrSubstitutor.replace(org, props));     }      @Test     public void testSamePrefixAndSuffix() {         final Map<String, String> map = new HashMap<>();         map.put("greeting", "Hello");         map.put(" there ", "XXX");         map.put("name", "commons");         assertEquals("Hi commons!", StrSubstitutor.replace("Hi @name@!", map, "@", "@"));         assertEquals("Hello there commons!", StrSubstitutor.replace("@greeting@ there @name@!", map, "@", "@"));     }      @Test     public void testSubstitutePreserveEscape() {         final String org = "${not-escaped} $${escaped}";         final Map<String, String> map = new HashMap<>();         map.put("not-escaped", "value");          final StrSubstitutor sub = new StrSubstitutor(map, "${", "}", '$');         assertFalse(sub.isPreserveEscapes());         assertEquals("value ${escaped}", sub.replace(org));          sub.setPreserveEscapes(true);         assertTrue(sub.isPreserveEscapes());         assertEquals("value $${escaped}", sub.replace(org));     }      //-----------------------------------------------------------------------     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) {         final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);         final StrSubstitutor sub = new StrSubstitutor(values);          // replace using String         assertEquals(expectedResult, sub.replace(replaceTemplate));         if (substring) {             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));         }          // replace using char[]         final char[] chars = replaceTemplate.toCharArray();         assertEquals(expectedResult, sub.replace(chars));         if (substring) {             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));         }          // replace using StringBuffer         StringBuffer buf = new StringBuffer(replaceTemplate);         assertEquals(expectedResult, sub.replace(buf));         if (substring) {             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));         }          // replace using StringBuilder         StringBuilder builder = new StringBuilder(replaceTemplate);         assertEquals(expectedResult, sub.replace(builder));         if (substring) {             assertEquals(expectedShortResult, sub.replace(builder, 1, builder.length() - 2));         }          // replace using StrBuilder         StrBuilder bld = new StrBuilder(replaceTemplate);         assertEquals(expectedResult, sub.replace(bld));         if (substring) {             assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));         }          // replace using object         final MutableObject<String> obj = new MutableObject<>(replaceTemplate);  // toString returns template         assertEquals(expectedResult, sub.replace(obj));          // replace in StringBuffer         buf = new StringBuffer(replaceTemplate);         assertTrue(sub.replaceIn(buf));         assertEquals(expectedResult, buf.toString());         if (substring) {             buf = new StringBuffer(replaceTemplate);             assertTrue(sub.replaceIn(buf, 1, buf.length() - 2));             assertEquals(expectedResult, buf.toString());  // expect full result as remainder is untouched         }          // replace in StringBuilder         builder = new StringBuilder(replaceTemplate);         assertTrue(sub.replaceIn(builder));         assertEquals(expectedResult, builder.toString());         if (substring) {             builder = new StringBuilder(replaceTemplate);             assertTrue(sub.replaceIn(builder, 1, builder.length() - 2));             assertEquals(expectedResult, builder.toString());  // expect full result as remainder is untouched         }          // replace in StrBuilder         bld = new StrBuilder(replaceTemplate);         assertTrue(sub.replaceIn(bld));         assertEquals(expectedResult, bld.toString());         if (substring) {             bld = new StrBuilder(replaceTemplate);             assertTrue(sub.replaceIn(bld, 1, bld.length() - 2));             assertEquals(expectedResult, bld.toString());  // expect full result as remainder is untouched         }     }      private void doTestNoReplace(final String replaceTemplate) {         final StrSubstitutor sub = new StrSubstitutor(values);          if (replaceTemplate == null) {             assertNull(sub.replace((String) null));             assertNull(sub.replace((String) null, 0, 100));             assertNull(sub.replace((char[]) null));             assertNull(sub.replace((char[]) null, 0, 100));             assertNull(sub.replace((StringBuffer) null));             assertNull(sub.replace((StringBuffer) null, 0, 100));             assertNull(sub.replace((StrBuilder) null));             assertNull(sub.replace((StrBuilder) null, 0, 100));             assertNull(sub.replace((Object) null));             assertFalse(sub.replaceIn((StringBuffer) null));             assertFalse(sub.replaceIn((StringBuffer) null, 0, 100));             assertFalse(sub.replaceIn((StrBuilder) null));             assertFalse(sub.replaceIn((StrBuilder) null, 0, 100));         } else {             assertEquals(replaceTemplate, sub.replace(replaceTemplate));             final StrBuilder bld = new StrBuilder(replaceTemplate);             assertFalse(sub.replaceIn(bld));             assertEquals(replaceTemplate, bld.toString());         }     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier;  import org.junit.jupiter.api.Test;  /**  * Unit tests for WordUtils class.  */ @Deprecated public class WordUtilsTest {      //-----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new WordUtils());         final Constructor<?>[] cons = WordUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(WordUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(WordUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     @Test     public void testWrap_StringInt() {         assertNull(WordUtils.wrap(null, 20));         assertNull(WordUtils.wrap(null, -1));          assertEquals("", WordUtils.wrap("", 20));         assertEquals("", WordUtils.wrap("", -1));          // normal         final String systemNewLine = System.lineSeparator();         String input = "Here is one line of text that is going to be wrapped after 20 columns.";         String expected = "Here is one line of" + systemNewLine + "text that is going"             + systemNewLine + "to be wrapped after" + systemNewLine + "20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20));          // long word at end         input = "Click here to jump to the commons website - https://commons.apache.org";         expected = "Click here to jump" + systemNewLine + "to the commons" + systemNewLine             + "website -" + systemNewLine + "https://commons.apache.org";         assertEquals(expected, WordUtils.wrap(input, 20));          // long word in middle         input = "Click here, https://commons.apache.org, to jump to the commons website";         expected = "Click here," + systemNewLine + "https://commons.apache.org," + systemNewLine             + "to jump to the" + systemNewLine + "commons website";         assertEquals(expected, WordUtils.wrap(input, 20));          // leading spaces on a new line are stripped         // trailing spaces are not stripped         input = "word1             word2                        word3";         expected = "word1  " + systemNewLine + "word2  " + systemNewLine + "word3";         assertEquals(expected, WordUtils.wrap(input, 7));     }      @Test     public void testWrap_StringIntStringBoolean() {         assertNull(WordUtils.wrap(null, 20, "\n", false));         assertNull(WordUtils.wrap(null, 20, "\n", true));         assertNull(WordUtils.wrap(null, 20, null, true));         assertNull(WordUtils.wrap(null, 20, null, false));         assertNull(WordUtils.wrap(null, -1, null, true));         assertNull(WordUtils.wrap(null, -1, null, false));          assertEquals("", WordUtils.wrap("", 20, "\n", false));         assertEquals("", WordUtils.wrap("", 20, "\n", true));         assertEquals("", WordUtils.wrap("", 20, null, false));         assertEquals("", WordUtils.wrap("", 20, null, true));         assertEquals("", WordUtils.wrap("", -1, null, false));         assertEquals("", WordUtils.wrap("", -1, null, true));          // normal         String input = "Here is one line of text that is going to be wrapped after 20 columns.";         String expected = "Here is one line of\ntext that is going\nto be wrapped after\n20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));          // unusual newline char         input = "Here is one line of text that is going to be wrapped after 20 columns.";         expected = "Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20, "<br />", false));         assertEquals(expected, WordUtils.wrap(input, 20, "<br />", true));          // short line length         input = "Here is one line";         expected = "Here\nis one\nline";         assertEquals(expected, WordUtils.wrap(input, 6, "\n", false));         expected = "Here\nis\none\nline";         assertEquals(expected, WordUtils.wrap(input, 2, "\n", false));         assertEquals(expected, WordUtils.wrap(input, -1, "\n", false));          // system newline char         final String systemNewLine = System.lineSeparator();         input = "Here is one line of text that is going to be wrapped after 20 columns.";         expected = "Here is one line of" + systemNewLine + "text that is going" + systemNewLine             + "to be wrapped after" + systemNewLine + "20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20, null, false));         assertEquals(expected, WordUtils.wrap(input, 20, null, true));          // with extra spaces         input = " Here:  is  one  line  of  text  that  is  going  to  be  wrapped  after  20  columns.";         expected = "Here:  is  one  line\nof  text  that  is \ngoing  to  be \nwrapped  after  20 \ncolumns.";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));          // with tab         input = "Here is\tone line of text that is going to be wrapped after 20 columns.";         expected = "Here is\tone line of\ntext that is going\nto be wrapped after\n20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));          // with tab at wrapColumn         input = "Here is one line of\ttext that is going to be wrapped after 20 columns.";         expected = "Here is one line\nof\ttext that is\ngoing to be wrapped\nafter 20 columns.";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));          // difference because of long word         input = "Click here to jump to the commons website - https://commons.apache.org";         expected = "Click here to jump\nto the commons\nwebsite -\nhttps://commons.apache.org";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         expected = "Click here to jump\nto the commons\nwebsite -\nhttps://commons.apac\nhe.org";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));          // difference because of long word in middle         input = "Click here, https://commons.apache.org, to jump to the commons website";         expected = "Click here,\nhttps://commons.apache.org,\nto jump to the\ncommons website";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", false));         expected = "Click here,\nhttps://commons.apac\nhe.org, to jump to\nthe commons website";         assertEquals(expected, WordUtils.wrap(input, 20, "\n", true));     }      @Test     public void testWrap_StringIntStringBooleanString() {          //no changes test         String input = "flammable/inflammable";         String expected = "flammable/inflammable";         assertEquals(expected, WordUtils.wrap(input, 30, "\n", false, "/"));          // wrap on / and small width         expected = "flammable\ninflammable";         assertEquals(expected, WordUtils.wrap(input, 2, "\n", false, "/"));          // wrap long words on / 1         expected = "flammable\ninflammab\nle";         assertEquals(expected, WordUtils.wrap(input, 9, "\n", true, "/"));          // wrap long words on / 2         expected = "flammable\ninflammable";         assertEquals(expected, WordUtils.wrap(input, 15, "\n", true, "/"));          // wrap long words on / 3         input = "flammableinflammable";         expected = "flammableinflam\nmable";         assertEquals(expected, WordUtils.wrap(input, 15, "\n", true, "/"));     }      //-----------------------------------------------------------------------     @Test     public void testCapitalize_String() {         assertNull(WordUtils.capitalize(null));         assertEquals("", WordUtils.capitalize(""));         assertEquals("  ", WordUtils.capitalize("  "));          assertEquals("I", WordUtils.capitalize("I") );         assertEquals("I", WordUtils.capitalize("i") );         assertEquals("I Am Here 123", WordUtils.capitalize("i am here 123") );         assertEquals("I Am Here 123", WordUtils.capitalize("I Am Here 123") );         assertEquals("I Am HERE 123", WordUtils.capitalize("i am HERE 123") );         assertEquals("I AM HERE 123", WordUtils.capitalize("I AM HERE 123") );     }      @Test     public void testCapitalizeWithDelimiters_String() {         assertNull(WordUtils.capitalize(null, null));         assertEquals("", WordUtils.capitalize(""));         assertEquals("  ", WordUtils.capitalize("  "));          char[] chars = new char[] { '-', '+', ' ', '@' };         assertEquals("I", WordUtils.capitalize("I", chars) );         assertEquals("I", WordUtils.capitalize("i", chars) );         assertEquals("I-Am Here+123", WordUtils.capitalize("i-am here+123", chars) );         assertEquals("I Am+Here-123", WordUtils.capitalize("I Am+Here-123", chars) );         assertEquals("I+Am-HERE 123", WordUtils.capitalize("i+am-HERE 123", chars) );         assertEquals("I-AM HERE+123", WordUtils.capitalize("I-AM HERE+123", chars) );         chars = new char[] {'.'};         assertEquals("I aM.Fine", WordUtils.capitalize("i aM.fine", chars) );         assertEquals("I Am.fine", WordUtils.capitalize("i am.fine", null) );     }      @Test     public void testCapitalizeFully_String() {         assertNull(WordUtils.capitalizeFully(null));         assertEquals("", WordUtils.capitalizeFully(""));         assertEquals("  ", WordUtils.capitalizeFully("  "));          assertEquals("I", WordUtils.capitalizeFully("I") );         assertEquals("I", WordUtils.capitalizeFully("i") );         assertEquals("I Am Here 123", WordUtils.capitalizeFully("i am here 123") );         assertEquals("I Am Here 123", WordUtils.capitalizeFully("I Am Here 123") );         assertEquals("I Am Here 123", WordUtils.capitalizeFully("i am HERE 123") );         assertEquals("I Am Here 123", WordUtils.capitalizeFully("I AM HERE 123") );     }      @Test     public void testCapitalizeFullyWithDelimiters_String() {         assertNull(WordUtils.capitalizeFully(null, null));         assertEquals("", WordUtils.capitalizeFully(""));         assertEquals("  ", WordUtils.capitalizeFully("  "));          char[] chars = new char[] { '-', '+', ' ', '@' };         assertEquals("I", WordUtils.capitalizeFully("I", chars) );         assertEquals("I", WordUtils.capitalizeFully("i", chars) );         assertEquals("I-Am Here+123", WordUtils.capitalizeFully("i-am here+123", chars) );         assertEquals("I Am+Here-123", WordUtils.capitalizeFully("I Am+Here-123", chars) );         assertEquals("I+Am-Here 123", WordUtils.capitalizeFully("i+am-HERE 123", chars) );         assertEquals("I-Am Here+123", WordUtils.capitalizeFully("I-AM HERE+123", chars) );         chars = new char[] {'.'};         assertEquals("I am.Fine", WordUtils.capitalizeFully("i aM.fine", chars) );         assertEquals("I Am.fine", WordUtils.capitalizeFully("i am.fine", null) );     }      @Test     public void testContainsAllWords_StringString() {         assertFalse(WordUtils.containsAllWords(null, (String) null));         assertFalse(WordUtils.containsAllWords(null, ""));         assertFalse(WordUtils.containsAllWords(null, "ab"));          assertFalse(WordUtils.containsAllWords("", (String) null));         assertFalse(WordUtils.containsAllWords("", ""));         assertFalse(WordUtils.containsAllWords("", "ab"));          assertFalse(WordUtils.containsAllWords("foo", (String) null));         assertFalse(WordUtils.containsAllWords("bar", ""));         assertFalse(WordUtils.containsAllWords("zzabyycdxx", "by"));         assertTrue(WordUtils.containsAllWords("lorem ipsum dolor sit amet", "ipsum", "lorem", "dolor"));         assertFalse(WordUtils.containsAllWords("lorem ipsum dolor sit amet", "ipsum", null, "lorem", "dolor"));         assertFalse(WordUtils.containsAllWords("lorem ipsum null dolor sit amet", "ipsum", null, "lorem", "dolor"));         assertFalse(WordUtils.containsAllWords("ab", "b"));         assertFalse(WordUtils.containsAllWords("ab", "z"));     }      @Test     public void testUncapitalize_String() {         assertNull(WordUtils.uncapitalize(null));         assertEquals("", WordUtils.uncapitalize(""));         assertEquals("  ", WordUtils.uncapitalize("  "));          assertEquals("i", WordUtils.uncapitalize("I") );         assertEquals("i", WordUtils.uncapitalize("i") );         assertEquals("i am here 123", WordUtils.uncapitalize("i am here 123") );         assertEquals("i am here 123", WordUtils.uncapitalize("I Am Here 123") );         assertEquals("i am hERE 123", WordUtils.uncapitalize("i am HERE 123") );         assertEquals("i aM hERE 123", WordUtils.uncapitalize("I AM HERE 123") );     }      @Test     public void testUncapitalizeWithDelimiters_String() {         assertNull(WordUtils.uncapitalize(null, null));         assertEquals("", WordUtils.uncapitalize(""));         assertEquals("  ", WordUtils.uncapitalize("  "));          char[] chars = new char[] { '-', '+', ' ', '@' };         assertEquals("i", WordUtils.uncapitalize("I", chars) );         assertEquals("i", WordUtils.uncapitalize("i", chars) );         assertEquals("i am-here+123", WordUtils.uncapitalize("i am-here+123", chars) );         assertEquals("i+am here-123", WordUtils.uncapitalize("I+Am Here-123", chars) );         assertEquals("i-am+hERE 123", WordUtils.uncapitalize("i-am+HERE 123", chars) );         assertEquals("i aM-hERE+123", WordUtils.uncapitalize("I AM-HERE+123", chars) );         chars = new char[] {'.'};         assertEquals("i AM.fINE", WordUtils.uncapitalize("I AM.FINE", chars) );         assertEquals("i aM.FINE", WordUtils.uncapitalize("I AM.FINE", null) );     }      //-----------------------------------------------------------------------     @Test     public void testInitials_String() {         assertNull(WordUtils.initials(null));         assertEquals("", WordUtils.initials(""));         assertEquals("", WordUtils.initials("  "));          assertEquals("I", WordUtils.initials("I"));         assertEquals("i", WordUtils.initials("i"));         assertEquals("BJL", WordUtils.initials("Ben John Lee"));         assertEquals("BJL", WordUtils.initials("   Ben \n   John\tLee\t"));         assertEquals("BJ", WordUtils.initials("Ben J.Lee"));         assertEquals("BJ.L", WordUtils.initials(" Ben   John  . Lee"));         assertEquals("iah1", WordUtils.initials("i am here 123"));     }      // -----------------------------------------------------------------------     @Test     public void testInitials_String_charArray() {         char[] array = null;         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals("", WordUtils.initials("  ", array));         assertEquals("I", WordUtils.initials("I", array));         assertEquals("i", WordUtils.initials("i", array));         assertEquals("S", WordUtils.initials("SJC", array));         assertEquals("BJL", WordUtils.initials("Ben John Lee", array));         assertEquals("BJL", WordUtils.initials("   Ben \n   John\tLee\t", array));         assertEquals("BJ", WordUtils.initials("Ben J.Lee", array));         assertEquals("BJ.L", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("KO", WordUtils.initials("Kay O'Murphy", array));         assertEquals("iah1", WordUtils.initials("i am here 123", array));          array = new char[0];         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals("", WordUtils.initials("  ", array));         assertEquals("", WordUtils.initials("I", array));         assertEquals("", WordUtils.initials("i", array));         assertEquals("", WordUtils.initials("SJC", array));         assertEquals("", WordUtils.initials("Ben John Lee", array));         assertEquals("", WordUtils.initials("   Ben \n   John\tLee\t", array));         assertEquals("", WordUtils.initials("Ben J.Lee", array));         assertEquals("", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("", WordUtils.initials("Kay O'Murphy", array));         assertEquals("", WordUtils.initials("i am here 123", array));          array = " ".toCharArray();         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals("", WordUtils.initials("  ", array));         assertEquals("I", WordUtils.initials("I", array));         assertEquals("i", WordUtils.initials("i", array));         assertEquals("S", WordUtils.initials("SJC", array));         assertEquals("BJL", WordUtils.initials("Ben John Lee", array));         assertEquals("BJ", WordUtils.initials("Ben J.Lee", array));         assertEquals("B\nJ", WordUtils.initials("   Ben \n   John\tLee\t", array));         assertEquals("BJ.L", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("KO", WordUtils.initials("Kay O'Murphy", array));         assertEquals("iah1", WordUtils.initials("i am here 123", array));          array = " .".toCharArray();         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals("", WordUtils.initials("  ", array));         assertEquals("I", WordUtils.initials("I", array));         assertEquals("i", WordUtils.initials("i", array));         assertEquals("S", WordUtils.initials("SJC", array));         assertEquals("BJL", WordUtils.initials("Ben John Lee", array));         assertEquals("BJL", WordUtils.initials("Ben J.Lee", array));         assertEquals("BJL", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("KO", WordUtils.initials("Kay O'Murphy", array));         assertEquals("iah1", WordUtils.initials("i am here 123", array));          array = " .'".toCharArray();         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals("", WordUtils.initials("  ", array));         assertEquals("I", WordUtils.initials("I", array));         assertEquals("i", WordUtils.initials("i", array));         assertEquals("S", WordUtils.initials("SJC", array));         assertEquals("BJL", WordUtils.initials("Ben John Lee", array));         assertEquals("BJL", WordUtils.initials("Ben J.Lee", array));         assertEquals("BJL", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("KOM", WordUtils.initials("Kay O'Murphy", array));         assertEquals("iah1", WordUtils.initials("i am here 123", array));          array = "SIJo1".toCharArray();         assertNull(WordUtils.initials(null, array));         assertEquals("", WordUtils.initials("", array));         assertEquals(" ", WordUtils.initials("  ", array));         assertEquals("", WordUtils.initials("I", array));         assertEquals("i", WordUtils.initials("i", array));         assertEquals("C", WordUtils.initials("SJC", array));         assertEquals("Bh", WordUtils.initials("Ben John Lee", array));         assertEquals("B.", WordUtils.initials("Ben J.Lee", array));         assertEquals(" h", WordUtils.initials(" Ben   John  . Lee", array));         assertEquals("K", WordUtils.initials("Kay O'Murphy", array));         assertEquals("i2", WordUtils.initials("i am here 123", array));     }      // -----------------------------------------------------------------------     @Test     public void testSwapCase_String() {         assertNull(WordUtils.swapCase(null));         assertEquals("", WordUtils.swapCase(""));         assertEquals("  ", WordUtils.swapCase("  "));          assertEquals("i", WordUtils.swapCase("I") );         assertEquals("I", WordUtils.swapCase("i") );         assertEquals("I AM HERE 123", WordUtils.swapCase("i am here 123") );         assertEquals("i aM hERE 123", WordUtils.swapCase("I Am Here 123") );         assertEquals("I AM here 123", WordUtils.swapCase("i am HERE 123") );         assertEquals("i am here 123", WordUtils.swapCase("I AM HERE 123") );          final String test = "This String contains a TitleCase character: \u01C8";         final String expect = "tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \u01C9";         assertEquals(expect, WordUtils.swapCase(test));     }      @Test     public void testLANG1292() {         // Prior to fix, this was throwing StringIndexOutOfBoundsException         WordUtils.wrap("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "                 + "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "                 + "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 70);     }      @Test     public void testLANG1397() {         // Prior to fix, this was throwing StringIndexOutOfBoundsException         WordUtils.wrap("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "             + "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "             + "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", Integer.MAX_VALUE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.HashMap; import java.util.Map; import java.util.Properties;  import org.junit.jupiter.api.Test;  /**  * Test class for StrLookup.  */ @Deprecated public class StrLookupTest  {      //-----------------------------------------------------------------------     @Test     public void testNoneLookup() {         assertNull(StrLookup.noneLookup().lookup(null));         assertNull(StrLookup.noneLookup().lookup(""));         assertNull(StrLookup.noneLookup().lookup("any"));     }      @Test     public void testSystemPropertiesLookup() {         assertEquals(System.getProperty("os.name"), StrLookup.systemPropertiesLookup().lookup("os.name"));         assertNull(StrLookup.systemPropertiesLookup().lookup(""));         assertNull(StrLookup.systemPropertiesLookup().lookup("other"));         assertThrows(NullPointerException.class, () -> StrLookup.systemPropertiesLookup().lookup(null));     }      /**      * Tests that a lookup object for system properties can deal with a full      * replacement of the system properties object. This test is related to      * LANG-1055.      */     @Test     public void testSystemPropertiesLookupReplacedProperties() {         final Properties oldProperties = System.getProperties();         final String osName = "os.name";         final String newOsName = oldProperties.getProperty(osName) + "_changed";          final StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();         final Properties newProps = new Properties();         newProps.setProperty(osName, newOsName);         System.setProperties(newProps);         try {             assertEquals(newOsName, sysLookup.lookup(osName), "Changed properties not detected");         } finally {             System.setProperties(oldProperties);         }     }      /**      * Tests that a lookup object for system properties sees changes on system      * properties. This test is related to LANG-1141.      */     @Test     public void testSystemPropertiesLookupUpdatedProperty() {         final String osName = "os.name";         final String oldOs = System.getProperty(osName);         final String newOsName = oldOs + "_changed";          final StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();         System.setProperty(osName, newOsName);         try {             assertEquals(newOsName, sysLookup.lookup(osName), "Changed properties not detected");         } finally {             System.setProperty(osName, oldOs);         }     }      @Test     public void testMapLookup() {         final Map<String, Object> map = new HashMap<>();         map.put("key", "value");         map.put("number", Integer.valueOf(2));         assertEquals("value", StrLookup.mapLookup(map).lookup("key"));         assertEquals("2", StrLookup.mapLookup(map).lookup("number"));         assertNull(StrLookup.mapLookup(map).lookup(null));         assertNull(StrLookup.mapLookup(map).lookup(""));         assertNull(StrLookup.mapLookup(map).lookup("other"));     }      @Test     public void testMapLookup_nullMap() {         final Map<String, ?> map = null;         assertNull(StrLookup.mapLookup(map).lookup(null));         assertNull(StrLookup.mapLookup(map).lookup(""));         assertNull(StrLookup.mapLookup(map).lookup("any"));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals;  import java.text.DateFormat; import java.text.FieldPosition; import java.text.Format; import java.text.MessageFormat; import java.text.NumberFormat; import java.text.ParsePosition; import java.util.Arrays; import java.util.Calendar; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Locale; import java.util.Map;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Test case for {@link ExtendedMessageFormat}.  *  * @since 2.4  */ @Deprecated public class ExtendedMessageFormatTest {      private final Map<String, FormatFactory> registry = new HashMap<>();      @BeforeEach     public void setUp() {         registry.put("lower", new LowerCaseFormatFactory());         registry.put("upper", new UpperCaseFormatFactory());     }      /**      * Test extended formats.      */     @Test     public void testExtendedFormats() {         final String pattern = "Lower: {0,lower} Upper: {1,upper}";         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);         assertEquals(pattern, emf.toPattern(), "TOPATTERN");         assertEquals(emf.format(new Object[] {"foo", "bar"}), "Lower: foo Upper: BAR");         assertEquals(emf.format(new Object[] {"Foo", "Bar"}), "Lower: foo Upper: BAR");         assertEquals(emf.format(new Object[] {"FOO", "BAR"}), "Lower: foo Upper: BAR");         assertEquals(emf.format(new Object[] {"FOO", "bar"}), "Lower: foo Upper: BAR");         assertEquals(emf.format(new Object[] {"foo", "BAR"}), "Lower: foo Upper: BAR");     }      /**      * Test Bug LANG-477 - out of memory error with escaped quote      */     @Test     public void testEscapedQuote_LANG_477() {         final String pattern = "it''s a {0,lower} 'test'!";         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);         assertEquals("it's a dummy test!", emf.format(new Object[] {"DUMMY"}));     }      /**      * Test Bug LANG-917 - IndexOutOfBoundsException and/or infinite loop when using a choice pattern      */     @Test     public void testEmbeddedPatternInChoice() {         final String pattern = "Hi {0,lower}, got {1,choice,0#none|1#one|1<{1,number}}, {2,upper}!";         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);         assertEquals(emf.format(new Object[] {"there", 3, "great"}), "Hi there, got 3, GREAT!");     }      /**      * Test Bug LANG-948 - Exception while using ExtendedMessageFormat and escaping braces      */     @Test     public void testEscapedBraces_LANG_948() {         // message without placeholder because braces are escaped by quotes         final String pattern = "Message without placeholders '{}'";         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);         assertEquals("Message without placeholders {}", emf.format(new Object[] {"DUMMY"}));          // message with placeholder because quotes are escaped by quotes         final String pattern2 = "Message with placeholder ''{0}''";         final ExtendedMessageFormat emf2 = new ExtendedMessageFormat(pattern2, registry);         assertEquals("Message with placeholder 'DUMMY'", emf2.format(new Object[] {"DUMMY"}));     }      /**      * Test extended and built in formats.      */     @Test     public void testExtendedAndBuiltInFormats() {         final Calendar cal = Calendar.getInstance();         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 5);         final Object[] args = new Object[] {"John Doe", cal.getTime(), Double.valueOf("12345.67")};         final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}";         final String extendedPattern = "Name: {0,upper} ";         final String pattern = extendedPattern + builtinsPattern;          final HashSet<Locale> testLocales = new HashSet<>(Arrays.asList(DateFormat.getAvailableLocales()));         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));         testLocales.add(null);          for (final Locale locale : testLocales) {             final MessageFormat builtins = createMessageFormat(builtinsPattern, locale);             final String expectedPattern = extendedPattern + builtins.toPattern();             DateFormat df = null;             NumberFormat nf = null;             ExtendedMessageFormat emf = null;             if (locale == null) {                 df = DateFormat.getDateInstance(DateFormat.SHORT);                 nf = NumberFormat.getCurrencyInstance();                 emf = new ExtendedMessageFormat(pattern, registry);             } else {                 df = DateFormat.getDateInstance(DateFormat.SHORT, locale);                 nf = NumberFormat.getCurrencyInstance(locale);                 emf = new ExtendedMessageFormat(pattern, locale, registry);             }             final StringBuilder expected = new StringBuilder();             expected.append("Name: ");             expected.append(args[0].toString().toUpperCase(Locale.ROOT));             expected.append(" DOB: ");             expected.append(df.format(args[1]));             expected.append(" Salary: ");             expected.append(nf.format(args[2]));             assertEquals(expectedPattern, emf.toPattern(), "pattern comparison for locale " + locale);             assertEquals(expected.toString(), emf.format(args), String.valueOf(locale));         }     }  //    /** //     * Test extended formats with choice format. //     * //     * NOTE: FAILING - currently sub-formats not supported //     */ //    public void testExtendedWithChoiceFormat() { //        String pattern = "Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}"; //        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); //        assertPatterns(null, pattern, emf.toPattern()); //        try { //            assertEquals("one", emf.format(new Object[] {Integer.valueOf(1), "ONE"})); //            assertEquals("TWO", emf.format(new Object[] {Integer.valueOf(2), "two"})); //        } catch (IllegalArgumentException e) { //            // currently sub-formats not supported //        } //    }  //    /** //     * Test mixed extended and built-in formats with choice format. //     * //     * NOTE: FAILING - currently sub-formats not supported //     */ //    public void testExtendedAndBuiltInWithChoiceFormat() { //        String pattern = "Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}"; //        Object[] lowArgs  = new Object[] {Integer.valueOf(1), "Low",  Double.valueOf("1234.56")}; //        Object[] highArgs = new Object[] {Integer.valueOf(2), "High", Double.valueOf("9876.54")}; //        Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); //        Locale[] testLocales = new Locale[availableLocales.length + 1]; //        testLocales[0] = null; //        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length); //        for (int i = 0; i < testLocales.length; i++) { //            NumberFormat nf = null; //            NumberFormat cf = null; //            ExtendedMessageFormat emf = null; //            if (testLocales[i] == null) { //                nf = NumberFormat.getNumberInstance(); //                cf = NumberFormat.getCurrencyInstance(); //                emf = new ExtendedMessageFormat(pattern, registry); //            } else { //                nf = NumberFormat.getNumberInstance(testLocales[i]); //                cf = NumberFormat.getCurrencyInstance(testLocales[i]); //                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry); //            } //            assertPatterns(null, pattern, emf.toPattern()); //            try { //                String lowExpected = lowArgs[0] + " low "    + nf.format(lowArgs[2]); //                String highExpected = highArgs[0] + " HIGH "  + cf.format(highArgs[2]); //                assertEquals(lowExpected,  emf.format(lowArgs)); //                assertEquals(highExpected, emf.format(highArgs)); //            } catch (IllegalArgumentException e) { //                // currently sub-formats not supported //            } //        } //    }      /**      * Test the built in choice format.      */     @Test     public void testBuiltInChoiceFormat() {         final Object[] values = new Number[] {Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5")};         String choicePattern = null;         final Locale[] availableLocales = NumberFormat.getAvailableLocales();          choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}";         for (final Object value : values) {             checkBuiltInFormat(value + ": " + choicePattern, new Object[] {value}, availableLocales);         }          choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}";         for (final Object value : values) {             checkBuiltInFormat(value + ": " + choicePattern, new Object[] {value}, availableLocales);         }     }      /**      * Test the built in date/time formats      */     @Test     public void testBuiltInDateTimeFormat() {         final Calendar cal = Calendar.getInstance();         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 5);         final Object[] args = new Object[] {cal.getTime()};         final Locale[] availableLocales = DateFormat.getAvailableLocales();          checkBuiltInFormat("1: {0,date,short}",    args, availableLocales);         checkBuiltInFormat("2: {0,date,medium}",   args, availableLocales);         checkBuiltInFormat("3: {0,date,long}",     args, availableLocales);         checkBuiltInFormat("4: {0,date,full}",     args, availableLocales);         checkBuiltInFormat("5: {0,date,d MMM yy}", args, availableLocales);         checkBuiltInFormat("6: {0,time,short}",    args, availableLocales);         checkBuiltInFormat("7: {0,time,medium}",   args, availableLocales);         checkBuiltInFormat("8: {0,time,long}",     args, availableLocales);         checkBuiltInFormat("9: {0,time,full}",     args, availableLocales);         checkBuiltInFormat("10: {0,time,HH:mm}",   args, availableLocales);         checkBuiltInFormat("11: {0,date}",         args, availableLocales);         checkBuiltInFormat("12: {0,time}",         args, availableLocales);     }      @Test     public void testOverriddenBuiltinFormat() {         final Calendar cal = Calendar.getInstance();         cal.set(2007, Calendar.JANUARY, 23);         final Object[] args = new Object[] {cal.getTime()};         final Locale[] availableLocales = DateFormat.getAvailableLocales();         final Map<String, ? extends FormatFactory> dateRegistry = Collections.singletonMap("date", new OverrideShortDateFormatFactory());          //check the non-overridden builtins:         checkBuiltInFormat("1: {0,date}", dateRegistry,          args, availableLocales);         checkBuiltInFormat("2: {0,date,medium}", dateRegistry,   args, availableLocales);         checkBuiltInFormat("3: {0,date,long}", dateRegistry,     args, availableLocales);         checkBuiltInFormat("4: {0,date,full}", dateRegistry,     args, availableLocales);         checkBuiltInFormat("5: {0,date,d MMM yy}", dateRegistry, args, availableLocales);          //check the overridden format:         for (int i = -1; i < availableLocales.length; i++) {             final Locale locale = i < 0 ? null : availableLocales[i];             final MessageFormat dateDefault = createMessageFormat("{0,date}", locale);             final String pattern = "{0,date,short}";             final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, dateRegistry);             assertEquals(dateDefault.format(args), dateShort.format(args), "overridden date,short format");             assertEquals(pattern, dateShort.toPattern(), "overridden date,short pattern");         }     }      /**      * Test the built in number formats.      */     @Test     public void testBuiltInNumberFormat() {         final Object[] args = new Object[] {Double.valueOf("6543.21")};         final Locale[] availableLocales = NumberFormat.getAvailableLocales();         checkBuiltInFormat("1: {0,number}",            args, availableLocales);         checkBuiltInFormat("2: {0,number,integer}",    args, availableLocales);         checkBuiltInFormat("3: {0,number,currency}",   args, availableLocales);         checkBuiltInFormat("4: {0,number,percent}",    args, availableLocales);         checkBuiltInFormat("5: {0,number,00000.000}",  args, availableLocales);     }      /**      * Test equals() and hashcode.      */     @Test     public void testEqualsHashcode() {         final Map<String, ? extends FormatFactory> fmtRegistry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory());         final Map<String, ? extends FormatFactory> otherRegistry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory());          final String pattern = "Pattern: {0,testfmt}";         final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, fmtRegistry);          ExtendedMessageFormat other = null;          // Same object         assertEquals(emf, emf, "same, equals()");         assertEquals(emf.hashCode(), emf.hashCode(), "same, hashcode()");          // Equal Object         other = new ExtendedMessageFormat(pattern, Locale.US, fmtRegistry);         assertEquals(emf, other, "equal, equals()");         assertEquals(emf.hashCode(), other.hashCode(), "equal, hashcode()");          // Different Class         other = new OtherExtendedMessageFormat(pattern, Locale.US, fmtRegistry);         assertNotEquals(emf, other, "class, equals()");         assertEquals(emf.hashCode(), other.hashCode(), "class, hashcode()"); // same hashcode          // Different pattern         other = new ExtendedMessageFormat("X" + pattern, Locale.US, fmtRegistry);         assertNotEquals(emf, other, "pattern, equals()");         assertNotEquals(emf.hashCode(), other.hashCode(), "pattern, hashcode()");          // Different registry         other = new ExtendedMessageFormat(pattern, Locale.US, otherRegistry);         assertNotEquals(emf, other, "registry, equals()");         assertNotEquals(emf.hashCode(), other.hashCode(), "registry, hashcode()");          // Different Locale         other = new ExtendedMessageFormat(pattern, Locale.FRANCE, fmtRegistry);         assertNotEquals(emf, other, "locale, equals()");         assertEquals(emf.hashCode(), other.hashCode(), "locale, hashcode()"); // same hashcode     }      /**      * Test a built in format for the specified Locales, plus {@code null} Locale.      * @param pattern MessageFormat pattern      * @param args MessageFormat arguments      * @param locales to test      */     private void checkBuiltInFormat(final String pattern, final Object[] args, final Locale[] locales) {         checkBuiltInFormat(pattern, null, args, locales);     }      /**      * Test a built in format for the specified Locales, plus {@code null} Locale.      * @param pattern MessageFormat pattern      * @param fmtRegistry FormatFactory registry to use      * @param args MessageFormat arguments      * @param locales to test      */     private void checkBuiltInFormat(final String pattern, final Map<String, ?> fmtRegistry, final Object[] args, final Locale[] locales) {         checkBuiltInFormat(pattern, fmtRegistry, args, (Locale) null);         for (final Locale locale : locales) {             checkBuiltInFormat(pattern, fmtRegistry, args, locale);         }     }      /**      * Create an ExtendedMessageFormat for the specified pattern and locale and check the      * formatted output matches the expected result for the parameters.      * @param pattern string      * @param registryUnused map (currently unused)      * @param args Object[]      * @param locale Locale      */     private void checkBuiltInFormat(final String pattern, final Map<String, ?> registryUnused, final Object[] args, final Locale locale) {         final StringBuilder buffer = new StringBuilder();         buffer.append("Pattern=[");         buffer.append(pattern);         buffer.append("], locale=[");         buffer.append(locale);         buffer.append("]");         final MessageFormat mf = createMessageFormat(pattern, locale);         ExtendedMessageFormat emf = null;         if (locale == null) {             emf = new ExtendedMessageFormat(pattern);         } else {             emf = new ExtendedMessageFormat(pattern, locale);         }         assertEquals(mf.format(args), emf.format(args), "format "    + buffer.toString());         assertEquals(mf.toPattern(), emf.toPattern(), "toPattern " + buffer.toString());     }      /**      * Replace MessageFormat(String, Locale) constructor (not available until JDK 1.4).      * @param pattern string      * @param locale Locale      * @return MessageFormat      */     private MessageFormat createMessageFormat(final String pattern, final Locale locale) {         final MessageFormat result = new MessageFormat(pattern);         if (locale != null) {             result.setLocale(locale);             result.applyPattern(pattern);         }         return result;     }      // ------------------------ Test Formats ------------------------      /**      * {@link Format} implementation which converts to lower case.      */     private static class LowerCaseFormat extends Format {         private static final long serialVersionUID = 1L;          @Override         public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {             return toAppendTo.append(((String) obj).toLowerCase(Locale.ROOT));         }         @Override         public Object parseObject(final String source, final ParsePosition pos) {             throw new UnsupportedOperationException();         }     }      /**      * {@link Format} implementation which converts to upper case.      */     private static class UpperCaseFormat extends Format {         private static final long serialVersionUID = 1L;          @Override         public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {             return toAppendTo.append(((String) obj).toUpperCase(Locale.ROOT));         }          @Override         public Object parseObject(final String source, final ParsePosition pos) {             throw new UnsupportedOperationException();         }     }       // ------------------------ Test Format Factories ---------------     /**      * {@link FormatFactory} implementation for lower case format.      */     private static class LowerCaseFormatFactory implements FormatFactory {         private static final Format LOWER_INSTANCE = new LowerCaseFormat();          @Override         public Format getFormat(final String name, final String arguments, final Locale locale) {             return LOWER_INSTANCE;         }     }     /**      * {@link FormatFactory} implementation for upper case format.      */     private static class UpperCaseFormatFactory implements FormatFactory {         private static final Format UPPER_INSTANCE = new UpperCaseFormat();          @Override         public Format getFormat(final String name, final String arguments, final Locale locale) {             return UPPER_INSTANCE;         }     }     /**      * {@link FormatFactory} implementation to override date format "short" to "default".      */     private static class OverrideShortDateFormatFactory implements FormatFactory {          @Override         public Format getFormat(final String name, final String arguments, final Locale locale) {             return !"short".equals(arguments) ? null                     : locale == null ? DateFormat                             .getDateInstance(DateFormat.DEFAULT) : DateFormat                             .getDateInstance(DateFormat.DEFAULT, locale);         }     }      /**      * Alternative ExtendedMessageFormat impl.      */     private static class OtherExtendedMessageFormat extends ExtendedMessageFormat {         private static final long serialVersionUID = 1L;          OtherExtendedMessageFormat(final String pattern, final Locale locale,                 final Map<String, ? extends FormatFactory> registry) {             super(pattern, locale, registry);         }      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.NoSuchElementException;  import org.apache.commons.lang3.ArrayUtils; import org.junit.jupiter.api.Test;  /**  * Unit test for Tokenizer.  */ @Deprecated public class StrTokenizerTest {      private static final String CSV_SIMPLE_FIXTURE = "A,b,c";      private static final String TSV_SIMPLE_FIXTURE = "A\tb\tc";      private void checkClone(final StrTokenizer tokenizer) {         assertNotSame(StrTokenizer.getCSVInstance(), tokenizer);         assertNotSame(StrTokenizer.getTSVInstance(), tokenizer);     }      // -----------------------------------------------------------------------     @Test     public void test1() {          final String input = "a;b;c;\"d;\"\"e\";f; ; ;  ";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", "c", "d;\"e", "f", "", "", ""};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test2() {          final String input = "a;b;c ;\"d;\"\"e\";f; ; ;";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.noneMatcher());         tok.setIgnoreEmptyTokens(false);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", "c ", "d;\"e", "f", " ", " ", ""};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test3() {          final String input = "a;b; c;\"d;\"\"e\";f; ; ;";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.noneMatcher());         tok.setIgnoreEmptyTokens(false);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", " c", "d;\"e", "f", " ", " ", ""};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test4() {          final String input = "a;b; c;\"d;\"\"e\";f; ; ;";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(true);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", "c", "d;\"e", "f"};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test5() {          final String input = "a;b; c;\"d;\"\"e\";f; ; ;";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", "c", "d;\"e", "f", null, null, null};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test6() {          final String input = "a;b; c;\"d;\"\"e\";f; ; ;";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterChar(';');         tok.setQuoteChar('"');         tok.setIgnoredMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         // tok.setTreatingEmptyAsNull(true);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", " c", "d;\"e", "f", null, null, null};          int nextCount = 0;         while (tok.hasNext()) {             tok.next();             nextCount++;         }          int prevCount = 0;         while (tok.hasPrevious()) {             tok.previous();             prevCount++;         }          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));          assertEquals(nextCount, expected.length, "could not cycle through entire token list" + " using the 'hasNext' and 'next' methods");          assertEquals(prevCount, expected.length, "could not cycle through entire token list" + " using the 'hasPrevious' and 'previous' methods");      }      @Test     public void test7() {          final String input = "a   b c \"d e\" f ";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterMatcher(StrMatcher.spaceMatcher());         tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());         tok.setIgnoredMatcher(StrMatcher.noneMatcher());         tok.setIgnoreEmptyTokens(false);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "", "", "b", "c", "d e", "f", ""};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void test8() {          final String input = "a   b c \"d e\" f ";         final StrTokenizer tok = new StrTokenizer(input);         tok.setDelimiterMatcher(StrMatcher.spaceMatcher());         tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());         tok.setIgnoredMatcher(StrMatcher.noneMatcher());         tok.setIgnoreEmptyTokens(true);         final String[] tokens = tok.getTokenArray();          final String[] expected = new String[]{"a", "b", "c", "d e", "f"};          assertEquals(expected.length, tokens.length, ArrayUtils.toString(tokens));         for (int i = 0; i < expected.length; i++) {             assertEquals(expected[i], tokens[i],                     "token[" + i + "] was '" + tokens[i] + "' but was expected to be '" + expected[i] + "'");         }      }      @Test     public void testBasic1() {         final String input = "a  b c";         final StrTokenizer tok = new StrTokenizer(input);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasic2() {         final String input = "a \nb\fc";         final StrTokenizer tok = new StrTokenizer(input);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasic3() {         final String input = "a \nb\u0001\fc";         final StrTokenizer tok = new StrTokenizer(input);         assertEquals("a", tok.next());         assertEquals("b\u0001", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasic4() {         final String input = "a \"b\" c";         final StrTokenizer tok = new StrTokenizer(input);         assertEquals("a", tok.next());         assertEquals("\"b\"", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasic5() {         final String input = "a:b':c";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         assertEquals("a", tok.next());         assertEquals("b'", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicDelim1() {         final String input = "a:b:c";         final StrTokenizer tok = new StrTokenizer(input, ':');         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicDelim2() {         final String input = "a:b:c";         final StrTokenizer tok = new StrTokenizer(input, ',');         assertEquals("a:b:c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicEmpty1() {         final String input = "a  b c";         final StrTokenizer tok = new StrTokenizer(input);         tok.setIgnoreEmptyTokens(false);         assertEquals("a", tok.next());         assertEquals("", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicEmpty2() {         final String input = "a  b c";         final StrTokenizer tok = new StrTokenizer(input);         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertNull(tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted1() {         final String input = "a 'b' c";         final StrTokenizer tok = new StrTokenizer(input, ' ', '\'');         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted2() {         final String input = "a:'b':";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted3() {         final String input = "a:'b''c'";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b'c", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted4() {         final String input = "a: 'b' 'c' :d";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b c", tok.next());         assertEquals("d", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted5() {         final String input = "a: 'b'x'c' :d";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("bxc", tok.next());         assertEquals("d", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted6() {         final String input = "a:'b'\"c':d";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setQuoteMatcher(StrMatcher.quoteMatcher());         assertEquals("a", tok.next());         assertEquals("b\"c:d", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuoted7() {         final String input = "a:\"There's a reason here\":b";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setQuoteMatcher(StrMatcher.quoteMatcher());         assertEquals("a", tok.next());         assertEquals("There's a reason here", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicQuotedTrimmed1() {         final String input = "a: 'b' :";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicTrimmed1() {         final String input = "a: b :  ";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicTrimmed2() {         final String input = "a:  b  :";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setTrimmerMatcher(StrMatcher.stringMatcher("  "));         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicIgnoreTrimmed1() {         final String input = "a: bIGNOREc : ";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE"));         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("bc", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicIgnoreTrimmed2() {         final String input = "IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE ";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE"));         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("bc", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicIgnoreTrimmed3() {         final String input = "IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE ";         final StrTokenizer tok = new StrTokenizer(input, ':');         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE"));         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("  bc  ", tok.next());         assertEquals("  ", tok.next());         assertFalse(tok.hasNext());     }      @Test     public void testBasicIgnoreTrimmed4() {         final String input = "IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE ";         final StrTokenizer tok = new StrTokenizer(input, ':', '\'');         tok.setIgnoredMatcher(StrMatcher.stringMatcher("IGNORE"));         tok.setTrimmerMatcher(StrMatcher.trimMatcher());         tok.setIgnoreEmptyTokens(false);         tok.setEmptyTokenAsNull(true);         assertEquals("a", tok.next());         assertEquals("bIGNOREcd", tok.next());         assertNull(tok.next());         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testListArray() {         final String input = "a  b c";         final StrTokenizer tok = new StrTokenizer(input);         final String[] array = tok.getTokenArray();         final List<?> list = tok.getTokenList();          assertEquals(Arrays.asList(array), list);         assertEquals(3, list.size());     }      //-----------------------------------------------------------------------     private void testCSV(final String data) {         this.testXSVAbc(StrTokenizer.getCSVInstance(data));         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray()));     }      @Test     public void testCSVEmpty() {         this.testEmpty(StrTokenizer.getCSVInstance());         this.testEmpty(StrTokenizer.getCSVInstance(""));     }      @Test     public void testCSVSimple() {         this.testCSV(CSV_SIMPLE_FIXTURE);     }      @Test     public void testCSVSimpleNeedsTrim() {         this.testCSV("   " + CSV_SIMPLE_FIXTURE);         this.testCSV("   \n\t  " + CSV_SIMPLE_FIXTURE);         this.testCSV("   \n  " + CSV_SIMPLE_FIXTURE + "\n\n\r");     }      void testEmpty(final StrTokenizer tokenizer) {         this.checkClone(tokenizer);         assertFalse(tokenizer.hasNext());         assertFalse(tokenizer.hasPrevious());         assertNull(tokenizer.nextToken());         assertEquals(0, tokenizer.size());         assertThrows(NoSuchElementException.class, tokenizer::next);     }      @Test     public void testGetContent() {         final String input = "a   b c \"d e\" f ";         StrTokenizer tok = new StrTokenizer(input);         assertEquals(input, tok.getContent());          tok = new StrTokenizer(input.toCharArray());         assertEquals(input, tok.getContent());          tok = new StrTokenizer();         assertNull(tok.getContent());     }      //-----------------------------------------------------------------------     @Test     public void testChaining() {         final StrTokenizer tok = new StrTokenizer();         assertEquals(tok, tok.reset());         assertEquals(tok, tok.reset(""));         assertEquals(tok, tok.reset(new char[0]));         assertEquals(tok, tok.setDelimiterChar(' '));         assertEquals(tok, tok.setDelimiterString(" "));         assertEquals(tok, tok.setDelimiterMatcher(null));         assertEquals(tok, tok.setQuoteChar(' '));         assertEquals(tok, tok.setQuoteMatcher(null));         assertEquals(tok, tok.setIgnoredChar(' '));         assertEquals(tok, tok.setIgnoredMatcher(null));         assertEquals(tok, tok.setTrimmerMatcher(null));         assertEquals(tok, tok.setEmptyTokenAsNull(false));         assertEquals(tok, tok.setIgnoreEmptyTokens(false));     }      /**      * Tests that the {@link StrTokenizer#clone()} clone method catches {@link CloneNotSupportedException} and returns      * {@code null}.      */     @Test     public void testCloneNotSupportedException() {         final Object notCloned = new StrTokenizer() {             @Override             Object cloneReset() throws CloneNotSupportedException {                 throw new CloneNotSupportedException("test");             }         }.clone();         assertNull(notCloned);     }      @Test     public void testCloneNull() {         final StrTokenizer tokenizer = new StrTokenizer((char[]) null);         // Start sanity check         assertNull(tokenizer.nextToken());         tokenizer.reset();         assertNull(tokenizer.nextToken());         // End sanity check         final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();         tokenizer.reset();         assertNull(tokenizer.nextToken());         assertNull(clonedTokenizer.nextToken());     }      @Test     public void testCloneReset() {         final char[] input = new char[]{'a'};         final StrTokenizer tokenizer = new StrTokenizer(input);         // Start sanity check         assertEquals("a", tokenizer.nextToken());         tokenizer.reset(input);         assertEquals("a", tokenizer.nextToken());         // End sanity check         final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();         input[0] = 'b';         tokenizer.reset(input);         assertEquals("b", tokenizer.nextToken());         assertEquals("a", clonedTokenizer.nextToken());     }      // -----------------------------------------------------------------------     @Test     public void testConstructor_String() {         StrTokenizer tok = new StrTokenizer("a b");         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer("");         assertFalse(tok.hasNext());          tok = new StrTokenizer((String) null);         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_String_char() {         StrTokenizer tok = new StrTokenizer("a b", ' ');         assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1));         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer("", ' ');         assertFalse(tok.hasNext());          tok = new StrTokenizer((String) null, ' ');         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_String_char_char() {         StrTokenizer tok = new StrTokenizer("a b", ' ', '"');         assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1));         assertEquals(1, tok.getQuoteMatcher().isMatch("\"".toCharArray(), 0, 0, 1));         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer("", ' ', '"');         assertFalse(tok.hasNext());          tok = new StrTokenizer((String) null, ' ', '"');         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_charArray() {         StrTokenizer tok = new StrTokenizer("a b".toCharArray());         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer(new char[0]);         assertFalse(tok.hasNext());          tok = new StrTokenizer((char[]) null);         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_charArray_char() {         StrTokenizer tok = new StrTokenizer("a b".toCharArray(), ' ');         assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1));         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer(new char[0], ' ');         assertFalse(tok.hasNext());          tok = new StrTokenizer((char[]) null, ' ');         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testConstructor_charArray_char_char() {         StrTokenizer tok = new StrTokenizer("a b".toCharArray(), ' ', '"');         assertEquals(1, tok.getDelimiterMatcher().isMatch(" ".toCharArray(), 0, 0, 1));         assertEquals(1, tok.getQuoteMatcher().isMatch("\"".toCharArray(), 0, 0, 1));         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertFalse(tok.hasNext());          tok = new StrTokenizer(new char[0], ' ', '"');         assertFalse(tok.hasNext());          tok = new StrTokenizer((char[]) null, ' ', '"');         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testReset() {         final StrTokenizer tok = new StrTokenizer("a b c");         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());          tok.reset();         assertEquals("a", tok.next());         assertEquals("b", tok.next());         assertEquals("c", tok.next());         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testReset_String() {         final StrTokenizer tok = new StrTokenizer("x x x");         tok.reset("d e");         assertEquals("d", tok.next());         assertEquals("e", tok.next());         assertFalse(tok.hasNext());          tok.reset((String) null);         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testReset_charArray() {         final StrTokenizer tok = new StrTokenizer("x x x");          final char[] array = new char[] {'a', 'b', 'c'};         tok.reset(array);         assertEquals("abc", tok.next());         assertFalse(tok.hasNext());          tok.reset((char[]) null);         assertFalse(tok.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testTSV() {         this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE));         this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray()));     }      @Test     public void testTSVEmpty() {         this.testEmpty(StrTokenizer.getTSVInstance());         this.testEmpty(StrTokenizer.getTSVInstance(""));     }      void testXSVAbc(final StrTokenizer tokenizer) {         this.checkClone(tokenizer);         assertEquals(-1, tokenizer.previousIndex());         assertEquals(0, tokenizer.nextIndex());         assertNull(tokenizer.previousToken());         assertEquals("A", tokenizer.nextToken());         assertEquals(1, tokenizer.nextIndex());         assertEquals("b", tokenizer.nextToken());         assertEquals(2, tokenizer.nextIndex());         assertEquals("c", tokenizer.nextToken());         assertEquals(3, tokenizer.nextIndex());         assertNull(tokenizer.nextToken());         assertEquals(3, tokenizer.nextIndex());         assertEquals("c", tokenizer.previousToken());         assertEquals(2, tokenizer.nextIndex());         assertEquals("b", tokenizer.previousToken());         assertEquals(1, tokenizer.nextIndex());         assertEquals("A", tokenizer.previousToken());         assertEquals(0, tokenizer.nextIndex());         assertNull(tokenizer.previousToken());         assertEquals(0, tokenizer.nextIndex());         assertEquals(-1, tokenizer.previousIndex());         assertEquals(3, tokenizer.size());     }      @Test     public void testIteration() {         final StrTokenizer tkn = new StrTokenizer("a b c");         assertFalse(tkn.hasPrevious());         assertThrows(NoSuchElementException.class, tkn::previous);         assertTrue(tkn.hasNext());          assertEquals("a", tkn.next());         assertThrows(UnsupportedOperationException.class, tkn::remove);         assertThrows(UnsupportedOperationException.class, () -> tkn.set("x"));         assertThrows(UnsupportedOperationException.class, () -> tkn.add("y"));         assertTrue(tkn.hasPrevious());         assertTrue(tkn.hasNext());          assertEquals("b", tkn.next());         assertTrue(tkn.hasPrevious());         assertTrue(tkn.hasNext());          assertEquals("c", tkn.next());         assertTrue(tkn.hasPrevious());         assertFalse(tkn.hasNext());          assertThrows(NoSuchElementException.class, tkn::next);         assertTrue(tkn.hasPrevious());         assertFalse(tkn.hasNext());     }      //-----------------------------------------------------------------------     @Test     public void testTokenizeSubclassInputChange() {         final StrTokenizer tkn = new StrTokenizer("a b c d e") {             @Override             protected List<String> tokenize(final char[] chars, final int offset, final int count) {                 return super.tokenize("w x y z".toCharArray(), 2, 5);             }         };         assertEquals("x", tkn.next());         assertEquals("y", tkn.next());     }      //-----------------------------------------------------------------------     @Test     public void testTokenizeSubclassOutputChange() {         final StrTokenizer tkn = new StrTokenizer("a b c") {             @Override             protected List<String> tokenize(final char[] chars, final int offset, final int count) {                 final List<String> list = super.tokenize(chars, offset, count);                 Collections.reverse(list);                 return list;             }         };         assertEquals("c", tkn.next());         assertEquals("b", tkn.next());         assertEquals("a", tkn.next());     }      //-----------------------------------------------------------------------     @Test     public void testToString() {         final StrTokenizer tkn = new StrTokenizer("a b c d e");         assertEquals("StrTokenizer[not tokenized yet]", tkn.toString());         tkn.next();         assertEquals("StrTokenizer[a, b, c, d, e]", tkn.toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.HashSet; import java.util.Set;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.EntityArrays}.  */ @Deprecated public class EntityArraysTest  {      @Test     public void testConstructorExists() {         new EntityArrays();     }      // LANG-659 - check arrays for duplicate entries     @Test     public void testHTML40_EXTENDED_ESCAPE() {         final Set<String> col0 = new HashSet<>();         final Set<String> col1 = new HashSet<>();         final String [][] sa = EntityArrays.HTML40_EXTENDED_ESCAPE();         for (int i =0; i <sa.length; i++) {             assertTrue(col0.add(sa[i][0]), "Already added entry 0: "+i+" "+sa[i][0]);             assertTrue(col1.add(sa[i][1]), "Already added entry 1: "+i+" "+sa[i][1]);         }     }     // LANG-658 - check arrays for duplicate entries     @Test     public void testISO8859_1_ESCAPE() {         final Set<String> col0 = new HashSet<>();         final Set<String> col1 = new HashSet<>();         final String [][] sa = EntityArrays.ISO8859_1_ESCAPE();         boolean success = true;         for (int i =0; i <sa.length; i++) {             final boolean add0 = col0.add(sa[i][0]);             final boolean add1 = col1.add(sa[i][1]);             if (!add0) {                 success = false;                 System.out.println("Already added entry 0: "+i+" "+sa[i][0]+" "+sa[i][1]);             }             if (!add1) {                 success = false;                 System.out.println("Already added entry 1: "+i+" "+sa[i][0]+" "+sa[i][1]);             }         }         assertTrue(success, "One or more errors detected");     }   } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals;  import java.io.IOException; import java.io.StringWriter;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.LookupTranslator}.  */ @Deprecated public class LookupTranslatorTest  {      @Test     public void testBasicLookup() throws IOException {         final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { "one", "two" } });         final StringWriter out = new StringWriter();         final int result = lt.translate("one", 0, out);         assertEquals(3, result, "Incorrect codepoint consumption");         assertEquals("two", out.toString(), "Incorrect value");     }      // Tests: https://issues.apache.org/jira/browse/LANG-882     @Test     public void testLang882() throws IOException {         final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer("one"), new StringBuffer("two") } });         final StringWriter out = new StringWriter();         final int result = lt.translate(new StringBuffer("one"), 0, out);         assertEquals(3, result, "Incorrect codepoint consumption");         assertEquals("two", out.toString(), "Incorrect value");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.NumericEntityEscaper}.  */ @Deprecated public class NumericEntityEscaperTest  {      @Test     public void testBelow() {         final NumericEntityEscaper nee = NumericEntityEscaper.below('F');          final String input = "ADFGZ";         final String result = nee.translate(input);         assertEquals("&#65;&#68;FGZ", result, "Failed to escape numeric entities via the below method");     }      @Test     public void testBetween() {         final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L');          final String input = "ADFGZ";         final String result = nee.translate(input);         assertEquals("AD&#70;&#71;Z", result, "Failed to escape numeric entities via the between method");     }      @Test     public void testAbove() {         final NumericEntityEscaper nee = NumericEntityEscaper.above('F');          final String input = "ADFGZ";         final String result = nee.translate(input);         assertEquals("ADF&#71;&#90;", result, "Failed to escape numeric entities via the above method");     }      // See LANG-617     @Test     public void testSupplementary() {         final NumericEntityEscaper nee = new NumericEntityEscaper();         final String input = "\uD803\uDC22";         final String expected = "&#68642;";          final String result = nee.translate(input);         assertEquals(expected, result, "Failed to escape numeric entities supplementary characters");      }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.NumericEntityUnescaper}.  */ @Deprecated public class NumericEntityUnescaperTest  {      @Test     public void testSupplementaryUnescaping() {         final NumericEntityUnescaper neu = new NumericEntityUnescaper();         final String input = "&#68642;";         final String expected = "\uD803\uDC22";          final String result = neu.translate(input);         assertEquals(expected, result, "Failed to unescape numeric entities supplementary characters");     }      @Test     public void testOutOfBounds() {         final NumericEntityUnescaper neu = new NumericEntityUnescaper();          assertEquals("Test &", neu.translate("Test &"), "Failed to ignore when last character is &");         assertEquals("Test &#", neu.translate("Test &#"), "Failed to ignore when last character is &");         assertEquals("Test &#x", neu.translate("Test &#x"), "Failed to ignore when last character is &");         assertEquals("Test &#X", neu.translate("Test &#X"), "Failed to ignore when last character is &");     }      @Test     public void testUnfinishedEntity() {         // parse it         NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional);         String input = "Test &#x30 not test";         String expected = "Test \u0030 not test";          String result = neu.translate(input);         assertEquals(expected, result, "Failed to support unfinished entities (i.e. missing semi-colon)");          // ignore it         neu = new NumericEntityUnescaper();         input = "Test &#x30 not test";         expected = input;          result = neu.translate(input);         assertEquals(expected, result, "Failed to ignore unfinished entities (i.e. missing semi-colon)");          // fail it         final NumericEntityUnescaper failingNeu =                 new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon);         final String failingInput = "Test &#x30 not test";         assertThrows(IllegalArgumentException.class, () -> failingNeu.translate(failingInput));     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.OctalUnescaper}.  */ @Deprecated public class OctalUnescaperTest {      @Test     public void testBetween() {         final OctalUnescaper oue = new OctalUnescaper();   //.between("1", "377");          String input = "\\45";         String result = oue.translate(input);         assertEquals("\45", result, "Failed to unescape octal characters via the between method");          input = "\\377";         result = oue.translate(input);         assertEquals("\377", result, "Failed to unescape octal characters via the between method");          input = "\\377 and";         result = oue.translate(input);         assertEquals("\377 and", result, "Failed to unescape octal characters via the between method");          input = "\\378 and";         result = oue.translate(input);         assertEquals("\37" + "8 and", result, "Failed to unescape octal characters via the between method");          input = "\\378";         result = oue.translate(input);         assertEquals("\37" + "8", result, "Failed to unescape octal characters via the between method");          input = "\\1";         result = oue.translate(input);         assertEquals("\1", result, "Failed to unescape octal characters via the between method");          input = "\\036";         result = oue.translate(input);         assertEquals("\036", result, "Failed to unescape octal characters via the between method");          input = "\\0365";         result = oue.translate(input);         assertEquals("\036" + "5", result, "Failed to unescape octal characters via the between method");          input = "\\003";         result = oue.translate(input);         assertEquals("\003", result, "Failed to unescape octal characters via the between method");          input = "\\0003";         result = oue.translate(input);         assertEquals("\000" + "3", result, "Failed to unescape octal characters via the between method");          input = "\\279";         result = oue.translate(input);         assertEquals("\279", result, "Failed to unescape octal characters via the between method");          input = "\\999";         result = oue.translate(input);         assertEquals("\\999", result, "Failed to ignore an out of range octal character via the between method");     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.CharArrayWriter; import java.io.IOException;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.UnicodeUnpairedSurrogateRemover}.  */ @Deprecated public class UnicodeUnpairedSurrogateRemoverTest {     final UnicodeUnpairedSurrogateRemover subject = new UnicodeUnpairedSurrogateRemover();     final CharArrayWriter writer = new CharArrayWriter(); // nothing is ever written to it      @Test     public void testValidCharacters() throws IOException {         assertFalse(subject.translate(0xd7ff, writer));         assertFalse(subject.translate(0xe000, writer));         assertEquals(0, writer.size());     }      @Test     public void testInvalidCharacters() throws IOException {         assertTrue(subject.translate(0xd800, writer));         assertTrue(subject.translate(0xdfff, writer));         assertEquals(0, writer.size());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.UnicodeEscaper}.  */ @Deprecated public class UnicodeUnescaperTest {      // Requested in LANG-507     @Test     public void testUPlus() {         final UnicodeUnescaper uu = new UnicodeUnescaper();          final String input = "\\u+0047";         assertEquals("G", uu.translate(input), "Failed to unescape Unicode characters with 'u+' notation");     }      @Test     public void testUuuuu() {         final UnicodeUnescaper uu = new UnicodeUnescaper();          final String input = "\\uuuuuuuu0047";         final String result = uu.translate(input);         assertEquals("G", result, "Failed to unescape Unicode characters with many 'u' characters");     }      @Test     public void testLessThanFour() {         final UnicodeUnescaper uu = new UnicodeUnescaper();          final String input = "\\0047\\u006";         assertThrows(                 IllegalArgumentException.class,                 () -> uu.translate(input),                 "A lack of digits in a Unicode escape sequence failed to throw an exception");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.text.translate;  import static org.junit.jupiter.api.Assertions.assertEquals;  import org.junit.jupiter.api.Test;  /**  * Unit tests for {@link org.apache.commons.lang3.text.translate.UnicodeEscaper}.  */ @Deprecated public class UnicodeEscaperTest  {      @Test     public void testBelow() {         final UnicodeEscaper ue = UnicodeEscaper.below('F');          final String input = "ADFGZ";         final String result = ue.translate(input);         assertEquals("\\u0041\\u0044FGZ", result, "Failed to escape Unicode characters via the below method");     }      @Test     public void testBetween() {         final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L');          final String input = "ADFGZ";         final String result = ue.translate(input);         assertEquals("AD\\u0046\\u0047Z", result, "Failed to escape Unicode characters via the between method");     }      @Test     public void testAbove() {         final UnicodeEscaper ue = UnicodeEscaper.above('F');          final String input = "ADFGZ";         final String result = ue.translate(input);         assertEquals("ADF\\u0047\\u005A", result, "Failed to escape Unicode characters via the above method");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.hamcrest.MatcherAssert.assertThat; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Locale;  import org.hamcrest.core.IsNot; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Equals/IndexOf methods  */ public class StringUtilsEqualsIndexOfTest  {     private static final String BAR = "bar";     /**      * Supplementary character U+20000      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharU20000 = "\uD840\uDC00";     /**      * Supplementary character U+20001      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharU20001 = "\uD840\uDC01";      private static final String FOO = "foo";      private static final String FOOBAR = "foobar";      private static final String[] FOOBAR_SUB_ARRAY = new String[] {"ob", "ba"};      // The purpose of this class is to test StringUtils#equals(CharSequence, CharSequence)     // with a CharSequence implementation whose equals(Object) override requires that the     // other object be an instance of CustomCharSequence, even though, as char sequences,     // `seq` may equal the other object.     private static class CustomCharSequence implements CharSequence {         private final CharSequence seq;          CustomCharSequence(final CharSequence seq) {             this.seq = seq;         }          @Override         public char charAt(final int index) {             return seq.charAt(index);         }          @Override         public int length() {             return seq.length();         }          @Override         public CharSequence subSequence(final int start, final int end) {             return new CustomCharSequence(seq.subSequence(start, end));         }          @Override         public boolean equals(final Object obj) {             if (!(obj instanceof CustomCharSequence)) {                 return false;             }             final CustomCharSequence other = (CustomCharSequence) obj;             return seq.equals(other.seq);         }          @Override         public int hashCode() {             return seq.hashCode();         }          @Override         public String toString() {             return seq.toString();         }     }      @Test     public void testCustomCharSequence() {         assertThat(new CustomCharSequence(FOO), IsNot.<CharSequence>not(FOO));         assertThat(FOO, IsNot.<CharSequence>not(new CustomCharSequence(FOO)));         assertEquals(new CustomCharSequence(FOO), new CustomCharSequence(FOO));     }      @Test     public void testEquals() {         final CharSequence fooCs = new StringBuilder(FOO), barCs = new StringBuilder(BAR), foobarCs = new StringBuilder(FOOBAR);         assertTrue(StringUtils.equals(null, null));         assertTrue(StringUtils.equals(fooCs, fooCs));         assertTrue(StringUtils.equals(fooCs, new StringBuilder(FOO)));         assertTrue(StringUtils.equals(fooCs, new String(new char[] { 'f', 'o', 'o' })));         assertTrue(StringUtils.equals(fooCs, new CustomCharSequence(FOO)));         assertTrue(StringUtils.equals(new CustomCharSequence(FOO), fooCs));         assertFalse(StringUtils.equals(fooCs, new String(new char[] { 'f', 'O', 'O' })));         assertFalse(StringUtils.equals(fooCs, barCs));         assertFalse(StringUtils.equals(fooCs, null));         assertFalse(StringUtils.equals(null, fooCs));         assertFalse(StringUtils.equals(fooCs, foobarCs));         assertFalse(StringUtils.equals(foobarCs, fooCs));     }      @Test     public void testEqualsOnStrings() {         assertTrue(StringUtils.equals(null, null));         assertTrue(StringUtils.equals(FOO, FOO));         assertTrue(StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));         assertFalse(StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));         assertFalse(StringUtils.equals(FOO, BAR));         assertFalse(StringUtils.equals(FOO, null));         assertFalse(StringUtils.equals(null, FOO));         assertFalse(StringUtils.equals(FOO, FOOBAR));         assertFalse(StringUtils.equals(FOOBAR, FOO));     }      @Test     public void testEqualsIgnoreCase() {         assertTrue(StringUtils.equalsIgnoreCase(null, null));         assertTrue(StringUtils.equalsIgnoreCase(FOO, FOO));         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));         assertTrue(StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));         assertFalse(StringUtils.equalsIgnoreCase(FOO, BAR));         assertFalse(StringUtils.equalsIgnoreCase(FOO, null));         assertFalse(StringUtils.equalsIgnoreCase(null, FOO));         assertTrue(StringUtils.equalsIgnoreCase("", ""));         assertFalse(StringUtils.equalsIgnoreCase("abcd", "abcd "));     }      @Test     public void testEqualsAny() {         assertFalse(StringUtils.equalsAny(FOO));         assertFalse(StringUtils.equalsAny(FOO, new String[]{}));          assertTrue(StringUtils.equalsAny(FOO, FOO));         assertTrue(StringUtils.equalsAny(FOO, BAR, new String(new char[] { 'f', 'o', 'o' })));         assertFalse(StringUtils.equalsAny(FOO, BAR, new String(new char[] { 'f', 'O', 'O' })));         assertFalse(StringUtils.equalsAny(FOO, BAR));         assertFalse(StringUtils.equalsAny(FOO, BAR, null));         assertFalse(StringUtils.equalsAny(null, FOO));         assertFalse(StringUtils.equalsAny(FOO, FOOBAR));         assertFalse(StringUtils.equalsAny(FOOBAR, FOO));          assertTrue(StringUtils.equalsAny(null, null, null));         assertFalse(StringUtils.equalsAny(null, FOO, BAR, FOOBAR));         assertFalse(StringUtils.equalsAny(FOO, null, BAR));         assertTrue(StringUtils.equalsAny(FOO, BAR, null, "", FOO, BAR));         assertFalse(StringUtils.equalsAny(FOO, FOO.toUpperCase(Locale.ROOT)));          assertFalse(StringUtils.equalsAny(null, (CharSequence[]) null));         assertTrue(StringUtils.equalsAny(FOO, new CustomCharSequence("foo")));         assertTrue(StringUtils.equalsAny(FOO, new StringBuilder("foo")));         assertFalse(StringUtils.equalsAny(FOO, new CustomCharSequence("fOo")));         assertFalse(StringUtils.equalsAny(FOO, new StringBuilder("fOo")));     }      @Test     public void testEqualsAnyIgnoreCase() {         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO, new String[]{}));          assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, FOO));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, FOO.toUpperCase(Locale.ROOT)));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, FOO, new String(new char[]{'f', 'o', 'o'})));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, BAR, new String(new char[]{'f', 'O', 'O'})));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO, BAR));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO, BAR, null));         assertFalse(StringUtils.equalsAnyIgnoreCase(null, FOO));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO, FOOBAR));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOOBAR, FOO));          assertTrue(StringUtils.equalsAnyIgnoreCase(null, null, null));         assertFalse(StringUtils.equalsAnyIgnoreCase(null, FOO, BAR, FOOBAR));         assertFalse(StringUtils.equalsAnyIgnoreCase(FOO, null, BAR));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, BAR, null, "", FOO.toUpperCase(Locale.ROOT), BAR));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, FOO.toUpperCase(Locale.ROOT)));          assertFalse(StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, new CustomCharSequence("fOo")));         assertTrue(StringUtils.equalsAnyIgnoreCase(FOO, new StringBuilder("fOo")));     }      //-----------------------------------------------------------------------     @Test     public void testCompare_StringString() {         assertEquals(0, StringUtils.compare(null, null));         assertTrue(StringUtils.compare(null, "a") < 0);         assertTrue(StringUtils.compare("a", null) > 0);         assertEquals(0, StringUtils.compare("abc", "abc"));         assertTrue(StringUtils.compare("a", "b") < 0);         assertTrue(StringUtils.compare("b", "a") > 0);         assertTrue(StringUtils.compare("a", "B") > 0);         assertTrue(StringUtils.compare("abc", "abd") < 0);         assertTrue(StringUtils.compare("ab", "abc") < 0);         assertTrue(StringUtils.compare("ab", "ab ") < 0);         assertTrue(StringUtils.compare("abc", "ab ") > 0);     }      @Test     public void testCompare_StringStringBoolean() {         assertEquals(0, StringUtils.compare(null, null, false));         assertTrue(StringUtils.compare(null, "a", true) < 0);         assertTrue(StringUtils.compare(null, "a", false) > 0);         assertTrue(StringUtils.compare("a", null, true) > 0);         assertTrue(StringUtils.compare("a", null, false) < 0);         assertEquals(0, StringUtils.compare("abc", "abc", false));         assertTrue(StringUtils.compare("a", "b", false) < 0);         assertTrue(StringUtils.compare("b", "a", false) > 0);         assertTrue(StringUtils.compare("a", "B", false) > 0);         assertTrue(StringUtils.compare("abc", "abd", false) < 0);         assertTrue(StringUtils.compare("ab", "abc", false) < 0);         assertTrue(StringUtils.compare("ab", "ab ", false) < 0);         assertTrue(StringUtils.compare("abc", "ab ", false) > 0);     }      @Test     public void testCompareIgnoreCase_StringString() {         assertEquals(0, StringUtils.compareIgnoreCase(null, null));         assertTrue(StringUtils.compareIgnoreCase(null, "a") < 0);         assertTrue(StringUtils.compareIgnoreCase("a", null) > 0);         assertEquals(0, StringUtils.compareIgnoreCase("abc", "abc"));         assertEquals(0, StringUtils.compareIgnoreCase("abc", "ABC"));         assertTrue(StringUtils.compareIgnoreCase("a", "b") < 0);         assertTrue(StringUtils.compareIgnoreCase("b", "a") > 0);         assertTrue(StringUtils.compareIgnoreCase("a", "B") < 0);         assertTrue(StringUtils.compareIgnoreCase("A", "b") < 0);         assertTrue(StringUtils.compareIgnoreCase("abc", "ABD") < 0);         assertTrue(StringUtils.compareIgnoreCase("ab", "ABC") < 0);         assertTrue(StringUtils.compareIgnoreCase("ab", "AB ") < 0);         assertTrue(StringUtils.compareIgnoreCase("abc", "AB ") > 0);     }      @Test     public void testCompareIgnoreCase_StringStringBoolean() {         assertEquals(0, StringUtils.compareIgnoreCase(null, null, false));         assertTrue(StringUtils.compareIgnoreCase(null, "a", true) < 0);         assertTrue(StringUtils.compareIgnoreCase(null, "a", false) > 0);         assertTrue(StringUtils.compareIgnoreCase("a", null, true) > 0);         assertTrue(StringUtils.compareIgnoreCase("a", null, false) < 0);         assertEquals(0, StringUtils.compareIgnoreCase("abc", "abc", false));         assertEquals(0, StringUtils.compareIgnoreCase("abc", "ABC", false));         assertTrue(StringUtils.compareIgnoreCase("a", "b", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("b", "a", false) > 0);         assertTrue(StringUtils.compareIgnoreCase("a", "B", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("A", "b", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("abc", "ABD", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("ab", "ABC", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("ab", "AB ", false) < 0);         assertTrue(StringUtils.compareIgnoreCase("abc", "AB ", false) > 0);     }      //-----------------------------------------------------------------------     @Test     public void testIndexOf_char() {         assertEquals(-1, StringUtils.indexOf(null, ' '));         assertEquals(-1, StringUtils.indexOf("", ' '));         assertEquals(0, StringUtils.indexOf("aabaabaa", 'a'));         assertEquals(2, StringUtils.indexOf("aabaabaa", 'b'));          assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), 'b'));     }      @Test     public void testIndexOf_charInt() {         assertEquals(-1, StringUtils.indexOf(null, ' ', 0));         assertEquals(-1, StringUtils.indexOf(null, ' ', -1));         assertEquals(-1, StringUtils.indexOf("", ' ', 0));         assertEquals(-1, StringUtils.indexOf("", ' ', -1));         assertEquals(0, StringUtils.indexOf("aabaabaa", 'a', 0));         assertEquals(2, StringUtils.indexOf("aabaabaa", 'b', 0));         assertEquals(5, StringUtils.indexOf("aabaabaa", 'b', 3));         assertEquals(-1, StringUtils.indexOf("aabaabaa", 'b', 9));         assertEquals(2, StringUtils.indexOf("aabaabaa", 'b', -1));          assertEquals(5, StringUtils.indexOf(new StringBuilder("aabaabaa"), 'b', 3));          //LANG-1300 tests go here         final int CODE_POINT = 0x2070E;         StringBuilder builder = new StringBuilder();         builder.appendCodePoint(CODE_POINT);         assertEquals(0, StringUtils.indexOf(builder, CODE_POINT, 0));         assertEquals(0, StringUtils.indexOf(builder.toString(), CODE_POINT, 0));         builder.appendCodePoint(CODE_POINT);         assertEquals(2, StringUtils.indexOf(builder, CODE_POINT, 1));         assertEquals(2, StringUtils.indexOf(builder.toString(), CODE_POINT, 1));         // inner branch on the supplementary character block         final char[] tmp = { (char) 55361 };         builder = new StringBuilder();         builder.append(tmp);         assertEquals(-1, StringUtils.indexOf(builder, CODE_POINT, 0));         assertEquals(-1, StringUtils.indexOf(builder.toString(), CODE_POINT, 0));         builder.appendCodePoint(CODE_POINT);         assertEquals(1, StringUtils.indexOf(builder, CODE_POINT, 0));         assertEquals(1, StringUtils.indexOf(builder.toString(), CODE_POINT, 0));         assertEquals(-1, StringUtils.indexOf(builder, CODE_POINT, 2));         assertEquals(-1, StringUtils.indexOf(builder.toString(), CODE_POINT, 2));     }      @Test     public void testIndexOf_String() {         assertEquals(-1, StringUtils.indexOf(null, null));         assertEquals(-1, StringUtils.indexOf("", null));         assertEquals(0, StringUtils.indexOf("", ""));         assertEquals(0, StringUtils.indexOf("aabaabaa", "a"));         assertEquals(2, StringUtils.indexOf("aabaabaa", "b"));         assertEquals(1, StringUtils.indexOf("aabaabaa", "ab"));         assertEquals(0, StringUtils.indexOf("aabaabaa", ""));          assertEquals(2, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b"));     }      @Test     public void testIndexOf_StringInt() {         assertEquals(-1, StringUtils.indexOf(null, null, 0));         assertEquals(-1, StringUtils.indexOf(null, null, -1));         assertEquals(-1, StringUtils.indexOf(null, "", 0));         assertEquals(-1, StringUtils.indexOf(null, "", -1));         assertEquals(-1, StringUtils.indexOf("", null, 0));         assertEquals(-1, StringUtils.indexOf("", null, -1));         assertEquals(0, StringUtils.indexOf("", "", 0));         assertEquals(0, StringUtils.indexOf("", "", -1));         assertEquals(0, StringUtils.indexOf("", "", 9));         assertEquals(0, StringUtils.indexOf("abc", "", 0));         assertEquals(0, StringUtils.indexOf("abc", "", -1));         assertEquals(3, StringUtils.indexOf("abc", "", 9));         assertEquals(3, StringUtils.indexOf("abc", "", 3));         assertEquals(0, StringUtils.indexOf("aabaabaa", "a", 0));         assertEquals(2, StringUtils.indexOf("aabaabaa", "b", 0));         assertEquals(1, StringUtils.indexOf("aabaabaa", "ab", 0));         assertEquals(5, StringUtils.indexOf("aabaabaa", "b", 3));         assertEquals(-1, StringUtils.indexOf("aabaabaa", "b", 9));         assertEquals(2, StringUtils.indexOf("aabaabaa", "b", -1));         assertEquals(2, StringUtils.indexOf("aabaabaa", "", 2));          // Test that startIndex works correctly, i.e. cannot match before startIndex         assertEquals(7, StringUtils.indexOf("12345678", "8", 5));         assertEquals(7, StringUtils.indexOf("12345678", "8", 6));         assertEquals(7, StringUtils.indexOf("12345678", "8", 7)); // 7 is last index         assertEquals(-1, StringUtils.indexOf("12345678", "8", 8));          assertEquals(5, StringUtils.indexOf(new StringBuilder("aabaabaa"), "b", 3));     }      @Test     public void testIndexOfAny_StringCharArray() {         assertEquals(-1, StringUtils.indexOfAny(null, (char[]) null));         assertEquals(-1, StringUtils.indexOfAny(null, new char[0]));         assertEquals(-1, StringUtils.indexOfAny(null, 'a', 'b'));          assertEquals(-1, StringUtils.indexOfAny("", (char[]) null));         assertEquals(-1, StringUtils.indexOfAny("", new char[0]));         assertEquals(-1, StringUtils.indexOfAny("", 'a', 'b'));          assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", (char[]) null));         assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", new char[0]));         assertEquals(0, StringUtils.indexOfAny("zzabyycdxx", 'z', 'a'));         assertEquals(3, StringUtils.indexOfAny("zzabyycdxx", 'b', 'y'));         assertEquals(-1, StringUtils.indexOfAny("ab", 'z'));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testIndexOfAny_StringCharArrayWithSupplementaryChars() {         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));     }      @Test     public void testIndexOfAny_StringString() {         assertEquals(-1, StringUtils.indexOfAny(null, (String) null));         assertEquals(-1, StringUtils.indexOfAny(null, ""));         assertEquals(-1, StringUtils.indexOfAny(null, "ab"));          assertEquals(-1, StringUtils.indexOfAny("", (String) null));         assertEquals(-1, StringUtils.indexOfAny("", ""));         assertEquals(-1, StringUtils.indexOfAny("", "ab"));          assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", (String) null));         assertEquals(-1, StringUtils.indexOfAny("zzabyycdxx", ""));         assertEquals(0, StringUtils.indexOfAny("zzabyycdxx", "za"));         assertEquals(3, StringUtils.indexOfAny("zzabyycdxx", "by"));         assertEquals(-1, StringUtils.indexOfAny("ab", "z"));     }      @Test     public void testIndexOfAny_StringStringArray() {         assertEquals(-1, StringUtils.indexOfAny(null, (String[]) null));         assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));         assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (String[]) null));         assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));         assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));         assertEquals(-1, StringUtils.indexOfAny(null, new String[0]));         assertEquals(-1, StringUtils.indexOfAny("", new String[0]));         assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {"llll"}));         assertEquals(0, StringUtils.indexOfAny(FOOBAR, new String[] {""}));         assertEquals(0, StringUtils.indexOfAny("", new String[] {""}));         assertEquals(-1, StringUtils.indexOfAny("", new String[] {"a"}));         assertEquals(-1, StringUtils.indexOfAny("", new String[] {null}));         assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {null}));         assertEquals(-1, StringUtils.indexOfAny(null, new String[] {null}));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testIndexOfAny_StringStringWithSupplementaryChars() {         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));         assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));     }      @Test     public void testIndexOfAnyBut_StringCharArray() {         assertEquals(-1, StringUtils.indexOfAnyBut(null, (char[]) null));         assertEquals(-1, StringUtils.indexOfAnyBut(null));         assertEquals(-1, StringUtils.indexOfAnyBut(null, 'a', 'b'));          assertEquals(-1, StringUtils.indexOfAnyBut("", (char[]) null));         assertEquals(-1, StringUtils.indexOfAnyBut(""));         assertEquals(-1, StringUtils.indexOfAnyBut("", 'a', 'b'));          assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", (char[]) null));         assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx"));         assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", 'z', 'a'));         assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", 'b', 'y'));         assertEquals(-1, StringUtils.indexOfAnyBut("aba", 'a', 'b'));         assertEquals(0, StringUtils.indexOfAnyBut("aba", 'z'));     }      @Test     public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() {         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray()));         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray()));         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));     }      @Test     public void testIndexOfAnyBut_StringString() {         assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null));         assertEquals(-1, StringUtils.indexOfAnyBut(null, ""));         assertEquals(-1, StringUtils.indexOfAnyBut(null, "ab"));          assertEquals(-1, StringUtils.indexOfAnyBut("", (String) null));         assertEquals(-1, StringUtils.indexOfAnyBut("", ""));         assertEquals(-1, StringUtils.indexOfAnyBut("", "ab"));          assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", (String) null));         assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx", ""));         assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", "za"));         assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", "by"));         assertEquals(0, StringUtils.indexOfAnyBut("ab", "z"));     }      @Test     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() {         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001));         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000));         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));     }      @Test     public void testIndexOfIgnoreCase_String() {         assertEquals(-1, StringUtils.indexOfIgnoreCase(null, null));         assertEquals(-1, StringUtils.indexOfIgnoreCase(null, ""));         assertEquals(-1, StringUtils.indexOfIgnoreCase("", null));         assertEquals(0, StringUtils.indexOfIgnoreCase("", ""));         assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "a"));         assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", "A"));         assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "b"));         assertEquals(2, StringUtils.indexOfIgnoreCase("aabaabaa", "B"));         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "ab"));         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB"));         assertEquals(0, StringUtils.indexOfIgnoreCase("aabaabaa", ""));     }      @Test     public void testIndexOfIgnoreCase_StringInt() {         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", -1));         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 0));         assertEquals(1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 1));         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 2));         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 3));         assertEquals(4, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 4));         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 5));         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 6));         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 7));         assertEquals(-1, StringUtils.indexOfIgnoreCase("aabaabaa", "AB", 8));         assertEquals(1, StringUtils.indexOfIgnoreCase("aab", "AB", 1));         assertEquals(5, StringUtils.indexOfIgnoreCase("aabaabaa", "", 5));         assertEquals(-1, StringUtils.indexOfIgnoreCase("ab", "AAB", 0));         assertEquals(-1, StringUtils.indexOfIgnoreCase("aab", "AAB", 1));         assertEquals(-1, StringUtils.indexOfIgnoreCase("abc", "", 9));     }      @Test     public void testLastIndexOf_char() {         assertEquals(-1, StringUtils.lastIndexOf(null, ' '));         assertEquals(-1, StringUtils.lastIndexOf("", ' '));         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", 'a'));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b'));          assertEquals(5, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), 'b'));     }      @Test     public void testLastIndexOf_charInt() {         assertEquals(-1, StringUtils.lastIndexOf(null, ' ', 0));         assertEquals(-1, StringUtils.lastIndexOf(null, ' ', -1));         assertEquals(-1, StringUtils.lastIndexOf("", ' ', 0));         assertEquals(-1, StringUtils.lastIndexOf("", ' ', -1));         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", 'a', 8));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b', 8));         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", 'b', 3));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", 'b', 9));         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", 'b', -1));         assertEquals(0, StringUtils.lastIndexOf("aabaabaa", 'a', 0));          assertEquals(2, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), 'b', 2));          //LANG-1300 addition test         final int CODE_POINT = 0x2070E;         StringBuilder builder = new StringBuilder();         builder.appendCodePoint(CODE_POINT);         assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT, 0));         builder.appendCodePoint(CODE_POINT);         assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT, 0));         assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT, 1));         assertEquals(2, StringUtils.lastIndexOf(builder, CODE_POINT, 2));          builder.append("aaaaa");         assertEquals(2, StringUtils.lastIndexOf(builder, CODE_POINT, 4));         // inner branch on the supplementary character block         final char[] tmp = { (char) 55361 };         builder = new StringBuilder();         builder.append(tmp);         assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT, 0));         builder.appendCodePoint(CODE_POINT);         assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT, 0));         assertEquals(1, StringUtils.lastIndexOf(builder, CODE_POINT, 1 ));         assertEquals(-1, StringUtils.lastIndexOf(builder.toString(), CODE_POINT, 0));         assertEquals(1, StringUtils.lastIndexOf(builder.toString(), CODE_POINT, 1));     }      @Test     public void testLastIndexOf_String() {         assertEquals(-1, StringUtils.lastIndexOf(null, null));         assertEquals(-1, StringUtils.lastIndexOf("", null));         assertEquals(-1, StringUtils.lastIndexOf("", "a"));         assertEquals(0, StringUtils.lastIndexOf("", ""));         assertEquals(8, StringUtils.lastIndexOf("aabaabaa", ""));         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a"));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b"));         assertEquals(4, StringUtils.lastIndexOf("aabaabaa", "ab"));          assertEquals(4, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), "ab"));     }      @Test     public void testLastIndexOf_StringInt() {         assertEquals(-1, StringUtils.lastIndexOf(null, null, 0));         assertEquals(-1, StringUtils.lastIndexOf(null, null, -1));         assertEquals(-1, StringUtils.lastIndexOf(null, "", 0));         assertEquals(-1, StringUtils.lastIndexOf(null, "", -1));         assertEquals(-1, StringUtils.lastIndexOf("", null, 0));         assertEquals(-1, StringUtils.lastIndexOf("", null, -1));         assertEquals(0, StringUtils.lastIndexOf("", "", 0));         assertEquals(-1, StringUtils.lastIndexOf("", "", -1));         assertEquals(0, StringUtils.lastIndexOf("", "", 9));         assertEquals(0, StringUtils.lastIndexOf("abc", "", 0));         assertEquals(-1, StringUtils.lastIndexOf("abc", "", -1));         assertEquals(3, StringUtils.lastIndexOf("abc", "", 9));         assertEquals(7, StringUtils.lastIndexOf("aabaabaa", "a", 8));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 8));         assertEquals(4, StringUtils.lastIndexOf("aabaabaa", "ab", 8));         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 3));         assertEquals(5, StringUtils.lastIndexOf("aabaabaa", "b", 9));         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", -1));         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 0));         assertEquals(0, StringUtils.lastIndexOf("aabaabaa", "a", 0));         assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "a", -1));          // Test that fromIndex works correctly, i.e. cannot match after fromIndex         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 9));         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 8));         assertEquals(7, StringUtils.lastIndexOf("12345678", "8", 7)); // 7 is last index         assertEquals(-1, StringUtils.lastIndexOf("12345678", "8", 6));          assertEquals(-1, StringUtils.lastIndexOf("aabaabaa", "b", 1));         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "b", 2));         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 2));         assertEquals(2, StringUtils.lastIndexOf("aabaabaa", "ba", 3));          assertEquals(2, StringUtils.lastIndexOf(new StringBuilder("aabaabaa"), "b", 3));     }      @Test     public void testLastIndexOfAny_StringStringArray() {         assertEquals(-1, StringUtils.lastIndexOfAny(null, (CharSequence) null));   // test both types of ...         assertEquals(-1, StringUtils.lastIndexOfAny(null, (CharSequence[]) null)); // ... varargs invocation         assertEquals(-1, StringUtils.lastIndexOfAny(null)); // Missing varag         assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, (CharSequence) null));   // test both types of ...         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, (CharSequence[]) null)); // ... varargs invocation         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR)); // Missing vararg         assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));         assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[0]));         assertEquals(-1, StringUtils.lastIndexOfAny("", new String[0]));         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {"llll"}));         assertEquals(6, StringUtils.lastIndexOfAny(FOOBAR, new String[] {""}));         assertEquals(0, StringUtils.lastIndexOfAny("", new String[] {""}));         assertEquals(-1, StringUtils.lastIndexOfAny("", new String[] {"a"}));         assertEquals(-1, StringUtils.lastIndexOfAny("", new String[] {null}));         assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {null}));         assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[] {null}));     }      @Test     public void testLastIndexOfIgnoreCase_String() {         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, ""));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "a"));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", ""));         assertEquals(8, StringUtils.lastIndexOfIgnoreCase("aabaabaa", ""));         assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "a"));         assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A"));         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "b"));         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B"));         assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "ab"));         assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB"));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("ab", "AAB"));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("aab", "AAB"));     }      @Test     public void testLastIndexOfIgnoreCase_StringInt() {         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, 0));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, -1));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", 0));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, "", -1));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, 0));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", null, -1));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 0));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("", "", -1));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("", "", 9));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("abc", "", 0));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("abc", "", -1));         assertEquals(3, StringUtils.lastIndexOfIgnoreCase("abc", "", 9));         assertEquals(7, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 8));         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 8));         assertEquals(4, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "AB", 8));         assertEquals(2, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 3));         assertEquals(5, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 9));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", -1));         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "B", 0));         assertEquals(0, StringUtils.lastIndexOfIgnoreCase("aabaabaa", "A", 0));         assertEquals(1, StringUtils.lastIndexOfIgnoreCase("aab", "AB", 1));     }      @Test     public void testLastOrdinalIndexOf() {         assertEquals(-1, StringUtils.lastOrdinalIndexOf(null, "*", 42) );         assertEquals(-1, StringUtils.lastOrdinalIndexOf("*", null, 42) );         assertEquals(0, StringUtils.lastOrdinalIndexOf("", "", 42) );         assertEquals(7, StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 1) );         assertEquals(6, StringUtils.lastOrdinalIndexOf("aabaabaa", "a", 2) );         assertEquals(5, StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 1) );         assertEquals(2, StringUtils.lastOrdinalIndexOf("aabaabaa", "b", 2) );         assertEquals(4, StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 1) );         assertEquals(1, StringUtils.lastOrdinalIndexOf("aabaabaa", "ab", 2) );         assertEquals(8, StringUtils.lastOrdinalIndexOf("aabaabaa", "", 1) );         assertEquals(8, StringUtils.lastOrdinalIndexOf("aabaabaa", "", 2) );     }      @Test     public void testOrdinalIndexOf() {         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("", "", Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MIN_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MIN_VALUE));          assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, -1));         assertEquals(-1, StringUtils.ordinalIndexOf("", "", -1));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", -1));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", -1));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", -1));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", -1));          assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 0));         assertEquals(-1, StringUtils.ordinalIndexOf("", "", 0));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", 0));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", 0));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 0));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "", 0));          assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 1));         assertEquals(0, StringUtils.ordinalIndexOf("", "", 1));         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "a", 1));         assertEquals(2, StringUtils.ordinalIndexOf("aabaabaa", "b", 1));         assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "ab", 1));         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 1));          assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, 2));         assertEquals(0, StringUtils.ordinalIndexOf("", "", 2));         assertEquals(1, StringUtils.ordinalIndexOf("aabaabaa", "a", 2));         assertEquals(5, StringUtils.ordinalIndexOf("aabaabaa", "b", 2));         assertEquals(4, StringUtils.ordinalIndexOf("aabaabaa", "ab", 2));         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", 2));          assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("", null, Integer.MAX_VALUE));         assertEquals(0, StringUtils.ordinalIndexOf("", "", Integer.MAX_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "a", Integer.MAX_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "b", Integer.MAX_VALUE));         assertEquals(-1, StringUtils.ordinalIndexOf("aabaabaa", "ab", Integer.MAX_VALUE));         assertEquals(0, StringUtils.ordinalIndexOf("aabaabaa", "", Integer.MAX_VALUE));          assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 0));         assertEquals(0, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 1));         assertEquals(1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 2));         assertEquals(2, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 3));         assertEquals(3, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 4));         assertEquals(4, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 5));         assertEquals(5, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 6));         assertEquals(6, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 7));         assertEquals(7, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 8));         assertEquals(8, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 9));         assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaaaaa", "a", 10));          // match at each possible position         assertEquals(0, StringUtils.ordinalIndexOf("aaaaaa", "aa", 1));         assertEquals(1, StringUtils.ordinalIndexOf("aaaaaa", "aa", 2));         assertEquals(2, StringUtils.ordinalIndexOf("aaaaaa", "aa", 3));         assertEquals(3, StringUtils.ordinalIndexOf("aaaaaa", "aa", 4));         assertEquals(4, StringUtils.ordinalIndexOf("aaaaaa", "aa", 5));         assertEquals(-1, StringUtils.ordinalIndexOf("aaaaaa", "aa", 6));          assertEquals(0, StringUtils.ordinalIndexOf("ababab", "aba", 1));         assertEquals(2, StringUtils.ordinalIndexOf("ababab", "aba", 2));         assertEquals(-1, StringUtils.ordinalIndexOf("ababab", "aba", 3));          assertEquals(0, StringUtils.ordinalIndexOf("abababab", "abab", 1));         assertEquals(2, StringUtils.ordinalIndexOf("abababab", "abab", 2));         assertEquals(4, StringUtils.ordinalIndexOf("abababab", "abab", 3));         assertEquals(-1, StringUtils.ordinalIndexOf("abababab", "abab", 4));     }      @Test     public void testLANG1193() {         assertEquals(0, StringUtils.ordinalIndexOf("abc", "ab", 1));     }      @Test     // Non-overlapping test     public void testLANG1241_1() {         //                                          0  3  6         assertEquals(0, StringUtils.ordinalIndexOf("abaabaab", "ab", 1));         assertEquals(3, StringUtils.ordinalIndexOf("abaabaab", "ab", 2));         assertEquals(6, StringUtils.ordinalIndexOf("abaabaab", "ab", 3));     }      @Test     // Overlapping matching test     public void testLANG1241_2() {         //                                          0 2 4         assertEquals(0, StringUtils.ordinalIndexOf("abababa", "aba", 1));         assertEquals(2, StringUtils.ordinalIndexOf("abababa", "aba", 2));         assertEquals(4, StringUtils.ordinalIndexOf("abababa", "aba", 3));         assertEquals(0, StringUtils.ordinalIndexOf("abababab", "abab", 1));         assertEquals(2, StringUtils.ordinalIndexOf("abababab", "abab", 2));         assertEquals(4, StringUtils.ordinalIndexOf("abababab", "abab", 3));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.test;  /**  * Allows for testing an exception that is not visible to  * {@link org.apache.commons.lang3.exception.ExceptionUtils}  */ public class NotVisibleExceptionFactory {    private NotVisibleExceptionFactory() {}    /**    * Create a new Exception whose getCause method returns the    * provided cause.    * @param cause the cause of the exception    * @return a new {@link Exception}    */   public static Exception createException(final Throwable cause) {     return new NotVisibleException(cause);   }    private static class NotVisibleException extends Exception {      private static final long serialVersionUID = 1L; // avoid warning      private final Throwable cause;      private NotVisibleException(final Throwable cause) {       this.cause = cause;     }      @Override     public Throwable getCause() {       return cause;     }   } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.HashMap;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.SerializationUtils}.  */ public class SerializationUtilsTest {    static final String CLASS_NOT_FOUND_MESSAGE = "ClassNotFoundSerialization.readObject fake exception";     protected static final String SERIALIZE_IO_EXCEPTION_MESSAGE = "Anonymous OutputStream I/O exception";      private String iString;     private Integer iInteger;     private HashMap<Object, Object> iMap;      @BeforeEach     public void setUp() {         iString = "foo";         iInteger = Integer.valueOf(7);         iMap = new HashMap<>();         iMap.put("FOO", iString);         iMap.put("BAR", iInteger);     }      //-----------------------------------------------------------------------      @Test     public void testConstructor() {         assertNotNull(new SerializationUtils());         final Constructor<?>[] cons = SerializationUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(SerializationUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(SerializationUtils.class.getModifiers()));     }      @Test     public void testException() {         SerializationException serEx;         final Exception ex = new Exception();          serEx = new SerializationException();         assertSame(null, serEx.getMessage());         assertSame(null, serEx.getCause());          serEx = new SerializationException("Message");         assertSame("Message", serEx.getMessage());         assertSame(null, serEx.getCause());          serEx = new SerializationException(ex);         assertEquals("java.lang.Exception", serEx.getMessage());         assertSame(ex, serEx.getCause());          serEx = new SerializationException("Message", ex);         assertSame("Message", serEx.getMessage());         assertSame(ex, serEx.getCause());     }      //-----------------------------------------------------------------------      @Test     public void testSerializeStream() throws Exception {         final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();         SerializationUtils.serialize(iMap, streamTest);          final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(iMap);         oos.flush();         oos.close();          final byte[] testBytes = streamTest.toByteArray();         final byte[] realBytes = streamReal.toByteArray();         assertEquals(testBytes.length, realBytes.length);         assertArrayEquals(realBytes, testBytes);     }      @Test     public void testSerializeStreamUnserializable() {         final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();         iMap.put(new Object(), new Object());         assertThrows(SerializationException.class, () -> SerializationUtils.serialize(iMap, streamTest));     }      @Test     public void testSerializeStreamNullObj() throws Exception {         final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();         SerializationUtils.serialize(null, streamTest);          final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(null);         oos.flush();         oos.close();          final byte[] testBytes = streamTest.toByteArray();         final byte[] realBytes = streamReal.toByteArray();         assertEquals(testBytes.length, realBytes.length);         assertArrayEquals(realBytes, testBytes);     }      @Test     public void testSerializeStreamObjNull() {         assertThrows(NullPointerException.class, () -> SerializationUtils.serialize(iMap, null));     }      @Test     public void testSerializeStreamNullNull() {         assertThrows(NullPointerException.class, () -> SerializationUtils.serialize(null, null));     }      @Test     public void testSerializeIOException() {         // forces an IOException when the ObjectOutputStream is created, to test not closing the stream         // in the finally block         final OutputStream streamTest = new OutputStream() {             @Override             public void write(final int arg0) throws IOException {                 throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE);             }         };         final SerializationException e =                 assertThrows(SerializationException.class, () -> SerializationUtils.serialize(iMap, streamTest));         assertEquals("java.io.IOException: " + SERIALIZE_IO_EXCEPTION_MESSAGE, e.getMessage());     }      //-----------------------------------------------------------------------      @Test     public void testDeserializeStream() throws Exception {         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(iMap);         oos.flush();         oos.close();          final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());         final Object test = SerializationUtils.deserialize(inTest);         assertNotNull(test);         assertTrue(test instanceof HashMap<?, ?>);         assertNotSame(test, iMap);         final HashMap<?, ?> testMap = (HashMap<?, ?>) test;         assertEquals(iString, testMap.get("FOO"));         assertNotSame(iString, testMap.get("FOO"));         assertEquals(iInteger, testMap.get("BAR"));         assertNotSame(iInteger, testMap.get("BAR"));         assertEquals(iMap, testMap);     }      @Test     public void testDeserializeClassCastException() {         final String value = "Hello";         final byte[] serialized = SerializationUtils.serialize(value);         assertEquals(value, SerializationUtils.deserialize(serialized));         assertThrows(ClassCastException.class, () -> {             // Causes ClassCastException in call site, not in SerializationUtils.deserialize             @SuppressWarnings("unused") // needed to cause Exception             final Integer i = SerializationUtils.deserialize(serialized);         });     }      @Test     public void testDeserializeStreamOfNull() throws Exception {         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(null);         oos.flush();         oos.close();          final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());         final Object test = SerializationUtils.deserialize(inTest);         assertNull(test);     }      @Test     public void testDeserializeStreamNull() {         assertThrows(NullPointerException.class, () -> SerializationUtils.deserialize((InputStream) null));     }      @Test     public void testDeserializeStreamBadStream() {         assertThrows(SerializationException.class,                 () -> SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0])));     }      @Test     public void testDeserializeStreamClassNotFound() throws Exception {         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(new ClassNotFoundSerialization());         oos.flush();         oos.close();          final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());         final SerializationException se =                 assertThrows(SerializationException.class, () -> SerializationUtils.deserialize(inTest));         assertEquals("java.lang.ClassNotFoundException: " + CLASS_NOT_FOUND_MESSAGE, se.getMessage());     }      @Test     public void testRoundtrip() {         final HashMap<Object, Object> newMap = SerializationUtils.roundtrip(iMap);         assertEquals(iMap, newMap);     }      //-----------------------------------------------------------------------      @Test     public void testSerializeBytes() throws Exception {         final byte[] testBytes = SerializationUtils.serialize(iMap);          final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(iMap);         oos.flush();         oos.close();          final byte[] realBytes = streamReal.toByteArray();         assertEquals(testBytes.length, realBytes.length);         assertArrayEquals(realBytes, testBytes);     }      @Test     public void testSerializeBytesUnserializable() {         iMap.put(new Object(), new Object());         assertThrows(SerializationException.class, () -> SerializationUtils.serialize(iMap));     }      @Test     public void testSerializeBytesNull() throws Exception {         final byte[] testBytes = SerializationUtils.serialize(null);          final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(null);         oos.flush();         oos.close();          final byte[] realBytes = streamReal.toByteArray();         assertEquals(testBytes.length, realBytes.length);         assertArrayEquals(realBytes, testBytes);     }      //-----------------------------------------------------------------------      @Test     public void testDeserializeBytes() throws Exception {         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(iMap);         oos.flush();         oos.close();          final Object test = SerializationUtils.deserialize(streamReal.toByteArray());         assertNotNull(test);         assertTrue(test instanceof HashMap<?, ?>);         assertNotSame(test, iMap);         final HashMap<?, ?> testMap = (HashMap<?, ?>) test;         assertEquals(iString, testMap.get("FOO"));         assertNotSame(iString, testMap.get("FOO"));         assertEquals(iInteger, testMap.get("BAR"));         assertNotSame(iInteger, testMap.get("BAR"));         assertEquals(iMap, testMap);     }      @Test     public void testDeserializeBytesOfNull() throws Exception {         final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();         final ObjectOutputStream oos = new ObjectOutputStream(streamReal);         oos.writeObject(null);         oos.flush();         oos.close();          final Object test = SerializationUtils.deserialize(streamReal.toByteArray());         assertNull(test);     }      @Test     public void testDeserializeBytesNull() {         assertThrows(NullPointerException.class, () -> SerializationUtils.deserialize((byte[]) null));     }      @Test     public void testDeserializeBytesBadStream() {         assertThrows(SerializationException.class, () -> SerializationUtils.deserialize(new byte[0]));     }      //-----------------------------------------------------------------------      @Test     public void testClone() {         final Object test = SerializationUtils.clone(iMap);         assertNotNull(test);         assertTrue(test instanceof HashMap<?, ?>);         assertNotSame(test, iMap);         final HashMap<?, ?> testMap = (HashMap<?, ?>) test;         assertEquals(iString, testMap.get("FOO"));         assertNotSame(iString, testMap.get("FOO"));         assertEquals(iInteger, testMap.get("BAR"));         assertNotSame(iInteger, testMap.get("BAR"));         assertEquals(iMap, testMap);     }      @Test     public void testCloneNull() {         final Object test = SerializationUtils.clone(null);         assertNull(test);     }      @Test     public void testCloneUnserializable() {         iMap.put(new Object(), new Object());         assertThrows(SerializationException.class, () -> SerializationUtils.clone(iMap));     }      @Test     public void testPrimitiveTypeClassSerialization() {         final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,                 boolean.class, char.class, void.class };          for (final Class<?> primitiveType : primitiveTypes) {             final Class<?> clone = SerializationUtils.clone(primitiveType);             assertEquals(primitiveType, clone);         }     }  }  class ClassNotFoundSerialization implements Serializable {      private static final long serialVersionUID = 1L;      private void readObject(final ObjectInputStream in) throws ClassNotFoundException    {         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Locale; import java.util.Set;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  /**  * Unit tests for {@link LocaleUtils}.  */ public class LocaleUtilsTest  {      private static final Locale LOCALE_EN = new Locale("en", "");     private static final Locale LOCALE_EN_US = new Locale("en", "US");     private static final Locale LOCALE_EN_US_ZZZZ = new Locale("en", "US", "ZZZZ");     private static final Locale LOCALE_FR = new Locale("fr", "");     private static final Locale LOCALE_FR_CA = new Locale("fr", "CA");     private static final Locale LOCALE_QQ = new Locale("qq", "");     private static final Locale LOCALE_QQ_ZZ = new Locale("qq", "ZZ");      @BeforeEach     public void setUp() {         // Testing #LANG-304. Must be called before availableLocaleSet is called.         LocaleUtils.isAvailableLocale(Locale.getDefault());     }      //-----------------------------------------------------------------------     /**      * Test that constructors are public, and work, etc.      */     @Test     public void testConstructor() {         assertNotNull(new LocaleUtils());         final Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(LocaleUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(LocaleUtils.class.getModifiers()));     }      //-----------------------------------------------------------------------     /**      * Pass in a valid language, test toLocale.      *      * @param language  the language string      */     private static void assertValidToLocale(final String language) {         final Locale locale = LocaleUtils.toLocale(language);         assertNotNull(locale, "valid locale");         assertEquals(language, locale.getLanguage());         //country and variant are empty         assertTrue(locale.getCountry() == null || locale.getCountry().isEmpty());         assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty());     }      /**      * Pass in a valid language, test toLocale.      *      * @param localeString to pass to toLocale()      * @param language of the resulting Locale      * @param country of the resulting Locale      */     private static void assertValidToLocale(final String localeString, final String language, final String country) {         final Locale locale = LocaleUtils.toLocale(localeString);         assertNotNull(locale, "valid locale");         assertEquals(language, locale.getLanguage());         assertEquals(country, locale.getCountry());         //variant is empty         assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty());     }      /**      * Pass in a valid language, test toLocale.      *      * @param localeString to pass to toLocale()      * @param language of the resulting Locale      * @param country of the resulting Locale      * @param variant of the resulting Locale      */     private static void assertValidToLocale(             final String localeString, final String language,             final String country, final String variant) {         final Locale locale = LocaleUtils.toLocale(localeString);         assertNotNull(locale, "valid locale");         assertEquals(language, locale.getLanguage());         assertEquals(country, locale.getCountry());         assertEquals(variant, locale.getVariant());     }      /**      * Test toLocale() method.      */     @Test     public void testToLocale_1Part() {         assertNull(LocaleUtils.toLocale(null));          assertValidToLocale("us");         assertValidToLocale("fr");         assertValidToLocale("de");         assertValidToLocale("zh");         // Valid format but lang doesn't exist, should make instance anyway         assertValidToLocale("qq");         // LANG-941: JDK 8 introduced the empty locale as one of the default locales         assertValidToLocale("");          assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale("Us"), "Should fail if not lowercase");         assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale("uS"), "Should fail if not lowercase");         assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale("u#"), "Should fail if not lowercase");         assertThrows(                 IllegalArgumentException.class, () -> LocaleUtils.toLocale("u"), "Must be 2 chars if less than 5");         assertThrows(                 IllegalArgumentException.class, () -> LocaleUtils.toLocale("uu_U"), "Must be 2 chars if less than 5");     }      /**      * Test toLocale() method.      */     @Test     public void testToLocale_2Part() {         assertValidToLocale("us_EN", "us", "EN");         //valid though doesn't exist         assertValidToLocale("us_ZH", "us", "ZH");          assertThrows(                 IllegalArgumentException.class, () -> LocaleUtils.toLocale("us-EN"), "Should fail as not underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("us_En"),                 "Should fail second part not uppercase");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("us_en"),                 "Should fail second part not uppercase");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("us_eN"),                 "Should fail second part not uppercase");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("uS_EN"),                 "Should fail first part not lowercase");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("us_E3"),                 "Should fail second part not uppercase");     }      /**      * Test toLocale() method.      */     @Test     public void testToLocale_3Part() {         assertValidToLocale("us_EN_A", "us", "EN", "A");         // this isn't pretty, but was caused by a jdk bug it seems         // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) {             assertValidToLocale("us_EN_a", "us", "EN", "a");             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF");         } else {             assertValidToLocale("us_EN_a", "us", "EN", "A");             assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF");         }          assertThrows(                 IllegalArgumentException.class, () -> LocaleUtils.toLocale("us_EN-a"), "Should fail as not underscore");         assertThrows(                 IllegalArgumentException.class, () -> LocaleUtils.toLocale("uu_UU_"), "Must be 3, 5 or 7+ in length");     }      //-----------------------------------------------------------------------     /**      * Helper method for local lookups.      *      * @param locale  the input locale      * @param defaultLocale  the input default locale      * @param expected  expected results      */     private static void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) {         final List<Locale> localeList = defaultLocale == null ?                 LocaleUtils.localeLookupList(locale) :                 LocaleUtils.localeLookupList(locale, defaultLocale);          assertEquals(expected.length, localeList.size());         assertEquals(Arrays.asList(expected), localeList);         assertUnmodifiableCollection(localeList);     }      //-----------------------------------------------------------------------     /**      * Test localeLookupList() method.      */     @Test     public void testLocaleLookupList_Locale() {         assertLocaleLookupList(null, null, new Locale[0]);         assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});         assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});         assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});         assertLocaleLookupList(LOCALE_EN_US, null,             new Locale[] {                 LOCALE_EN_US,                 LOCALE_EN});         assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,             new Locale[] {                 LOCALE_EN_US_ZZZZ,                 LOCALE_EN_US,                 LOCALE_EN});     }      /**      * Test localeLookupList() method.      */     @Test     public void testLocaleLookupList_LocaleLocale() {         assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ,                 new Locale[]{LOCALE_QQ});         assertLocaleLookupList(LOCALE_EN, LOCALE_EN,                 new Locale[]{LOCALE_EN});          assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US,             new Locale[]{                 LOCALE_EN_US,                 LOCALE_EN});         assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,             new Locale[] {                 LOCALE_EN_US,                 LOCALE_EN,                 LOCALE_QQ});         assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,             new Locale[] {                 LOCALE_EN_US,                 LOCALE_EN,                 LOCALE_QQ_ZZ});          assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,             new Locale[] {                 LOCALE_EN_US_ZZZZ,                 LOCALE_EN_US,                 LOCALE_EN});         assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,             new Locale[] {                 LOCALE_EN_US_ZZZZ,                 LOCALE_EN_US,                 LOCALE_EN});         assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,             new Locale[] {                 LOCALE_EN_US_ZZZZ,                 LOCALE_EN_US,                 LOCALE_EN,                 LOCALE_QQ});         assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,             new Locale[] {                 LOCALE_EN_US_ZZZZ,                 LOCALE_EN_US,                 LOCALE_EN,                 LOCALE_QQ_ZZ});         assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,             new Locale[] {                 LOCALE_FR_CA,                 LOCALE_FR,                 LOCALE_EN});     }      //-----------------------------------------------------------------------     /**      * Test availableLocaleList() method.      */     @Test     public void testAvailableLocaleList() {         final List<Locale> list = LocaleUtils.availableLocaleList();         final List<Locale> list2 = LocaleUtils.availableLocaleList();         assertNotNull(list);         assertSame(list, list2);         assertUnmodifiableCollection(list);          final Locale[] jdkLocaleArray = Locale.getAvailableLocales();         final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);         assertEquals(jdkLocaleList, list);     }      //-----------------------------------------------------------------------     /**      * Test availableLocaleSet() method.      */     @Test     public void testAvailableLocaleSet() {         final Set<Locale> set = LocaleUtils.availableLocaleSet();         final Set<Locale> set2 = LocaleUtils.availableLocaleSet();         assertNotNull(set);         assertSame(set, set2);         assertUnmodifiableCollection(set);          final Locale[] jdkLocaleArray = Locale.getAvailableLocales();         final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);         final Set<Locale> jdkLocaleSet = new HashSet<>(jdkLocaleList);         assertEquals(jdkLocaleSet, set);     }      //-----------------------------------------------------------------------     /**      * Test availableLocaleSet() method.      */     @SuppressWarnings("boxing") // JUnit4 does not support primitive equality testing apart from long     @Test     public void testIsAvailableLocale() {         final Set<Locale> set = LocaleUtils.availableLocaleSet();         assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));         assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));         assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));         assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));         assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));         assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));         assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));     }      /**      * Test for 3-chars locale, further details at LANG-915      *      */     @Test     public void testThreeCharsLocale() {         for (final String str : Arrays.asList("udm", "tet")) {             final Locale locale = LocaleUtils.toLocale(str);             assertNotNull(locale);             assertEquals(str, locale.getLanguage());             assertTrue(StringUtils.isBlank(locale.getCountry()));             assertEquals(new Locale(str), locale);         }     }      //-----------------------------------------------------------------------     /**      * Make sure the language by country is correct. It checks that      * the LocaleUtils.languagesByCountry(country) call contains the      * array of languages passed in. It may contain more due to JVM      * variations.      *      * @param country      * @param languages array of languages that should be returned      */     private static void assertLanguageByCountry(final String country, final String[] languages) {         final List<Locale> list = LocaleUtils.languagesByCountry(country);         final List<Locale> list2 = LocaleUtils.languagesByCountry(country);         assertNotNull(list);         assertSame(list, list2);         //search through languages         for (final String language : languages) {             final Iterator<Locale> iterator = list.iterator();             boolean found = false;             // see if it was returned by the set             while (iterator.hasNext()) {                 final Locale locale = iterator.next();                 // should have an en empty variant                 assertTrue(locale.getVariant() == null                         || locale.getVariant().isEmpty());                 assertEquals(country, locale.getCountry());                 if (language.equals(locale.getLanguage())) {                     found = true;                     break;                 }             }             assertTrue(found, "Could not find language: " + language + " for country: " + country);         }         assertUnmodifiableCollection(list);     }      /**      * Test languagesByCountry() method.      */     @Test     public void testLanguagesByCountry() {         assertLanguageByCountry(null, new String[0]);         assertLanguageByCountry("GB", new String[]{"en"});         assertLanguageByCountry("ZZ", new String[0]);         assertLanguageByCountry("CH", new String[]{"fr", "de", "it"});     }      //-----------------------------------------------------------------------     /**      * Make sure the country by language is correct. It checks that      * the LocaleUtils.countryByLanguage(language) call contains the      * array of countries passed in. It may contain more due to JVM      * variations.      *      *      * @param language      * @param countries array of countries that should be returned      */     private static void assertCountriesByLanguage(final String language, final String[] countries) {         final List<Locale> list = LocaleUtils.countriesByLanguage(language);         final List<Locale> list2 = LocaleUtils.countriesByLanguage(language);         assertNotNull(list);         assertSame(list, list2);         //search through languages         for (final String country : countries) {             final Iterator<Locale> iterator = list.iterator();             boolean found = false;             // see if it was returned by the set             while (iterator.hasNext()) {                 final Locale locale = iterator.next();                 // should have an en empty variant                 assertTrue(locale.getVariant() == null                         || locale.getVariant().isEmpty());                 assertEquals(language, locale.getLanguage());                 if (country.equals(locale.getCountry())) {                     found = true;                     break;                 }             }             assertTrue(found, "Could not find language: " + country + " for country: " + language);         }         assertUnmodifiableCollection(list);     }      /**      * Test countriesByLanguage() method.      */     @Test     public void testCountriesByLanguage() {         assertCountriesByLanguage(null, new String[0]);         assertCountriesByLanguage("de", new String[]{"DE", "CH", "AT", "LU"});         assertCountriesByLanguage("zz", new String[0]);         assertCountriesByLanguage("it", new String[]{"IT", "CH"});     }      /**      * @param coll  the collection to check      */     private static void assertUnmodifiableCollection(final Collection<?> coll) {         assertThrows(UnsupportedOperationException.class, () -> coll.add(null));     }      /**      * Tests #LANG-328 - only language+variant      */     @Test     public void testLang328() {         assertValidToLocale("fr__P", "fr", "", "P");         assertValidToLocale("fr__POSIX", "fr", "", "POSIX");     }      @Test     public void testLanguageAndUNM49Numeric3AreaCodeLang1312() {         assertValidToLocale("en_001", "en", "001");         assertValidToLocale("en_150", "en", "150");         assertValidToLocale("ar_001", "ar", "001");          // LANG-1312         assertValidToLocale("en_001_GB", "en", "001", "GB");         assertValidToLocale("en_150_US", "en", "150", "US");     }      /**      * Tests #LANG-865, strings starting with an underscore.      */     @Test     public void testLang865() {         assertValidToLocale("_GB", "", "GB", "");         assertValidToLocale("_GB_P", "", "GB", "P");         assertValidToLocale("_GB_POSIX", "", "GB", "POSIX");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_G"),                 "Must be at least 3 chars if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_Gb"),                 "Must be uppercase if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_gB"),                 "Must be uppercase if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_1B"),                 "Must be letter if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_G1"),                 "Must be letter if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_GB_"),                 "Must be at least 5 chars if starts with underscore");         assertThrows(                 IllegalArgumentException.class,                 () -> LocaleUtils.toLocale("_GBAP"),                 "Must have underscore after the country if starts with underscore and is at least 5 chars");     }      @ParameterizedTest     @MethodSource("java.util.Locale#getAvailableLocales")     public void testParseAllLocales(final Locale l) {         // Check if it's possible to recreate the Locale using just the standard constructor         final Locale locale = new Locale(l.getLanguage(), l.getCountry(), l.getVariant());         if (l.equals(locale)) { // it is possible for LocaleUtils.toLocale to handle these Locales             final String str = l.toString();             // Look for the script/extension suffix             int suff = str.indexOf("_#");             if (suff == - 1) {                 suff = str.indexOf("#");             }             String localeStr = str;             if (suff >= 0) { // we have a suffix                 assertThrows(IllegalArgumentException.class, () -> LocaleUtils.toLocale(str));                 // try without suffix                 localeStr = str.substring(0, suff);             }             final Locale loc = LocaleUtils.toLocale(localeStr);             assertEquals(l, loc);         }     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.stream;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.core.Is.is; import static org.hamcrest.core.IsEqual.equalTo; import static org.hamcrest.core.IsNull.nullValue; import static org.junit.jupiter.api.Assertions.assertAll; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.DynamicTest.dynamicTest;  import java.lang.reflect.UndeclaredThrowableException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream;  import org.apache.commons.lang3.function.Failable; import org.apache.commons.lang3.function.FailableConsumer; import org.apache.commons.lang3.function.FailablePredicate; import org.junit.jupiter.api.DynamicTest; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestFactory; import org.junit.jupiter.api.function.Executable; import org.xml.sax.SAXException;  public class StreamsTest {      protected <T extends Throwable> FailableConsumer<String, T> asIntConsumer(final T pThrowable) {         return s -> {             final Integer i = Integer.valueOf(s);             if (i.intValue() == 4) {                 throw pThrowable;             }         };     }      protected <T extends Throwable> FailablePredicate<Integer, T> asIntPredicate(final T pThrowable) {         return i -> {             if (i.intValue() == 5) {                 if (pThrowable != null) {                     throw pThrowable;                 }             }             return i % 2 == 0;         };     }      private void assertEvenNumbers(final List<Integer> output) {         assertEquals(3, output.size());         for (int i = 0; i < 3; i++) {             assertEquals((i + 1) * 2, output.get(i).intValue());         }     }      @TestFactory     public Stream<DynamicTest> simpleStreamFilterFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Failable.stream(input).map(Integer::valueOf).filter(asIntPredicate(null))             .collect(Collectors.toList());         assertEvenNumbers(output);          return Stream.of(              dynamicTest("IllegalArgumentException", () -> {                 final IllegalArgumentException iae = new IllegalArgumentException("Invalid argument: " + 5);                 final Executable testMethod = () -> Failable.stream(input).map(Integer::valueOf)                     .filter(asIntPredicate(iae)).collect(Collectors.toList());                 final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, testMethod);                 assertThat(thrown.getMessage(), is(equalTo("Invalid argument: " + 5)));             }),              dynamicTest("OutOfMemoryError", () -> {                 final OutOfMemoryError oome = new OutOfMemoryError();                 final Executable testMethod = () -> Failable.stream(input).map(Integer::valueOf)                     .filter(asIntPredicate(oome)).collect(Collectors.toList());                 final OutOfMemoryError thrown = assertThrows(OutOfMemoryError.class, testMethod);                 assertThat(thrown.getMessage(), is(nullValue()));             }),              dynamicTest("SAXException", () -> {                 final SAXException se = new SAXException();                 final Executable testMethod = () -> Failable.stream(input).map(Integer::valueOf)                     .filter(asIntPredicate(se)).collect(Collectors.toList());                 final UndeclaredThrowableException thrown = assertThrows(UndeclaredThrowableException.class,                     testMethod);                 assertAll(() -> assertThat(thrown.getMessage(), is(nullValue())),                     () -> assertThat(thrown.getCause(), is(equalTo(se))));             }));     }      @TestFactory     public Stream<DynamicTest> simpleStreamForEachFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");          return Stream.of(              dynamicTest("IllegalArgumentException", () -> {                 final IllegalArgumentException ise = new IllegalArgumentException();                 final Executable testMethod = () -> Failable.stream(input).forEach(asIntConsumer(ise));                 final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, testMethod);                 assertThat(thrown.getMessage(), is(nullValue()));             }),              dynamicTest("OutOfMemoryError", () -> {                 final OutOfMemoryError oome = new OutOfMemoryError();                 final Executable oomeTestMethod = () -> Failable.stream(input).forEach(asIntConsumer(oome));                 final OutOfMemoryError oomeThrown = assertThrows(OutOfMemoryError.class, oomeTestMethod);                 assertThat(oomeThrown.getMessage(), is(nullValue()));             }),              dynamicTest("SAXException", () -> {                 final SAXException se = new SAXException();                 final Executable seTestMethod = () -> Failable.stream(input).forEach(asIntConsumer(se));                 final UndeclaredThrowableException seThrown = assertThrows(UndeclaredThrowableException.class,                     seTestMethod);                 assertAll(() -> assertThat(seThrown.getMessage(), is(nullValue())),                     () -> assertThat(seThrown.getCause(), is(equalTo(se))));             }));     }      @Test     public void testSimpleStreamFilter() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Failable.stream(input).map(Integer::valueOf).filter(i -> (i.intValue() % 2 == 0))             .collect(Collectors.toList());         assertEvenNumbers(output);     }      @Test     public void testSimpleStreamForEach() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = new ArrayList<>();         Failable.stream(input).forEach(s -> output.add(Integer.valueOf(s)));         assertEquals(6, output.size());         for (int i = 0; i < 6; i++) {             assertEquals(i + 1, output.get(i).intValue());         }     }      @Test     public void testSimpleStreamMap() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Failable.stream(input).map(Integer::valueOf).collect(Collectors.toList());         assertEquals(6, output.size());         for (int i = 0; i < 6; i++) {             assertEquals(i + 1, output.get(i).intValue());         }     }      @Test     public void testSimpleStreamMapFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4 ", "5", "6");         final Executable testMethod = () -> Failable.stream(input).map(Integer::valueOf).collect(Collectors.toList());         final NumberFormatException thrown = assertThrows(NumberFormatException.class, testMethod);         assertEquals("For input string: \"4 \"", thrown.getMessage());     }      @Test     public void testToArray() {         final String[] array = Arrays.asList("2", "3", "1").stream().collect(Streams.toArray(String.class));         assertNotNull(array);         assertEquals(3, array.length);         assertEquals("2", array[0]);         assertEquals("3", array[1]);         assertEquals("1", array[2]);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  /**  * Tests {@link StringUtils}'s valueOf() methods.  *  * @since 3.9  */ public class StringUtilsValueOfTest {      @Test     public void testValueOfChar() {         Assertions.assertEquals("ABC", StringUtils.valueOf(new char[] {'A', 'B', 'C' }));     }      @Test     public void testValueOfCharEmpty() {         Assertions.assertEquals(StringUtils.EMPTY, StringUtils.valueOf(ArrayUtils.EMPTY_CHAR_ARRAY));     }      @Test     public void testValueOfCharNull() {         Assertions.assertNull(StringUtils.valueOf(null));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.core.Is.is; import static org.hamcrest.core.IsEqual.equalTo; import static org.hamcrest.core.IsNull.nullValue; import static org.junit.jupiter.api.Assertions.assertAll; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.DynamicTest.dynamicTest;  import java.lang.reflect.UndeclaredThrowableException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream;  import org.apache.commons.lang3.Functions.FailableConsumer; import org.apache.commons.lang3.Functions.FailablePredicate; import org.junit.jupiter.api.DynamicTest; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestFactory; import org.junit.jupiter.api.function.Executable; import org.xml.sax.SAXException;  public class StreamsTest {      @Test     public void testSimpleStreamMap() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Functions.stream(input).map(Integer::valueOf).collect(Collectors.toList());         assertEquals(6, output.size());         for (int i = 0;  i < 6;  i++) {             assertEquals(i+1, output.get(i).intValue());         }     }      @Test     public void testSimpleStreamMapFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4 ", "5", "6");         final Executable testMethod = () -> Functions.stream(input).map(Integer::valueOf).collect(Collectors.toList());         final NumberFormatException thrown = assertThrows(NumberFormatException.class, testMethod);         assertEquals("For input string: \"4 \"", thrown.getMessage());     }      @Test     public void testSimpleStreamForEach() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = new ArrayList<>();         Functions.stream(input).forEach(s -> output.add(Integer.valueOf(s)));         assertEquals(6, output.size());         for (int i = 0;  i < 6;  i++) {             assertEquals(i+1, output.get(i).intValue());         }     }      @Test     public void testToArray() {         final String[] array = Arrays.asList("2", "3", "1").stream().collect(Streams.toArray(String.class));         assertNotNull(array);         assertEquals(3, array.length);         assertEquals("2", array[0]);         assertEquals("3", array[1]);         assertEquals("1", array[2]);     }      protected <T extends Throwable> FailableConsumer<String, T> asIntConsumer(final T pThrowable) {         return s -> {             final Integer i = Integer.valueOf(s);             if (i.intValue() == 4) {                 throw pThrowable;             }         };     }      @TestFactory     public Stream<DynamicTest> simpleStreamForEachFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");          return Stream.of(                  dynamicTest("IllegalArgumentException", () -> {                     final IllegalArgumentException ise = new IllegalArgumentException();                     final Executable testMethod = () -> Functions.stream(input)                             .forEach(asIntConsumer(ise));                     final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, testMethod);                     assertThat(thrown.getMessage(), is(nullValue()));                 }),                  dynamicTest("OutOfMemoryError", () -> {                     final OutOfMemoryError oome = new OutOfMemoryError();                     final Executable oomeTestMethod = () -> Functions.stream(input)                             .forEach(asIntConsumer(oome));                     final OutOfMemoryError oomeThrown = assertThrows(OutOfMemoryError.class, oomeTestMethod);                     assertThat(oomeThrown.getMessage(), is(nullValue()));                 }),                  dynamicTest("SAXException", () -> {                     final SAXException se = new SAXException();                     final Executable seTestMethod = () -> Functions.stream(input)                             .forEach(asIntConsumer(se));                     final UndeclaredThrowableException seThrown = assertThrows(UndeclaredThrowableException.class, seTestMethod);                     assertAll(                             () -> assertThat(seThrown.getMessage(), is(nullValue())),                             () -> assertThat(seThrown.getCause(), is(equalTo(se)))                     );                 })         );     }      @Test     public void testSimpleStreamFilter() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Functions.stream(input)                 .map(Integer::valueOf)                 .filter(i -> (i.intValue() %2 == 0))                 .collect(Collectors.toList());         assertEvenNumbers(output);     }      private void assertEvenNumbers(final List<Integer> output) {         assertEquals(3, output.size());         for (int i = 0;  i < 3;  i++) {             assertEquals((i+1)*2, output.get(i).intValue());         }     }      protected <T extends Throwable> FailablePredicate<Integer, T> asIntPredicate(final T pThrowable) {         return i -> {             if (i.intValue() == 5) {                 if (pThrowable != null) {                     throw pThrowable;                 }             }             return i%2==0;         };     }      @TestFactory     public Stream<DynamicTest> simpleStreamFilterFailing() {         final List<String> input = Arrays.asList("1", "2", "3", "4", "5", "6");         final List<Integer> output = Functions.stream(input)                 .map(Integer::valueOf)                 .filter(asIntPredicate(null))                 .collect(Collectors.toList());         assertEvenNumbers(output);          return Stream.of(                  dynamicTest("IllegalArgumentException", () -> {                     final IllegalArgumentException iae = new IllegalArgumentException("Invalid argument: " + 5);                     final Executable testMethod = () -> Functions.stream(input)                             .map(Integer::valueOf)                             .filter(asIntPredicate(iae))                             .collect(Collectors.toList());                     final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, testMethod);                     assertThat(thrown.getMessage(), is(equalTo("Invalid argument: " + 5)));                 }),                  dynamicTest("OutOfMemoryError", () -> {                     final OutOfMemoryError oome = new OutOfMemoryError();                     final Executable testMethod = () -> Functions.stream(input)                             .map(Integer::valueOf)                             .filter(asIntPredicate(oome))                             .collect(Collectors.toList());                     final OutOfMemoryError thrown = assertThrows(OutOfMemoryError.class, testMethod);                     assertThat(thrown.getMessage(), is(nullValue()));                 }),                  dynamicTest("SAXException", () -> {                     final SAXException se = new SAXException();                     final Executable testMethod = () -> Functions.stream(input)                             .map(Integer::valueOf)                             .filter(asIntPredicate(se))                             .collect(Collectors.toList());                     final UndeclaredThrowableException thrown = assertThrows(UndeclaredThrowableException.class, testMethod);                     assertAll(                             () -> assertThat(thrown.getMessage(), is(nullValue())),                             () -> assertThat(thrown.getCause(), is(equalTo(se)))                     );                 })         );     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3;  import static org.apache.commons.lang3.JavaVersion.JAVA_0_9; import static org.apache.commons.lang3.JavaVersion.JAVA_10; import static org.apache.commons.lang3.JavaVersion.JAVA_11; import static org.apache.commons.lang3.JavaVersion.JAVA_12; import static org.apache.commons.lang3.JavaVersion.JAVA_13; import static org.apache.commons.lang3.JavaVersion.JAVA_14; import static org.apache.commons.lang3.JavaVersion.JAVA_15; import static org.apache.commons.lang3.JavaVersion.JAVA_16; import static org.apache.commons.lang3.JavaVersion.JAVA_1_1; import static org.apache.commons.lang3.JavaVersion.JAVA_1_2; import static org.apache.commons.lang3.JavaVersion.JAVA_1_3; import static org.apache.commons.lang3.JavaVersion.JAVA_1_4; import static org.apache.commons.lang3.JavaVersion.JAVA_1_5; import static org.apache.commons.lang3.JavaVersion.JAVA_1_6; import static org.apache.commons.lang3.JavaVersion.JAVA_1_7; import static org.apache.commons.lang3.JavaVersion.JAVA_1_8; import static org.apache.commons.lang3.JavaVersion.JAVA_9; import static org.apache.commons.lang3.JavaVersion.JAVA_RECENT; import static org.apache.commons.lang3.JavaVersion.get; import static org.apache.commons.lang3.JavaVersion.getJavaVersion; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.JavaVersion}.  */ public class JavaVersionTest {      @Test     public void testGetJavaVersion() {         assertEquals(JAVA_0_9, get("0.9"), "0.9 failed");         assertEquals(JAVA_1_1, get("1.1"), "1.1 failed");         assertEquals(JAVA_1_2, get("1.2"), "1.2 failed");         assertEquals(JAVA_1_3, get("1.3"), "1.3 failed");         assertEquals(JAVA_1_4, get("1.4"), "1.4 failed");         assertEquals(JAVA_1_5, get("1.5"), "1.5 failed");         assertEquals(JAVA_1_6, get("1.6"), "1.6 failed");         assertEquals(JAVA_1_7, get("1.7"), "1.7 failed");         assertEquals(JAVA_1_8, get("1.8"), "1.8 failed");         assertEquals(JAVA_9, get("9"), "9 failed");         assertEquals(JAVA_10, get("10"), "10 failed");         assertEquals(JAVA_11, get("11"), "11 failed");         assertEquals(JAVA_12, get("12"), "12 failed");         assertEquals(JAVA_13, get("13"), "13 failed");         assertEquals(JAVA_14, get("14"), "14 failed");         assertEquals(JAVA_15, get("15"), "15 failed");         assertEquals(JAVA_16, get("16"), "16 failed");         assertEquals(JAVA_RECENT, get("1.10"), "1.10 failed");         // assertNull("2.10 unexpectedly worked", get("2.10"));         assertEquals(get("1.5"), getJavaVersion("1.5"), "Wrapper method failed");         assertEquals(JAVA_RECENT, get("17"), "Unhandled"); // LANG-1384     }      @Test     public void testAtLeast() {         assertFalse(JAVA_1_2.atLeast(JAVA_1_5), "1.2 at least 1.5 passed");         assertTrue(JAVA_1_5.atLeast(JAVA_1_2), "1.5 at least 1.2 failed");         assertFalse(JAVA_1_6.atLeast(JAVA_1_7), "1.6 at least 1.7 passed");          assertTrue(JAVA_0_9.atLeast(JAVA_1_5), "0.9 at least 1.5 failed");         assertFalse(JAVA_0_9.atLeast(JAVA_1_6), "0.9 at least 1.6 passed");     }      @Test     public void testToString() {         assertEquals("1.2", JAVA_1_2.toString());     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */ package org.apache.commons.lang3.math;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Test cases for the {@link Fraction} class  */ public class FractionTest  {      private static final int SKIP = 500;  //53      //--------------------------------------------------------------------------     @Test     public void testConstants() {         assertEquals(0, Fraction.ZERO.getNumerator());         assertEquals(1, Fraction.ZERO.getDenominator());          assertEquals(1, Fraction.ONE.getNumerator());         assertEquals(1, Fraction.ONE.getDenominator());          assertEquals(1, Fraction.ONE_HALF.getNumerator());         assertEquals(2, Fraction.ONE_HALF.getDenominator());          assertEquals(1, Fraction.ONE_THIRD.getNumerator());         assertEquals(3, Fraction.ONE_THIRD.getDenominator());          assertEquals(2, Fraction.TWO_THIRDS.getNumerator());         assertEquals(3, Fraction.TWO_THIRDS.getDenominator());          assertEquals(1, Fraction.ONE_QUARTER.getNumerator());         assertEquals(4, Fraction.ONE_QUARTER.getDenominator());          assertEquals(2, Fraction.TWO_QUARTERS.getNumerator());         assertEquals(4, Fraction.TWO_QUARTERS.getDenominator());          assertEquals(3, Fraction.THREE_QUARTERS.getNumerator());         assertEquals(4, Fraction.THREE_QUARTERS.getDenominator());          assertEquals(1, Fraction.ONE_FIFTH.getNumerator());         assertEquals(5, Fraction.ONE_FIFTH.getDenominator());          assertEquals(2, Fraction.TWO_FIFTHS.getNumerator());         assertEquals(5, Fraction.TWO_FIFTHS.getDenominator());          assertEquals(3, Fraction.THREE_FIFTHS.getNumerator());         assertEquals(5, Fraction.THREE_FIFTHS.getDenominator());          assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator());         assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator());     }      @Test     public void testFactory_int_int() {         Fraction f = null;          // zero         f = Fraction.getFraction(0, 1);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction(0, 2);         assertEquals(0, f.getNumerator());         assertEquals(2, f.getDenominator());          // normal         f = Fraction.getFraction(1, 1);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction(2, 1);         assertEquals(2, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction(23, 345);         assertEquals(23, f.getNumerator());         assertEquals(345, f.getDenominator());          // improper         f = Fraction.getFraction(22, 7);         assertEquals(22, f.getNumerator());         assertEquals(7, f.getDenominator());          // negatives         f = Fraction.getFraction(-6, 10);         assertEquals(-6, f.getNumerator());         assertEquals(10, f.getDenominator());          f = Fraction.getFraction(6, -10);         assertEquals(-6, f.getNumerator());         assertEquals(10, f.getDenominator());          f = Fraction.getFraction(-6, -10);         assertEquals(6, f.getNumerator());         assertEquals(10, f.getDenominator());          // zero denominator         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(2, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-3, 0));          // very large: can't represent as unsimplified fraction, although         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(4, Integer.MIN_VALUE));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, Integer.MIN_VALUE));     }      @Test     public void testFactory_int_int_int() {         Fraction f = null;          // zero         f = Fraction.getFraction(0, 0, 2);         assertEquals(0, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction(2, 0, 2);         assertEquals(4, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction(0, 1, 2);         assertEquals(1, f.getNumerator());         assertEquals(2, f.getDenominator());          // normal         f = Fraction.getFraction(1, 1, 2);         assertEquals(3, f.getNumerator());         assertEquals(2, f.getDenominator());          // negatives         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, -6, -10));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, -6, -10));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, -6, -10));          // negative whole         f = Fraction.getFraction(-1, 6, 10);         assertEquals(-16, f.getNumerator());         assertEquals(10, f.getDenominator());          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-1, -6, 10));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-1, 6, -10));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-1, -6, -10));          // zero denominator         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(0, 1, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, 2, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-1, -3, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MAX_VALUE, 1, 2));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-Integer.MAX_VALUE, 1, 2));          // very large         f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE);         assertEquals(-Integer.MAX_VALUE, f.getNumerator());         assertEquals(Integer.MAX_VALUE, f.getDenominator());          // negative denominators not allowed in this constructor.         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(0, 4, Integer.MIN_VALUE));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(1, 1, Integer.MAX_VALUE));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(-1, 2, Integer.MAX_VALUE));     }      @Test     public void testReducedFactory_int_int() {         Fraction f = null;          // zero         f = Fraction.getReducedFraction(0, 1);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          // normal         f = Fraction.getReducedFraction(1, 1);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getReducedFraction(2, 1);         assertEquals(2, f.getNumerator());         assertEquals(1, f.getDenominator());          // improper         f = Fraction.getReducedFraction(22, 7);         assertEquals(22, f.getNumerator());         assertEquals(7, f.getDenominator());          // negatives         f = Fraction.getReducedFraction(-6, 10);         assertEquals(-3, f.getNumerator());         assertEquals(5, f.getDenominator());          f = Fraction.getReducedFraction(6, -10);         assertEquals(-3, f.getNumerator());         assertEquals(5, f.getDenominator());          f = Fraction.getReducedFraction(-6, -10);         assertEquals(3, f.getNumerator());         assertEquals(5, f.getDenominator());          // zero denominator         assertThrows(ArithmeticException.class, () -> Fraction.getReducedFraction(1, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getReducedFraction(2, 0));         assertThrows(ArithmeticException.class, () -> Fraction.getReducedFraction(-3, 0));          // reduced         f = Fraction.getReducedFraction(0, 2);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getReducedFraction(2, 2);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getReducedFraction(2, 4);         assertEquals(1, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getReducedFraction(15, 10);         assertEquals(3, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getReducedFraction(121, 22);         assertEquals(11, f.getNumerator());         assertEquals(2, f.getDenominator());          // Extreme values         // OK, can reduce before negating         f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);         assertEquals(1, f.getNumerator());         assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());          // Can't reduce, negation will throw         assertThrows(ArithmeticException.class, () -> Fraction.getReducedFraction(-7, Integer.MIN_VALUE));          // LANG-662         f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);         assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());         assertEquals(1, f.getDenominator());     }      @Test     public void testFactory_double() {         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Double.NaN));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Double.POSITIVE_INFINITY));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Double.NEGATIVE_INFINITY));         assertThrows(ArithmeticException.class, () -> Fraction.getFraction((double) Integer.MAX_VALUE + 1));          // zero         Fraction f = Fraction.getFraction(0.0d);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          // one         f = Fraction.getFraction(1.0d);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          // one half         f = Fraction.getFraction(0.5d);         assertEquals(1, f.getNumerator());         assertEquals(2, f.getDenominator());          // negative         f = Fraction.getFraction(-0.875d);         assertEquals(-7, f.getNumerator());         assertEquals(8, f.getDenominator());          // over 1         f = Fraction.getFraction(1.25d);         assertEquals(5, f.getNumerator());         assertEquals(4, f.getDenominator());          // two thirds         f = Fraction.getFraction(0.66666d);         assertEquals(2, f.getNumerator());         assertEquals(3, f.getDenominator());          // small         f = Fraction.getFraction(1.0d/10001d);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          // normal         Fraction f2 = null;         for (int i = 1; i <= 100; i++) {  // denominator             for (int j = 1; j <= i; j++) {  // numerator                 f = Fraction.getFraction((double) j / (double) i);                  f2 = Fraction.getReducedFraction(j, i);                 assertEquals(f2.getNumerator(), f.getNumerator());                 assertEquals(f2.getDenominator(), f.getDenominator());             }         }         // save time by skipping some tests!  (         for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator             for (int j = 1; j <= i; j++) {  // numerator                 f = Fraction.getFraction((double) j / (double) i);                 f2 = Fraction.getReducedFraction(j, i);                 assertEquals(f2.getNumerator(), f.getNumerator());                 assertEquals(f2.getDenominator(), f.getDenominator());             }         }     }      @Test     public void testFactory_String() {         assertThrows(NullPointerException.class, () -> Fraction.getFraction(null));     }       @Test     public void testFactory_String_double() {         Fraction f = null;          f = Fraction.getFraction("0.0");         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction("0.2");         assertEquals(1, f.getNumerator());         assertEquals(5, f.getDenominator());          f = Fraction.getFraction("0.5");         assertEquals(1, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction("0.66666");         assertEquals(2, f.getNumerator());         assertEquals(3, f.getDenominator());          assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2.3R"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2147483648")); // too big         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("."));     }      @Test     public void testFactory_String_proper() {         Fraction f = null;          f = Fraction.getFraction("0 0/1");         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction("1 1/5");         assertEquals(6, f.getNumerator());         assertEquals(5, f.getDenominator());          f = Fraction.getFraction("7 1/2");         assertEquals(15, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction("1 2/4");         assertEquals(6, f.getNumerator());         assertEquals(4, f.getDenominator());          f = Fraction.getFraction("-7 1/2");         assertEquals(-15, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction("-1 2/4");         assertEquals(-6, f.getNumerator());         assertEquals(4, f.getDenominator());          assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2 3"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("a 3"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2 b/4"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2 "));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction(" 3"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction(" "));     }      @Test     public void testFactory_String_improper() {         Fraction f = null;          f = Fraction.getFraction("0/1");         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction("1/5");         assertEquals(1, f.getNumerator());         assertEquals(5, f.getDenominator());          f = Fraction.getFraction("1/2");         assertEquals(1, f.getNumerator());         assertEquals(2, f.getDenominator());          f = Fraction.getFraction("2/3");         assertEquals(2, f.getNumerator());         assertEquals(3, f.getDenominator());          f = Fraction.getFraction("7/3");         assertEquals(7, f.getNumerator());         assertEquals(3, f.getDenominator());          f = Fraction.getFraction("2/4");         assertEquals(2, f.getNumerator());         assertEquals(4, f.getDenominator());          assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2/d"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2e/3"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("2/"));         assertThrows(NumberFormatException.class, () -> Fraction.getFraction("/"));     }      @Test     public void testGets() {         Fraction f = null;          f = Fraction.getFraction(3, 5, 6);         assertEquals(23, f.getNumerator());         assertEquals(3, f.getProperWhole());         assertEquals(5, f.getProperNumerator());         assertEquals(6, f.getDenominator());          f = Fraction.getFraction(-3, 5, 6);         assertEquals(-23, f.getNumerator());         assertEquals(-3, f.getProperWhole());         assertEquals(5, f.getProperNumerator());         assertEquals(6, f.getDenominator());          f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);         assertEquals(Integer.MIN_VALUE, f.getNumerator());         assertEquals(Integer.MIN_VALUE, f.getProperWhole());         assertEquals(0, f.getProperNumerator());         assertEquals(1, f.getDenominator());     }      @Test     public void testConversions() {         Fraction f = null;          f = Fraction.getFraction(3, 7, 8);         assertEquals(3, f.intValue());         assertEquals(3L, f.longValue());         assertEquals(3.875f, f.floatValue(), 0.00001f);         assertEquals(3.875d, f.doubleValue(), 0.00001d);     }      @Test     public void testReduce() {         Fraction f = null;          f = Fraction.getFraction(50, 75);         Fraction result = f.reduce();         assertEquals(2, result.getNumerator());         assertEquals(3, result.getDenominator());          f = Fraction.getFraction(-2, -3);         result = f.reduce();         assertEquals(2, result.getNumerator());         assertEquals(3, result.getDenominator());          f = Fraction.getFraction(2, -3);         result = f.reduce();         assertEquals(-2, result.getNumerator());         assertEquals(3, result.getDenominator());          f = Fraction.getFraction(-2, 3);         result = f.reduce();         assertEquals(-2, result.getNumerator());         assertEquals(3, result.getDenominator());         assertSame(f, result);          f = Fraction.getFraction(2, 3);         result = f.reduce();         assertEquals(2, result.getNumerator());         assertEquals(3, result.getDenominator());         assertSame(f, result);          f = Fraction.getFraction(0, 1);         result = f.reduce();         assertEquals(0, result.getNumerator());         assertEquals(1, result.getDenominator());         assertSame(f, result);          f = Fraction.getFraction(0, 100);         result = f.reduce();         assertEquals(0, result.getNumerator());         assertEquals(1, result.getDenominator());         assertSame(result, Fraction.ZERO);          f = Fraction.getFraction(Integer.MIN_VALUE, 2);         result = f.reduce();         assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());         assertEquals(1, result.getDenominator());     }      @Test     public void testInvert() {         Fraction f = null;          f = Fraction.getFraction(50, 75);         f = f.invert();         assertEquals(75, f.getNumerator());         assertEquals(50, f.getDenominator());          f = Fraction.getFraction(4, 3);         f = f.invert();         assertEquals(3, f.getNumerator());         assertEquals(4, f.getDenominator());          f = Fraction.getFraction(-15, 47);         f = f.invert();         assertEquals(-47, f.getNumerator());         assertEquals(15, f.getDenominator());          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(0, 3).invert());         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MIN_VALUE, 1).invert());          f = Fraction.getFraction(Integer.MAX_VALUE, 1);         f = f.invert();         assertEquals(1, f.getNumerator());         assertEquals(Integer.MAX_VALUE, f.getDenominator());     }      @Test     public void testNegate() {         Fraction f = null;          f = Fraction.getFraction(50, 75);         f = f.negate();         assertEquals(-50, f.getNumerator());         assertEquals(75, f.getDenominator());          f = Fraction.getFraction(-50, 75);         f = f.negate();         assertEquals(50, f.getNumerator());         assertEquals(75, f.getDenominator());          // large values         f = Fraction.getFraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);         f = f.negate();         assertEquals(Integer.MIN_VALUE+2, f.getNumerator());         assertEquals(Integer.MAX_VALUE, f.getDenominator());          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MIN_VALUE, 1).negate());     }      @Test     public void testAbs() {         Fraction f = null;          f = Fraction.getFraction(50, 75);         f = f.abs();         assertEquals(50, f.getNumerator());         assertEquals(75, f.getDenominator());          f = Fraction.getFraction(-50, 75);         f = f.abs();         assertEquals(50, f.getNumerator());         assertEquals(75, f.getDenominator());          f = Fraction.getFraction(Integer.MAX_VALUE, 1);         f = f.abs();         assertEquals(Integer.MAX_VALUE, f.getNumerator());         assertEquals(1, f.getDenominator());          f = Fraction.getFraction(Integer.MAX_VALUE, -1);         f = f.abs();         assertEquals(Integer.MAX_VALUE, f.getNumerator());         assertEquals(1, f.getDenominator());          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MIN_VALUE, 1).abs());     }      @Test     public void testPow() {         Fraction f = null;          f = Fraction.getFraction(3, 5);         assertEquals(Fraction.ONE, f.pow(0));          f = Fraction.getFraction(3, 5);         assertSame(f, f.pow(1));         assertEquals(f, f.pow(1));          f = Fraction.getFraction(3, 5);         f = f.pow(2);         assertEquals(9, f.getNumerator());         assertEquals(25, f.getDenominator());          f = Fraction.getFraction(3, 5);         f = f.pow(3);         assertEquals(27, f.getNumerator());         assertEquals(125, f.getDenominator());          f = Fraction.getFraction(3, 5);         f = f.pow(-1);         assertEquals(5, f.getNumerator());         assertEquals(3, f.getDenominator());          f = Fraction.getFraction(3, 5);         f = f.pow(-2);         assertEquals(25, f.getNumerator());         assertEquals(9, f.getDenominator());          // check unreduced fractions stay that way.         f = Fraction.getFraction(6, 10);         assertEquals(Fraction.ONE, f.pow(0));          f = Fraction.getFraction(6, 10);         assertEquals(f, f.pow(1));         assertNotEquals(f.pow(1), Fraction.getFraction(3, 5));          f = Fraction.getFraction(6, 10);         f = f.pow(2);         assertEquals(9, f.getNumerator());         assertEquals(25, f.getDenominator());          f = Fraction.getFraction(6, 10);         f = f.pow(3);         assertEquals(27, f.getNumerator());         assertEquals(125, f.getDenominator());          f = Fraction.getFraction(6, 10);         f = f.pow(-1);         assertEquals(10, f.getNumerator());         assertEquals(6, f.getDenominator());          f = Fraction.getFraction(6, 10);         f = f.pow(-2);         assertEquals(25, f.getNumerator());         assertEquals(9, f.getDenominator());          // zero to any positive power is still zero.         f = Fraction.getFraction(0, 1231);         f = f.pow(1);         assertEquals(0, f.compareTo(Fraction.ZERO));         assertEquals(0, f.getNumerator());         assertEquals(1231, f.getDenominator());         f = f.pow(2);         assertEquals(0, f.compareTo(Fraction.ZERO));         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          // zero to negative powers should throw an exception         final Fraction fr = f;         assertThrows(ArithmeticException.class, () -> fr.pow(-1));         assertThrows(ArithmeticException.class, () -> fr.pow(Integer.MIN_VALUE));          // one to any power is still one.         f = Fraction.getFraction(1, 1);         f = f.pow(0);         assertEquals(f, Fraction.ONE);         f = f.pow(1);         assertEquals(f, Fraction.ONE);         f = f.pow(-1);         assertEquals(f, Fraction.ONE);         f = f.pow(Integer.MAX_VALUE);         assertEquals(f, Fraction.ONE);         f = f.pow(Integer.MIN_VALUE);         assertEquals(f, Fraction.ONE);          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MAX_VALUE, 1).pow(2));          // Numerator growing too negative during the pow operation.         assertThrows(ArithmeticException.class, () -> Fraction.getFraction(Integer.MIN_VALUE, 1).pow(3));          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(65536, 1).pow(2));     }      @Test     public void testAdd() {         Fraction f = null;         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(1, 5);         f = f1.add(f2);         assertEquals(4, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(2, 5);         f = f1.add(f2);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(3, 5);         f = f1.add(f2);         assertEquals(6, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(-4, 5);         f = f1.add(f2);         assertEquals(-1, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);         f2 = Fraction.ONE;         f = f1.add(f2);         assertEquals(Integer.MAX_VALUE, f.getNumerator());         assertEquals(1, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(1, 2);         f = f1.add(f2);         assertEquals(11, f.getNumerator());         assertEquals(10, f.getDenominator());          f1 = Fraction.getFraction(3, 8);         f2 = Fraction.getFraction(1, 6);         f = f1.add(f2);         assertEquals(13, f.getNumerator());         assertEquals(24, f.getDenominator());          f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(1, 5);         f = f1.add(f2);         assertSame(f2, f);         f = f2.add(f1);         assertSame(f2, f);          f1 = Fraction.getFraction(-1, 13*13*2*2);         f2 = Fraction.getFraction(-2, 13*17*2);         final Fraction fr = f1.add(f2);         assertEquals(13*13*17*2*2, fr.getDenominator());         assertEquals(-17 - 2*13*2, fr.getNumerator());          assertThrows(NullPointerException.class, () -> fr.add(null));          // if this fraction is added naively, it will overflow.         // check that it doesn't.         f1 = Fraction.getFraction(1, 32768*3);         f2 = Fraction.getFraction(1, 59049);         f = f1.add(f2);         assertEquals(52451, f.getNumerator());         assertEquals(1934917632, f.getDenominator());          f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);         f2 = Fraction.ONE_THIRD;         f = f1.add(f2);         assertEquals(Integer.MIN_VALUE+1, f.getNumerator());         assertEquals(3, f.getDenominator());          f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);         f2 = Fraction.ONE;         f = f1.add(f2);         assertEquals(Integer.MAX_VALUE, f.getNumerator());         assertEquals(1, f.getDenominator());          final Fraction overflower = f;         assertThrows(ArithmeticException.class, () -> overflower.add(Fraction.ONE)); // should overflow          // denominator should not be a multiple of 2 or 3 to trigger overflow         assertThrows(                 ArithmeticException.class,                 () -> Fraction.getFraction(Integer.MIN_VALUE, 5).add(Fraction.getFraction(-1, 5)));          final Fraction maxValue = Fraction.getFraction(-Integer.MAX_VALUE, 1);         assertThrows(ArithmeticException.class, () -> maxValue.add(maxValue));          final Fraction negativeMaxValue = Fraction.getFraction(-Integer.MAX_VALUE, 1);         assertThrows(ArithmeticException.class, () -> negativeMaxValue.add(negativeMaxValue));          final Fraction f3 = Fraction.getFraction(3, 327680);         final Fraction f4 = Fraction.getFraction(2, 59049);         assertThrows(ArithmeticException.class, () -> f3.add(f4)); // should overflow     }      @Test     public void testSubtract() {         Fraction f = null;         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(1, 5);         f = f1.subtract(f2);         assertEquals(2, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(7, 5);         f2 = Fraction.getFraction(2, 5);         f = f1.subtract(f2);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(3, 5);         f = f1.subtract(f2);         assertEquals(0, f.getNumerator());         assertEquals(1, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(-4, 5);         f = f1.subtract(f2);         assertEquals(7, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(4, 5);         f = f1.subtract(f2);         assertEquals(-4, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(-4, 5);         f = f1.subtract(f2);         assertEquals(4, f.getNumerator());         assertEquals(5, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(1, 2);         f = f1.subtract(f2);         assertEquals(1, f.getNumerator());         assertEquals(10, f.getDenominator());          f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(1, 5);         f = f2.subtract(f1);         assertSame(f2, f);          final Fraction fr = f;         assertThrows(NullPointerException.class, () -> fr.subtract(null));          // if this fraction is subtracted naively, it will overflow.         // check that it doesn't.         f1 = Fraction.getFraction(1, 32768*3);         f2 = Fraction.getFraction(1, 59049);         f = f1.subtract(f2);         assertEquals(-13085, f.getNumerator());         assertEquals(1934917632, f.getDenominator());          f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);         f2 = Fraction.ONE_THIRD.negate();         f = f1.subtract(f2);         assertEquals(Integer.MIN_VALUE+1, f.getNumerator());         assertEquals(3, f.getDenominator());          f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);         f2 = Fraction.ONE;         f = f1.subtract(f2);         assertEquals(Integer.MAX_VALUE-1, f.getNumerator());         assertEquals(1, f.getDenominator());          // Should overflow         assertThrows(                 ArithmeticException.class,                 () -> Fraction.getFraction(1, Integer.MAX_VALUE).subtract(Fraction.getFraction(1, Integer.MAX_VALUE - 1)));             f = f1.subtract(f2);          // denominator should not be a multiple of 2 or 3 to trigger overflow         assertThrows(                 ArithmeticException.class,                 () -> Fraction.getFraction(Integer.MIN_VALUE, 5).subtract(Fraction.getFraction(1, 5)));          assertThrows(                 ArithmeticException.class, () -> Fraction.getFraction(Integer.MIN_VALUE, 1).subtract(Fraction.ONE));          assertThrows(                 ArithmeticException.class,                 () -> Fraction.getFraction(Integer.MAX_VALUE, 1).subtract(Fraction.ONE.negate()));          // Should overflow         assertThrows(                 ArithmeticException.class,                 () -> Fraction.getFraction(3, 327680).subtract(Fraction.getFraction(2, 59049)));     }      @Test     public void testMultiply() {         Fraction f = null;         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(2, 5);         f = f1.multiplyBy(f2);         assertEquals(6, f.getNumerator());         assertEquals(25, f.getDenominator());          f1 = Fraction.getFraction(6, 10);         f2 = Fraction.getFraction(6, 10);         f = f1.multiplyBy(f2);         assertEquals(9, f.getNumerator());         assertEquals(25, f.getDenominator());         f = f.multiplyBy(f2);         assertEquals(27, f.getNumerator());         assertEquals(125, f.getDenominator());          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(-2, 5);         f = f1.multiplyBy(f2);         assertEquals(-6, f.getNumerator());         assertEquals(25, f.getDenominator());          f1 = Fraction.getFraction(-3, 5);         f2 = Fraction.getFraction(-2, 5);         f = f1.multiplyBy(f2);         assertEquals(6, f.getNumerator());         assertEquals(25, f.getDenominator());           f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(2, 7);         f = f1.multiplyBy(f2);         assertSame(Fraction.ZERO, f);          f1 = Fraction.getFraction(2, 7);         f2 = Fraction.ONE;         f = f1.multiplyBy(f2);         assertEquals(2, f.getNumerator());         assertEquals(7, f.getDenominator());          f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);         f2 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);         f = f1.multiplyBy(f2);         assertEquals(Integer.MIN_VALUE, f.getNumerator());         assertEquals(1, f.getDenominator());          final Fraction fr = f;         assertThrows(NullPointerException.class, () -> fr.multiplyBy(null));          final Fraction fr1 = Fraction.getFraction(1, Integer.MAX_VALUE);         assertThrows(ArithmeticException.class, () -> fr1.multiplyBy(fr1));          final Fraction fr2 = Fraction.getFraction(1, -Integer.MAX_VALUE);         assertThrows(ArithmeticException.class, () -> fr2.multiplyBy(fr2));     }      @Test     public void testDivide() {         Fraction f = null;         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(2, 5);         f = f1.divideBy(f2);         assertEquals(3, f.getNumerator());         assertEquals(2, f.getDenominator());          assertThrows(ArithmeticException.class, () -> Fraction.getFraction(3, 5).divideBy(Fraction.ZERO));          f1 = Fraction.getFraction(0, 5);         f2 = Fraction.getFraction(2, 7);         f = f1.divideBy(f2);         assertSame(Fraction.ZERO, f);          f1 = Fraction.getFraction(2, 7);         f2 = Fraction.ONE;         f = f1.divideBy(f2);         assertEquals(2, f.getNumerator());         assertEquals(7, f.getDenominator());          f1 = Fraction.getFraction(1, Integer.MAX_VALUE);         f = f1.divideBy(f1);         assertEquals(1, f.getNumerator());         assertEquals(1, f.getDenominator());          f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);         f2 = Fraction.getFraction(1, Integer.MAX_VALUE);         final Fraction fr = f1.divideBy(f2);         assertEquals(Integer.MIN_VALUE, fr.getNumerator());         assertEquals(1, fr.getDenominator());          assertThrows(NullPointerException.class, () -> fr.divideBy(null));          final Fraction smallest = Fraction.getFraction(1, Integer.MAX_VALUE);         assertThrows(ArithmeticException.class, () -> smallest.divideBy(smallest.invert())); // Should overflow          final Fraction negative = Fraction.getFraction(1, -Integer.MAX_VALUE);         assertThrows(ArithmeticException.class, () -> negative.divideBy(negative.invert())); // Should overflow     }      @Test     public void testEquals() {         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         assertNotEquals(null, f1);         assertNotEquals(f1, new Object());         assertNotEquals(f1, Integer.valueOf(6));          f1 = Fraction.getFraction(3, 5);         f2 = Fraction.getFraction(2, 5);         assertNotEquals(f1, f2);         assertEquals(f1, f1);         assertEquals(f2, f2);          f2 = Fraction.getFraction(3, 5);         assertEquals(f1, f2);          f2 = Fraction.getFraction(6, 10);         assertNotEquals(f1, f2);     }      @Test     public void testHashCode() {         final Fraction f1 = Fraction.getFraction(3, 5);         Fraction f2 = Fraction.getFraction(3, 5);          assertEquals(f1.hashCode(), f2.hashCode());          f2 = Fraction.getFraction(2, 5);         assertTrue(f1.hashCode() != f2.hashCode());          f2 = Fraction.getFraction(6, 10);         assertTrue(f1.hashCode() != f2.hashCode());     }      @Test     public void testCompareTo() {         Fraction f1 = null;         Fraction f2 = null;          f1 = Fraction.getFraction(3, 5);         assertEquals(0, f1.compareTo(f1));          final Fraction fr = f1;         assertThrows(NullPointerException.class, () -> fr.compareTo(null));          f2 = Fraction.getFraction(2, 5);         assertTrue(f1.compareTo(f2) > 0);         assertEquals(0, f2.compareTo(f2));          f2 = Fraction.getFraction(4, 5);         assertTrue(f1.compareTo(f2) < 0);         assertEquals(0, f2.compareTo(f2));          f2 = Fraction.getFraction(3, 5);         assertEquals(0, f1.compareTo(f2));         assertEquals(0, f2.compareTo(f2));          f2 = Fraction.getFraction(6, 10);         assertEquals(0, f1.compareTo(f2));         assertEquals(0, f2.compareTo(f2));          f2 = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);         assertTrue(f1.compareTo(f2) > 0);         assertEquals(0, f2.compareTo(f2));      }      @Test     public void testToString() {         Fraction f = null;          f = Fraction.getFraction(3, 5);         final String str = f.toString();         assertEquals("3/5", str);         assertSame(str, f.toString());          f = Fraction.getFraction(7, 5);         assertEquals("7/5", f.toString());          f = Fraction.getFraction(4, 2);         assertEquals("4/2", f.toString());          f = Fraction.getFraction(0, 2);         assertEquals("0/2", f.toString());          f = Fraction.getFraction(2, 2);         assertEquals("2/2", f.toString());          f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);         assertEquals("-2147483648/1", f.toString());          f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);         assertEquals("-2147483648/2147483647", f.toString());     }      @Test     public void testToProperString() {         Fraction f = null;          f = Fraction.getFraction(3, 5);         final String str = f.toProperString();         assertEquals("3/5", str);         assertSame(str, f.toProperString());          f = Fraction.getFraction(7, 5);         assertEquals("1 2/5", f.toProperString());          f = Fraction.getFraction(14, 10);         assertEquals("1 4/10", f.toProperString());          f = Fraction.getFraction(4, 2);         assertEquals("2", f.toProperString());          f = Fraction.getFraction(0, 2);         assertEquals("0", f.toProperString());          f = Fraction.getFraction(2, 2);         assertEquals("1", f.toProperString());          f = Fraction.getFraction(-7, 5);         assertEquals("-1 2/5", f.toProperString());          f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);         assertEquals("-2147483648", f.toProperString());          f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);         assertEquals("-1 1/2147483647", f.toProperString());          assertEquals("-1", Fraction.getFraction(-1).toProperString());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.math;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.math.IEEE754rUtils}.  */ public class IEEE754rUtilsTest  {      @Test     public void testLang381() {         assertEquals(1.2, IEEE754rUtils.min(1.2, 2.5, Double.NaN), 0.01);         assertEquals(2.5, IEEE754rUtils.max(1.2, 2.5, Double.NaN), 0.01);         assertTrue(Double.isNaN(IEEE754rUtils.max(Double.NaN, Double.NaN, Double.NaN)));         assertEquals(1.2f, IEEE754rUtils.min(1.2f, 2.5f, Float.NaN), 0.01);         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01);         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN)));          final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };         assertEquals(42.0, IEEE754rUtils.max(a), 0.01);         assertEquals(1.2, IEEE754rUtils.min(a), 0.01);          final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };         assertEquals(42.0, IEEE754rUtils.max(b), 0.01);         assertEquals(1.2, IEEE754rUtils.min(b), 0.01);          final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01);         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01);          final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01);         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01);     }      @Test     public void testEnforceExceptions() {         assertThrows(                 NullPointerException.class,                 () -> IEEE754rUtils.min( (float[]) null),                 "IllegalArgumentException expected for null input");          assertThrows(                 IllegalArgumentException.class,                 IEEE754rUtils::min,                 "IllegalArgumentException expected for empty input");          assertThrows(                 NullPointerException.class,                 () -> IEEE754rUtils.max( (float[]) null),                 "IllegalArgumentException expected for null input");          assertThrows(                 IllegalArgumentException.class,                 IEEE754rUtils::max,                 "IllegalArgumentException expected for empty input");          assertThrows(                 NullPointerException.class,                 () -> IEEE754rUtils.min( (double[]) null),                 "IllegalArgumentException expected for null input");          assertThrows(                 IllegalArgumentException.class,                 IEEE754rUtils::min,                 "IllegalArgumentException expected for empty input");          assertThrows(                 NullPointerException.class,                 () -> IEEE754rUtils.max( (double[]) null),                 "IllegalArgumentException expected for null input");          assertThrows(                 IllegalArgumentException.class,                 IEEE754rUtils::max,                 "IllegalArgumentException expected for empty input");     }      @Test     public void testConstructorExists() {         new IEEE754rUtils();     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.math;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.math.BigDecimal; import java.math.BigInteger; import java.math.RoundingMode;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.math.NumberUtils}.  */ public class NumberUtilsTest {      private boolean checkCreateNumber(final String val) {         try {             final Object obj = NumberUtils.createNumber(val);             return obj != null;         } catch (final NumberFormatException e) {             return false;         }     }      // ---------------------------------------------------------------------      @Test     public void compareByte() {         assertTrue(NumberUtils.compare((byte) -3, (byte) 0) < 0);         assertEquals(0, NumberUtils.compare((byte) 113, (byte) 113));         assertTrue(NumberUtils.compare((byte) 123, (byte) 32) > 0);     }      @Test     public void compareInt() {         assertTrue(NumberUtils.compare(-3, 0) < 0);         assertEquals(0, NumberUtils.compare(113, 113));         assertTrue(NumberUtils.compare(213, 32) > 0);     }      private void compareIsCreatableWithCreateNumber(final String val, final boolean expected) {         final boolean isValid = NumberUtils.isCreatable(val);         final boolean canCreate = checkCreateNumber(val);         assertTrue(isValid == expected && canCreate == expected, "Expecting " + expected             + " for isCreatable/createNumber using \"" + val + "\" but got " + isValid + " and " + canCreate);     }      private void compareIsNumberWithCreateNumber(final String val, final boolean expected) {         final boolean isValid = NumberUtils.isCreatable(val);         final boolean canCreate = checkCreateNumber(val);         assertTrue(isValid == expected && canCreate == expected, "Expecting " + expected             + " for isCreatable/createNumber using \"" + val + "\" but got " + isValid + " and " + canCreate);     }      @Test     public void compareLong() {         assertTrue(NumberUtils.compare(-3L, 0L) < 0);         assertEquals(0, NumberUtils.compare(113L, 113L));         assertTrue(NumberUtils.compare(213L, 32L) > 0);     }      @Test     public void compareShort() {         assertTrue(NumberUtils.compare((short) -3, (short) 0) < 0);         assertEquals(0, NumberUtils.compare((short) 113, (short) 113));         assertTrue(NumberUtils.compare((short) 213, (short) 32) > 0);     }      /**      * Test for {@link NumberUtils#toDouble(BigDecimal)}      */     @Test     public void testBigIntegerToDoubleBigInteger() {         assertEquals(0.0d, NumberUtils.toDouble((BigDecimal) null), "toDouble(BigInteger) 1 failed");         assertEquals(8.5d, NumberUtils.toDouble(BigDecimal.valueOf(8.5d)), "toDouble(BigInteger) 2 failed");     }      /**      * Test for {@link NumberUtils#toDouble(BigDecimal, double)}      */     @Test     public void testBigIntegerToDoubleBigIntegerD() {         assertEquals(1.1d, NumberUtils.toDouble((BigDecimal) null, 1.1d), "toDouble(BigInteger) 1 failed");         assertEquals(8.5d, NumberUtils.toDouble(BigDecimal.valueOf(8.5d), 1.1d), "toDouble(BigInteger) 2 failed");     }      // Testing JDK against old Lang functionality     @Test     public void testCompareDouble() {         assertEquals(0, Double.compare(Double.NaN, Double.NaN));         assertEquals(Double.compare(Double.NaN, Double.POSITIVE_INFINITY), +1);         assertEquals(Double.compare(Double.NaN, Double.MAX_VALUE), +1);         assertEquals(Double.compare(Double.NaN, 1.2d), +1);         assertEquals(Double.compare(Double.NaN, 0.0d), +1);         assertEquals(Double.compare(Double.NaN, -0.0d), +1);         assertEquals(Double.compare(Double.NaN, -1.2d), +1);         assertEquals(Double.compare(Double.NaN, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(Double.NaN, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.NaN), -1);         assertEquals(0, Double.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));         assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, 1.2d), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, 0.0d), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, -0.0d), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, -1.2d), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(Double.MAX_VALUE, Double.NaN), -1);         assertEquals(Double.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY), -1);         assertEquals(0, Double.compare(Double.MAX_VALUE, Double.MAX_VALUE));         assertEquals(Double.compare(Double.MAX_VALUE, 1.2d), +1);         assertEquals(Double.compare(Double.MAX_VALUE, 0.0d), +1);         assertEquals(Double.compare(Double.MAX_VALUE, -0.0d), +1);         assertEquals(Double.compare(Double.MAX_VALUE, -1.2d), +1);         assertEquals(Double.compare(Double.MAX_VALUE, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(1.2d, Double.NaN), -1);         assertEquals(Double.compare(1.2d, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(1.2d, Double.MAX_VALUE), -1);         assertEquals(0, Double.compare(1.2d, 1.2d));         assertEquals(Double.compare(1.2d, 0.0d), +1);         assertEquals(Double.compare(1.2d, -0.0d), +1);         assertEquals(Double.compare(1.2d, -1.2d), +1);         assertEquals(Double.compare(1.2d, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(1.2d, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(0.0d, Double.NaN), -1);         assertEquals(Double.compare(0.0d, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(0.0d, Double.MAX_VALUE), -1);         assertEquals(Double.compare(0.0d, 1.2d), -1);         assertEquals(0, Double.compare(0.0d, 0.0d));         assertEquals(Double.compare(0.0d, -0.0d), +1);         assertEquals(Double.compare(0.0d, -1.2d), +1);         assertEquals(Double.compare(0.0d, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(0.0d, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(-0.0d, Double.NaN), -1);         assertEquals(Double.compare(-0.0d, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(-0.0d, Double.MAX_VALUE), -1);         assertEquals(Double.compare(-0.0d, 1.2d), -1);         assertEquals(Double.compare(-0.0d, 0.0d), -1);         assertEquals(0, Double.compare(-0.0d, -0.0d));         assertEquals(Double.compare(-0.0d, -1.2d), +1);         assertEquals(Double.compare(-0.0d, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(-0.0d, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(-1.2d, Double.NaN), -1);         assertEquals(Double.compare(-1.2d, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(-1.2d, Double.MAX_VALUE), -1);         assertEquals(Double.compare(-1.2d, 1.2d), -1);         assertEquals(Double.compare(-1.2d, 0.0d), -1);         assertEquals(Double.compare(-1.2d, -0.0d), -1);         assertEquals(0, Double.compare(-1.2d, -1.2d));         assertEquals(Double.compare(-1.2d, -Double.MAX_VALUE), +1);         assertEquals(Double.compare(-1.2d, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(-Double.MAX_VALUE, Double.NaN), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, Double.MAX_VALUE), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, 1.2d), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, 0.0d), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, -0.0d), -1);         assertEquals(Double.compare(-Double.MAX_VALUE, -1.2d), -1);         assertEquals(0, Double.compare(-Double.MAX_VALUE, -Double.MAX_VALUE));         assertEquals(Double.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), +1);          assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.NaN), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, 1.2d), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, 0.0d), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -0.0d), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -1.2d), -1);         assertEquals(Double.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE), -1);         assertEquals(0, Double.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));     }      @Test     public void testCompareFloat() {         assertEquals(0, Float.compare(Float.NaN, Float.NaN));         assertEquals(Float.compare(Float.NaN, Float.POSITIVE_INFINITY), +1);         assertEquals(Float.compare(Float.NaN, Float.MAX_VALUE), +1);         assertEquals(Float.compare(Float.NaN, 1.2f), +1);         assertEquals(Float.compare(Float.NaN, 0.0f), +1);         assertEquals(Float.compare(Float.NaN, -0.0f), +1);         assertEquals(Float.compare(Float.NaN, -1.2f), +1);         assertEquals(Float.compare(Float.NaN, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(Float.NaN, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(Float.POSITIVE_INFINITY, Float.NaN), -1);         assertEquals(0, Float.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY));         assertEquals(Float.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, 1.2f), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, 0.0f), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, -0.0f), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, -1.2f), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(Float.MAX_VALUE, Float.NaN), -1);         assertEquals(Float.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY), -1);         assertEquals(0, Float.compare(Float.MAX_VALUE, Float.MAX_VALUE));         assertEquals(Float.compare(Float.MAX_VALUE, 1.2f), +1);         assertEquals(Float.compare(Float.MAX_VALUE, 0.0f), +1);         assertEquals(Float.compare(Float.MAX_VALUE, -0.0f), +1);         assertEquals(Float.compare(Float.MAX_VALUE, -1.2f), +1);         assertEquals(Float.compare(Float.MAX_VALUE, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(1.2f, Float.NaN), -1);         assertEquals(Float.compare(1.2f, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(1.2f, Float.MAX_VALUE), -1);         assertEquals(0, Float.compare(1.2f, 1.2f));         assertEquals(Float.compare(1.2f, 0.0f), +1);         assertEquals(Float.compare(1.2f, -0.0f), +1);         assertEquals(Float.compare(1.2f, -1.2f), +1);         assertEquals(Float.compare(1.2f, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(1.2f, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(0.0f, Float.NaN), -1);         assertEquals(Float.compare(0.0f, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(0.0f, Float.MAX_VALUE), -1);         assertEquals(Float.compare(0.0f, 1.2f), -1);         assertEquals(0, Float.compare(0.0f, 0.0f));         assertEquals(Float.compare(0.0f, -0.0f), +1);         assertEquals(Float.compare(0.0f, -1.2f), +1);         assertEquals(Float.compare(0.0f, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(0.0f, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(-0.0f, Float.NaN), -1);         assertEquals(Float.compare(-0.0f, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(-0.0f, Float.MAX_VALUE), -1);         assertEquals(Float.compare(-0.0f, 1.2f), -1);         assertEquals(Float.compare(-0.0f, 0.0f), -1);         assertEquals(0, Float.compare(-0.0f, -0.0f));         assertEquals(Float.compare(-0.0f, -1.2f), +1);         assertEquals(Float.compare(-0.0f, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(-0.0f, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(-1.2f, Float.NaN), -1);         assertEquals(Float.compare(-1.2f, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(-1.2f, Float.MAX_VALUE), -1);         assertEquals(Float.compare(-1.2f, 1.2f), -1);         assertEquals(Float.compare(-1.2f, 0.0f), -1);         assertEquals(Float.compare(-1.2f, -0.0f), -1);         assertEquals(0, Float.compare(-1.2f, -1.2f));         assertEquals(Float.compare(-1.2f, -Float.MAX_VALUE), +1);         assertEquals(Float.compare(-1.2f, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(-Float.MAX_VALUE, Float.NaN), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, Float.MAX_VALUE), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, 1.2f), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, 0.0f), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, -0.0f), -1);         assertEquals(Float.compare(-Float.MAX_VALUE, -1.2f), -1);         assertEquals(0, Float.compare(-Float.MAX_VALUE, -Float.MAX_VALUE));         assertEquals(Float.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY), +1);          assertEquals(Float.compare(Float.NEGATIVE_INFINITY, Float.NaN), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, 1.2f), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, 0.0f), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, -0.0f), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, -1.2f), -1);         assertEquals(Float.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE), -1);         assertEquals(0, Float.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY));     }      @SuppressWarnings("cast") // suppress instanceof warning check     @Test     public void testConstants() {         assertTrue(NumberUtils.LONG_ZERO instanceof Long);         assertTrue(NumberUtils.LONG_ONE instanceof Long);         assertTrue(NumberUtils.LONG_MINUS_ONE instanceof Long);         assertTrue(NumberUtils.INTEGER_ZERO instanceof Integer);         assertTrue(NumberUtils.INTEGER_ONE instanceof Integer);         assertTrue(NumberUtils.INTEGER_MINUS_ONE instanceof Integer);         assertTrue(NumberUtils.SHORT_ZERO instanceof Short);         assertTrue(NumberUtils.SHORT_ONE instanceof Short);         assertTrue(NumberUtils.SHORT_MINUS_ONE instanceof Short);         assertTrue(NumberUtils.BYTE_ZERO instanceof Byte);         assertTrue(NumberUtils.BYTE_ONE instanceof Byte);         assertTrue(NumberUtils.BYTE_MINUS_ONE instanceof Byte);         assertTrue(NumberUtils.DOUBLE_ZERO instanceof Double);         assertTrue(NumberUtils.DOUBLE_ONE instanceof Double);         assertTrue(NumberUtils.DOUBLE_MINUS_ONE instanceof Double);         assertTrue(NumberUtils.FLOAT_ZERO instanceof Float);         assertTrue(NumberUtils.FLOAT_ONE instanceof Float);         assertTrue(NumberUtils.FLOAT_MINUS_ONE instanceof Float);          assertEquals(0, NumberUtils.LONG_ZERO.longValue());         assertEquals(1, NumberUtils.LONG_ONE.longValue());         assertEquals(NumberUtils.LONG_MINUS_ONE.longValue(), -1);         assertEquals(0, NumberUtils.INTEGER_ZERO.intValue());         assertEquals(1, NumberUtils.INTEGER_ONE.intValue());         assertEquals(NumberUtils.INTEGER_MINUS_ONE.intValue(), -1);         assertEquals(0, NumberUtils.SHORT_ZERO.shortValue());         assertEquals(1, NumberUtils.SHORT_ONE.shortValue());         assertEquals(NumberUtils.SHORT_MINUS_ONE.shortValue(), -1);         assertEquals(0, NumberUtils.BYTE_ZERO.byteValue());         assertEquals(1, NumberUtils.BYTE_ONE.byteValue());         assertEquals(NumberUtils.BYTE_MINUS_ONE.byteValue(), -1);         assertEquals(0.0d, NumberUtils.DOUBLE_ZERO.doubleValue());         assertEquals(1.0d, NumberUtils.DOUBLE_ONE.doubleValue());         assertEquals(NumberUtils.DOUBLE_MINUS_ONE.doubleValue(), -1.0d);         assertEquals(0.0f, NumberUtils.FLOAT_ZERO.floatValue());         assertEquals(1.0f, NumberUtils.FLOAT_ONE.floatValue());         assertEquals(NumberUtils.FLOAT_MINUS_ONE.floatValue(), -1.0f);     }      // -----------------------------------------------------------------------     @Test     public void testConstructor() {         assertNotNull(new NumberUtils());         final Constructor<?>[] cons = NumberUtils.class.getDeclaredConstructors();         assertEquals(1, cons.length);         assertTrue(Modifier.isPublic(cons[0].getModifiers()));         assertTrue(Modifier.isPublic(NumberUtils.class.getModifiers()));         assertFalse(Modifier.isFinal(NumberUtils.class.getModifiers()));     }      @Test     public void testCreateBigDecimal() {         assertEquals(new BigDecimal("1234.5"), NumberUtils.createBigDecimal("1234.5"),             "createBigDecimal(String) failed");         assertNull(NumberUtils.createBigDecimal(null), "createBigDecimal(null) failed");         this.testCreateBigDecimalFailure("");         this.testCreateBigDecimalFailure(" ");         this.testCreateBigDecimalFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateBigDecimalFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");         // sign alone not valid         this.testCreateBigDecimalFailure("-");         // comment in NumberUtils suggests some implementations may incorrectly allow this         this.testCreateBigDecimalFailure("--");         this.testCreateBigDecimalFailure("--0");         // sign alone not valid         this.testCreateBigDecimalFailure("+");         // in case this was also allowed by some JVMs         this.testCreateBigDecimalFailure("++");         this.testCreateBigDecimalFailure("++0");     }      protected void testCreateBigDecimalFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createBigDecimal(str),             "createBigDecimal(\"" + str + "\") should have failed.");     }      @Test     public void testCreateBigInteger() {         assertEquals(new BigInteger("12345"), NumberUtils.createBigInteger("12345"), "createBigInteger(String) failed");         assertNull(NumberUtils.createBigInteger(null), "createBigInteger(null) failed");         this.testCreateBigIntegerFailure("");         this.testCreateBigIntegerFailure(" ");         this.testCreateBigIntegerFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateBigIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");         assertEquals(new BigInteger("255"), NumberUtils.createBigInteger("0xff"), "createBigInteger(String) failed");         assertEquals(new BigInteger("255"), NumberUtils.createBigInteger("0Xff"), "createBigInteger(String) failed");         assertEquals(new BigInteger("255"), NumberUtils.createBigInteger("#ff"), "createBigInteger(String) failed");         assertEquals(new BigInteger("-255"), NumberUtils.createBigInteger("-0xff"), "createBigInteger(String) failed");         assertEquals(new BigInteger("255"), NumberUtils.createBigInteger("0377"), "createBigInteger(String) failed");         assertEquals(new BigInteger("-255"), NumberUtils.createBigInteger("-0377"), "createBigInteger(String) failed");         assertEquals(new BigInteger("-255"), NumberUtils.createBigInteger("-0377"), "createBigInteger(String) failed");         assertEquals(new BigInteger("-0"), NumberUtils.createBigInteger("-0"), "createBigInteger(String) failed");         assertEquals(new BigInteger("0"), NumberUtils.createBigInteger("0"), "createBigInteger(String) failed");         testCreateBigIntegerFailure("#");         testCreateBigIntegerFailure("-#");         testCreateBigIntegerFailure("0x");         testCreateBigIntegerFailure("-0x");     }      protected void testCreateBigIntegerFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createBigInteger(str),             "createBigInteger(\"" + str + "\") should have failed.");     }      @Test     public void testCreateDouble() {         assertEquals(Double.valueOf("1234.5"), NumberUtils.createDouble("1234.5"), "createDouble(String) failed");         assertNull(NumberUtils.createDouble(null), "createDouble(null) failed");         this.testCreateDoubleFailure("");         this.testCreateDoubleFailure(" ");         this.testCreateDoubleFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateDoubleFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");     }      protected void testCreateDoubleFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createDouble(str),             "createDouble(\"" + str + "\") should have failed.");     }      @Test     public void testCreateFloat() {         assertEquals(Float.valueOf("1234.5"), NumberUtils.createFloat("1234.5"), "createFloat(String) failed");         assertNull(NumberUtils.createFloat(null), "createFloat(null) failed");         this.testCreateFloatFailure("");         this.testCreateFloatFailure(" ");         this.testCreateFloatFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateFloatFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");     }      protected void testCreateFloatFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createFloat(str),             "createFloat(\"" + str + "\") should have failed.");     }      @Test     public void testCreateInteger() {         assertEquals(Integer.valueOf("12345"), NumberUtils.createInteger("12345"), "createInteger(String) failed");         assertNull(NumberUtils.createInteger(null), "createInteger(null) failed");         this.testCreateIntegerFailure("");         this.testCreateIntegerFailure(" ");         this.testCreateIntegerFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateIntegerFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");     }      protected void testCreateIntegerFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createInteger(str),             "createInteger(\"" + str + "\") should have failed.");     }      @Test     public void testCreateLong() {         assertEquals(Long.valueOf("12345"), NumberUtils.createLong("12345"), "createLong(String) failed");         assertNull(NumberUtils.createLong(null), "createLong(null) failed");         this.testCreateLongFailure("");         this.testCreateLongFailure(" ");         this.testCreateLongFailure("\b\t\n\f\r");         // Funky whitespaces         this.testCreateLongFailure("\u00A0\uFEFF\u000B\u000C\u001C\u001D\u001E\u001F");     }      protected void testCreateLongFailure(final String str) {         assertThrows(NumberFormatException.class, () -> NumberUtils.createLong(str),             "createLong(\"" + str + "\") should have failed.");     }      @Test     public void testCreateNumber() {         // a lot of things can go wrong         assertEquals(Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5"), "createNumber(String) 1 failed");         assertEquals(Integer.valueOf("12345"), NumberUtils.createNumber("12345"), "createNumber(String) 2 failed");         assertEquals(Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5D"), "createNumber(String) 3 failed");         assertEquals(Double.valueOf("1234.5"), NumberUtils.createNumber("1234.5d"), "createNumber(String) 3 failed");         assertEquals(Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5F"), "createNumber(String) 4 failed");         assertEquals(Float.valueOf("1234.5"), NumberUtils.createNumber("1234.5f"), "createNumber(String) 4 failed");         assertEquals(Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" + (Integer.MAX_VALUE + 1L)),             "createNumber(String) 5 failed");         assertEquals(Long.valueOf(12345), NumberUtils.createNumber("12345L"), "createNumber(String) 6 failed");         assertEquals(Long.valueOf(12345), NumberUtils.createNumber("12345l"), "createNumber(String) 6 failed");         assertEquals(Float.valueOf("-1234.5"), NumberUtils.createNumber("-1234.5"), "createNumber(String) 7 failed");         assertEquals(Integer.valueOf("-12345"), NumberUtils.createNumber("-12345"), "createNumber(String) 8 failed");         assertEquals(0xFADE, NumberUtils.createNumber("0xFADE").intValue(), "createNumber(String) 9a failed");         assertEquals(0xFADE, NumberUtils.createNumber("0Xfade").intValue(), "createNumber(String) 9b failed");         assertEquals(-0xFADE, NumberUtils.createNumber("-0xFADE").intValue(), "createNumber(String) 10a failed");         assertEquals(-0xFADE, NumberUtils.createNumber("-0Xfade").intValue(), "createNumber(String) 10b failed");         assertEquals(Double.valueOf("1.1E200"), NumberUtils.createNumber("1.1E200"), "createNumber(String) 11 failed");         assertEquals(Float.valueOf("1.1E20"), NumberUtils.createNumber("1.1E20"), "createNumber(String) 12 failed");         assertEquals(Double.valueOf("-1.1E200"), NumberUtils.createNumber("-1.1E200"),             "createNumber(String) 13 failed");         assertEquals(Double.valueOf("1.1E-200"), NumberUtils.createNumber("1.1E-200"),             "createNumber(String) 14 failed");         assertNull(NumberUtils.createNumber(null), "createNumber(null) failed");         assertEquals(new BigInteger("12345678901234567890"), NumberUtils.createNumber("12345678901234567890L"),             "createNumber(String) failed");          assertEquals(new BigDecimal("1.1E-700"), NumberUtils.createNumber("1.1E-700F"),             "createNumber(String) 15 failed");          assertEquals(Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils.createNumber("10" + Integer.MAX_VALUE + "L"),             "createNumber(String) 16 failed");         assertEquals(Long.valueOf("10" + Integer.MAX_VALUE), NumberUtils.createNumber("10" + Integer.MAX_VALUE),             "createNumber(String) 17 failed");         assertEquals(new BigInteger("10" + Long.MAX_VALUE), NumberUtils.createNumber("10" + Long.MAX_VALUE),             "createNumber(String) 18 failed");          // LANG-521         assertEquals(Float.valueOf("2."), NumberUtils.createNumber("2."), "createNumber(String) LANG-521 failed");          // LANG-638         assertFalse(checkCreateNumber("1eE"), "createNumber(String) succeeded");          // LANG-693         assertEquals(Double.valueOf(Double.MAX_VALUE), NumberUtils.createNumber("" + Double.MAX_VALUE),             "createNumber(String) LANG-693 failed");          // LANG-822         // ensure that the underlying negative number would create a BigDecimal         final Number bigNum = NumberUtils.createNumber("-1.1E-700F");         assertNotNull(bigNum);         assertEquals(BigDecimal.class, bigNum.getClass());          // LANG-1018         assertEquals(Double.valueOf("-160952.54"), NumberUtils.createNumber("-160952.54"),             "createNumber(String) LANG-1018 failed");         // LANG-1187         assertEquals(Double.valueOf("6264583.33"), NumberUtils.createNumber("6264583.33"),             "createNumber(String) LANG-1187 failed");         // LANG-1215         assertEquals(Double.valueOf("193343.82"), NumberUtils.createNumber("193343.82"),             "createNumber(String) LANG-1215 failed");         // LANG-1060         assertEquals(Double.valueOf("001234.5678"), NumberUtils.createNumber("001234.5678"),             "createNumber(String) LANG-1060a failed");         assertEquals(Double.valueOf("+001234.5678"), NumberUtils.createNumber("+001234.5678"),             "createNumber(String) LANG-1060b failed");         assertEquals(Double.valueOf("-001234.5678"), NumberUtils.createNumber("-001234.5678"),             "createNumber(String) LANG-1060c failed");         assertEquals(Double.valueOf("0000.00000"), NumberUtils.createNumber("0000.00000d"),             "createNumber(String) LANG-1060d failed");         assertEquals(Float.valueOf("001234.56"), NumberUtils.createNumber("001234.56"),             "createNumber(String) LANG-1060e failed");         assertEquals(Float.valueOf("+001234.56"), NumberUtils.createNumber("+001234.56"),             "createNumber(String) LANG-1060f failed");         assertEquals(Float.valueOf("-001234.56"), NumberUtils.createNumber("-001234.56"),             "createNumber(String) LANG-1060g failed");         assertEquals(Float.valueOf("0000.10"), NumberUtils.createNumber("0000.10"),             "createNumber(String) LANG-1060h failed");         assertEquals(Float.valueOf("001.1E20"), NumberUtils.createNumber("001.1E20"),             "createNumber(String) LANG-1060i failed");         assertEquals(Float.valueOf("+001.1E20"), NumberUtils.createNumber("+001.1E20"),             "createNumber(String) LANG-1060j failed");         assertEquals(Float.valueOf("-001.1E20"), NumberUtils.createNumber("-001.1E20"),             "createNumber(String) LANG-1060k failed");         assertEquals(Double.valueOf("001.1E200"), NumberUtils.createNumber("001.1E200"),             "createNumber(String) LANG-1060l failed");         assertEquals(Double.valueOf("+001.1E200"), NumberUtils.createNumber("+001.1E200"),             "createNumber(String) LANG-1060m failed");         assertEquals(Double.valueOf("-001.1E200"), NumberUtils.createNumber("-001.1E200"),             "createNumber(String) LANG-1060n failed");     }      @Test     // Check that the code fails to create a valid number when preceded by -- rather than -     public void testCreateNumberFailure_1() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("--1.1E-700F"));     }      @Test     // Check that the code fails to create a valid number when both e and E are present (with decimal)     public void testCreateNumberFailure_2() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("-1.1E+0-7e00"));     }      @Test     // Check that the code fails to create a valid number when both e and E are present (no decimal)     public void testCreateNumberFailure_3() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("-11E+0-7e00"));     }      @Test     // Check that the code fails to create a valid number when both e and E are present (no decimal)     public void testCreateNumberFailure_4() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("1eE+00001"));     }      @Test     // Check that the code fails to create a valid number when there are multiple trailing 'f' characters (LANG-1205)     public void testCreateNumberFailure_5() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("1234.5ff"));     }      @Test     // Check that the code fails to create a valid number when there are multiple trailing 'F' characters (LANG-1205)     public void testCreateNumberFailure_6() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("1234.5FF"));     }      @Test     // Check that the code fails to create a valid number when there are multiple trailing 'd' characters (LANG-1205)     public void testCreateNumberFailure_7() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("1234.5dd"));     }      @Test     // Check that the code fails to create a valid number when there are multiple trailing 'D' characters (LANG-1205)     public void testCreateNumberFailure_8() {         assertThrows(NumberFormatException.class, () -> NumberUtils.createNumber("1234.5DD"));     }      // Tests to show when magnitude causes switch to next Number type     // Will probably need to be adjusted if code is changed to check precision (LANG-693)     @Test     public void testCreateNumberMagnitude() {         // Test Float.MAX_VALUE, and same with +1 in final digit to check conversion changes to next Number type         assertEquals(Float.valueOf(Float.MAX_VALUE), NumberUtils.createNumber("3.4028235e+38"));         assertEquals(Double.valueOf(3.4028236e+38), NumberUtils.createNumber("3.4028236e+38"));          // Test Double.MAX_VALUE         assertEquals(Double.valueOf(Double.MAX_VALUE), NumberUtils.createNumber("1.7976931348623157e+308"));         // Test with +2 in final digit (+1 does not cause roll-over to BigDecimal)         assertEquals(new BigDecimal("1.7976931348623159e+308"), NumberUtils.createNumber("1.7976931348623159e+308"));          assertEquals(Integer.valueOf(0x12345678), NumberUtils.createNumber("0x12345678"));         assertEquals(Long.valueOf(0x123456789L), NumberUtils.createNumber("0x123456789"));          assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber("0x7fffffffffffffff"));         // Does not appear to be a way to create a literal BigInteger of this magnitude         assertEquals(new BigInteger("7fffffffffffffff0", 16), NumberUtils.createNumber("0x7fffffffffffffff0"));          assertEquals(Long.valueOf(0x7fffffffffffffffL), NumberUtils.createNumber("#7fffffffffffffff"));         assertEquals(new BigInteger("7fffffffffffffff0", 16), NumberUtils.createNumber("#7fffffffffffffff0"));          assertEquals(Integer.valueOf(017777777777), NumberUtils.createNumber("017777777777")); // 31 bits         assertEquals(Long.valueOf(037777777777L), NumberUtils.createNumber("037777777777")); // 32 bits          // 63 bits         assertEquals(Long.valueOf(0777777777777777777777L), NumberUtils.createNumber("0777777777777777777777"));         // 64 bits         assertEquals(new BigInteger("1777777777777777777777", 8), NumberUtils.createNumber("01777777777777777777777"));     }      /**      * Tests isCreatable(String) and tests that createNumber(String) returns a valid number iff isCreatable(String)      * returns false.      */     @Test     public void testIsCreatable() {         compareIsCreatableWithCreateNumber("12345", true);         compareIsCreatableWithCreateNumber("1234.5", true);         compareIsCreatableWithCreateNumber(".12345", true);         compareIsCreatableWithCreateNumber("1234E5", true);         compareIsCreatableWithCreateNumber("1234E+5", true);         compareIsCreatableWithCreateNumber("1234E-5", true);         compareIsCreatableWithCreateNumber("123.4E5", true);         compareIsCreatableWithCreateNumber("-1234", true);         compareIsCreatableWithCreateNumber("-1234.5", true);         compareIsCreatableWithCreateNumber("-.12345", true);         compareIsCreatableWithCreateNumber("-1234E5", true);         compareIsCreatableWithCreateNumber("0", true);         compareIsCreatableWithCreateNumber("0.1", true); // LANG-1216         compareIsCreatableWithCreateNumber("-0", true);         compareIsCreatableWithCreateNumber("01234", true);         compareIsCreatableWithCreateNumber("-01234", true);         compareIsCreatableWithCreateNumber("-0xABC123", true);         compareIsCreatableWithCreateNumber("-0x0", true);         compareIsCreatableWithCreateNumber("123.4E21D", true);         compareIsCreatableWithCreateNumber("-221.23F", true);         compareIsCreatableWithCreateNumber("22338L", true);          compareIsCreatableWithCreateNumber(null, false);         compareIsCreatableWithCreateNumber("", false);         compareIsCreatableWithCreateNumber(" ", false);         compareIsCreatableWithCreateNumber("\r\n\t", false);         compareIsCreatableWithCreateNumber("--2.3", false);         compareIsCreatableWithCreateNumber(".12.3", false);         compareIsCreatableWithCreateNumber("-123E", false);         compareIsCreatableWithCreateNumber("-123E+-212", false);         compareIsCreatableWithCreateNumber("-123E2.12", false);         compareIsCreatableWithCreateNumber("0xGF", false);         compareIsCreatableWithCreateNumber("0xFAE-1", false);         compareIsCreatableWithCreateNumber(".", false);         compareIsCreatableWithCreateNumber("-0ABC123", false);         compareIsCreatableWithCreateNumber("123.4E-D", false);         compareIsCreatableWithCreateNumber("123.4ED", false);         compareIsCreatableWithCreateNumber("1234E5l", false);         compareIsCreatableWithCreateNumber("11a", false);         compareIsCreatableWithCreateNumber("1a", false);         compareIsCreatableWithCreateNumber("a", false);         compareIsCreatableWithCreateNumber("11g", false);         compareIsCreatableWithCreateNumber("11z", false);         compareIsCreatableWithCreateNumber("11def", false);         compareIsCreatableWithCreateNumber("11d11", false);         compareIsCreatableWithCreateNumber("11 11", false);         compareIsCreatableWithCreateNumber(" 1111", false);         compareIsCreatableWithCreateNumber("1111 ", false);          compareIsCreatableWithCreateNumber("2.", true); // LANG-521         compareIsCreatableWithCreateNumber("1.1L", false); // LANG-664     }      @Test     public void testIsDigits() {         assertFalse(NumberUtils.isDigits(null), "isDigits(null) failed");         assertFalse(NumberUtils.isDigits(""), "isDigits('') failed");         assertTrue(NumberUtils.isDigits("12345"), "isDigits(String) failed");         assertFalse(NumberUtils.isDigits("1234.5"), "isDigits(String) neg 1 failed");         assertFalse(NumberUtils.isDigits("1ab"), "isDigits(String) neg 3 failed");         assertFalse(NumberUtils.isDigits("abc"), "isDigits(String) neg 4 failed");     }      /**      * Tests isCreatable(String) and tests that createNumber(String) returns a valid number iff isCreatable(String)      * returns false.      */     @Test     public void testIsNumber() {         compareIsNumberWithCreateNumber("12345", true);         compareIsNumberWithCreateNumber("1234.5", true);         compareIsNumberWithCreateNumber(".12345", true);         compareIsNumberWithCreateNumber("1234E5", true);         compareIsNumberWithCreateNumber("1234E+5", true);         compareIsNumberWithCreateNumber("1234E-5", true);         compareIsNumberWithCreateNumber("123.4E5", true);         compareIsNumberWithCreateNumber("-1234", true);         compareIsNumberWithCreateNumber("-1234.5", true);         compareIsNumberWithCreateNumber("-.12345", true);         compareIsNumberWithCreateNumber("-0001.12345", true);         compareIsNumberWithCreateNumber("-000.12345", true);         compareIsNumberWithCreateNumber("+00.12345", true);         compareIsNumberWithCreateNumber("+0002.12345", true);         compareIsNumberWithCreateNumber("-1234E5", true);         compareIsNumberWithCreateNumber("0", true);         compareIsNumberWithCreateNumber("-0", true);         compareIsNumberWithCreateNumber("01234", true);         compareIsNumberWithCreateNumber("-01234", true);         compareIsNumberWithCreateNumber("-0xABC123", true);         compareIsNumberWithCreateNumber("-0x0", true);         compareIsNumberWithCreateNumber("123.4E21D", true);         compareIsNumberWithCreateNumber("-221.23F", true);         compareIsNumberWithCreateNumber("22338L", true);          compareIsNumberWithCreateNumber(null, false);         compareIsNumberWithCreateNumber("", false);         compareIsNumberWithCreateNumber(" ", false);         compareIsNumberWithCreateNumber("\r\n\t", false);         compareIsNumberWithCreateNumber("--2.3", false);          compareIsNumberWithCreateNumber(".12.3", false);         compareIsNumberWithCreateNumber("-123E", false);         compareIsNumberWithCreateNumber("-123E+-212", false);         compareIsNumberWithCreateNumber("-123E2.12", false);         compareIsNumberWithCreateNumber("0xGF", false);         compareIsNumberWithCreateNumber("0xFAE-1", false);         compareIsNumberWithCreateNumber(".", false);         compareIsNumberWithCreateNumber("-0ABC123", false);         compareIsNumberWithCreateNumber("123.4E-D", false);         compareIsNumberWithCreateNumber("123.4ED", false);         compareIsNumberWithCreateNumber("+000E.12345", false);         compareIsNumberWithCreateNumber("-000E.12345", false);         compareIsNumberWithCreateNumber("1234E5l", false);         compareIsNumberWithCreateNumber("11a", false);         compareIsNumberWithCreateNumber("1a", false);         compareIsNumberWithCreateNumber("a", false);         compareIsNumberWithCreateNumber("11g", false);         compareIsNumberWithCreateNumber("11z", false);         compareIsNumberWithCreateNumber("11def", false);         compareIsNumberWithCreateNumber("11d11", false);         compareIsNumberWithCreateNumber("11 11", false);         compareIsNumberWithCreateNumber(" 1111", false);         compareIsNumberWithCreateNumber("1111 ", false);          compareIsNumberWithCreateNumber("2.", true); // LANG-521         compareIsNumberWithCreateNumber("1.1L", false); // LANG-664     }      @Test     public void testIsNumberLANG1252() {         compareIsNumberWithCreateNumber("+2", true);         compareIsNumberWithCreateNumber("+2.0", true);     }      @Test     public void testIsNumberLANG1385() {         compareIsNumberWithCreateNumber("L", false);     }      @Test     public void testIsNumberLANG971() {         compareIsNumberWithCreateNumber("0085", false);         compareIsNumberWithCreateNumber("085", false);         compareIsNumberWithCreateNumber("08", false);         compareIsNumberWithCreateNumber("07", true);         compareIsNumberWithCreateNumber("00", true);     }      @Test     public void testIsNumberLANG972() {         compareIsNumberWithCreateNumber("0xABCD", true);         compareIsNumberWithCreateNumber("0XABCD", true);     }      @Test     public void testIsNumberLANG992() {         compareIsNumberWithCreateNumber("0.0", true);         compareIsNumberWithCreateNumber("0.4790", true);     }      @Test     public void testIsParsable() {         assertFalse(NumberUtils.isParsable(null));         assertFalse(NumberUtils.isParsable(""));         assertFalse(NumberUtils.isParsable("0xC1AB"));         assertFalse(NumberUtils.isParsable("65CBA2"));         assertFalse(NumberUtils.isParsable("pendro"));         assertFalse(NumberUtils.isParsable("64, 2"));         assertFalse(NumberUtils.isParsable("64.2.2"));         assertFalse(NumberUtils.isParsable("64."));         assertFalse(NumberUtils.isParsable("64L"));         assertFalse(NumberUtils.isParsable("-"));         assertFalse(NumberUtils.isParsable("--2"));         assertTrue(NumberUtils.isParsable("64.2"));         assertTrue(NumberUtils.isParsable("64"));         assertTrue(NumberUtils.isParsable("018"));         assertTrue(NumberUtils.isParsable(".18"));         assertTrue(NumberUtils.isParsable("-65"));         assertTrue(NumberUtils.isParsable("-018"));         assertTrue(NumberUtils.isParsable("-018.2"));         assertTrue(NumberUtils.isParsable("-.236"));     }      @Test     public void testLang1087() {         // no sign cases         assertEquals(Float.class, NumberUtils.createNumber("0.0").getClass());         assertEquals(Float.valueOf("0.0"), NumberUtils.createNumber("0.0"));         // explicit positive sign cases         assertEquals(Float.class, NumberUtils.createNumber("+0.0").getClass());         assertEquals(Float.valueOf("+0.0"), NumberUtils.createNumber("+0.0"));         // negative sign cases         assertEquals(Float.class, NumberUtils.createNumber("-0.0").getClass());         assertEquals(Float.valueOf("-0.0"), NumberUtils.createNumber("-0.0"));     }      @Test     public void testLANG1252() {         compareIsCreatableWithCreateNumber("+2", true);         compareIsCreatableWithCreateNumber("+2.0", true);     }      @Test     public void testLang300() {         NumberUtils.createNumber("-1l");         NumberUtils.createNumber("01l");         NumberUtils.createNumber("1l");     }      @Test     public void testLang381() {         assertTrue(Double.isNaN(NumberUtils.min(1.2, 2.5, Double.NaN)));         assertTrue(Double.isNaN(NumberUtils.max(1.2, 2.5, Double.NaN)));         assertTrue(Float.isNaN(NumberUtils.min(1.2f, 2.5f, Float.NaN)));         assertTrue(Float.isNaN(NumberUtils.max(1.2f, 2.5f, Float.NaN)));          final double[] a = new double[] {1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN};         assertTrue(Double.isNaN(NumberUtils.max(a)));         assertTrue(Double.isNaN(NumberUtils.min(a)));          final double[] b = new double[] {Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN};         assertTrue(Double.isNaN(NumberUtils.max(b)));         assertTrue(Double.isNaN(NumberUtils.min(b)));          final float[] aF = new float[] {1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN};         assertTrue(Float.isNaN(NumberUtils.max(aF)));          final float[] bF = new float[] {Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN};         assertTrue(Float.isNaN(NumberUtils.max(bF)));     }      @Test     public void TestLang747() {         assertEquals(Integer.valueOf(0x8000), NumberUtils.createNumber("0x8000"));         assertEquals(Integer.valueOf(0x80000), NumberUtils.createNumber("0x80000"));         assertEquals(Integer.valueOf(0x800000), NumberUtils.createNumber("0x800000"));         assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x8000000"));         assertEquals(Integer.valueOf(0x7FFFFFFF), NumberUtils.createNumber("0x7FFFFFFF"));         assertEquals(Long.valueOf(0x80000000L), NumberUtils.createNumber("0x80000000"));         assertEquals(Long.valueOf(0xFFFFFFFFL), NumberUtils.createNumber("0xFFFFFFFF"));          // Leading zero tests         assertEquals(Integer.valueOf(0x8000000), NumberUtils.createNumber("0x08000000"));         assertEquals(Integer.valueOf(0x7FFFFFFF), NumberUtils.createNumber("0x007FFFFFFF"));         assertEquals(Long.valueOf(0x80000000L), NumberUtils.createNumber("0x080000000"));         assertEquals(Long.valueOf(0xFFFFFFFFL), NumberUtils.createNumber("0x00FFFFFFFF"));          assertEquals(Long.valueOf(0x800000000L), NumberUtils.createNumber("0x800000000"));         assertEquals(Long.valueOf(0x8000000000L), NumberUtils.createNumber("0x8000000000"));         assertEquals(Long.valueOf(0x80000000000L), NumberUtils.createNumber("0x80000000000"));         assertEquals(Long.valueOf(0x800000000000L), NumberUtils.createNumber("0x800000000000"));         assertEquals(Long.valueOf(0x8000000000000L), NumberUtils.createNumber("0x8000000000000"));         assertEquals(Long.valueOf(0x80000000000000L), NumberUtils.createNumber("0x80000000000000"));         assertEquals(Long.valueOf(0x800000000000000L), NumberUtils.createNumber("0x800000000000000"));         assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber("0x7FFFFFFFFFFFFFFF"));         // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long         assertEquals(new BigInteger("8000000000000000", 16), NumberUtils.createNumber("0x8000000000000000"));         assertEquals(new BigInteger("FFFFFFFFFFFFFFFF", 16), NumberUtils.createNumber("0xFFFFFFFFFFFFFFFF"));          // Leading zero tests         assertEquals(Long.valueOf(0x80000000000000L), NumberUtils.createNumber("0x00080000000000000"));         assertEquals(Long.valueOf(0x800000000000000L), NumberUtils.createNumber("0x0800000000000000"));         assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber("0x07FFFFFFFFFFFFFFF"));         // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long         assertEquals(new BigInteger("8000000000000000", 16), NumberUtils.createNumber("0x00008000000000000000"));         assertEquals(new BigInteger("FFFFFFFFFFFFFFFF", 16), NumberUtils.createNumber("0x0FFFFFFFFFFFFFFFF"));     }      @Test     public void testLANG971() {         compareIsCreatableWithCreateNumber("0085", false);         compareIsCreatableWithCreateNumber("085", false);         compareIsCreatableWithCreateNumber("08", false);         compareIsCreatableWithCreateNumber("07", true);         compareIsCreatableWithCreateNumber("00", true);     }      @Test     public void testLANG972() {         compareIsCreatableWithCreateNumber("0xABCD", true);         compareIsCreatableWithCreateNumber("0XABCD", true);     }      @Test     public void testLANG992() {         compareIsCreatableWithCreateNumber("0.0", true);         compareIsCreatableWithCreateNumber("0.4790", true);     }      @Test     public void testMaxByte() {         assertEquals((byte) 5, NumberUtils.max((byte) 5), "max(byte[]) failed for array length 1");         assertEquals((byte) 9, NumberUtils.max((byte) 6, (byte) 9), "max(byte[]) failed for array length 2");         assertEquals((byte) 10, NumberUtils.max((byte) -10, (byte) -5, (byte) 0, (byte) 5, (byte) 10),             "max(byte[]) failed for array length 5");         assertEquals((byte) 10, NumberUtils.max((byte) -10, (byte) -5, (byte) 0, (byte) 5, (byte) 10));         assertEquals((byte) 10, NumberUtils.max((byte) -5, (byte) 0, (byte) 10, (byte) 5, (byte) -10));     }      @Test     public void testMaxByte_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxByte_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((byte[]) null));     }      @Test     public void testMaxDouble() {         final double[] d = null;         assertThrows(NullPointerException.class, () -> NumberUtils.max(d), "No exception was thrown for null input.");          assertThrows(IllegalArgumentException.class, NumberUtils::max, "No exception was thrown for empty input.");          assertEquals(5.1f, NumberUtils.max(5.1f), "max(double[]) failed for array length 1");         assertEquals(9.2f, NumberUtils.max(6.3f, 9.2f), "max(double[]) failed for array length 2");         assertEquals(10.4f, NumberUtils.max(-10.5f, -5.6f, 0, 5.7f, 10.4f), "max(double[]) failed for float length 5");         assertEquals(10, NumberUtils.max(-10, -5, 0, 5, 10), 0.0001);         assertEquals(10, NumberUtils.max(-5, 0, 10, 5, -10), 0.0001);     }      @Test     public void testMaxDouble_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxDouble_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((double[]) null));     }      @Test     public void testMaxFloat() {         assertEquals(5.1f, NumberUtils.max(5.1f), "max(float[]) failed for array length 1");         assertEquals(9.2f, NumberUtils.max(6.3f, 9.2f), "max(float[]) failed for array length 2");         assertEquals(10.4f, NumberUtils.max(-10.5f, -5.6f, 0, 5.7f, 10.4f), "max(float[]) failed for float length 5");         assertEquals(10, NumberUtils.max(-10, -5, 0, 5, 10), 0.0001f);         assertEquals(10, NumberUtils.max(-5, 0, 10, 5, -10), 0.0001f);     }      @Test     public void testMaxFloat_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxFloat_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((float[]) null));     }      @Test     public void testMaximumByte() {         final byte low = 123;         final byte mid = 123 + 1;         final byte high = 123 + 2;         assertEquals(high, NumberUtils.max(low, mid, high), "maximum(byte, byte, byte) 1 failed");         assertEquals(high, NumberUtils.max(mid, low, high), "maximum(byte, byte, byte) 2 failed");         assertEquals(high, NumberUtils.max(mid, high, low), "maximum(byte, byte, byte) 3 failed");         assertEquals(high, NumberUtils.max(high, mid, high), "maximum(byte, byte, byte) 4 failed");     }      @Test     public void testMaximumDouble() {         final double low = 12.3;         final double mid = 12.3 + 1;         final double high = 12.3 + 2;         assertEquals(high, NumberUtils.max(low, mid, high), 0.0001);         assertEquals(high, NumberUtils.max(mid, low, high), 0.0001);         assertEquals(high, NumberUtils.max(mid, high, low), 0.0001);         assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001);         assertEquals(high, NumberUtils.max(high, mid, high), 0.0001);     }      @Test     public void testMaximumFloat() {         final float low = 12.3f;         final float mid = 12.3f + 1;         final float high = 12.3f + 2;         assertEquals(high, NumberUtils.max(low, mid, high), 0.0001f);         assertEquals(high, NumberUtils.max(mid, low, high), 0.0001f);         assertEquals(high, NumberUtils.max(mid, high, low), 0.0001f);         assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001f);         assertEquals(high, NumberUtils.max(high, mid, high), 0.0001f);     }      @Test     public void testMaximumInt() {         assertEquals(12345, NumberUtils.max(12345, 12345 - 1, 12345 - 2), "maximum(int, int, int) 1 failed");         assertEquals(12345, NumberUtils.max(12345 - 1, 12345, 12345 - 2), "maximum(int, int, int) 2 failed");         assertEquals(12345, NumberUtils.max(12345 - 1, 12345 - 2, 12345), "maximum(int, int, int) 3 failed");         assertEquals(12345, NumberUtils.max(12345 - 1, 12345, 12345), "maximum(int, int, int) 4 failed");         assertEquals(12345, NumberUtils.max(12345, 12345, 12345), "maximum(int, int, int) 5 failed");     }      @Test     public void testMaximumLong() {         assertEquals(12345L, NumberUtils.max(12345L, 12345L - 1L, 12345L - 2L), "maximum(long, long, long) 1 failed");         assertEquals(12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L - 2L), "maximum(long, long, long) 2 failed");         assertEquals(12345L, NumberUtils.max(12345L - 1L, 12345L - 2L, 12345L), "maximum(long, long, long) 3 failed");         assertEquals(12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L), "maximum(long, long, long) 4 failed");         assertEquals(12345L, NumberUtils.max(12345L, 12345L, 12345L), "maximum(long, long, long) 5 failed");     }      @Test     public void testMaximumShort() {         final short low = 1234;         final short mid = 1234 + 1;         final short high = 1234 + 2;         assertEquals(high, NumberUtils.max(low, mid, high), "maximum(short, short, short) 1 failed");         assertEquals(high, NumberUtils.max(mid, low, high), "maximum(short, short, short) 2 failed");         assertEquals(high, NumberUtils.max(mid, high, low), "maximum(short, short, short) 3 failed");         assertEquals(high, NumberUtils.max(high, mid, high), "maximum(short, short, short) 4 failed");     }      @Test     public void testMaxInt() {         assertEquals(5, NumberUtils.max(5), "max(int[]) failed for array length 1");         assertEquals(9, NumberUtils.max(6, 9), "max(int[]) failed for array length 2");         assertEquals(10, NumberUtils.max(-10, -5, 0, 5, 10), "max(int[]) failed for array length 5");         assertEquals(10, NumberUtils.max(-10, -5, 0, 5, 10));         assertEquals(10, NumberUtils.max(-5, 0, 10, 5, -10));     }      @Test     public void testMaxInt_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxInt_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((int[]) null));     }      @Test     public void testMaxLong() {         assertEquals(5L, NumberUtils.max(5L), "max(long[]) failed for array length 1");         assertEquals(9L, NumberUtils.max(6L, 9L), "max(long[]) failed for array length 2");         assertEquals(10L, NumberUtils.max(-10L, -5L, 0L, 5L, 10L), "max(long[]) failed for array length 5");         assertEquals(10L, NumberUtils.max(-10L, -5L, 0L, 5L, 10L));         assertEquals(10L, NumberUtils.max(-5L, 0L, 10L, 5L, -10L));     }      @Test     public void testMaxLong_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxLong_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((long[]) null));     }      @Test     public void testMaxShort() {         assertEquals((short) 5, NumberUtils.max((short) 5), "max(short[]) failed for array length 1");         assertEquals((short) 9, NumberUtils.max((short) 6, (short) 9), "max(short[]) failed for array length 2");         assertEquals((short) 10, NumberUtils.max((short) -10, (short) -5, (short) 0, (short) 5, (short) 10),             "max(short[]) failed for array length 5");         assertEquals((short) 10, NumberUtils.max((short) -10, (short) -5, (short) 0, (short) 5, (short) 10));         assertEquals((short) 10, NumberUtils.max((short) -5, (short) 0, (short) 10, (short) 5, (short) -10));     }      @Test     public void testMaxShort_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::max);     }      @Test     public void testMaxShort_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.max((short[]) null));     }      @Test     public void testMinByte() {         assertEquals((byte) 5, NumberUtils.min((byte) 5), "min(byte[]) failed for array length 1");         assertEquals((byte) 6, NumberUtils.min((byte) 6, (byte) 9), "min(byte[]) failed for array length 2");          assertEquals((byte) -10, NumberUtils.min((byte) -10, (byte) -5, (byte) 0, (byte) 5, (byte) 10));         assertEquals((byte) -10, NumberUtils.min((byte) -5, (byte) 0, (byte) -10, (byte) 5, (byte) 10));     }      @Test     public void testMinByte_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      @Test     public void testMinByte_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((byte[]) null));     }      @Test     public void testMinDouble() {         assertEquals(5.12, NumberUtils.min(5.12), "min(double[]) failed for array length 1");         assertEquals(6.23, NumberUtils.min(6.23, 9.34), "min(double[]) failed for array length 2");         assertEquals(-10.45, NumberUtils.min(-10.45, -5.56, 0, 5.67, 10.78), "min(double[]) failed for array length 5");         assertEquals(-10, NumberUtils.min(-10, -5, 0, 5, 10), 0.0001);         assertEquals(-10, NumberUtils.min(-5, 0, -10, 5, 10), 0.0001);     }      @Test     public void testMinDouble_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      @Test     public void testMinDouble_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((double[]) null));     }      @Test     public void testMinFloat() {         assertEquals(5.9f, NumberUtils.min(5.9f), "min(float[]) failed for array length 1");         assertEquals(6.8f, NumberUtils.min(6.8f, 9.7f), "min(float[]) failed for array length 2");         assertEquals(-10.6f, NumberUtils.min(-10.6f, -5.5f, 0, 5.4f, 10.3f), "min(float[]) failed for array length 5");         assertEquals(-10, NumberUtils.min(-10, -5, 0, 5, 10), 0.0001f);         assertEquals(-10, NumberUtils.min(-5, 0, -10, 5, 10), 0.0001f);     }      @Test     public void testMinFloat_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      @Test     public void testMinFloat_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((float[]) null));     }      @Test     public void testMinimumByte() {         final byte low = 123;         final byte mid = 123 + 1;         final byte high = 123 + 2;         assertEquals(low, NumberUtils.min(low, mid, high), "minimum(byte, byte, byte) 1 failed");         assertEquals(low, NumberUtils.min(mid, low, high), "minimum(byte, byte, byte) 2 failed");         assertEquals(low, NumberUtils.min(mid, high, low), "minimum(byte, byte, byte) 3 failed");         assertEquals(low, NumberUtils.min(low, mid, low), "minimum(byte, byte, byte) 4 failed");     }      @Test     public void testMinimumDouble() {         final double low = 12.3;         final double mid = 12.3 + 1;         final double high = 12.3 + 2;         assertEquals(low, NumberUtils.min(low, mid, high), 0.0001);         assertEquals(low, NumberUtils.min(mid, low, high), 0.0001);         assertEquals(low, NumberUtils.min(mid, high, low), 0.0001);         assertEquals(low, NumberUtils.min(low, mid, low), 0.0001);         assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001);     }      @Test     public void testMinimumFloat() {         final float low = 12.3f;         final float mid = 12.3f + 1;         final float high = 12.3f + 2;         assertEquals(low, NumberUtils.min(low, mid, high), 0.0001f);         assertEquals(low, NumberUtils.min(mid, low, high), 0.0001f);         assertEquals(low, NumberUtils.min(mid, high, low), 0.0001f);         assertEquals(low, NumberUtils.min(low, mid, low), 0.0001f);         assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001f);     }      @Test     public void testMinimumInt() {         assertEquals(12345, NumberUtils.min(12345, 12345 + 1, 12345 + 2), "minimum(int, int, int) 1 failed");         assertEquals(12345, NumberUtils.min(12345 + 1, 12345, 12345 + 2), "minimum(int, int, int) 2 failed");         assertEquals(12345, NumberUtils.min(12345 + 1, 12345 + 2, 12345), "minimum(int, int, int) 3 failed");         assertEquals(12345, NumberUtils.min(12345 + 1, 12345, 12345), "minimum(int, int, int) 4 failed");         assertEquals(12345, NumberUtils.min(12345, 12345, 12345), "minimum(int, int, int) 5 failed");     }      @Test     public void testMinimumLong() {         assertEquals(12345L, NumberUtils.min(12345L, 12345L + 1L, 12345L + 2L), "minimum(long, long, long) 1 failed");         assertEquals(12345L, NumberUtils.min(12345L + 1L, 12345L, 12345 + 2L), "minimum(long, long, long) 2 failed");         assertEquals(12345L, NumberUtils.min(12345L + 1L, 12345L + 2L, 12345L), "minimum(long, long, long) 3 failed");         assertEquals(12345L, NumberUtils.min(12345L + 1L, 12345L, 12345L), "minimum(long, long, long) 4 failed");         assertEquals(12345L, NumberUtils.min(12345L, 12345L, 12345L), "minimum(long, long, long) 5 failed");     }      @Test     public void testMinimumShort() {         final short low = 1234;         final short mid = 1234 + 1;         final short high = 1234 + 2;         assertEquals(low, NumberUtils.min(low, mid, high), "minimum(short, short, short) 1 failed");         assertEquals(low, NumberUtils.min(mid, low, high), "minimum(short, short, short) 2 failed");         assertEquals(low, NumberUtils.min(mid, high, low), "minimum(short, short, short) 3 failed");         assertEquals(low, NumberUtils.min(low, mid, low), "minimum(short, short, short) 4 failed");     }      @Test     public void testMinInt() {         assertEquals(5, NumberUtils.min(5), "min(int[]) failed for array length 1");         assertEquals(6, NumberUtils.min(6, 9), "min(int[]) failed for array length 2");          assertEquals(-10, NumberUtils.min(-10, -5, 0, 5, 10));         assertEquals(-10, NumberUtils.min(-5, 0, -10, 5, 10));     }      @Test     public void testMinInt_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      @Test     public void testMinInt_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((int[]) null));     }      @Test     public void testMinLong() {         assertEquals(5L, NumberUtils.min(5L), "min(long[]) failed for array length 1");         assertEquals(6L, NumberUtils.min(6L, 9L), "min(long[]) failed for array length 2");          assertEquals(-10L, NumberUtils.min(-10L, -5L, 0L, 5L, 10L));         assertEquals(-10L, NumberUtils.min(-5L, 0L, -10L, 5L, 10L));     }      @Test     public void testMinLong_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      // min/max tests     // ----------------------------------------------------------------------     @Test     public void testMinLong_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((long[]) null));     }      @Test     public void testMinShort() {         assertEquals((short) 5, NumberUtils.min((short) 5), "min(short[]) failed for array length 1");         assertEquals((short) 6, NumberUtils.min((short) 6, (short) 9), "min(short[]) failed for array length 2");          assertEquals((short) -10, NumberUtils.min((short) -10, (short) -5, (short) 0, (short) 5, (short) 10));         assertEquals((short) -10, NumberUtils.min((short) -5, (short) 0, (short) -10, (short) 5, (short) 10));     }      @Test     public void testMinShort_emptyArray() {         assertThrows(IllegalArgumentException.class, NumberUtils::min);     }      @Test     public void testMinShort_nullArray() {         assertThrows(NullPointerException.class, () -> NumberUtils.min((short[]) null));     }      /**      * Test for {(@link NumberUtils#createNumber(String)}      */     @Test     public void testStringCreateNumberEnsureNoPrecisionLoss() {         final String shouldBeFloat = "1.23";         final String shouldBeDouble = "3.40282354e+38";         final String shouldBeBigDecimal = "1.797693134862315759e+308";         assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float);         assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double);         assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal);         // LANG-1060         assertTrue(NumberUtils.createNumber("001.12") instanceof Float);         assertTrue(NumberUtils.createNumber("-001.12") instanceof Float);         assertTrue(NumberUtils.createNumber("+001.12") instanceof Float);         assertTrue(NumberUtils.createNumber("003.40282354e+38") instanceof Double);         assertTrue(NumberUtils.createNumber("-003.40282354e+38") instanceof Double);         assertTrue(NumberUtils.createNumber("+003.40282354e+38") instanceof Double);         assertTrue(NumberUtils.createNumber("0001.797693134862315759e+308") instanceof BigDecimal);         assertTrue(NumberUtils.createNumber("-001.797693134862315759e+308") instanceof BigDecimal);         assertTrue(NumberUtils.createNumber("+001.797693134862315759e+308") instanceof BigDecimal);     }      /**      * Test for {@link NumberUtils#toDouble(String)}.      */     @Test     public void testStringToDoubleString() {         assertEquals(NumberUtils.toDouble("-1.2345"), -1.2345d, "toDouble(String) 1 failed");         assertEquals(1.2345d, NumberUtils.toDouble("1.2345"), "toDouble(String) 2 failed");         assertEquals(0.0d, NumberUtils.toDouble("abc"), "toDouble(String) 3 failed");         // LANG-1060         assertEquals(NumberUtils.toDouble("-001.2345"), -1.2345d, "toDouble(String) 4 failed");         assertEquals(1.2345d, NumberUtils.toDouble("+001.2345"), "toDouble(String) 5 failed");         assertEquals(1.2345d, NumberUtils.toDouble("001.2345"), "toDouble(String) 6 failed");         assertEquals(0d, NumberUtils.toDouble("000.00000"), "toDouble(String) 7 failed");          assertEquals(NumberUtils.toDouble(Double.MAX_VALUE + ""), Double.MAX_VALUE,             "toDouble(Double.MAX_VALUE) failed");         assertEquals(NumberUtils.toDouble(Double.MIN_VALUE + ""), Double.MIN_VALUE,             "toDouble(Double.MIN_VALUE) failed");         assertEquals(0.0d, NumberUtils.toDouble(""), "toDouble(empty) failed");         assertEquals(0.0d, NumberUtils.toDouble((String) null), "toDouble(null) failed");     }      /**      * Test for {@link NumberUtils#toDouble(String, double)}.      */     @Test     public void testStringToDoubleStringD() {         assertEquals(1.2345d, NumberUtils.toDouble("1.2345", 5.1d), "toDouble(String, int) 1 failed");         assertEquals(5.0d, NumberUtils.toDouble("a", 5.0d), "toDouble(String, int) 2 failed");         // LANG-1060         assertEquals(1.2345d, NumberUtils.toDouble("001.2345", 5.1d), "toDouble(String, int) 3 failed");         assertEquals(NumberUtils.toDouble("-001.2345", 5.1d), -1.2345d, "toDouble(String, int) 4 failed");         assertEquals(1.2345d, NumberUtils.toDouble("+001.2345", 5.1d), "toDouble(String, int) 5 failed");         assertEquals(0d, NumberUtils.toDouble("000.00", 5.1d), "toDouble(String, int) 7 failed");     }      /**      * Test for {@link NumberUtils#toByte(String)}.      */     @Test     public void testToByteString() {         assertEquals(123, NumberUtils.toByte("123"), "toByte(String) 1 failed");         assertEquals(0, NumberUtils.toByte("abc"), "toByte(String) 2 failed");         assertEquals(0, NumberUtils.toByte(""), "toByte(empty) failed");         assertEquals(0, NumberUtils.toByte(null), "toByte(null) failed");     }      /**      * Test for {@link NumberUtils#toByte(String, byte)}.      */     @Test     public void testToByteStringI() {         assertEquals(123, NumberUtils.toByte("123", (byte) 5), "toByte(String, byte) 1 failed");         assertEquals(5, NumberUtils.toByte("12.3", (byte) 5), "toByte(String, byte) 2 failed");     }      /**      * Test for {@link NumberUtils#toFloat(String)}.      */     @Test     public void testToFloatString() {         assertEquals(NumberUtils.toFloat("-1.2345"), -1.2345f, "toFloat(String) 1 failed");         assertEquals(1.2345f, NumberUtils.toFloat("1.2345"), "toFloat(String) 2 failed");         assertEquals(0.0f, NumberUtils.toFloat("abc"), "toFloat(String) 3 failed");         // LANG-1060         assertEquals(NumberUtils.toFloat("-001.2345"), -1.2345f, "toFloat(String) 4 failed");         assertEquals(1.2345f, NumberUtils.toFloat("+001.2345"), "toFloat(String) 5 failed");         assertEquals(1.2345f, NumberUtils.toFloat("001.2345"), "toFloat(String) 6 failed");         assertEquals(0f, NumberUtils.toFloat("000.00"), "toFloat(String) 7 failed");          assertEquals(NumberUtils.toFloat(Float.MAX_VALUE + ""), Float.MAX_VALUE, "toFloat(Float.MAX_VALUE) failed");         assertEquals(NumberUtils.toFloat(Float.MIN_VALUE + ""), Float.MIN_VALUE, "toFloat(Float.MIN_VALUE) failed");         assertEquals(0.0f, NumberUtils.toFloat(""), "toFloat(empty) failed");         assertEquals(0.0f, NumberUtils.toFloat(null), "toFloat(null) failed");     }      /**      * Test for {@link NumberUtils#toFloat(String, float)}.      */     @Test     public void testToFloatStringF() {         assertEquals(1.2345f, NumberUtils.toFloat("1.2345", 5.1f), "toFloat(String, int) 1 failed");         assertEquals(5.0f, NumberUtils.toFloat("a", 5.0f), "toFloat(String, int) 2 failed");         // LANG-1060         assertEquals(5.0f, NumberUtils.toFloat("-001Z.2345", 5.0f), "toFloat(String, int) 3 failed");         assertEquals(5.0f, NumberUtils.toFloat("+001AB.2345", 5.0f), "toFloat(String, int) 4 failed");         assertEquals(5.0f, NumberUtils.toFloat("001Z.2345", 5.0f), "toFloat(String, int) 5 failed");     }      /**      * Test for {@link NumberUtils#toInt(String)}.      */     @Test     public void testToIntString() {         assertEquals(12345, NumberUtils.toInt("12345"), "toInt(String) 1 failed");         assertEquals(0, NumberUtils.toInt("abc"), "toInt(String) 2 failed");         assertEquals(0, NumberUtils.toInt(""), "toInt(empty) failed");         assertEquals(0, NumberUtils.toInt(null), "toInt(null) failed");     }      /**      * Test for {@link NumberUtils#toInt(String, int)}.      */     @Test     public void testToIntStringI() {         assertEquals(12345, NumberUtils.toInt("12345", 5), "toInt(String, int) 1 failed");         assertEquals(5, NumberUtils.toInt("1234.5", 5), "toInt(String, int) 2 failed");     }      /**      * Test for {@link NumberUtils#toLong(String)}.      */     @Test     public void testToLongString() {         assertEquals(12345L, NumberUtils.toLong("12345"), "toLong(String) 1 failed");         assertEquals(0L, NumberUtils.toLong("abc"), "toLong(String) 2 failed");         assertEquals(0L, NumberUtils.toLong("1L"), "toLong(String) 3 failed");         assertEquals(0L, NumberUtils.toLong("1l"), "toLong(String) 4 failed");         assertEquals(NumberUtils.toLong(Long.MAX_VALUE + ""), Long.MAX_VALUE, "toLong(Long.MAX_VALUE) failed");         assertEquals(NumberUtils.toLong(Long.MIN_VALUE + ""), Long.MIN_VALUE, "toLong(Long.MIN_VALUE) failed");         assertEquals(0L, NumberUtils.toLong(""), "toLong(empty) failed");         assertEquals(0L, NumberUtils.toLong(null), "toLong(null) failed");     }      /**      * Test for {@link NumberUtils#toLong(String, long)}.      */     @Test     public void testToLongStringL() {         assertEquals(12345L, NumberUtils.toLong("12345", 5L), "toLong(String, long) 1 failed");         assertEquals(5L, NumberUtils.toLong("1234.5", 5L), "toLong(String, long) 2 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(BigDecimal)}.      */     @Test     public void testToScaledBigDecimalBigDecimal() {         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(123.456)), BigDecimal.valueOf(123.46),             "toScaledBigDecimal(BigDecimal) 1 failed");         // Test RoudingMode.HALF_EVEN default rounding.         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.515)), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(BigDecimal) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525)), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(BigDecimal) 3 failed");         assertEquals("2352.00",             NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525)).multiply(BigDecimal.valueOf(100)).toString(),             "toScaledBigDecimal(BigDecimal) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((BigDecimal) null), BigDecimal.ZERO,             "toScaledBigDecimal(BigDecimal) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(BigDecimal, int, RoundingMode)}.      */     @Test     public void testToScaledBigDecimalBigDecimalIRM() {         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(123.456), 1, RoundingMode.CEILING),             BigDecimal.valueOf(123.5), "toScaledBigDecimal(BigDecimal, int, RoudingMode) 1 failed");         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.5159), 3, RoundingMode.FLOOR),             BigDecimal.valueOf(23.515), "toScaledBigDecimal(BigDecimal, int, RoudingMode) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.525), 2, RoundingMode.HALF_UP),             BigDecimal.valueOf(23.53), "toScaledBigDecimal(BigDecimal, int, RoudingMode) 3 failed");         assertEquals("23521.0000",             NumberUtils.toScaledBigDecimal(BigDecimal.valueOf(23.521), 4, RoundingMode.HALF_EVEN)                 .multiply(BigDecimal.valueOf(1000)).toString(),             "toScaledBigDecimal(BigDecimal, int, RoudingMode) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((BigDecimal) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO,             "toScaledBigDecimal(BigDecimal, int, RoudingMode) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Double)}.      */     @Test     public void testToScaledBigDecimalDouble() {         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(123.456d)), BigDecimal.valueOf(123.46),             "toScaledBigDecimal(Double) 1 failed");         // Test RoudingMode.HALF_EVEN default rounding.         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.515d)), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(Double) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d)), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(Double) 3 failed");         assertEquals("2352.00",             NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d)).multiply(BigDecimal.valueOf(100)).toString(),             "toScaledBigDecimal(Double) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((Double) null), BigDecimal.ZERO,             "toScaledBigDecimal(Double) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Double, int, RoundingMode)}.      */     @Test     public void testToScaledBigDecimalDoubleIRM() {         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(123.456d), 1, RoundingMode.CEILING),             BigDecimal.valueOf(123.5), "toScaledBigDecimal(Double, int, RoudingMode) 1 failed");         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.5159d), 3, RoundingMode.FLOOR),             BigDecimal.valueOf(23.515), "toScaledBigDecimal(Double, int, RoudingMode) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal(Double.valueOf(23.525d), 2, RoundingMode.HALF_UP),             BigDecimal.valueOf(23.53), "toScaledBigDecimal(Double, int, RoudingMode) 3 failed");         assertEquals("23521.0000",             NumberUtils.toScaledBigDecimal(Double.valueOf(23.521d), 4, RoundingMode.HALF_EVEN)                 .multiply(BigDecimal.valueOf(1000)).toString(),             "toScaledBigDecimal(Double, int, RoudingMode) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((Double) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO,             "toScaledBigDecimal(Double, int, RoudingMode) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Float)}.      */     @Test     public void testToScaledBigDecimalFloat() {         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(123.456f)), BigDecimal.valueOf(123.46),             "toScaledBigDecimal(Float) 1 failed");         // Test RoudingMode.HALF_EVEN default rounding.         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.515f)), BigDecimal.valueOf(23.51),             "toScaledBigDecimal(Float) 2 failed");         // Note. NumberUtils.toScaledBigDecimal(Float.valueOf(23.515f)).equals(BigDecimal.valueOf(23.51))         // because of roundoff error. It is ok.         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f)), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(Float) 3 failed");         assertEquals("2352.00",             NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f)).multiply(BigDecimal.valueOf(100)).toString(),             "toScaledBigDecimal(Float) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((Float) null), BigDecimal.ZERO,             "toScaledBigDecimal(Float) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Float, int, RoundingMode)}.      */     @Test     public void testToScaledBigDecimalFloatIRM() {         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(123.456f), 1, RoundingMode.CEILING),             BigDecimal.valueOf(123.5), "toScaledBigDecimal(Float, int, RoudingMode) 1 failed");         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.5159f), 3, RoundingMode.FLOOR),             BigDecimal.valueOf(23.515), "toScaledBigDecimal(Float, int, RoudingMode) 2 failed");         // The following happens due to roundoff error. We're ok with this.         assertEquals(NumberUtils.toScaledBigDecimal(Float.valueOf(23.525f), 2, RoundingMode.HALF_UP),             BigDecimal.valueOf(23.52), "toScaledBigDecimal(Float, int, RoudingMode) 3 failed");         assertEquals("23521.0000", NumberUtils.toScaledBigDecimal(Float.valueOf(23.521f), 4, RoundingMode.HALF_EVEN)             .multiply(BigDecimal.valueOf(1000)).toString(), "toScaledBigDecimal(Float, int, RoudingMode) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((Float) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO,             "toScaledBigDecimal(Float, int, RoudingMode) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Double)}.      */     @Test     public void testToScaledBigDecimalString() {         assertEquals(NumberUtils.toScaledBigDecimal("123.456"), BigDecimal.valueOf(123.46),             "toScaledBigDecimal(String) 1 failed");         // Test RoudingMode.HALF_EVEN default rounding.         assertEquals(NumberUtils.toScaledBigDecimal("23.515"), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(String) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal("23.525"), BigDecimal.valueOf(23.52),             "toScaledBigDecimal(String) 3 failed");         assertEquals("2352.00", NumberUtils.toScaledBigDecimal("23.525").multiply(BigDecimal.valueOf(100)).toString(),             "toScaledBigDecimal(String) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((String) null), BigDecimal.ZERO,             "toScaledBigDecimal(String) 5 failed");     }      /**      * Test for {@link NumberUtils#toScaledBigDecimal(Double, int, RoundingMode)}.      */     @Test     public void testToScaledBigDecimalStringIRM() {         assertEquals(NumberUtils.toScaledBigDecimal("123.456", 1, RoundingMode.CEILING), BigDecimal.valueOf(123.5),             "toScaledBigDecimal(String, int, RoudingMode) 1 failed");         assertEquals(NumberUtils.toScaledBigDecimal("23.5159", 3, RoundingMode.FLOOR), BigDecimal.valueOf(23.515),             "toScaledBigDecimal(String, int, RoudingMode) 2 failed");         assertEquals(NumberUtils.toScaledBigDecimal("23.525", 2, RoundingMode.HALF_UP), BigDecimal.valueOf(23.53),             "toScaledBigDecimal(String, int, RoudingMode) 3 failed");         assertEquals(             "23521.0000", NumberUtils.toScaledBigDecimal("23.521", 4, RoundingMode.HALF_EVEN)                 .multiply(BigDecimal.valueOf(1000)).toString(),             "toScaledBigDecimal(String, int, RoudingMode) 4 failed");         assertEquals(NumberUtils.toScaledBigDecimal((String) null, 2, RoundingMode.HALF_UP), BigDecimal.ZERO,             "toScaledBigDecimal(String, int, RoudingMode) 5 failed");     }      /**      * Test for {@link NumberUtils#toShort(String)}.      */     @Test     public void testToShortString() {         assertEquals(12345, NumberUtils.toShort("12345"), "toShort(String) 1 failed");         assertEquals(0, NumberUtils.toShort("abc"), "toShort(String) 2 failed");         assertEquals(0, NumberUtils.toShort(""), "toShort(empty) failed");         assertEquals(0, NumberUtils.toShort(null), "toShort(null) failed");     }      /**      * Test for {@link NumberUtils#toShort(String, short)}.      */     @Test     public void testToShortStringI() {         assertEquals(12345, NumberUtils.toShort("12345", (short) 5), "toShort(String, short) 1 failed");         assertEquals(5, NumberUtils.toShort("1234.5", (short) 5), "toShort(String, short) 2 failed");     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.hasItemInArray; import static org.hamcrest.Matchers.hasItems; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNotSame; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertSame; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.lang.reflect.Method; import java.lang.reflect.Type; import java.util.Arrays; import java.util.Date; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map;  import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.ClassUtils; import org.apache.commons.lang3.ClassUtils.Interfaces; import org.apache.commons.lang3.math.NumberUtils; import org.apache.commons.lang3.mutable.Mutable; import org.apache.commons.lang3.mutable.MutableObject; import org.apache.commons.lang3.reflect.testbed.Annotated; import org.apache.commons.lang3.reflect.testbed.GenericConsumer; import org.apache.commons.lang3.reflect.testbed.GenericParent; import org.apache.commons.lang3.reflect.testbed.PublicChild; import org.apache.commons.lang3.reflect.testbed.StringParameterizedChild; import org.apache.commons.lang3.tuple.ImmutablePair; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests MethodUtils  */ public class MethodUtilsTest {      private interface PrivateInterface {     }      static class TestBeanWithInterfaces implements PrivateInterface {         public String foo() {             return "foo()";         }     }      public static class TestBean {          public static String bar() {             return "bar()";         }          public static String bar(final int i) {             return "bar(int)";         }          public static String bar(final Integer i) {             return "bar(Integer)";         }          public static String bar(final double d) {             return "bar(double)";         }          public static String bar(final String s) {             return "bar(String)";         }          public static String bar(final Object o) {             return "bar(Object)";         }          public static String bar(final String... s) {             return "bar(String...)";         }          public static String bar(final long... s) {             return "bar(long...)";         }          public static String bar(final Integer i, final String... s) {             return "bar(int, String...)";         }          public static void oneParameterStatic(final String s) {             // empty         }          @SuppressWarnings("unused")         private void privateStuff() {         }          @SuppressWarnings("unused")         private String privateStringStuff() {             return "privateStringStuff()";         }          @SuppressWarnings("unused")         private String privateStringStuff(final int i) {             return "privateStringStuff(int)";         }          @SuppressWarnings("unused")         private String privateStringStuff(final Integer i) {             return "privateStringStuff(Integer)";         }          @SuppressWarnings("unused")         private String privateStringStuff(final double d) {             return "privateStringStuff(double)";         }          @SuppressWarnings("unused")         private String privateStringStuff(final String s) {             return "privateStringStuff(String)";         }          @SuppressWarnings("unused")         private String privateStringStuff(final Object s) {             return "privateStringStuff(Object)";         }          public String foo() {             return "foo()";         }          public String foo(final int i) {             return "foo(int)";         }          public String foo(final Integer i) {             return "foo(Integer)";         }          public String foo(final double d) {             return "foo(double)";         }          public String foo(final long l) {             return "foo(long)";         }          public String foo(final String s) {             return "foo(String)";         }          public String foo(final Object o) {             return "foo(Object)";         }          public String foo(final String... s) {             return "foo(String...)";         }          public String foo(final long... l) {             return "foo(long...)";         }          public String foo(final Integer i, final String... s) {             return "foo(int, String...)";         }          public void oneParameter(final String s) {             // empty         }          public String foo(final Object... s) {             return "foo(Object...)";         }          public int[] unboxing(final int... values) {             return values;         }          // This method is overloaded for the wrapper class for every primitive type, plus the common supertypes         // Number and Object. This is an acid test since it easily leads to ambiguous methods.         public static String varOverload(final Byte... args) {             return "Byte...";         }          public static String varOverload(final Character... args) {             return "Character...";         }          public static String varOverload(final Short... args) {             return "Short...";         }          public static String varOverload(final Boolean... args) {             return "Boolean...";         }          public static String varOverload(final Float... args) {             return "Float...";         }          public static String varOverload(final Double... args) {             return "Double...";         }          public static String varOverload(final Integer... args) {             return "Integer...";         }          public static String varOverload(final Long... args) {             return "Long...";         }          public static String varOverload(final Number... args) {             return "Number...";         }          public static String varOverload(final Object... args) {             return "Object...";         }          public static String varOverload(final String... args) {             return "String...";         }          // This method is overloaded for the wrapper class for every numeric primitive type, plus the common         // supertype Number         public static String numOverload(final Byte... args) {             return "Byte...";         }          public static String numOverload(final Short... args) {             return "Short...";         }          public static String numOverload(final Float... args) {             return "Float...";         }          public static String numOverload(final Double... args) {             return "Double...";         }          public static String numOverload(final Integer... args) {             return "Integer...";         }          public static String numOverload(final Long... args) {             return "Long...";         }          public static String numOverload(final Number... args) {             return "Number...";         }          // These varOverloadEcho and varOverloadEchoStatic methods are designed to verify that         // not only is the correct overloaded variant invoked, but that the varags arguments         // are also delivered correctly to the method.         public ImmutablePair<String, Object[]> varOverloadEcho(final String... args) {             return new ImmutablePair<>("String...", args);         }          public ImmutablePair<String, Object[]> varOverloadEcho(final Number... args) {             return new ImmutablePair<>("Number...", args);         }          public static ImmutablePair<String, Object[]> varOverloadEchoStatic(final String... args) {             return new ImmutablePair<>("String...", args);         }          public static ImmutablePair<String, Object[]> varOverloadEchoStatic(final Number... args) {             return new ImmutablePair<>("Number...", args);         }          static void verify(final ImmutablePair<String, Object[]> a, final ImmutablePair<String, Object[]> b) {             assertEquals(a.getLeft(), b.getLeft());             assertArrayEquals(a.getRight(), b.getRight());         }          static void verify(final ImmutablePair<String, Object[]> a, final Object _b) {             @SuppressWarnings("unchecked") final ImmutablePair<String, Object[]> b = (ImmutablePair<String, Object[]>) _b;             verify(a, b);         }      }      private static class TestMutable implements Mutable<Object> {         @Override         public Object getValue() {             return null;         }          @Override         public void setValue(final Object value) {         }     }      private TestBean testBean;     private final Map<Class<?>, Class<?>[]> classCache = new HashMap<>();      @BeforeEach     public void setUp() {         testBean = new TestBean();         classCache.clear();     }      @Test     public void testConstructor() throws Exception {         assertNotNull(MethodUtils.class.newInstance());     }      @Test     public void verifyJavaVarargsOverloadingResolution() {         // This code is not a test of MethodUtils.         // Rather it makes explicit the behavior of the Java specification for         // various cases of overload resolution.         assertEquals("Byte...", TestBean.varOverload((byte) 1, (byte) 2));         assertEquals("Short...", TestBean.varOverload((short) 1, (short) 2));         assertEquals("Integer...", TestBean.varOverload(1, 2));         assertEquals("Long...", TestBean.varOverload(1L, 2L));         assertEquals("Float...", TestBean.varOverload(1f, 2f));         assertEquals("Double...", TestBean.varOverload(1d, 2d));         assertEquals("Character...", TestBean.varOverload('a', 'b'));         assertEquals("String...", TestBean.varOverload("a", "b"));         assertEquals("Boolean...", TestBean.varOverload(true, false));          assertEquals("Object...", TestBean.varOverload(1, "s"));         assertEquals("Object...", TestBean.varOverload(1, true));         assertEquals("Object...", TestBean.varOverload(1.1, true));         assertEquals("Object...", TestBean.varOverload('c', true));         assertEquals("Number...", TestBean.varOverload(1, 1.1));         assertEquals("Number...", TestBean.varOverload(1, 1L));         assertEquals("Number...", TestBean.varOverload(1d, 1f));         assertEquals("Number...", TestBean.varOverload((short) 1, (byte) 1));         assertEquals("Object...", TestBean.varOverload(1, 'c'));         assertEquals("Object...", TestBean.varOverload('c', "s"));     }      @Test     public void testInvokeJavaVarargsOverloadingResolution() throws Exception {         assertEquals("Byte...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", (byte) 1, (byte) 2));         assertEquals("Short...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", (short) 1, (short) 2));         assertEquals("Integer...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, 2));         assertEquals("Long...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1L, 2L));         assertEquals("Float...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1f, 2f));         assertEquals("Double...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1d, 2d));         assertEquals("Character...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 'a', 'b'));         assertEquals("String...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", "a", "b"));         assertEquals("Boolean...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", true, false));          assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, "s"));         assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, true));         assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1.1, true));         assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 'c', true));         assertEquals("Number...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, 1.1));         assertEquals("Number...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, 1L));         assertEquals("Number...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1d, 1f));         assertEquals("Number...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", (short) 1, (byte) 1));         assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 1, 'c'));         assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class,                 "varOverload", 'c', "s"));          assertEquals("Object...", MethodUtils.invokeStaticMethod(TestBean.class, "varOverload",                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));         assertEquals("Number...", MethodUtils.invokeStaticMethod(TestBean.class, "numOverload",                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));     }      @Test     public void testInvokeMethod() throws Exception {         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo"));         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",                 (Object[]) null));         assertEquals("foo()", MethodUtils.invokeMethod(testBean, "foo",                 null, null));         assertEquals("foo(String)", MethodUtils.invokeMethod(testBean, "foo",                 ""));         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo",                 new Object()));         assertEquals("foo(Object)", MethodUtils.invokeMethod(testBean, "foo",                 Boolean.TRUE));         assertEquals("foo(Integer)", MethodUtils.invokeMethod(testBean, "foo",                 NumberUtils.INTEGER_ONE));         assertEquals("foo(int)", MethodUtils.invokeMethod(testBean, "foo",                 NumberUtils.BYTE_ONE));         assertEquals("foo(long)", MethodUtils.invokeMethod(testBean, "foo",                 NumberUtils.LONG_ONE));         assertEquals("foo(double)", MethodUtils.invokeMethod(testBean, "foo",                 NumberUtils.DOUBLE_ONE));         assertEquals("foo(String...)", MethodUtils.invokeMethod(testBean, "foo",                 "a", "b", "c"));         assertEquals("foo(String...)", MethodUtils.invokeMethod(testBean, "foo",                 "a", "b", "c"));         assertEquals("foo(int, String...)", MethodUtils.invokeMethod(testBean, "foo",                 5, "a", "b", "c"));         assertEquals("foo(long...)", MethodUtils.invokeMethod(testBean, "foo",                 1L, 2L));          assertThrows(NoSuchMethodException.class, () -> MethodUtils.invokeMethod(testBean, "foo", 1, 2));          TestBean.verify(new ImmutablePair<>("String...", new String[]{"x", "y"}),                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", "x", "y"));         TestBean.verify(new ImmutablePair<>("Number...", new Number[]{17, 23, 42}),                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", 17, 23, 42));         TestBean.verify(new ImmutablePair<>("String...", new String[]{"x", "y"}),                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", "x", "y"));         TestBean.verify(new ImmutablePair<>("Number...", new Number[]{17, 23, 42}),                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", 17, 23, 42));     }      @Test     public void testInvokeMethod_VarArgsWithNullValues() throws Exception {         assertEquals("String...", MethodUtils.invokeMethod(testBean, "varOverload",                 "a", null, "c"));         assertEquals("String...", MethodUtils.invokeMethod(testBean, "varOverload",                                                                 "a", "b", null));     }      @Test     public void testInvokeMethod_VarArgsNotUniqueResolvable() throws Exception {       assertEquals("Boolean...", MethodUtils.invokeMethod(testBean, "varOverload",                                                          new Object[] {null}));       assertEquals("Object...", MethodUtils.invokeMethod(testBean, "varOverload",                                                          (Object[]) null));     }      @Test     public void testInvokeExactMethod() throws Exception {         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo",                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo"));         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo",                 (Object[]) null));         assertEquals("foo()", MethodUtils.invokeExactMethod(testBean, "foo",                 null, null));         assertEquals("foo(String)", MethodUtils.invokeExactMethod(testBean,                 "foo", ""));         assertEquals("foo(Object)", MethodUtils.invokeExactMethod(testBean,                 "foo", new Object()));         assertEquals("foo(Integer)", MethodUtils.invokeExactMethod(testBean,                 "foo", NumberUtils.INTEGER_ONE));         assertEquals("foo(double)", MethodUtils.invokeExactMethod(testBean,                 "foo", new Object[]{NumberUtils.DOUBLE_ONE},                 new Class[]{Double.TYPE}));          assertThrows(                 NoSuchMethodException.class,                 () -> MethodUtils.invokeExactMethod(testBean, "foo", NumberUtils.BYTE_ONE));          assertThrows(                 NoSuchMethodException.class,                 () -> MethodUtils.invokeExactMethod(testBean, "foo", NumberUtils.LONG_ONE));         assertThrows(NoSuchMethodException.class, () -> MethodUtils.invokeExactMethod(testBean, "foo", Boolean.TRUE));     }      @Test     public void testInvokeStaticMethod() throws Exception {         assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class,                 "bar", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));         assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class,                 "bar", (Object[]) null));         assertEquals("bar()", MethodUtils.invokeStaticMethod(TestBean.class,                 "bar", null, null));         assertEquals("bar(String)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", ""));         assertEquals("bar(Object)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", new Object()));         assertEquals("bar(Object)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", Boolean.TRUE));         assertEquals("bar(Integer)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", NumberUtils.INTEGER_ONE));         assertEquals("bar(int)", MethodUtils.invokeStaticMethod(TestBean.class,                 "bar", NumberUtils.BYTE_ONE));         assertEquals("bar(double)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", NumberUtils.DOUBLE_ONE));         assertEquals("bar(String...)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", "a", "b"));         assertEquals("bar(long...)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", 1L, 2L));         assertEquals("bar(int, String...)", MethodUtils.invokeStaticMethod(                 TestBean.class, "bar", NumberUtils.INTEGER_ONE, "a", "b"));          TestBean.verify(new ImmutablePair<>("String...", new String[]{"x", "y"}),                 MethodUtils.invokeStaticMethod(TestBean.class, "varOverloadEchoStatic", "x", "y"));         TestBean.verify(new ImmutablePair<>("Number...", new Number[]{17, 23, 42}),                 MethodUtils.invokeStaticMethod(TestBean.class, "varOverloadEchoStatic", 17, 23, 42));         TestBean.verify(new ImmutablePair<>("String...", new String[]{"x", "y"}),                 MethodUtils.invokeStaticMethod(TestBean.class, "varOverloadEchoStatic", "x", "y"));         TestBean.verify(new ImmutablePair<>("Number...", new Number[]{17, 23, 42}),                 MethodUtils.invokeStaticMethod(TestBean.class, "varOverloadEchoStatic", 17, 23, 42));          assertThrows(                 NoSuchMethodException.class, () -> MethodUtils.invokeStaticMethod(TestBean.class, "does_not_exist"));     }      @Test     public void testInvokeExactStaticMethod() throws Exception {         assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class,                 "bar", (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY));         assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class,                 "bar", (Object[]) null));         assertEquals("bar()", MethodUtils.invokeExactStaticMethod(TestBean.class,                 "bar", null, null));         assertEquals("bar(String)", MethodUtils.invokeExactStaticMethod(                 TestBean.class, "bar", ""));         assertEquals("bar(Object)", MethodUtils.invokeExactStaticMethod(                 TestBean.class, "bar", new Object()));         assertEquals("bar(Integer)", MethodUtils.invokeExactStaticMethod(                 TestBean.class, "bar", NumberUtils.INTEGER_ONE));         assertEquals("bar(double)", MethodUtils.invokeExactStaticMethod(                 TestBean.class, "bar", new Object[]{NumberUtils.DOUBLE_ONE},                 new Class[]{Double.TYPE}));          assertThrows(                 NoSuchMethodException.class,                 () -> MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", NumberUtils.BYTE_ONE));         assertThrows(                 NoSuchMethodException.class,                 () -> MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", NumberUtils.LONG_ONE));         assertThrows(                 NoSuchMethodException.class,                 () -> MethodUtils.invokeExactStaticMethod(TestBean.class, "bar", Boolean.TRUE));     }      @Test     public void testGetAccessibleInterfaceMethod() throws Exception {         final Class<?>[][] p = {ArrayUtils.EMPTY_CLASS_ARRAY, null};         for (final Class<?>[] element : p) {             final Method method = TestMutable.class.getMethod("getValue", element);             final Method accessibleMethod = MethodUtils.getAccessibleMethod(method);             assertNotSame(accessibleMethod, method);             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());         }     }      @Test     public void testGetAccessibleMethodPrivateInterface() throws Exception {         final Method expected = TestBeanWithInterfaces.class.getMethod("foo");         assertNotNull(expected);         final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, "foo");         assertNull(actual);     }      @Test     public void testGetAccessibleInterfaceMethodFromDescription() {         final Class<?>[][] p = {ArrayUtils.EMPTY_CLASS_ARRAY, null};         for (final Class<?>[] element : p) {             final Method accessibleMethod = MethodUtils.getAccessibleMethod(                     TestMutable.class, "getValue", element);             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());         }     }      @Test     public void testGetAccessiblePublicMethod() throws Exception {         assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(                 MutableObject.class.getMethod("getValue",                         ArrayUtils.EMPTY_CLASS_ARRAY)).getDeclaringClass());     }      @Test     public void testGetAccessiblePublicMethodFromDescription() {         assertSame(MutableObject.class, MethodUtils.getAccessibleMethod(                 MutableObject.class, "getValue", ArrayUtils.EMPTY_CLASS_ARRAY)                 .getDeclaringClass());     }      @Test     public void testGetAccessibleMethodInaccessible() throws Exception {         final Method expected = TestBean.class.getDeclaredMethod("privateStuff");         final Method actual = MethodUtils.getAccessibleMethod(expected);         assertNull(actual);     }      @Test     public void testGetMatchingAccessibleMethod() {         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 null, ArrayUtils.EMPTY_CLASS_ARRAY);         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(String.class), singletonArray(String.class));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Object.class), singletonArray(Object.class));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Boolean.class), singletonArray(Object.class));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Byte.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Short.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Short.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Character.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Character.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Integer.class), singletonArray(Integer.class));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Long.class), singletonArray(Long.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Long.TYPE), singletonArray(Long.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Float.class), singletonArray(Double.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Float.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Double.class), singletonArray(Double.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Double.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 singletonArray(Double.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 new Class[]{String.class, String.class}, new Class[]{String[].class});         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "foo",                 new Class[]{Integer.TYPE, String.class, String.class}, new Class[]{Integer.class, String[].class});         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne",                 singletonArray(ParentObject.class), singletonArray(ParentObject.class));         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testOne",                 singletonArray(ChildObject.class), singletonArray(ParentObject.class));         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo",                 singletonArray(ParentObject.class), singletonArray(GrandParentObject.class));         expectMatchingAccessibleMethodParameterTypes(InheritanceBean.class, "testTwo",                 singletonArray(ChildObject.class), singletonArray(ChildInterface.class));     }      @Test     public void testNullArgument() {         expectMatchingAccessibleMethodParameterTypes(TestBean.class, "oneParameter",                 singletonArray(null), singletonArray(String.class));     }      @Test     public void testGetOverrideHierarchyIncludingInterfaces() {         final Method method = MethodUtils.getAccessibleMethod(StringParameterizedChild.class, "consume", String.class);         final Iterator<MethodDescriptor> expected =                 Arrays.asList(new MethodDescriptor(StringParameterizedChild.class, "consume", String.class),                         new MethodDescriptor(GenericParent.class, "consume", GenericParent.class.getTypeParameters()[0]),                         new MethodDescriptor(GenericConsumer.class, "consume", GenericConsumer.class.getTypeParameters()[0]))                         .iterator();         for (final Method m : MethodUtils.getOverrideHierarchy(method, Interfaces.INCLUDE)) {             assertTrue(expected.hasNext());             final MethodDescriptor md = expected.next();             assertEquals(md.declaringClass, m.getDeclaringClass());             assertEquals(md.name, m.getName());             assertEquals(md.parameterTypes.length, m.getParameterTypes().length);             for (int i = 0; i < md.parameterTypes.length; i++) {                 assertTrue(TypeUtils.equals(md.parameterTypes[i], m.getGenericParameterTypes()[i]));             }         }         assertFalse(expected.hasNext());     }      @Test     public void testGetOverrideHierarchyExcludingInterfaces() {         final Method method = MethodUtils.getAccessibleMethod(StringParameterizedChild.class, "consume", String.class);         final Iterator<MethodDescriptor> expected =                 Arrays.asList(new MethodDescriptor(StringParameterizedChild.class, "consume", String.class),                         new MethodDescriptor(GenericParent.class, "consume", GenericParent.class.getTypeParameters()[0]))                         .iterator();         for (final Method m : MethodUtils.getOverrideHierarchy(method, Interfaces.EXCLUDE)) {             assertTrue(expected.hasNext());             final MethodDescriptor md = expected.next();             assertEquals(md.declaringClass, m.getDeclaringClass());             assertEquals(md.name, m.getName());             assertEquals(md.parameterTypes.length, m.getParameterTypes().length);             for (int i = 0; i < md.parameterTypes.length; i++) {                 assertTrue(TypeUtils.equals(md.parameterTypes[i], m.getGenericParameterTypes()[i]));             }         }         assertFalse(expected.hasNext());     }      @Test     @Annotated     public void testGetMethodsWithAnnotation() throws NoSuchMethodException {         assertArrayEquals(new Method[0], MethodUtils.getMethodsWithAnnotation(Object.class, Annotated.class));          final Method[] methodsWithAnnotation = MethodUtils.getMethodsWithAnnotation(MethodUtilsTest.class, Annotated.class);         assertEquals(2, methodsWithAnnotation.length);         assertThat(methodsWithAnnotation, hasItemInArray(MethodUtilsTest.class.getMethod("testGetMethodsWithAnnotation")));         assertThat(methodsWithAnnotation, hasItemInArray(MethodUtilsTest.class.getMethod("testGetMethodsListWithAnnotation")));     }      @Test     public void testGetMethodsWithAnnotationSearchSupersAndIgnoreAccess() {         assertArrayEquals(new Method[0], MethodUtils.getMethodsWithAnnotation(Object.class, Annotated.class,                 true, true));          final Method[] methodsWithAnnotation = MethodUtils.getMethodsWithAnnotation(PublicChild.class, Annotated.class,                 true, true);         assertEquals(4, methodsWithAnnotation.length);         assertEquals("PublicChild", methodsWithAnnotation[0].getDeclaringClass().getSimpleName());         assertEquals("PublicChild", methodsWithAnnotation[1].getDeclaringClass().getSimpleName());         assertTrue(methodsWithAnnotation[0].getName().endsWith("AnnotatedMethod"));         assertTrue(methodsWithAnnotation[1].getName().endsWith("AnnotatedMethod"));         assertEquals("Foo.doIt",                 methodsWithAnnotation[2].getDeclaringClass().getSimpleName() + '.' +                         methodsWithAnnotation[2].getName());         assertEquals("Parent.parentProtectedAnnotatedMethod",                 methodsWithAnnotation[3].getDeclaringClass().getSimpleName() + '.' +                         methodsWithAnnotation[3].getName());     }      @Test     public void testGetMethodsWithAnnotationNotSearchSupersButIgnoreAccess() {         assertArrayEquals(new Method[0], MethodUtils.getMethodsWithAnnotation(Object.class, Annotated.class,                 false, true));          final Method[] methodsWithAnnotation = MethodUtils.getMethodsWithAnnotation(PublicChild.class, Annotated.class,                 false, true);         assertEquals(2, methodsWithAnnotation.length);         assertEquals("PublicChild", methodsWithAnnotation[0].getDeclaringClass().getSimpleName());         assertEquals("PublicChild", methodsWithAnnotation[1].getDeclaringClass().getSimpleName());         assertTrue(methodsWithAnnotation[0].getName().endsWith("AnnotatedMethod"));         assertTrue(methodsWithAnnotation[1].getName().endsWith("AnnotatedMethod"));     }      @Test     public void testGetMethodsWithAnnotationSearchSupersButNotIgnoreAccess() {         assertArrayEquals(new Method[0], MethodUtils.getMethodsWithAnnotation(Object.class, Annotated.class,                 true, false));          final Method[] methodsWithAnnotation = MethodUtils.getMethodsWithAnnotation(PublicChild.class, Annotated.class,                 true, false);         assertEquals(2, methodsWithAnnotation.length);         assertEquals("PublicChild.publicAnnotatedMethod",                 methodsWithAnnotation[0].getDeclaringClass().getSimpleName() + '.' +                         methodsWithAnnotation[0].getName());         assertEquals("Foo.doIt",                 methodsWithAnnotation[1].getDeclaringClass().getSimpleName() + '.' +                         methodsWithAnnotation[1].getName());     }      @Test     public void testGetMethodsWithAnnotationNotSearchSupersAndNotIgnoreAccess() {         assertArrayEquals(new Method[0], MethodUtils.getMethodsWithAnnotation(Object.class, Annotated.class,                 false, false));          final Method[] methodsWithAnnotation = MethodUtils.getMethodsWithAnnotation(PublicChild.class, Annotated.class,                 false, false);         assertEquals(1, methodsWithAnnotation.length);         assertEquals("PublicChild.publicAnnotatedMethod",                 methodsWithAnnotation[0].getDeclaringClass().getSimpleName() + '.' +                         methodsWithAnnotation[0].getName());     }      @Test     public void testGetAnnotationSearchSupersAndIgnoreAccess() throws NoSuchMethodException {         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentNotAnnotatedMethod"),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("doIt"), Annotated.class,                 true, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentProtectedAnnotatedMethod"),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getDeclaredMethod("privateAnnotatedMethod"),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("publicAnnotatedMethod"),                 Annotated.class, true, true));          assertNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("parentNotAnnotatedMethod", String.class),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("parentProtectedAnnotatedMethod", String.class),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getDeclaredMethod("privateAnnotatedMethod", String.class),                 Annotated.class, true, true));         assertNotNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("publicAnnotatedMethod", String.class),                 Annotated.class, true, true));     }      @Test     public void testGetAnnotationNotSearchSupersButIgnoreAccess() throws NoSuchMethodException {         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentNotAnnotatedMethod"),                 Annotated.class, false, true));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("doIt"), Annotated.class,                 false, true));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentProtectedAnnotatedMethod"),                 Annotated.class, false, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getDeclaredMethod("privateAnnotatedMethod"),                 Annotated.class, false, true));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("publicAnnotatedMethod"),                 Annotated.class, false, true));     }      @Test     public void testGetAnnotationSearchSupersButNotIgnoreAccess() throws NoSuchMethodException {         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentNotAnnotatedMethod"),                 Annotated.class, true, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("doIt"), Annotated.class,                 true, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentProtectedAnnotatedMethod"),                 Annotated.class, true, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getDeclaredMethod("privateAnnotatedMethod"),                 Annotated.class, true, false));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("publicAnnotatedMethod"),                 Annotated.class, true, false));          assertNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("parentNotAnnotatedMethod", String.class),                 Annotated.class, true, false));         assertNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("parentProtectedAnnotatedMethod", String.class),                 Annotated.class, true, false));         assertNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getDeclaredMethod("privateAnnotatedMethod", String.class),                 Annotated.class, true, false));         assertNotNull(MethodUtils.getAnnotation(StringParameterizedChild.class.getMethod("publicAnnotatedMethod", String.class),                 Annotated.class, true, false));     }      @Test     public void testGetAnnotationNotSearchSupersAndNotIgnoreAccess() throws NoSuchMethodException {         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentNotAnnotatedMethod"),                 Annotated.class, false, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("doIt"), Annotated.class,                 false, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("parentProtectedAnnotatedMethod"),                 Annotated.class, false, false));         assertNull(MethodUtils.getAnnotation(PublicChild.class.getDeclaredMethod("privateAnnotatedMethod"),                 Annotated.class, false, false));         assertNotNull(MethodUtils.getAnnotation(PublicChild.class.getMethod("publicAnnotatedMethod"),                 Annotated.class, false, false));     }      @Test     public void testGetMethodsWithAnnotationIllegalArgumentException1() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsWithAnnotation(FieldUtilsTest.class, null));     }      @Test     public void testGetMethodsWithAnnotationIllegalArgumentException2() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsWithAnnotation(null, Annotated.class));     }      @Test     public void testGetMethodsWithAnnotationIllegalArgumentException3() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsWithAnnotation(null, null));     }      @Test     @Annotated     public void testGetMethodsListWithAnnotation() throws NoSuchMethodException {         assertEquals(0, MethodUtils.getMethodsListWithAnnotation(Object.class, Annotated.class).size());          final List<Method> methodWithAnnotation = MethodUtils.getMethodsListWithAnnotation(MethodUtilsTest.class, Annotated.class);         assertEquals(2, methodWithAnnotation.size());         assertThat(methodWithAnnotation, hasItems(                 MethodUtilsTest.class.getMethod("testGetMethodsWithAnnotation"),                 MethodUtilsTest.class.getMethod("testGetMethodsListWithAnnotation")         ));     }      @Test     public void testGetMethodsListWithAnnotationIllegalArgumentException1() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(FieldUtilsTest.class, null));     }      @Test     public void testGetMethodsListWithAnnotationIllegalArgumentException2() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(null, Annotated.class));     }      @Test     public void testGetMethodsListWithAnnotationIllegalArgumentException3() {         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(null, null));     }      @Test     public void testGetAnnotationIllegalArgumentException1() {         assertThrows(NullPointerException.class,                 () -> MethodUtils.getAnnotation(FieldUtilsTest.class.getDeclaredMethods()[0], null, true, true));     }      @Test     public void testGetAnnotationIllegalArgumentException2() {         assertThrows(NullPointerException.class, () -> MethodUtils.getAnnotation(null, Annotated.class, true, true));     }      @Test     public void testGetAnnotationIllegalArgumentException3() {         assertThrows(NullPointerException.class, () -> MethodUtils.getAnnotation(null, null, true, true));     }      private void expectMatchingAccessibleMethodParameterTypes(final Class<?> cls,                                                               final String methodName, final Class<?>[] requestTypes, final Class<?>[] actualTypes) {         final Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,                 requestTypes);         assertNotNull(m, "could not find any matches for " + methodName                 + " (" + (requestTypes == null ? null : toString(requestTypes)) + ")");         assertArrayEquals(actualTypes, m.getParameterTypes(), toString(m.getParameterTypes()) + " not equals " + toString(actualTypes));     }      private String toString(final Class<?>[] c) {         return Arrays.asList(c).toString();     }      private Class<?>[] singletonArray(final Class<?> c) {         Class<?>[] result = classCache.get(c);         if (result == null) {             result = new Class[]{c};             classCache.put(c, result);         }         return result;     }      public static class InheritanceBean {         public void testOne(final Object obj) {         }          public void testOne(final GrandParentObject obj) {         }          public void testOne(final ParentObject obj) {         }          public void testTwo(final Object obj) {         }          public void testTwo(final GrandParentObject obj) {         }          public void testTwo(final ChildInterface obj) {         }     }      interface ChildInterface {     }      public static class GrandParentObject {     }      public static class ParentObject extends GrandParentObject {     }      public static class ChildObject extends ParentObject implements ChildInterface {     }      private static class MethodDescriptor {         final Class<?> declaringClass;         final String name;         final Type[] parameterTypes;          MethodDescriptor(final Class<?> declaringClass, final String name, final Type... parameterTypes) {             this.declaringClass = declaringClass;             this.name = name;             this.parameterTypes = parameterTypes;         }     }      @Test     public void testVarArgsUnboxing() throws Exception {         final TestBean testBean = new TestBean();         final int[] actual = (int[]) MethodUtils.invokeMethod(testBean, "unboxing", Integer.valueOf(1), Integer.valueOf(2));         assertArrayEquals(new int[]{1, 2}, actual);     }      @Test     public void testInvokeMethodForceAccessNoArgs() throws Exception {         assertEquals("privateStringStuff()", MethodUtils.invokeMethod(testBean, true, "privateStringStuff"));     }      @Test     public void testInvokeMethodForceAccessWithArgs() throws Exception {         assertEquals("privateStringStuff(Integer)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", 5));         assertEquals("privateStringStuff(double)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", 5.0d));         assertEquals("privateStringStuff(String)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", "Hi There"));         assertEquals("privateStringStuff(Object)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", new Date()));     }      @Test     public void testDistance() throws Exception {         final Method distanceMethod = MethodUtils.getMatchingMethod(MethodUtils.class, "distance", Class[].class, Class[].class);         distanceMethod.setAccessible(true);          assertEquals(-1, distanceMethod.invoke(null, new Class[]{String.class}, new Class[]{Date.class}));         assertEquals(0, distanceMethod.invoke(null, new Class[]{Date.class}, new Class[]{Date.class}));         assertEquals(1, distanceMethod.invoke(null, new Class[]{Integer.class}, new Class[]{ClassUtils.wrapperToPrimitive(Integer.class)}));         assertEquals(2, distanceMethod.invoke(null, new Class[]{Integer.class}, new Class[]{Object.class}));          distanceMethod.setAccessible(false);     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.List;  import org.junit.jupiter.api.Test;  public class TypeLiteralTest {      @Test     public void testBasic() {         assertTrue(TypeUtils.equals(String.class, new TypeLiteral<String>() {}.value));         assertTrue(TypeUtils.equals(TypeUtils.parameterize(List.class, String.class),             new TypeLiteral<List<String>>() {}.value));     }      @Test     public void testTyped() {         final Typed<String> stringType = new TypeLiteral<String>() {};         assertTrue(TypeUtils.equals(String.class, stringType.getType()));         final Typed<List<String>> listOfStringType = new TypeLiteral<List<String>>() {};         assertTrue(TypeUtils.equals(TypeUtils.parameterize(List.class, String.class), listOfStringType.getType()));     }      @Test     public void testEquals() {         assertEquals(new TypeLiteral<String>() {}, new TypeLiteral<String>() {});         assertEquals(new TypeLiteral<List<String>>() {}, new TypeLiteral<List<String>>() {});         assertNotEquals(new TypeLiteral<String>() {}, new TypeLiteral<List<String>>() {});     }      @SuppressWarnings("rawtypes")     @Test     public void testRaw() {         assertThrows(NullPointerException.class, () -> new TypeLiteral() {});     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.io.Serializable; import java.lang.reflect.Field; import java.lang.reflect.GenericArrayType; import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.lang.reflect.WildcardType; import java.net.URI; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.TreeSet;  import org.apache.commons.lang3.reflect.testbed.Foo; import org.apache.commons.lang3.reflect.testbed.GenericParent; import org.apache.commons.lang3.reflect.testbed.GenericTypeHolder; import org.apache.commons.lang3.reflect.testbed.StringParameterizedChild; import org.junit.jupiter.api.Test;  /**  * Test TypeUtils  */ @SuppressWarnings({ "unchecked", "unused", "rawtypes" }) //raw types, where used, are used purposely public class TypeUtilsTest<B> {      public interface This<K, V> {     }      public class That<K, V> implements This<K, V> {     }      public interface And<K, V> extends This<Number, Number> {     }      public class The<K, V> extends That<Number, Number> implements And<String, String> {     }      public class Other<T> implements This<String, T> {     }      public class Thing<Q> extends Other<B> {     }      public class Tester implements This<String, B> {     }      public This<String, String> dis;      public That<String, String> dat;      public The<String, String> da;      public Other<String> uhder;      public Thing ding;      public TypeUtilsTest<String>.Tester tester;      public Tester tester2;      public TypeUtilsTest<String>.That<String, String> dat2;      public TypeUtilsTest<Number>.That<String, String> dat3;      public Comparable<? extends Integer>[] intWildcardComparable;      public static Comparable<String> stringComparable;      public static Comparable<URI> uriComparable;      public static Comparable<Integer> intComparable;      public static Comparable<Long> longComparable;      public static Comparable<?> wildcardComparable;      public static URI uri;      public static List<String>[] stringListArray;      public void dummyMethod(final List list0, final List<Object> list1, final List<?> list2,             final List<? super Object> list3, final List<String> list4, final List<? extends String> list5,             final List<? super String> list6, final List[] list7, final List<Object>[] list8, final List<?>[] list9,             final List<? super Object>[] list10, final List<String>[] list11, final List<? extends String>[] list12,             final List<? super String>[] list13) {     }      @SuppressWarnings("boxing") // deliberately used here     @Test     public void testIsAssignable() throws SecurityException, NoSuchMethodException,             NoSuchFieldException {         List list0 = null;         List<Object> list1 = null;         List<?> list2 = null;         List<? super Object> list3 = null;         List<String> list4 = null;         List<? extends String> list5 = null;         List<? super String> list6 = null;         List[] list7 = null;         List<Object>[] list8 = null;         List<?>[] list9 = null;         List<? super Object>[] list10 = null;         List<String>[] list11 = null;         List<? extends String>[] list12 = null;         List<? super String>[] list13;         final Class<?> clazz = getClass();         final Method method = clazz.getMethod("dummyMethod", List.class, List.class, List.class,                 List.class, List.class, List.class, List.class, List[].class, List[].class,                 List[].class, List[].class, List[].class, List[].class, List[].class);         final Type[] types = method.getGenericParameterTypes(); //        list0 = list0;         delegateBooleanAssertion(types, 0, 0, true);         list1 = list0;         delegateBooleanAssertion(types, 0, 1, true);         list0 = list1;         delegateBooleanAssertion(types, 1, 0, true);         list2 = list0;         delegateBooleanAssertion(types, 0, 2, true);         list0 = list2;         delegateBooleanAssertion(types, 2, 0, true);         list3 = list0;         delegateBooleanAssertion(types, 0, 3, true);         list0 = list3;         delegateBooleanAssertion(types, 3, 0, true);         list4 = list0;         delegateBooleanAssertion(types, 0, 4, true);         list0 = list4;         delegateBooleanAssertion(types, 4, 0, true);         list5 = list0;         delegateBooleanAssertion(types, 0, 5, true);         list0 = list5;         delegateBooleanAssertion(types, 5, 0, true);         list6 = list0;         delegateBooleanAssertion(types, 0, 6, true);         list0 = list6;         delegateBooleanAssertion(types, 6, 0, true); //        list1 = list1;         delegateBooleanAssertion(types, 1, 1, true);         list2 = list1;         delegateBooleanAssertion(types, 1, 2, true);         list1 = (List<Object>) list2;         delegateBooleanAssertion(types, 2, 1, false);         list3 = list1;         delegateBooleanAssertion(types, 1, 3, true);         list1 = (List<Object>) list3;         delegateBooleanAssertion(types, 3, 1, false);         // list4 = list1;         delegateBooleanAssertion(types, 1, 4, false);         // list1 = list4;         delegateBooleanAssertion(types, 4, 1, false);         // list5 = list1;         delegateBooleanAssertion(types, 1, 5, false);         // list1 = list5;         delegateBooleanAssertion(types, 5, 1, false);         list6 = list1;         delegateBooleanAssertion(types, 1, 6, true);         list1 = (List<Object>) list6;         delegateBooleanAssertion(types, 6, 1, false); //        list2 = list2;         delegateBooleanAssertion(types, 2, 2, true);         list2 = list3;         delegateBooleanAssertion(types, 2, 3, false);         list2 = list4;         delegateBooleanAssertion(types, 3, 2, true);         list3 = (List<? super Object>) list2;         delegateBooleanAssertion(types, 2, 4, false);         list2 = list5;         delegateBooleanAssertion(types, 4, 2, true);         list4 = (List<String>) list2;         delegateBooleanAssertion(types, 2, 5, false);         list2 = list6;         delegateBooleanAssertion(types, 5, 2, true);         list5 = (List<? extends String>) list2;         delegateBooleanAssertion(types, 2, 6, false); //        list3 = list3;         delegateBooleanAssertion(types, 6, 2, true);         list6 = (List<? super String>) list2;         delegateBooleanAssertion(types, 3, 3, true);         // list4 = list3;         delegateBooleanAssertion(types, 3, 4, false);         // list3 = list4;         delegateBooleanAssertion(types, 4, 3, false);         // list5 = list3;         delegateBooleanAssertion(types, 3, 5, false);         // list3 = list5;         delegateBooleanAssertion(types, 5, 3, false);         list6 = list3;         delegateBooleanAssertion(types, 3, 6, true);         list3 = (List<? super Object>) list6;         delegateBooleanAssertion(types, 6, 3, false); //        list4 = list4;         delegateBooleanAssertion(types, 4, 4, true);         list5 = list4;         delegateBooleanAssertion(types, 4, 5, true);         list4 = (List<String>) list5;         delegateBooleanAssertion(types, 5, 4, false);         list6 = list4;         delegateBooleanAssertion(types, 4, 6, true);         list4 = (List<String>) list6;         delegateBooleanAssertion(types, 6, 4, false); //        list5 = list5;         delegateBooleanAssertion(types, 5, 5, true);         list6 = (List<? super String>) list5;         delegateBooleanAssertion(types, 5, 6, false);         list5 = (List<? extends String>) list6;         delegateBooleanAssertion(types, 6, 5, false); //        list6 = list6;         delegateBooleanAssertion(types, 6, 6, true);  //        list7 = list7;         delegateBooleanAssertion(types, 7, 7, true);         list8 = list7;         delegateBooleanAssertion(types, 7, 8, true);         list7 = list8;         delegateBooleanAssertion(types, 8, 7, true);         list9 = list7;         delegateBooleanAssertion(types, 7, 9, true);         list7 = list9;         delegateBooleanAssertion(types, 9, 7, true);         list10 = list7;         delegateBooleanAssertion(types, 7, 10, true);         list7 = list10;         delegateBooleanAssertion(types, 10, 7, true);         list11 = list7;         delegateBooleanAssertion(types, 7, 11, true);         list7 = list11;         delegateBooleanAssertion(types, 11, 7, true);         list12 = list7;         delegateBooleanAssertion(types, 7, 12, true);         list7 = list12;         delegateBooleanAssertion(types, 12, 7, true);         list13 = list7;         delegateBooleanAssertion(types, 7, 13, true);         list7 = list13;         delegateBooleanAssertion(types, 13, 7, true); //        list8 = list8;         delegateBooleanAssertion(types, 8, 8, true);         list9 = list8;         delegateBooleanAssertion(types, 8, 9, true);         list8 = (List<Object>[]) list9;         delegateBooleanAssertion(types, 9, 8, false);         list10 = list8;         delegateBooleanAssertion(types, 8, 10, true);         list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse         delegateBooleanAssertion(types, 10, 8, false);         // list11 = list8;         delegateBooleanAssertion(types, 8, 11, false);         // list8 = list11;         delegateBooleanAssertion(types, 11, 8, false);         // list12 = list8;         delegateBooleanAssertion(types, 8, 12, false);         // list8 = list12;         delegateBooleanAssertion(types, 12, 8, false);         list13 = list8;         delegateBooleanAssertion(types, 8, 13, true);         list8 = (List<Object>[]) list13;         delegateBooleanAssertion(types, 13, 8, false); //        list9 = list9;         delegateBooleanAssertion(types, 9, 9, true);         list10 = (List<? super Object>[]) list9;         delegateBooleanAssertion(types, 9, 10, false);         list9 = list10;         delegateBooleanAssertion(types, 10, 9, true);         list11 = (List<String>[]) list9;         delegateBooleanAssertion(types, 9, 11, false);         list9 = list11;         delegateBooleanAssertion(types, 11, 9, true);         list12 = (List<? extends String>[]) list9;         delegateBooleanAssertion(types, 9, 12, false);         list9 = list12;         delegateBooleanAssertion(types, 12, 9, true);         list13 = (List<? super String>[]) list9;         delegateBooleanAssertion(types, 9, 13, false);         list9 = list13;         delegateBooleanAssertion(types, 13, 9, true); //        list10 = list10;         delegateBooleanAssertion(types, 10, 10, true);         // list11 = list10;         delegateBooleanAssertion(types, 10, 11, false);         // list10 = list11;         delegateBooleanAssertion(types, 11, 10, false);         // list12 = list10;         delegateBooleanAssertion(types, 10, 12, false);         // list10 = list12;         delegateBooleanAssertion(types, 12, 10, false);         list13 = list10;         delegateBooleanAssertion(types, 10, 13, true);         list10 = (List<? super Object>[]) list13;         delegateBooleanAssertion(types, 13, 10, false); //        list11 = list11;         delegateBooleanAssertion(types, 11, 11, true);         list12 = list11;         delegateBooleanAssertion(types, 11, 12, true);         list11 = (List<String>[]) list12;         delegateBooleanAssertion(types, 12, 11, false);         list13 = list11;         delegateBooleanAssertion(types, 11, 13, true);         list11 = (List<String>[]) list13;         delegateBooleanAssertion(types, 13, 11, false); //        list12 = list12;         delegateBooleanAssertion(types, 12, 12, true);         list13 = (List<? super String>[]) list12;         delegateBooleanAssertion(types, 12, 13, false);         list12 = (List<? extends String>[]) list13;         delegateBooleanAssertion(types, 13, 12, false); //        list13 = list13;         delegateBooleanAssertion(types, 13, 13, true);         final Type disType = getClass().getField("dis").getGenericType();         // Reporter.log( ( ( ParameterizedType ) disType         // ).getOwnerType().getClass().toString() );         final Type datType = getClass().getField("dat").getGenericType();         final Type daType = getClass().getField("da").getGenericType();         final Type uhderType = getClass().getField("uhder").getGenericType();         final Type dingType = getClass().getField("ding").getGenericType();         final Type testerType = getClass().getField("tester").getGenericType();         final Type tester2Type = getClass().getField("tester2").getGenericType();         final Type dat2Type = getClass().getField("dat2").getGenericType();         final Type dat3Type = getClass().getField("dat3").getGenericType();         dis = dat;         assertTrue(TypeUtils.isAssignable(datType, disType));         // dis = da;         assertFalse(TypeUtils.isAssignable(daType, disType));         dis = uhder;         assertTrue(TypeUtils.isAssignable(uhderType, disType));         dis = ding;         assertFalse(TypeUtils.isAssignable(dingType, disType),                 String.format("type %s not assignable to %s!", dingType, disType));         dis = tester;         assertTrue(TypeUtils.isAssignable(testerType, disType));         // dis = tester2;         assertFalse(TypeUtils.isAssignable(tester2Type, disType));         // dat = dat2;         assertFalse(TypeUtils.isAssignable(dat2Type, datType));         // dat2 = dat;         assertFalse(TypeUtils.isAssignable(datType, dat2Type));         // dat = dat3;         assertFalse(TypeUtils.isAssignable(dat3Type, datType));         final char ch = 0;         final boolean bo = false;         final byte by = 0;         final short sh = 0;         int in = 0;         long lo = 0;         final float fl = 0;         double du = 0;         du = ch;         assertTrue(TypeUtils.isAssignable(char.class, double.class));         du = by;         assertTrue(TypeUtils.isAssignable(byte.class, double.class));         du = sh;         assertTrue(TypeUtils.isAssignable(short.class, double.class));         du = in;         assertTrue(TypeUtils.isAssignable(int.class, double.class));         du = lo;         assertTrue(TypeUtils.isAssignable(long.class, double.class));         du = fl;         assertTrue(TypeUtils.isAssignable(float.class, double.class));         lo = in;         assertTrue(TypeUtils.isAssignable(int.class, long.class));         lo = Integer.valueOf(0);         assertTrue(TypeUtils.isAssignable(Integer.class, long.class));         // Long lngW = 1;         assertFalse(TypeUtils.isAssignable(int.class, Long.class));         // lngW = Integer.valueOf( 0 );         assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));         in = Integer.valueOf(0);         assertTrue(TypeUtils.isAssignable(Integer.class, int.class));         final Integer inte = in;         assertTrue(TypeUtils.isAssignable(int.class, Integer.class));         assertTrue(TypeUtils.isAssignable(int.class, Number.class));         assertTrue(TypeUtils.isAssignable(int.class, Object.class));         final Type intComparableType = getClass().getField("intComparable").getGenericType();         intComparable = 1;         assertTrue(TypeUtils.isAssignable(int.class, intComparableType));         assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));         final Serializable ser = 1;         assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));         final Type longComparableType = getClass().getField("longComparable").getGenericType();         // longComparable = 1;         assertFalse(TypeUtils.isAssignable(int.class, longComparableType));         // longComparable = Integer.valueOf( 0 );         assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));         // int[] ia;         // long[] la = ia;         assertFalse(TypeUtils.isAssignable(int[].class, long[].class));         final Integer[] ia = null;         final Type caType = getClass().getField("intWildcardComparable").getGenericType();         intWildcardComparable = ia;         assertTrue(TypeUtils.isAssignable(Integer[].class, caType));         // int[] ina = ia;         assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));         final int[] ina = null;         Object[] oa;         // oa = ina;         assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));         oa = new Integer[0];         assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));         final Type bClassType = AClass.class.getField("bClass").getGenericType();         final Type cClassType = AClass.class.getField("cClass").getGenericType();         final Type dClassType = AClass.class.getField("dClass").getGenericType();         final Type eClassType = AClass.class.getField("eClass").getGenericType();         final Type fClassType = AClass.class.getField("fClass").getGenericType();         final AClass aClass = new AClass(new AAClass<>());         aClass.bClass = aClass.cClass;         assertTrue(TypeUtils.isAssignable(cClassType, bClassType));         aClass.bClass = aClass.dClass;         assertTrue(TypeUtils.isAssignable(dClassType, bClassType));         aClass.bClass = aClass.eClass;         assertTrue(TypeUtils.isAssignable(eClassType, bClassType));         aClass.bClass = aClass.fClass;         assertTrue(TypeUtils.isAssignable(fClassType, bClassType));         aClass.cClass = aClass.dClass;         assertTrue(TypeUtils.isAssignable(dClassType, cClassType));         aClass.cClass = aClass.eClass;         assertTrue(TypeUtils.isAssignable(eClassType, cClassType));         aClass.cClass = aClass.fClass;         assertTrue(TypeUtils.isAssignable(fClassType, cClassType));         aClass.dClass = aClass.eClass;         assertTrue(TypeUtils.isAssignable(eClassType, dClassType));         aClass.dClass = aClass.fClass;         assertTrue(TypeUtils.isAssignable(fClassType, dClassType));         aClass.eClass = aClass.fClass;         assertTrue(TypeUtils.isAssignable(fClassType, eClassType));     }      public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) {         final Type type1 = types[i1];         final Type type2 = types[i2];         final boolean isAssignable = TypeUtils.isAssignable(type2, type1);          if (expected) {             assertTrue(isAssignable,                     "[" + i1 + ", " + i2 + "]: From "                                 + String.valueOf(type2) + " to "                                 + String.valueOf(type1));         } else {             assertFalse(isAssignable,                     "[" + i1 + ", " + i2 + "]: From "                                 + String.valueOf(type2) + " to "                                 + String.valueOf(type1));         }     }      @SuppressWarnings("boxing") // boxing is deliberate here     @Test     public void testIsInstance() throws SecurityException, NoSuchFieldException {         final Type intComparableType = getClass().getField("intComparable").getGenericType();         final Type uriComparableType = getClass().getField("uriComparable").getGenericType();         intComparable = 1;         assertTrue(TypeUtils.isInstance(1, intComparableType));         // uriComparable = 1;         assertFalse(TypeUtils.isInstance(1, uriComparableType));     }      @Test     public void testGetTypeArguments() {         Map<TypeVariable<?>, Type> typeVarAssigns;         TypeVariable<?> treeSetTypeVar;         Type typeArg;          typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);         treeSetTypeVar = Comparable.class.getTypeParameters()[0];         assertTrue(typeVarAssigns.containsKey(treeSetTypeVar),                 "Type var assigns for Comparable from Integer: " + typeVarAssigns);         typeArg = typeVarAssigns.get(treeSetTypeVar);         assertEquals(Integer.class, typeVarAssigns.get(treeSetTypeVar),                 "Type argument of Comparable from Integer: " + typeArg);          typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);         treeSetTypeVar = Comparable.class.getTypeParameters()[0];         assertTrue(typeVarAssigns.containsKey(treeSetTypeVar),                 "Type var assigns for Comparable from int: " + typeVarAssigns);         typeArg = typeVarAssigns.get(treeSetTypeVar);         assertEquals(Integer.class, typeVarAssigns.get(treeSetTypeVar),                 "Type argument of Comparable from int: " + typeArg);          final Collection<Integer> col = Collections.emptyList();         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);         treeSetTypeVar = Comparable.class.getTypeParameters()[0];         assertFalse(typeVarAssigns.containsKey(treeSetTypeVar),                 "Type var assigns for Collection from List: " + typeVarAssigns);          typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);         assertEquals(2, typeVarAssigns.size());         assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0]));         assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0]));          typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);         assertEquals(2, typeVarAssigns.size());         assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));         assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));          typeVarAssigns = TypeUtils.getTypeArguments(And.class, This.class);         assertEquals(2, typeVarAssigns.size());         assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));         assertEquals(Number.class, typeVarAssigns.get(This.class.getTypeParameters()[1]));          typeVarAssigns = TypeUtils.getTypeArguments(Thing.class, Other.class);         assertEquals(2, typeVarAssigns.size());         assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(getClass().getTypeParameters()[0]));         assertEquals(getClass().getTypeParameters()[0], typeVarAssigns.get(Other.class.getTypeParameters()[0]));     }      @Test     public void testTypesSatisfyVariables() throws SecurityException,             NoSuchMethodException {         final Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>();         final Integer max = TypeUtilsTest.<Integer>stub();         typeVarAssigns.put(getClass().getMethod("stub").getTypeParameters()[0], Integer.class);         assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns));         typeVarAssigns.clear();         typeVarAssigns.put(getClass().getMethod("stub2").getTypeParameters()[0], Integer.class);         assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns));         typeVarAssigns.clear();         typeVarAssigns.put(getClass().getMethod("stub3").getTypeParameters()[0], Integer.class);         assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns));     }      @Test     public void testDetermineTypeVariableAssignments() throws SecurityException,             NoSuchFieldException {         final ParameterizedType iterableType = (ParameterizedType) getClass().getField("iterable")                 .getGenericType();         final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class,                 iterableType);         final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0];         assertTrue(typeVarAssigns.containsKey(treeSetTypeVar));         assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns                 .get(treeSetTypeVar));     }      @Test     public void testGetRawType() throws SecurityException, NoSuchFieldException {         final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField("stringParent")                 .getGenericType();         final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField("integerParent")                 .getGenericType();         final Type foosFieldType = GenericTypeHolder.class.getDeclaredField("foos").getGenericType();         final Type genericParentT = GenericParent.class.getTypeParameters()[0];         assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null));         assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType,                         null));         assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null));         assertEquals(String.class, TypeUtils.getRawType(genericParentT,                 StringParameterizedChild.class));         assertEquals(String.class, TypeUtils.getRawType(genericParentT,                 stringParentFieldType));         assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0],                 foosFieldType));         assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0],                 foosFieldType));         assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class));         assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class                 .getDeclaredField("barParents").getGenericType(), null));     }      @Test     public void testIsArrayTypeClasses() {         assertTrue(TypeUtils.isArrayType(boolean[].class));         assertTrue(TypeUtils.isArrayType(byte[].class));         assertTrue(TypeUtils.isArrayType(short[].class));         assertTrue(TypeUtils.isArrayType(int[].class));         assertTrue(TypeUtils.isArrayType(char[].class));         assertTrue(TypeUtils.isArrayType(long[].class));         assertTrue(TypeUtils.isArrayType(float[].class));         assertTrue(TypeUtils.isArrayType(double[].class));         assertTrue(TypeUtils.isArrayType(Object[].class));         assertTrue(TypeUtils.isArrayType(String[].class));          assertFalse(TypeUtils.isArrayType(boolean.class));         assertFalse(TypeUtils.isArrayType(byte.class));         assertFalse(TypeUtils.isArrayType(short.class));         assertFalse(TypeUtils.isArrayType(int.class));         assertFalse(TypeUtils.isArrayType(char.class));         assertFalse(TypeUtils.isArrayType(long.class));         assertFalse(TypeUtils.isArrayType(float.class));         assertFalse(TypeUtils.isArrayType(double.class));         assertFalse(TypeUtils.isArrayType(Object.class));         assertFalse(TypeUtils.isArrayType(String.class));     }      @Test     public void testIsArrayGenericTypes() throws Exception {         final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class,                 List.class, List.class, List.class, List.class, List[].class, List[].class,                 List[].class, List[].class, List[].class, List[].class, List[].class);          final Type[] types = method.getGenericParameterTypes();          assertFalse(TypeUtils.isArrayType(types[0]));         assertFalse(TypeUtils.isArrayType(types[1]));         assertFalse(TypeUtils.isArrayType(types[2]));         assertFalse(TypeUtils.isArrayType(types[3]));         assertFalse(TypeUtils.isArrayType(types[4]));         assertFalse(TypeUtils.isArrayType(types[5]));         assertFalse(TypeUtils.isArrayType(types[6]));         assertTrue(TypeUtils.isArrayType(types[7]));         assertTrue(TypeUtils.isArrayType(types[8]));         assertTrue(TypeUtils.isArrayType(types[9]));         assertTrue(TypeUtils.isArrayType(types[10]));         assertTrue(TypeUtils.isArrayType(types[11]));         assertTrue(TypeUtils.isArrayType(types[12]));         assertTrue(TypeUtils.isArrayType(types[13]));     }      @Test     public void testGetPrimitiveArrayComponentType() {         assertEquals(boolean.class, TypeUtils.getArrayComponentType(boolean[].class));         assertEquals(byte.class, TypeUtils.getArrayComponentType(byte[].class));         assertEquals(short.class, TypeUtils.getArrayComponentType(short[].class));         assertEquals(int.class, TypeUtils.getArrayComponentType(int[].class));         assertEquals(char.class, TypeUtils.getArrayComponentType(char[].class));         assertEquals(long.class, TypeUtils.getArrayComponentType(long[].class));         assertEquals(float.class, TypeUtils.getArrayComponentType(float[].class));         assertEquals(double.class, TypeUtils.getArrayComponentType(double[].class));          assertNull(TypeUtils.getArrayComponentType(boolean.class));         assertNull(TypeUtils.getArrayComponentType(byte.class));         assertNull(TypeUtils.getArrayComponentType(short.class));         assertNull(TypeUtils.getArrayComponentType(int.class));         assertNull(TypeUtils.getArrayComponentType(char.class));         assertNull(TypeUtils.getArrayComponentType(long.class));         assertNull(TypeUtils.getArrayComponentType(float.class));         assertNull(TypeUtils.getArrayComponentType(double.class));     }      @Test     public void testGetArrayComponentType() throws Exception {         final Method method = getClass().getMethod("dummyMethod", List.class, List.class, List.class,                 List.class, List.class, List.class, List.class, List[].class, List[].class,                 List[].class, List[].class, List[].class, List[].class, List[].class);          final Type[] types = method.getGenericParameterTypes();          assertNull(TypeUtils.getArrayComponentType(types[0]));         assertNull(TypeUtils.getArrayComponentType(types[1]));         assertNull(TypeUtils.getArrayComponentType(types[2]));         assertNull(TypeUtils.getArrayComponentType(types[3]));         assertNull(TypeUtils.getArrayComponentType(types[4]));         assertNull(TypeUtils.getArrayComponentType(types[5]));         assertNull(TypeUtils.getArrayComponentType(types[6]));         assertEquals(types[0], TypeUtils.getArrayComponentType(types[7]));         assertEquals(types[1], TypeUtils.getArrayComponentType(types[8]));         assertEquals(types[2], TypeUtils.getArrayComponentType(types[9]));         assertEquals(types[3], TypeUtils.getArrayComponentType(types[10]));         assertEquals(types[4], TypeUtils.getArrayComponentType(types[11]));         assertEquals(types[5], TypeUtils.getArrayComponentType(types[12]));         assertEquals(types[6], TypeUtils.getArrayComponentType(types[13]));     }      @Test     public void testLang820() {         final Type[] typeArray = {String.class, String.class};         final Type[] expectedArray = {String.class};         assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray));     }      @Test     public void testParameterize() throws Exception {         final ParameterizedType stringComparableType = TypeUtils.parameterize(Comparable.class, String.class);         assertTrue(TypeUtils.equals(getClass().getField("stringComparable").getGenericType(),             stringComparableType));         assertEquals("java.lang.Comparable<java.lang.String>", stringComparableType.toString());     }      @Test     public void testParameterizeNarrowerTypeArray() {         final TypeVariable<?>[] variables = ArrayList.class.getTypeParameters();         final ParameterizedType parameterizedType = TypeUtils.parameterize(ArrayList.class, variables);         final Map<TypeVariable<?>, Type> mapping = Collections.<TypeVariable<?>, Type>singletonMap(variables[0], String.class);         final Type unrolled = TypeUtils.unrollVariables(mapping, parameterizedType);         assertEquals(TypeUtils.parameterize(ArrayList.class, String.class), unrolled);     }      @Test     public void testParameterizeWithOwner() throws Exception {         final Type owner = TypeUtils.parameterize(TypeUtilsTest.class, String.class);         final ParameterizedType dat2Type = TypeUtils.parameterizeWithOwner(owner, That.class, String.class, String.class);         assertTrue(TypeUtils.equals(getClass().getField("dat2").getGenericType(), dat2Type));     }      @Test     public void testWildcardType() throws Exception {         final WildcardType simpleWildcard = TypeUtils.wildcardType().withUpperBounds(String.class).build();         final Field cClass = AClass.class.getField("cClass");         assertTrue(TypeUtils.equals(((ParameterizedType) cClass.getGenericType()).getActualTypeArguments()[0],             simpleWildcard));         assertEquals(String.format("? extends %s", String.class.getName()), TypeUtils.toString(simpleWildcard));         assertEquals(String.format("? extends %s", String.class.getName()), simpleWildcard.toString());     }      @Test     public void testUnboundedWildcardType() {         final WildcardType unbounded = TypeUtils.wildcardType().withLowerBounds((Type) null).withUpperBounds().build();         assertTrue(TypeUtils.equals(TypeUtils.WILDCARD_ALL, unbounded));         assertArrayEquals(new Type[] { Object.class }, TypeUtils.getImplicitUpperBounds(unbounded));         assertArrayEquals(new Type[] { null }, TypeUtils.getImplicitLowerBounds(unbounded));         assertEquals("?", TypeUtils.toString(unbounded));         assertEquals("?", unbounded.toString());     }      @Test     public void testLowerBoundedWildcardType() {        final WildcardType lowerBounded = TypeUtils.wildcardType().withLowerBounds(java.sql.Date.class).build();        assertEquals(String.format("? super %s", java.sql.Date.class.getName()), TypeUtils.toString(lowerBounded));        assertEquals(String.format("? super %s", java.sql.Date.class.getName()), lowerBounded.toString());         final TypeVariable<Class<Iterable>> iterableT0 = Iterable.class.getTypeParameters()[0];        final WildcardType lowerTypeVariable = TypeUtils.wildcardType().withLowerBounds(iterableT0).build();        assertEquals(String.format("? super %s", iterableT0.getName()), TypeUtils.toString(lowerTypeVariable));        assertEquals(String.format("? super %s", iterableT0.getName()), lowerTypeVariable.toString());     }      @Test     public void testLang1114() throws Exception {         final Type nonWildcardType = getClass().getDeclaredField("wildcardComparable").getGenericType();         final Type wildcardType = ((ParameterizedType) nonWildcardType).getActualTypeArguments()[0];          assertFalse(TypeUtils.equals(wildcardType, nonWildcardType));         assertFalse(TypeUtils.equals(nonWildcardType, wildcardType));     }      @Test     public void testGenericArrayType() throws Exception {         final Type expected = getClass().getField("intWildcardComparable").getGenericType();         final GenericArrayType actual =             TypeUtils.genericArrayType(TypeUtils.parameterize(Comparable.class, TypeUtils.wildcardType()                 .withUpperBounds(Integer.class).build()));         assertTrue(TypeUtils.equals(expected, actual));         assertEquals("java.lang.Comparable<? extends java.lang.Integer>[]", actual.toString());     }      @Test     public void testToStringLang1311() {         assertEquals("int[]", TypeUtils.toString(int[].class));         assertEquals("java.lang.Integer[]", TypeUtils.toString(Integer[].class));         final Field stringListField = FieldUtils.getDeclaredField(getClass(), "stringListArray");         assertEquals("java.util.List<java.lang.String>[]", TypeUtils.toString(stringListField.getGenericType()));     }      @Test     public void testToLongString() {         assertEquals(getClass().getName() + ":B", TypeUtils.toLongString(getClass().getTypeParameters()[0]));     }      @Test     public void testWrap() {         final Type t = getClass().getTypeParameters()[0];         assertTrue(TypeUtils.equals(t, TypeUtils.wrap(t).getType()));          assertEquals(String.class, TypeUtils.wrap(String.class).getType());     }      public static class ClassWithSuperClassWithGenericType extends ArrayList<Object> {         private static final long serialVersionUID = 1L;          public static <U> Iterable<U> methodWithGenericReturnType() {             return null;         }     }      @Test     public void testLANG1190() throws Exception {         final Type fromType = ClassWithSuperClassWithGenericType.class.getDeclaredMethod("methodWithGenericReturnType").getGenericReturnType();         final Type failingToType = TypeUtils.wildcardType().withLowerBounds(ClassWithSuperClassWithGenericType.class).build();          assertTrue(TypeUtils.isAssignable(fromType, failingToType));     }      @Test     public void testLANG1348() throws Exception {         final Method method = Enum.class.getMethod("valueOf", Class.class, String.class);         assertEquals("T extends java.lang.Enum<T>", TypeUtils.toString(method.getGenericReturnType()));     }      public Iterable<? extends Map<Integer, ? extends Collection<?>>> iterable;      public static <G extends Comparable<G>> G stub() {         return null;     }      public static <G extends Comparable<? super G>> G stub2() {         return null;     }      public static <T extends Comparable<? extends T>> T stub3() {         return null;     } }  class AAClass<T> {      public class BBClass<S> {     } }  class AAAClass extends AAClass<String> {     public class BBBClass extends BBClass<String> {     } }  @SuppressWarnings("rawtypes") //raw types, where used, are used purposely class AClass extends AAClass<String>.BBClass<Number> {      AClass(final AAClass<String> enclosingInstance) {         enclosingInstance.super();     }      public class BClass<T> {     }      public class CClass<T> extends BClass {     }      public class DClass<T> extends CClass<T> {     }      public class EClass<T> extends DClass {     }      public class FClass extends EClass<String> {     }      public class GClass<T extends BClass<? extends T> & AInterface<AInterface<? super T>>> {     }      public BClass<Number> bClass;      public CClass<? extends String> cClass;      public DClass<String> dClass;      public EClass<String> eClass;      public FClass fClass;      public GClass gClass;      public interface AInterface<T> {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect;  import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertNull; import static org.junit.jupiter.api.Assertions.assertThrows;  import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.HashMap; import java.util.Map;  import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.math.NumberUtils; import org.apache.commons.lang3.mutable.MutableObject; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  /**  * Unit tests ConstructorUtils  */ public class ConstructorUtilsTest {     public static class TestBean {         private final String toString;         final String[] varArgs;          public TestBean() {             toString = "()";             varArgs = null;         }          public TestBean(final int i) {             toString = "(int)";             varArgs = null;         }          public TestBean(final Integer i) {             toString = "(Integer)";             varArgs = null;         }          public TestBean(final double d) {             toString = "(double)";             varArgs = null;         }          public TestBean(final String s) {             toString = "(String)";             varArgs = null;         }          public TestBean(final Object o) {             toString = "(Object)";             varArgs = null;         }          public TestBean(final String... s) {             toString = "(String...)";             varArgs = s;         }          public TestBean(final BaseClass bc, final String... s) {             toString = "(BaseClass, String...)";             varArgs = s;         }          public TestBean(final Integer i, final String... s) {             toString = "(Integer, String...)";             varArgs = s;         }          public TestBean(final Integer first, final int... args) {             toString = "(Integer, String...)";             varArgs = new String[args.length];             for (int i = 0; i< args.length; ++i) {                 varArgs[i] = Integer.toString(args[i]);             }         }          @Override         public String toString() {             return toString;         }          void verify(final String str, final String[] args) {           assertEquals(str, toString);           assertArrayEquals(args, varArgs);         }     }      private static class BaseClass {}      private static class SubClass extends BaseClass {}      static class PrivateClass {         @SuppressWarnings("unused")         public PrivateClass() {         }          @SuppressWarnings("unused")         public static class PublicInnerClass {             public PublicInnerClass() {             }         }     }      private final Map<Class<?>, Class<?>[]> classCache;      public ConstructorUtilsTest() {         classCache = new HashMap<>();     }       @BeforeEach     public void setUp() {         classCache.clear();     }      @Test     public void testConstructor() throws Exception {         assertNotNull(MethodUtils.class.newInstance());     }      @Test     public void testInvokeConstructor() throws Exception {         assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class,                 (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString());         assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class,                 (Object[]) null).toString());         assertEquals("()", ConstructorUtils.invokeConstructor(TestBean.class).toString());         assertEquals("(String)", ConstructorUtils.invokeConstructor(                 TestBean.class, "").toString());         assertEquals("(Object)", ConstructorUtils.invokeConstructor(                 TestBean.class, new Object()).toString());         assertEquals("(Object)", ConstructorUtils.invokeConstructor(                 TestBean.class, Boolean.TRUE).toString());         assertEquals("(Integer)", ConstructorUtils.invokeConstructor(                 TestBean.class, NumberUtils.INTEGER_ONE).toString());         assertEquals("(int)", ConstructorUtils.invokeConstructor(                 TestBean.class, NumberUtils.BYTE_ONE).toString());         assertEquals("(double)", ConstructorUtils.invokeConstructor(                 TestBean.class, NumberUtils.LONG_ONE).toString());         assertEquals("(double)", ConstructorUtils.invokeConstructor(                 TestBean.class, NumberUtils.DOUBLE_ONE).toString());         ConstructorUtils.invokeConstructor(TestBean.class, NumberUtils.INTEGER_ONE)           .verify("(Integer)", null);         ConstructorUtils.invokeConstructor(TestBean.class, "a", "b")           .verify("(String...)", new String[]{"a", "b"});         ConstructorUtils.invokeConstructor(TestBean.class, NumberUtils.INTEGER_ONE, "a", "b")           .verify("(Integer, String...)", new String[]{"a", "b"});         ConstructorUtils.invokeConstructor(TestBean.class, new SubClass(), new String[]{"a", "b"})           .verify("(BaseClass, String...)", new String[]{"a", "b"});     }      @Test     public void testInvokeExactConstructor() throws Exception {         assertEquals("()", ConstructorUtils.invokeExactConstructor(                 TestBean.class, (Object[]) ArrayUtils.EMPTY_CLASS_ARRAY).toString());         assertEquals("()", ConstructorUtils.invokeExactConstructor(                 TestBean.class, (Object[]) null).toString());         assertEquals("(String)", ConstructorUtils.invokeExactConstructor(                 TestBean.class, "").toString());         assertEquals("(Object)", ConstructorUtils.invokeExactConstructor(                 TestBean.class, new Object()).toString());         assertEquals("(Integer)", ConstructorUtils.invokeExactConstructor(                 TestBean.class, NumberUtils.INTEGER_ONE).toString());         assertEquals("(double)", ConstructorUtils.invokeExactConstructor(                 TestBean.class, new Object[] { NumberUtils.DOUBLE_ONE },                 new Class[] { Double.TYPE }).toString());          assertThrows(                 NoSuchMethodException.class,                 () -> ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.BYTE_ONE));         assertThrows(                 NoSuchMethodException.class,                 () -> ConstructorUtils.invokeExactConstructor(TestBean.class, NumberUtils.LONG_ONE));         assertThrows(                 NoSuchMethodException.class,                 () -> ConstructorUtils.invokeExactConstructor(TestBean.class, Boolean.TRUE));     }      @Test     public void testGetAccessibleConstructor() throws Exception {         assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class                 .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));         assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.class                 .getConstructor(ArrayUtils.EMPTY_CLASS_ARRAY)));         assertNull(ConstructorUtils.getAccessibleConstructor(PrivateClass.PublicInnerClass.class));     }      @Test     public void testGetAccessibleConstructorFromDescription() {         assertNotNull(ConstructorUtils.getAccessibleConstructor(Object.class,                 ArrayUtils.EMPTY_CLASS_ARRAY));         assertNull(ConstructorUtils.getAccessibleConstructor(                 PrivateClass.class, ArrayUtils.EMPTY_CLASS_ARRAY));     }      @Test     public void testGetMatchingAccessibleMethod() {         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 ArrayUtils.EMPTY_CLASS_ARRAY, ArrayUtils.EMPTY_CLASS_ARRAY);         expectMatchingAccessibleConstructorParameterTypes(TestBean.class, null,                 ArrayUtils.EMPTY_CLASS_ARRAY);         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(String.class), singletonArray(String.class));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Object.class), singletonArray(Object.class));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Boolean.class), singletonArray(Object.class));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Byte.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Byte.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Short.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Short.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Character.class), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Character.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Integer.class), singletonArray(Integer.class));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Integer.TYPE), singletonArray(Integer.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Long.class), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Long.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Float.class), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Float.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Double.class), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 singletonArray(Double.TYPE), singletonArray(Double.TYPE));         expectMatchingAccessibleConstructorParameterTypes(TestBean.class,                 new Class<?>[]{SubClass.class, String[].class},                 new Class<?>[]{BaseClass.class, String[].class});     }      @Test     public void testNullArgument() {         expectMatchingAccessibleConstructorParameterTypes(MutableObject.class,                 singletonArray(null), singletonArray(Object.class));     }      private void expectMatchingAccessibleConstructorParameterTypes(final Class<?> cls,             final Class<?>[] requestTypes, final Class<?>[] actualTypes) {         final Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls,                 requestTypes);         assertArrayEquals(actualTypes, c.getParameterTypes(), toString(c.getParameterTypes()) + " not equals " + toString(actualTypes));     }      private String toString(final Class<?>[] c) {         return Arrays.asList(c).toString();     }      private Class<?>[] singletonArray(final Class<?> c) {         Class<?>[] result = classCache.get(c);         if (result == null) {             result = new Class[] { c };             classCache.put(c, result);         }         return result;     }      @Test     public void testVarArgsUnboxing() throws Exception {         final TestBean testBean = ConstructorUtils.invokeConstructor(                 TestBean.class, Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3));          assertArrayEquals(new String[]{"2", "3"}, testBean.varArgs);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  import org.apache.commons.lang3.reflect.testbed.AnotherChild; import org.apache.commons.lang3.reflect.testbed.AnotherParent; import org.apache.commons.lang3.reflect.testbed.Grandchild; import org.junit.jupiter.api.Test;  /**  * Unit tests InheritanceUtils  */ public class InheritanceUtilsTest {      @Test     public void testConstructor() throws Exception {         assertNotNull(InheritanceUtils.class.newInstance());     }      @Test     public void testDistanceGreaterThanZero() {         assertEquals(1, InheritanceUtils.distance(AnotherChild.class, AnotherParent.class));         assertEquals(1, InheritanceUtils.distance(Grandchild.class, AnotherChild.class));         assertEquals(2, InheritanceUtils.distance(Grandchild.class, AnotherParent.class));         assertEquals(3, InheritanceUtils.distance(Grandchild.class, Object.class));     }      @Test     public void testDistanceEqual() {         assertEquals(0, InheritanceUtils.distance(AnotherChild.class, AnotherChild.class));     }      @Test     public void testDistanceEqualObject() {         assertEquals(0, InheritanceUtils.distance(Object.class, Object.class));     }      @Test     public void testDistanceNullChild() {         assertEquals(-1, InheritanceUtils.distance(null, Object.class));     }      @Test     public void testDistanceNullParent() {         assertEquals(-1, InheritanceUtils.distance(Object.class, null));     }      @Test     public void testDistanceNullParentNullChild() {         assertEquals(-1, InheritanceUtils.distance(null, null));     }      @Test     public void testDistanceDisjoint() {         assertEquals(-1, InheritanceUtils.distance(Boolean.class, String.class));     }      @Test     public void testDistanceReverseParentChild() {         assertEquals(-1, InheritanceUtils.distance(Object.class, Grandchild.class));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  * Class declaring a parameter variable.  */ public class GenericParent<T> implements GenericConsumer<T> {      @Override     public void consume(final T t) {     }      @Annotated     protected void parentProtectedAnnotatedMethod(final T t) {     }      public void parentNotAnnotatedMethod(final T t) {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  * {@link GenericParent} subclass that explicitly specifies &lt;T&gt; as {@link String}.  */ public class StringParameterizedChild extends GenericParent<String> {     @Override     public void consume(final String t) {         super.consume(t);     }      @Override     public void parentProtectedAnnotatedMethod(final String t) {     }      @Override     public void parentNotAnnotatedMethod(final String t) {     }      @Annotated     private void privateAnnotatedMethod(final String t) {     }      @Annotated     public void publicAnnotatedMethod(final String t) {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  *  */ public class AnotherChild extends AnotherParent { } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  import java.util.List;  /**  * Holds generic testbed types.  */ public class GenericTypeHolder {     public GenericParent<String> stringParent;     public GenericParent<Integer> integerParent;     public List<Foo> foos;     public GenericParent<Bar>[] barParents; } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public interface Bar {     String VALUE = "bar";      void doIt(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ @SuppressWarnings({ "unused" }) // deliberate re-use of variable names public class PrivatelyShadowedChild extends Parent {     private final String s = "ss";     private final boolean b = true;     private final int i = 1;     private final double d = 1.0; } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ class Parent implements Foo {     public String s = "s";     protected boolean b = false;     int i = 0;     @SuppressWarnings("unused")     private final double d = 0.0;      @Override     public void doIt() {     }      @Annotated     protected void parentProtectedAnnotatedMethod() {     }      public void parentNotAnnotatedMethod() {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public interface Foo {     String VALUE = "foo";      @Annotated     void doIt(); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public class Ambig implements Foo, Bar {      @Override     public void doIt() {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public class StaticContainer {     public static final Object IMMUTABLE_PUBLIC = "public";     protected static final Object IMMUTABLE_PROTECTED = "protected";     static final Object IMMUTABLE_PACKAGE = "";     @SuppressWarnings("unused")     private static final Object IMMUTABLE_PRIVATE = "private";      /**      * This final modifier of this field is meant to be removed by a test.      * Using this field may produce unpredictable results.      */     @SuppressWarnings("unused")     private static final Object IMMUTABLE_PRIVATE_2 = "private";      public static Object mutablePublic;     protected static Object mutableProtected;     static Object mutablePackage;     private static Object mutablePrivate;      public static void reset() {         mutablePublic = null;         mutableProtected = null;         mutablePackage = null;         mutablePrivate = null;     }      public static Object getMutableProtected() {         return mutableProtected;     }      public static Object getMutablePackage() {         return mutablePackage;     }      public static Object getMutablePrivate() {         return mutablePrivate;     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  public interface GenericConsumer<T> {     void consume(T t); } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  *  */ public class Grandchild extends AnotherChild { } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public class StaticContainerChild extends StaticContainer {  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public class PubliclyShadowedChild extends Parent {     public String s = "ss";     public boolean b = true;     public int i = 1;     public double d = 1.0; } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.lang3.reflect.testbed;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.METHOD}) public @interface Annotated { } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  *  */ public class AnotherParent { } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3.reflect.testbed;  /**  */ public class PublicChild extends Parent {     static final String VALUE = "child";      @Override     public void parentProtectedAnnotatedMethod() {     }      @Override     public void parentNotAnnotatedMethod() {     }      @Annotated     private void privateAnnotatedMethod() {     }      @Annotated     public void publicAnnotatedMethod() {     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.Locale;  import org.junit.jupiter.api.Test; import org.junitpioneer.jupiter.DefaultLocale;  /**  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Contains methods  */ public class StringUtilsContainsTest  {     /**      * Supplementary character U+20000      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharU20000 = "\uD840\uDC00";     /**      * Supplementary character U+20001      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharU20001 = "\uD840\uDC01";     /**      * Incomplete supplementary character U+20000, high surrogate only.      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharUSuppCharHigh = "\uDC00";      /**      * Incomplete supplementary character U+20000, low surrogate only.      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     private static final String CharUSuppCharLow = "\uD840";      @Test     public void testContains_Char() {         assertFalse(StringUtils.contains(null, ' '));         assertFalse(StringUtils.contains("", ' '));         assertFalse(StringUtils.contains("", null));         assertFalse(StringUtils.contains(null, null));         assertTrue(StringUtils.contains("abc", 'a'));         assertTrue(StringUtils.contains("abc", 'b'));         assertTrue(StringUtils.contains("abc", 'c'));         assertFalse(StringUtils.contains("abc", 'z'));     }      @Test     public void testContains_String() {         assertFalse(StringUtils.contains(null, null));         assertFalse(StringUtils.contains(null, ""));         assertFalse(StringUtils.contains(null, "a"));         assertFalse(StringUtils.contains("", null));         assertTrue(StringUtils.contains("", ""));         assertFalse(StringUtils.contains("", "a"));         assertTrue(StringUtils.contains("abc", "a"));         assertTrue(StringUtils.contains("abc", "b"));         assertTrue(StringUtils.contains("abc", "c"));         assertTrue(StringUtils.contains("abc", "abc"));         assertFalse(StringUtils.contains("abc", "z"));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContains_StringWithBadSupplementaryChars() {         // Test edge case: 1/2 of a (broken) supplementary char         assertFalse(StringUtils.contains(CharUSuppCharHigh, CharU20001));         assertFalse(StringUtils.contains(CharUSuppCharLow, CharU20001));         assertFalse(StringUtils.contains(CharU20001, CharUSuppCharHigh));         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));         assertTrue(StringUtils.contains(CharU20001, CharUSuppCharLow));         assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharLow + "a", "a"));         assertTrue(StringUtils.contains(CharU20001 + CharUSuppCharHigh + "a", "a"));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContains_StringWithSupplementaryChars() {         assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20000));         assertTrue(StringUtils.contains(CharU20000 + CharU20001, CharU20001));         assertTrue(StringUtils.contains(CharU20000, CharU20000));         assertFalse(StringUtils.contains(CharU20000, CharU20001));     }      @Test     public void testContainsAny_StringCharArray() {         assertFalse(StringUtils.containsAny(null, (char[]) null));         assertFalse(StringUtils.containsAny(null, new char[0]));         assertFalse(StringUtils.containsAny(null, 'a', 'b'));          assertFalse(StringUtils.containsAny("", (char[]) null));         assertFalse(StringUtils.containsAny("", new char[0]));         assertFalse(StringUtils.containsAny("", 'a', 'b'));          assertFalse(StringUtils.containsAny("zzabyycdxx", (char[]) null));         assertFalse(StringUtils.containsAny("zzabyycdxx", new char[0]));         assertTrue(StringUtils.containsAny("zzabyycdxx", 'z', 'a'));         assertTrue(StringUtils.containsAny("zzabyycdxx", 'b', 'y'));         assertTrue(StringUtils.containsAny("zzabyycdxx", 'z', 'y'));         assertFalse(StringUtils.containsAny("ab", 'z'));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsAny_StringCharArrayWithBadSupplementaryChars() {         // Test edge case: 1/2 of a (broken) supplementary char         assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray()));         assertFalse(StringUtils.containsAny("abc" + CharUSuppCharHigh + "xyz", CharU20001.toCharArray()));         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));         assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));         assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray()));         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));         assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray()));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsAny_StringCharArrayWithSupplementaryChars() {         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));         assertTrue(StringUtils.containsAny("a" + CharU20000 + CharU20001, "a".toCharArray()));         assertTrue(StringUtils.containsAny(CharU20000 + "a" + CharU20001, "a".toCharArray()));         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001 + "a", "a".toCharArray()));         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));         assertTrue(StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));         // Sanity check:         assertEquals(-1, CharU20000.indexOf(CharU20001));         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));         // Test:         assertFalse(StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));         assertFalse(StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));     }      @Test     public void testContainsAny_StringString() {         assertFalse(StringUtils.containsAny(null, (String) null));         assertFalse(StringUtils.containsAny(null, ""));         assertFalse(StringUtils.containsAny(null, "ab"));          assertFalse(StringUtils.containsAny("", (String) null));         assertFalse(StringUtils.containsAny("", ""));         assertFalse(StringUtils.containsAny("", "ab"));          assertFalse(StringUtils.containsAny("zzabyycdxx", (String) null));         assertFalse(StringUtils.containsAny("zzabyycdxx", ""));         assertTrue(StringUtils.containsAny("zzabyycdxx", "za"));         assertTrue(StringUtils.containsAny("zzabyycdxx", "by"));         assertTrue(StringUtils.containsAny("zzabyycdxx", "zy"));         assertFalse(StringUtils.containsAny("ab", "z"));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsAny_StringWithBadSupplementaryChars() {         // Test edge case: 1/2 of a (broken) supplementary char         assertFalse(StringUtils.containsAny(CharUSuppCharHigh, CharU20001));         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));         assertFalse(StringUtils.containsAny(CharUSuppCharLow, CharU20001));         assertFalse(StringUtils.containsAny(CharU20001, CharUSuppCharHigh));         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));         assertTrue(StringUtils.containsAny(CharU20001, CharUSuppCharLow));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsAny_StringWithSupplementaryChars() {         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));         assertTrue(StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));         assertTrue(StringUtils.containsAny(CharU20000, CharU20000));         // Sanity check:         assertEquals(-1, CharU20000.indexOf(CharU20001));         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));         // Test:         assertFalse(StringUtils.containsAny(CharU20000, CharU20001));         assertFalse(StringUtils.containsAny(CharU20001, CharU20000));     }      @Test     public void testContainsAny_StringStringArray() {         assertFalse(StringUtils.containsAny(null, (String[]) null));         assertFalse(StringUtils.containsAny(null, new String[0]));         assertFalse(StringUtils.containsAny(null, new String[] { "hello" }));         assertFalse(StringUtils.containsAny("", (String[]) null));         assertFalse(StringUtils.containsAny("", new String[0]));         assertFalse(StringUtils.containsAny("", new String[] { "hello" }));         assertFalse(StringUtils.containsAny("hello, goodbye", (String[]) null));         assertFalse(StringUtils.containsAny("hello, goodbye", new String[0]));         assertTrue(StringUtils.containsAny("hello, goodbye", new String[]{"hello", "goodbye"}));         assertTrue(StringUtils.containsAny("hello, goodbye", new String[]{"hello", "Goodbye"}));         assertFalse(StringUtils.containsAny("hello, goodbye", new String[]{"Hello", "Goodbye"}));         assertFalse(StringUtils.containsAny("hello, goodbye", new String[]{"Hello", null}));         assertFalse(StringUtils.containsAny("hello, null", new String[] { "Hello", null }));         // Javadoc examples:         assertTrue(StringUtils.containsAny("abcd", "ab", null));         assertTrue(StringUtils.containsAny("abcd", "ab", "cd"));         assertTrue(StringUtils.containsAny("abc", "d", "abc"));     }      @DefaultLocale(language = "de", country = "DE")     @Test     public void testContainsIgnoreCase_LocaleIndependence() {         final Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() };          final String[][] tdata = { { "i", "I" }, { "I", "i" }, { "\u03C2", "\u03C3" }, { "\u03A3", "\u03C2" },             { "\u03A3", "\u03C3" }, };          final String[][] fdata = { { "\u00DF", "SS" }, };          for (final Locale testLocale : locales) {             Locale.setDefault(testLocale);             for (int j = 0; j < tdata.length; j++) {                 assertTrue(StringUtils.containsIgnoreCase(tdata[j][0], tdata[j][1]),                     Locale.getDefault() + ": " + j + " " + tdata[j][0] + " " + tdata[j][1]);             }             for (int j = 0; j < fdata.length; j++) {                 assertFalse(StringUtils.containsIgnoreCase(fdata[j][0], fdata[j][1]),                     Locale.getDefault() + ": " + j + " " + fdata[j][0] + " " + fdata[j][1]);             }         }     }      @Test     public void testContainsIgnoreCase_StringString() {         assertFalse(StringUtils.containsIgnoreCase(null, null));          // Null tests         assertFalse(StringUtils.containsIgnoreCase(null, ""));         assertFalse(StringUtils.containsIgnoreCase(null, "a"));         assertFalse(StringUtils.containsIgnoreCase(null, "abc"));          assertFalse(StringUtils.containsIgnoreCase("", null));         assertFalse(StringUtils.containsIgnoreCase("a", null));         assertFalse(StringUtils.containsIgnoreCase("abc", null));          // Match len = 0         assertTrue(StringUtils.containsIgnoreCase("", ""));         assertTrue(StringUtils.containsIgnoreCase("a", ""));         assertTrue(StringUtils.containsIgnoreCase("abc", ""));          // Match len = 1         assertFalse(StringUtils.containsIgnoreCase("", "a"));         assertTrue(StringUtils.containsIgnoreCase("a", "a"));         assertTrue(StringUtils.containsIgnoreCase("abc", "a"));         assertFalse(StringUtils.containsIgnoreCase("", "A"));         assertTrue(StringUtils.containsIgnoreCase("a", "A"));         assertTrue(StringUtils.containsIgnoreCase("abc", "A"));          // Match len > 1         assertFalse(StringUtils.containsIgnoreCase("", "abc"));         assertFalse(StringUtils.containsIgnoreCase("a", "abc"));         assertTrue(StringUtils.containsIgnoreCase("xabcz", "abc"));         assertFalse(StringUtils.containsIgnoreCase("", "ABC"));         assertFalse(StringUtils.containsIgnoreCase("a", "ABC"));         assertTrue(StringUtils.containsIgnoreCase("xabcz", "ABC"));     }      @Test     public void testContainsNone_CharArray() {         final String str1 = "a";         final String str2 = "b";         final String str3 = "ab.";         final char[] chars1= {'b'};         final char[] chars2= {'.'};         final char[] chars3= {'c', 'd'};         final char[] emptyChars = new char[0];         assertTrue(StringUtils.containsNone(null, (char[]) null));         assertTrue(StringUtils.containsNone("", (char[]) null));         assertTrue(StringUtils.containsNone(null, emptyChars));         assertTrue(StringUtils.containsNone(str1, emptyChars));         assertTrue(StringUtils.containsNone("", emptyChars));         assertTrue(StringUtils.containsNone("", chars1));         assertTrue(StringUtils.containsNone(str1, chars1));         assertTrue(StringUtils.containsNone(str1, chars2));         assertTrue(StringUtils.containsNone(str1, chars3));         assertFalse(StringUtils.containsNone(str2, chars1));         assertTrue(StringUtils.containsNone(str2, chars2));         assertTrue(StringUtils.containsNone(str2, chars3));         assertFalse(StringUtils.containsNone(str3, chars1));         assertFalse(StringUtils.containsNone(str3, chars2));         assertTrue(StringUtils.containsNone(str3, chars3));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsNone_CharArrayWithBadSupplementaryChars() {         // Test edge case: 1/2 of a (broken) supplementary char         assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray()));         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));         assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));         assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));         assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray()));         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));         assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray()));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsNone_CharArrayWithSupplementaryChars() {         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray()));         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray()));         assertFalse(StringUtils.containsNone(CharU20000, CharU20000.toCharArray()));         // Sanity check:         assertEquals(-1, CharU20000.indexOf(CharU20001));         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));         // Test:         assertTrue(StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));         assertTrue(StringUtils.containsNone(CharU20001, CharU20000.toCharArray()));     }      @Test     public void testContainsNone_String() {         final String str1 = "a";         final String str2 = "b";         final String str3 = "ab.";         final String chars1= "b";         final String chars2= ".";         final String chars3= "cd";         assertTrue(StringUtils.containsNone(null, (String) null));         assertTrue(StringUtils.containsNone("", (String) null));         assertTrue(StringUtils.containsNone(null, ""));         assertTrue(StringUtils.containsNone(str1, ""));         assertTrue(StringUtils.containsNone("", ""));         assertTrue(StringUtils.containsNone("", chars1));         assertTrue(StringUtils.containsNone(str1, chars1));         assertTrue(StringUtils.containsNone(str1, chars2));         assertTrue(StringUtils.containsNone(str1, chars3));         assertFalse(StringUtils.containsNone(str2, chars1));         assertTrue(StringUtils.containsNone(str2, chars2));         assertTrue(StringUtils.containsNone(str2, chars3));         assertFalse(StringUtils.containsNone(str3, chars1));         assertFalse(StringUtils.containsNone(str3, chars2));         assertTrue(StringUtils.containsNone(str3, chars3));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsNone_StringWithBadSupplementaryChars() {         // Test edge case: 1/2 of a (broken) supplementary char         assertTrue(StringUtils.containsNone(CharUSuppCharHigh, CharU20001));         assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));         assertTrue(StringUtils.containsNone(CharUSuppCharLow, CharU20001));         assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));         assertTrue(StringUtils.containsNone(CharU20001, CharUSuppCharHigh));         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));         assertFalse(StringUtils.containsNone(CharU20001, CharUSuppCharLow));     }      /**      * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html      */     @Test     public void testContainsNone_StringWithSupplementaryChars() {         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20000));         assertFalse(StringUtils.containsNone(CharU20000 + CharU20001, CharU20001));         assertFalse(StringUtils.containsNone(CharU20000, CharU20000));         // Sanity check:         assertEquals(-1, CharU20000.indexOf(CharU20001));         assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));         assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));         // Test:         assertTrue(StringUtils.containsNone(CharU20000, CharU20001));         assertTrue(StringUtils.containsNone(CharU20001, CharU20000));     }      @Test     public void testContainsOnly_CharArray() {         final String str1 = "a";         final String str2 = "b";         final String str3 = "ab";         final char[] chars1= {'b'};         final char[] chars2= {'a'};         final char[] chars3= {'a', 'b'};         final char[] emptyChars = new char[0];         assertFalse(StringUtils.containsOnly(null, (char[]) null));         assertFalse(StringUtils.containsOnly("", (char[]) null));         assertFalse(StringUtils.containsOnly(null, emptyChars));         assertFalse(StringUtils.containsOnly(str1, emptyChars));         assertTrue(StringUtils.containsOnly("", emptyChars));         assertTrue(StringUtils.containsOnly("", chars1));         assertFalse(StringUtils.containsOnly(str1, chars1));         assertTrue(StringUtils.containsOnly(str1, chars2));         assertTrue(StringUtils.containsOnly(str1, chars3));         assertTrue(StringUtils.containsOnly(str2, chars1));         assertFalse(StringUtils.containsOnly(str2, chars2));         assertTrue(StringUtils.containsOnly(str2, chars3));         assertFalse(StringUtils.containsOnly(str3, chars1));         assertFalse(StringUtils.containsOnly(str3, chars2));         assertTrue(StringUtils.containsOnly(str3, chars3));     }      @Test     public void testContainsOnly_String() {         final String str1 = "a";         final String str2 = "b";         final String str3 = "ab";         final String chars1= "b";         final String chars2= "a";         final String chars3= "ab";         assertFalse(StringUtils.containsOnly(null, (String) null));         assertFalse(StringUtils.containsOnly("", (String) null));         assertFalse(StringUtils.containsOnly(null, ""));         assertFalse(StringUtils.containsOnly(str1, ""));         assertTrue(StringUtils.containsOnly("", ""));         assertTrue(StringUtils.containsOnly("", chars1));         assertFalse(StringUtils.containsOnly(str1, chars1));         assertTrue(StringUtils.containsOnly(str1, chars2));         assertTrue(StringUtils.containsOnly(str1, chars3));         assertTrue(StringUtils.containsOnly(str2, chars1));         assertFalse(StringUtils.containsOnly(str2, chars2));         assertTrue(StringUtils.containsOnly(str2, chars3));         assertFalse(StringUtils.containsOnly(str3, chars1));         assertFalse(StringUtils.containsOnly(str3, chars2));         assertTrue(StringUtils.containsOnly(str3, chars3));     }      @Test     public void testContainsWhitespace() {         assertFalse( StringUtils.containsWhitespace("") );         assertTrue( StringUtils.containsWhitespace(" ") );         assertFalse( StringUtils.containsWhitespace("a") );         assertTrue( StringUtils.containsWhitespace("a ") );         assertTrue( StringUtils.containsWhitespace(" a") );         assertTrue( StringUtils.containsWhitespace("a\t") );         assertTrue( StringUtils.containsWhitespace("\n") );     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.lang3;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  import org.junit.jupiter.api.Test;  /**  * Unit tests {@link org.apache.commons.lang3.NotImplementedException}.  */ public class NotImplementedExceptionTest {      @Test     public void testConstructors() {         final Throwable nested = new RuntimeException();         final String message = "Not Implemented";         final String code = "CODE";          NotImplementedException nie = new NotImplementedException(message);         assertCorrect("Issue in (String)", nie, message, null, null);         nie = new NotImplementedException(nested);         assertCorrect("Issue in (Throwable)", nie, nested.toString(), nested, null);         nie = new NotImplementedException(message, nested);         assertCorrect("Issue in (String, Throwable)", nie, message, nested, null);         nie = new NotImplementedException(message, code);         assertCorrect("Issue in (String, String)", nie, message, null, code);         nie = new NotImplementedException(nested, code);         assertCorrect("Issue in (Throwable, String)", nie, nested.toString(), nested, code);         nie = new NotImplementedException(message, nested, code);         assertCorrect("Issue in (String, Throwable, String)", nie, message, nested, code);     }      private void assertCorrect(final String assertMessage, final NotImplementedException nie, final String message, final Throwable nested, final String code) {         assertNotNull(nie, assertMessage + ": target is null");         assertEquals(message, nie.getMessage(), assertMessage + ": Message not equal");         assertEquals(nested, nie.getCause(), assertMessage + ": Nested throwable not equal");         assertEquals(code, nie.getCode(), assertMessage + ": Code not equal");     } } 
