/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Test;  import static joptsimple.ExceptionMatchers.withOption; import static org.junit.Assert.*;  public class OptionParserUnrecognizedOptionsAllowedTest extends AbstractOptionParserFixture {     @Test     public void unrecognizedOptionDisallowed() {         assertFalse( parser.doesAllowsUnrecognizedOptions() );          thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "a" ) );          parser.parse( "-a" );     }      @Test     public void unrecognizedOptionAllowed() {         parser.allowsUnrecognizedOptions();          OptionSet options = parser.parse( "-a" );          assertEquals( singletonList( "-a" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RequiredIfAnyTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         parser.accepts( "a" );         parser.accepts( "b" );         OptionSpec<Void> c = parser.accepts( "c" );         OptionSpec<Void> d = parser.accepts( "d" );         parser.accepts( "e" );         parser.accepts( "n" ).requiredIf( "a", "b" ).requiredIf( c, d );     }      @Test     public void rejectsCommandLineMissingConditionallyRequiredOption() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "-a" );     }      @Test     public void rejectsCommandLineMissingOtherConditionallyRequiredOption() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "-b" );     }      @Test     public void rejectsCommandLineWithNotAllConditionallyRequiredOptionsPresent() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "-a", "-b", "-c", "-d" );     }      @Test     public void acceptsCommandLineWithConditionallyRequiredOptionsPresent() {         OptionSet options = parser.parse( "-b", "-n" );                  assertOptionDetected( options, "b" );         assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsOptionWithPrerequisiteAsNormalIfPrerequisiteNotInPlay() {         OptionSet options = parser.parse( "-n" );          assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class NoArgumentOptionSpecValuesImmutabilityTest extends AbstractOptionSpecValuesImmutabilityTestCase<Void> {     @Override     protected AbstractOptionSpec<Void> newOptionSpec() {         return new NoArgumentOptionSpec( "verbose" );     }      @Override     protected String firstArg() {         return "1";     }      @Override     protected String secondArg() {         return "2";     }      @Override     protected Void newItem() {         return null;     }      @Override     protected Void containedItem() {         return null;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.infinitest.toolkit.StrictEqualsHashCodeTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetEqualsHashCodeTest extends StrictEqualsHashCodeTestSupport {     @Override     protected OptionSet equal() {         OptionSet options = new OptionSet( emptyMap() );         options.addWithArgument( new RequiredArgumentOptionSpec<String>( "anOption" ), "anArg" );         return options;     }      @Override     protected OptionSet notEqual() {         OptionSet options = new OptionSet( emptyMap() );         options.addWithArgument( new RequiredArgumentOptionSpec<String>( "anOption" ), "aDifferentArg" );         return options;     }      @Override     protected Object equalButDifferentClass() {         OptionSet options =             new OptionSet( emptyMap() ) {                 // anonymous subclass             };         options.addWithArgument( new RequiredArgumentOptionSpec<String>( "anOption" ), "anArg" );         return options;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ArgumentAcceptingOptionSpecDefaultValuesImmutabilityTest extends UnmodifiableListTestSupport<String> {     @Override     protected List<String> newList() {         return new RequiredArgumentOptionSpec<String>( "option" ).defaultsTo( "a", "b" ).defaultValues();     }      @Override     protected String containedItem() {         return "a";     }      @Override     protected String newItem() {         return "c";     } } 
package joptsimple;  import java.io.StringWriter; import java.util.Collections; import java.util.HashMap; import java.util.Iterator; import java.util.Map;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.infinitest.toolkit.CollectionMatchers.*; import static org.junit.Assert.*;  public class OptionParserAlternateHelpFormatterTest extends AbstractOptionParserFixture {     private StringWriter sink;     private Map<String, ? extends OptionDescriptor> captured;      @Before     public void primeParser() throws Exception {         captured = new HashMap<>();          parser.accepts( "b", "boo" );          parser.formatHelpWith( new HelpFormatter() {             public String format( Map<String, ? extends OptionDescriptor> options ) {                 captured = options;                 return "some help you are";             }         } );          sink = new StringWriter();          parser.printHelpOn( sink );     }      @Test     public void asksAlternateFormatterForHelpString() {         assertEquals( "some help you are", sink.toString() );     }      @Test     public void getsFedOptionDescriptorsForRecognizedOptions() {         assertEquals( 2, captured.size() );         Iterator<? extends Map.Entry<String,? extends OptionDescriptor>> iterator = captured.entrySet().iterator();         Map.Entry<String, ? extends OptionDescriptor> first = iterator.next();         assertEquals( "[arguments]", first.getKey() );         Map.Entry<String, ? extends OptionDescriptor> second = iterator.next();         assertEquals("b", second.getKey());         OptionDescriptor descriptor = second.getValue();         assertThat( descriptor.options(), hasSameContentsAs( singletonList( "b" ) ) );         assertEquals( "boo", descriptor.description() );         assertFalse( descriptor.acceptsArguments() );         assertFalse( descriptor.requiresArgument() );         assertEquals( "", descriptor.argumentDescription() );         assertEquals( "", descriptor.argumentTypeIndicator() );         assertEquals( Collections.emptyList(), descriptor.defaultValues() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.ArrayList; import java.util.List;  import static java.util.Arrays.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSpecsReportTheirOptionsSortedSpeciallyTest {     @Test     public void shortOptionsComeFirstFollowedByLongOptionsLexicographically() {         AbstractOptionSpec<Void> spec = new NoArgumentOptionSpec( asList( "after-date", "n", "N", "past" ), "" );          List<String> actualOptions = new ArrayList<>( spec.options() );          assertEquals( asList( "N", "n", "after-date", "past" ), actualOptions );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.File; import java.text.SimpleDateFormat; import java.util.Date;  import org.junit.Test;  import static java.util.Arrays.*; import static java.util.Collections.*; import static joptsimple.util.DateConverter.*; import static org.junit.Assert.*;  public class NonOptionArgumentSpecTest extends AbstractOptionParserFixture {     @Test     public void allowsTypingOfNonOptionArguments() {         OptionSpec<File> nonOptions = parser.nonOptions().ofType( File.class );          OptionSet options = parser.parse( "/opt", "/var" );          assertEquals( asList( new File( "/opt" ), new File( "/var" ) ), nonOptions.values( options ) );     }      @Test     public void allowsDescriptionOfNonOptionArguments() {         OptionSpec<String> nonOptions = parser.nonOptions( "directories" );          OptionSet options = parser.parse( "/opt", "/var" );          assertEquals( asList( "/opt", "/var" ), nonOptions.values( options ) );     }      @Test     public void allowsTypeAndDescriptionOfNonOptionArguments() {         OptionSpec<File> nonOptions = parser.nonOptions( "directories" ).ofType( File.class );          OptionSet options = parser.parse( "/opt", "/var" );          assertEquals( asList( new File( "/opt" ), new File( "/var" ) ), nonOptions.values( options ) );     }      @Test     public void allowsArgumentDescriptionForNonOptionArguments() {         OptionSpec<String> nonOptions = parser.nonOptions().describedAs( "dirs" );          OptionSet options = parser.parse( "/opt", "/var" );          assertEquals( asList( "/opt", "/var" ), nonOptions.values( options ) );     }      @Test     public void doesNotAcceptArguments() {         OptionDescriptor nonOptions = parser.nonOptions().describedAs( "dirs" );          assertFalse( nonOptions.acceptsArguments() );     }      @Test     public void convertingUsingConverter() throws Exception {         OptionSpec<Date> date = parser.nonOptions().withValuesConvertedBy( datePattern( "MM/dd/yyyy" ) );          OptionSet options = parser.parse( "01/24/2013" );          assertEquals(             singletonList( new SimpleDateFormat( "MM/dd/yyyy" ).parse( "01/24/2013" ) ),             date.values( options ) );     }      @Test( expected = NullPointerException.class )     public void convertingUsingNullConverter() {         parser.nonOptions().withValuesConvertedBy( null );     }      @Test     public void noSpecsCorrespondingToNonOptions() {         OptionParser parser = new OptionParser();         parser.nonOptions();          OptionSet options = parser.parse( "one", "two" );          assertEquals( emptyList(), options.specs() );     }      @Test     public void specsCorrespondingToNonOptions() {         OptionParser parser = new OptionParser();         parser.nonOptions();          OptionSet options = parser.parse( "one", "two" );          assertEquals(             asList(                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME ),                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME )             ),             options.specsWithNonOptions() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSpecBuilderOptionsImmutabilityTest extends AbstractOptionSpecOptionsImmutabilityTestCase {     @Override     protected AbstractOptionSpec<?> newOptionSpec( String option ) {         return new OptionSpecBuilder( new OptionParser(), singletonList( option ), "" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.math.BigInteger; import java.sql.Time; import java.sql.Timestamp; import java.util.Optional;  import static java.lang.Boolean.*; import static java.util.Collections.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionParserNewDeclarationTest extends AbstractOptionParserFixture {     @Test( expected = IllegalOptionSpecificationException.class )     public void acceptsIllegalCharacters() {         parser.accepts( "!" );     }      @Test     public void booleanArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Boolean.class );         parser.accepts( "b" ).withOptionalArg().ofType( Boolean.class );          OptionSet options = parser.parse( "-a", "true", "-b", "false" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( TRUE, options.valueOf( "a" ) );         assertEquals( Optional.of( true ) , options.valueOfOptional( "a" ) );         assertEquals( singletonList( true ), options.valuesOf( "a" ) );         assertEquals( FALSE, options.valueOf( "b" ) );         assertEquals( Optional.of( false ) , options.valueOfOptional( "b" ) );         assertEquals( singletonList( false ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void byteArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Byte.class );         parser.accepts( "b" ).withOptionalArg().ofType( Byte.class );          OptionSet options = parser.parse( "-a", "-1", "-b", "-2" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Byte.valueOf( "-1" ), options.valueOf( "a" ) );         assertEquals( Optional.of( Byte.valueOf( "-1" ) ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( Byte.valueOf( "-1" ) ), options.valuesOf( "a" ) );         assertEquals( Byte.valueOf( "-2" ), options.valueOf( "b" ) );         assertEquals( Optional.of( Byte.valueOf( "-2" ) ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( Byte.valueOf( "-2" ) ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void doubleArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Double.class );         parser.accepts( "b" ).withOptionalArg().ofType( Double.class );          OptionSet options = parser.parse( "-a", "3.1415926D", "-b", "6.02E23" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Double.valueOf( "3.1415926D" ), options.valueOf( "a" ) );         assertEquals( Optional.of( 3.1415926D ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( 3.1415926D ), options.valuesOf( "a" ) );         assertEquals( Double.valueOf( "6.02E23" ), options.valueOf( "b" ) );         assertEquals( Optional.of( 6.02E23 ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( 6.02E23 ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void floatArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Float.class );         parser.accepts( "b" ).withOptionalArg().ofType( Float.class );          OptionSet options = parser.parse( "-a", "3.1415926F", "-b", "6.02E23F" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Float.valueOf( "3.1415926F" ), options.valueOf( "a" ) );         assertEquals( Optional.of( 3.1415926F ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( 3.1415926F ), options.valuesOf( "a" ) );         assertEquals( Float.valueOf( "6.02E23F" ), options.valueOf( "b" ) );         assertEquals( Optional.of( 6.02E23F ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( 6.02E23F ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void integerArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Integer.class );         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class );          OptionSet options = parser.parse( "-a", "12", "-b", "34" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Integer.valueOf( "12" ), options.valueOf( "a" ) );         assertEquals( Optional.of( 12 ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( 12 ), options.valuesOf( "a" ) );         assertEquals( Integer.valueOf( "34" ), options.valueOf( "b" ) );         assertEquals( Optional.of( 34 ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( 34 ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void longArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Long.class );         parser.accepts( "b" ).withOptionalArg().ofType( Long.class );          OptionSet options = parser.parse( "-a", "123454678901234", "-b", "98765432109876" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Long.valueOf( "123454678901234" ), options.valueOf( "a" ) );         assertEquals( Optional.of( 123454678901234L ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( 123454678901234L ), options.valuesOf( "a" ) );         assertEquals( Long.valueOf( "98765432109876" ), options.valueOf( "b" ) );         assertEquals( Optional.of( 98765432109876L ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( 98765432109876L ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void shortArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Short.class );         parser.accepts( "b" ).withOptionalArg().ofType( Short.class );          OptionSet options = parser.parse( "-a", "5675", "-b", "345" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Short.valueOf( "5675" ), options.valueOf( "a" ) );         assertEquals( Optional.of( Short.valueOf( "5675" ) ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( Short.valueOf( "5675" ) ), options.valuesOf( "a" ) );         assertEquals( Short.valueOf( "345" ), options.valueOf( "b" ) );         assertEquals( Optional.of( Short.valueOf( "345" ) ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( Short.valueOf( "345" ) ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void sqlDateArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( java.sql.Date.class );         parser.accepts( "b" ).withOptionalArg().ofType( java.sql.Date.class );          OptionSet options = parser.parse( "-a", "2001-09-11", "-b", "1941-12-07" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( java.sql.Date.valueOf( "2001-09-11" ), options.valueOf( "a" ) );         assertEquals( Optional.of( java.sql.Date.valueOf( "2001-09-11" ) ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( java.sql.Date.valueOf( "2001-09-11" ) ), options.valuesOf( "a" ) );         assertEquals( java.sql.Date.valueOf( "1941-12-07" ), options.valueOf( "b" ) );         assertEquals( Optional.of( java.sql.Date.valueOf( "1941-12-07" ) ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( java.sql.Date.valueOf( "1941-12-07" ) ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void sqlTimeArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Time.class );         parser.accepts( "b" ).withOptionalArg().ofType( Time.class );          OptionSet options = parser.parse( "-a", "08:57:39", "-b", "23:59:59" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Time.valueOf( "08:57:39" ), options.valueOf( "a" ) );         assertEquals( Optional.of( Time.valueOf( "08:57:39" ) ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( Time.valueOf( "08:57:39" ) ), options.valuesOf( "a" ) );         assertEquals( Time.valueOf( "23:59:59" ), options.valueOf( "b" ) );         assertEquals( Optional.of( Time.valueOf( "23:59:59" ) ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( Time.valueOf( "23:59:59" ) ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void sqlTimestampArgumentType() {         parser.accepts( "a" ).withRequiredArg().ofType( Timestamp.class );         parser.accepts( "b" ).withOptionalArg().ofType( Timestamp.class );          OptionSet options = parser.parse( "-a", "1970-01-01 00:00:00", "-b", "1979-12-31 23:59:59.0123456" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Timestamp.valueOf( "1970-01-01 00:00:00" ), options.valueOf( "a" ) );         assertEquals( Optional.of( Timestamp.valueOf( "1970-01-01 00:00:00" ) ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( Timestamp.valueOf( "1970-01-01 00:00:00" ) ), options.valuesOf( "a" ) );         assertEquals( Timestamp.valueOf( "1979-12-31 23:59:59.0123456" ), options.valueOf( "b" ) );         assertEquals(             Optional.of( Timestamp.valueOf( "1979-12-31 23:59:59.0123456" ) ),             options.valueOfOptional( "b" ) );         assertEquals( singletonList( Timestamp.valueOf( "1979-12-31 23:59:59.0123456" ) ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test( expected = OptionException.class )     public void illegalOptionArgumentMethodConversion() {         parser.accepts( "a" ).withRequiredArg().ofType( Integer.class );          OptionSet options = parser.parse( "-a", "foo" );          options.valueOf( "a" );     }      @Test( expected = OptionException.class )     public void illegalOptionArgumentConstructorConversion() {         parser.accepts( "a" ).withRequiredArg().ofType( BigInteger.class );          OptionSet options = parser.parse( "-a", "foo" );          options.valueOf( "a" );     }      @Test     public void optionsWithOptionalNegativeNumberArguments() {         parser.accepts( "a" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "1" );         parser.accepts( "2" );          OptionSet options = parser.parse( "-a", "-1", "-b", "-2" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( Integer.valueOf( "-1" ), options.valueOf( "a" ) );         assertEquals( Optional.of( -1 ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( -1 ), options.valuesOf( "a" ) );         assertEquals( Integer.valueOf( "-2" ), options.valueOf( "b" ) );         assertEquals( Optional.of( -2 ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( -2 ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionsWithOptionalNegativeNumberArgumentsAndNumberOptions() {         parser.accepts( "a" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "1" );         parser.accepts( "2" );          OptionSet options = parser.parse( "-1", "-2", "-a", "-b" );          assertOptionDetected( options, "1" );         assertOptionDetected( options, "a" );         assertOptionDetected( options, "2" );         assertOptionDetected( options, "b" );         assertNull( options.valueOf( "1" ) );         assertNull( options.valueOf( "a" ) );         assertNull( options.valueOf( "2" ) );         assertNull( options.valueOf( "b" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "1" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "2" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "b" ) );         assertEquals( emptyList(), options.valuesOf( "1" ) );         assertEquals( emptyList(), options.valuesOf( "a" ) );         assertEquals( emptyList(), options.valuesOf( "2" ) );         assertEquals( emptyList(), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionsWithNegativeNumberArgumentsAndNonNumberOptions() {         parser.accepts( "a" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "1" );         parser.accepts( "2" );          OptionSet options = parser.parse( "-1", "-a", "-b", "-2" );          assertOptionDetected( options, "1" );         assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertOptionNotDetected( options, "2" );         assertNull( options.valueOf( "1" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "1" ) );         assertNull( options.valueOf( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertEquals( Integer.valueOf( "-2" ), options.valueOf( "b" ) );         assertEquals( Optional.of( -2 ), options.valueOfOptional( "b" ) );         assertEquals( emptyList(), options.valuesOf( "1" ) );         assertEquals( emptyList(), options.valuesOf( "a" ) );         assertEquals( singletonList( -2 ), options.valuesOf( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ClusterVersusLongOptionTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "fox" );         parser.accepts( "f" );         parser.accepts( "o" );         parser.accepts( "x" );     }      @Test     public void resolvesToLongOptionEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "--fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesToLongOptionWithSingleDashEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "-fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesAbbreviationToLongOption() {         OptionSet options = parser.parse( "-fo" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );     }      @Test     public void resolvesShortOptionToShortOption() {         OptionSet options = parser.parse( "-f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     }      @Test     public void resolvesShortOptionToShortOptionEvenWithDoubleHyphen() {         OptionSet options = parser.parse( "--f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.StringWriter; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.stream.Stream;  import static java.math.BigDecimal.*; import static java.util.Arrays.*; import static java.util.Collections.*; import static java.util.stream.Collectors.*;  import joptsimple.util.InetAddressConverter; import org.junit.Before; import org.junit.Test;  import static joptsimple.internal.Strings.*; import static joptsimple.util.DateConverter.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class DefaultSettingsOptionParserHelpTest extends AbstractOptionParserFixture {     private StringWriter sink;      @Before     public final void createSink() {         sink = new StringWriter();     }      @Test     public void unconfiguredParser() throws Exception {         parser.printHelpOn( sink );          assertHelpLines( "No options specified  ", EMPTY );     }      @Test     public void repeatedCalls() throws Exception {         parser.accepts( "apple" );          parser.printHelpOn( sink );         parser.printHelpOn( sink );          assertHelpLines(             "Option   Description",             "------   -----------",             "--apple             ",             "Option   Description",             "------   -----------",             "--apple             ",             EMPTY );     }      @Test     public void oneOptionNoArgNoDescription() throws Exception {         parser.accepts( "apple" );          parser.printHelpOn( sink );          assertHelpLines(                 "Option   Description",                 "------   -----------",                 "--apple             ",                 EMPTY );     }      @Test     public void oneOptionNoArgWithDescription() throws Exception {         parser.accepts( "a", "some description" );          parser.printHelpOn( sink );          assertHelpLines(             "Option  Description     ",             "------  -----------     ",             "-a      some description",             EMPTY );     }      @Test     public void twoOptionsNoArgWithDescription() throws Exception {         parser.accepts( "a", "some description" );         parser.accepts( "verbose", "even more description" );          parser.printHelpOn( sink );          assertHelpLines(             "Option     Description          ",             "------     -----------          ",             "-a         some description     ",             "--verbose  even more description",             EMPTY );     }      @Test     public void oneOptionRequiredArgNoDescription() throws Exception {         parser.accepts( "a" ).withRequiredArg();          parser.printHelpOn( sink );          assertHelpLines(             "Option       Description",             "------       -----------",             "-a <String>             ",             EMPTY );     }      @Test     public void oneOptionRequiredArgNoDescriptionWithType() throws Exception {         parser.accepts( "a" ).withRequiredArg().ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option        Description",             "------        -----------",             "-a <Integer>             ",             EMPTY );     }      @Test     public void oneOptionRequiredArgWithDescription() throws Exception {         parser.accepts( "a", "some value you need" ).withRequiredArg().describedAs( "numerical" );          parser.printHelpOn( sink );          assertHelpLines(             "Option                  Description        ",             "------                  -----------        ",             "-a <String: numerical>  some value you need",             EMPTY );     }      @Test     public void oneOptionRequiredArgWithDescriptionAndType() throws Exception {         parser.accepts( "a", "some value you need" )                 .withRequiredArg().describedAs( "numerical" ).ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                   Description        ",             "------                   -----------        ",             "-a <Integer: numerical>  some value you need",             EMPTY );     }      @Test     public void oneOptionOptionalArgNoDescription() throws Exception {         parser.accepts( "threshold" ).withOptionalArg();          parser.printHelpOn( sink );          assertHelpLines(             "Option                Description",             "------                -----------",             "--threshold [String]             ",             EMPTY );     }      @Test     public void oneOptionOptionalArgNoDescriptionWithType() throws Exception {         parser.accepts( "a" ).withOptionalArg().ofType( Float.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option      Description",             "------      -----------",             "-a [Float]             ",             EMPTY );     }      @Test     public void oneOptionOptionalArgWithDescription() throws Exception {         parser.accepts( "threshold", "some value you need" ).withOptionalArg().describedAs( "positive integer" );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                  Description        ",             "------                                  -----------        ",             "--threshold [String: positive integer]  some value you need",             EMPTY );     }      @Test     public void oneOptionOptionalArgWithDescriptionAndType() throws Exception {         parser.accepts( "threshold", "some value you need" )             .withOptionalArg().describedAs( "positive decimal" ).ofType( Double.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                  Description        ",             "------                                  -----------        ",             "--threshold [Double: positive decimal]  some value you need",             EMPTY );     }      @Test     public void alternativeLongOptions() throws Exception {         parser.recognizeAlternativeLongOptions( true );          parser.printHelpOn( sink );          assertHelpLines(             "Option                  Description                     ",             "------                  -----------                     ",             "-W <String: opt=value>  Alternative form of long options",             EMPTY );     }      @Test     public void optionSynonymsWithoutArguments() throws Exception {         parser.acceptsAll( asList( "v", "chatty" ), "be verbose" );          parser.printHelpOn( sink );          assertHelpLines(             "Option        Description",             "------        -----------",             "-v, --chatty  be verbose ",             EMPTY );     }      @Test     public void optionSynonymsWithRequiredArgument() throws Exception {         parser.acceptsAll( asList( "L", "index" ), "set level" ).withRequiredArg().ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                 Description",             "------                 -----------",             "-L, --index <Integer>  set level  ",             EMPTY );     }      @Test     public void optionSynonymsWithOptionalArgument() throws Exception {         parser.acceptsAll( asList( "d", "since" ), "date filter" )             .withOptionalArg().describedAs( "yyyyMMdd" ).ofType( Date.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                        Description",             "------                        -----------",             "-d, --since [Date: yyyyMMdd]  date filter",             EMPTY );     }      @Test     public void optionSynonymsSortedByShortOptionThenLexicographical() throws Exception {         parser.acceptsAll( asList( "v", "prolix", "chatty" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option                  Description",             "------                  -----------",             "-v, --chatty, --prolix             ",             EMPTY );     }      @Test     public void writingToOutputStream() throws Exception {         ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();          parser.printHelpOn( bytesOut );          assertEquals( "No options specified  " + LINE_SEPARATOR, bytesOut.toString() );     }      // Bug 1956418     @Test     public void outputStreamFlushedButNotClosedWhenPrintingHelp() throws Exception {         FakeOutputStream fake = new FakeOutputStream();          parser.printHelpOn( fake );          assertTrue( fake.flushed );         assertFalse( fake.closed );     }      @Test     public void bothColumnsExceedingAllocatedWidths() throws Exception {         parser.acceptsAll( asList( "t", "threshold", "cutoff" ),             "a threshold value beyond which a certain level of the application should cease to write logs" )             .withRequiredArg()             .describedAs( "a positive decimal number that will represent the threshold that has been outlined" )             .ofType( Double.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                Description                       ",             "------                                -----------                       ",             "-t, --cutoff, --threshold <Double: a  a threshold value beyond which a  ",             "  positive decimal number that will     certain level of the application",             "  represent the threshold that has      should cease to write logs      ",             "  been outlined>                                                        ",             EMPTY );     }      // Bug 2018262     @Test     public void gradleHelp() throws Exception {         parser.acceptsAll( asList( "n", "non-recursive" ),             "Do not execute primary tasks of child projects." );         parser.acceptsAll( singletonList( "S" ),             "Don't trigger a System.exit(0) for normal termination. Used for Gradle's internal testing." );         parser.acceptsAll( asList( "I", "no-imports" ),             "Disable usage of default imports for build script files." );         parser.acceptsAll( asList( "u", "no-search-upward" ),             "Don't search in parent folders for a settings.gradle file." );         parser.acceptsAll( asList( "x", "cache-off" ),             "No caching of compiled build scripts." );         parser.acceptsAll( asList( "r", "rebuild-cache" ),             "Rebuild the cache of compiled build scripts." );         parser.acceptsAll( asList( "v", "version" ), "Print version info." );         parser.acceptsAll( asList( "d", "debug" ),             "Log in debug mode (includes normal stacktrace)." );         parser.acceptsAll( asList( "q", "quiet" ), "Log errors only." );         parser.acceptsAll( asList( "j", "ivy-debug" ),             "Set Ivy log level to debug (very verbose)." );         parser.acceptsAll( asList( "i", "ivy-quiet" ), "Set Ivy log level to quiet." );         parser.acceptsAll( asList( "s", "stacktrace" ),             "Print out the stacktrace also for user exceptions (e.g. compile error)." );         parser.acceptsAll( asList( "f", "full-stacktrace" ),             "Print out the full (very verbose) stacktrace for any exceptions." );         parser.acceptsAll( asList( "t", "tasks" ),             "Show list of all available tasks and their dependencies." );         parser.acceptsAll( asList( "p", "project-dir" ),             "Specifies the start dir for Gradle. Defaults to current dir." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "g", "gradle-user-home" ),             "Specifies the gradle user home dir." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "l", "plugin-properties-file" ),             "Specifies the plugin.properties file." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "b", "buildfile" ),             "Specifies the build file name (also for subprojects). Defaults to build.gradle." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "D", "systemprop" ),             "Set system property of the JVM (e.g. -Dmyprop=myvalue)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "P", "projectprop" ),             "Set project property for the build script (e.g. -Pmyprop=myvalue)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "e", "embedded" ),             "Specify an embedded build script." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "B", "bootstrap-debug" ),             "Specify a text to be logged at the beginning (e.g. used by Gradle's bootstrap class)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "h", "?" ), "Shows this help message" ).forHelp();          parser.printHelpOn( sink );          assertHelpLines(             "Option                                 Description                              ",             "------                                 -----------                              ",             "-?, -h                                 Shows this help message                  ",             "-B, --bootstrap-debug <String>         Specify a text to be logged at the       ",             "                                         beginning (e.g. used by Gradle's       ",             "                                         bootstrap class).                      ",             "-D, --systemprop <String>              Set system property of the JVM (e.g. -   ",             "                                         Dmyprop=myvalue).                      ",             "-I, --no-imports                       Disable usage of default imports for     ",             "                                         build script files.                    ",             "-P, --projectprop <String>             Set project property for the build       ",             "                                         script (e.g. -Pmyprop=myvalue).        ",             "-S                                     Don't trigger a System.exit(0) for       ",             "                                         normal termination. Used for Gradle's  ",             "                                         internal testing.                      ",             "-b, --buildfile <String>               Specifies the build file name (also for  ",             "                                         subprojects). Defaults to build.gradle.",             "-d, --debug                            Log in debug mode (includes normal       ",             "                                         stacktrace).                           ",             "-e, --embedded <String>                Specify an embedded build script.        ",             "-f, --full-stacktrace                  Print out the full (very verbose)        ",             "                                         stacktrace for any exceptions.         ",             "-g, --gradle-user-home <String>        Specifies the gradle user home dir.      ",             "-i, --ivy-quiet                        Set Ivy log level to quiet.              ",             "-j, --ivy-debug                        Set Ivy log level to debug (very         ",             "                                         verbose).                              ",             "-l, --plugin-properties-file <String>  Specifies the plugin.properties file.    ",             "-n, --non-recursive                    Do not execute primary tasks of child    ",             "                                         projects.                              ",             "-p, --project-dir <String>             Specifies the start dir for Gradle.      ",             "                                         Defaults to current dir.               ",             "-q, --quiet                            Log errors only.                         ",             "-r, --rebuild-cache                    Rebuild the cache of compiled build      ",             "                                         scripts.                               ",             "-s, --stacktrace                       Print out the stacktrace also for user   ",             "                                         exceptions (e.g. compile error).       ",             "-t, --tasks                            Show list of all available tasks and     ",             "                                         their dependencies.                    ",             "-u, --no-search-upward                 Don't search in parent folders for a     ",             "                                         settings.gradle file.                  ",             "-v, --version                          Print version info.                      ",             "-x, --cache-off                        No caching of compiled build scripts.    ",             EMPTY );     }      @Test     public void dateConverterShowsDatePattern() throws Exception {         parser.accepts( "date", "a date" )             .withRequiredArg()             .withValuesConvertedBy( datePattern( "MM/dd/yy" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option             Description",             "------             -----------",             "--date <MM/dd/yy>  a date     ",             EMPTY );     }      @Test     public void dateConverterShowsDatePatternInCombinationWithDescription() throws Exception {         parser.accepts( "date", "a date" ).withOptionalArg()             .describedAs( "your basic date pattern" )             .withValuesConvertedBy( datePattern( "MM/dd/yy" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option                             Description",             "------                             -----------",             "--date [MM/dd/yy: your basic date  a date     ",             "  pattern]                                    ",             EMPTY );     }      @Test     public void inetAddressConverterShowsType() throws Exception {         parser.accepts( "addr", "an internet address" )             .withRequiredArg()             .withValuesConvertedBy( new InetAddressConverter() );          parser.printHelpOn( sink );          assertHelpLines(             "Option                Description        ",             "------                -----------        ",             "--addr <InetAddress>  an internet address",             EMPTY );     }      @Test     public void leavesEmbeddedNewlinesInDescriptionsAlone() throws Exception {         List<String> descriptionPieces =             asList( "Specify the output type.", "'raw' = raw data.", "'java' = java class" );         parser.accepts(             "type",             descriptionPieces.stream().collect( joining( LINE_SEPARATOR ) ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option  Description             ",             "------  -----------             ",             "--type  Specify the output type.",             "        'raw' = raw data.       ",             "        'java' = java class     ",             EMPTY );     }      @Test     public void includesDefaultValueForRequiredOptionArgument() throws Exception {         parser.accepts( "a" ).withRequiredArg().defaultsTo( "boo" );          parser.printHelpOn( sink );          assertHelpLines(             "Option       Description   ",             "------       -----------   ",             "-a <String>  (default: boo)",             EMPTY );     }      @Test     public void includesDefaultValueForOptionalOptionArgument() throws Exception {         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class ).defaultsTo( 5 );          parser.printHelpOn( sink );          assertHelpLines(             "Option        Description ",             "------        ----------- ",             "-b [Integer]  (default: 5)",             EMPTY );     }      @Test     public void includesDefaultValueForArgumentWithDescription() throws Exception {         parser.accepts( "c", "a quantity" ).withOptionalArg().ofType( BigDecimal.class )             .describedAs( "quantity" ).defaultsTo( TEN );          parser.printHelpOn( sink );          assertHelpLines(             "Option                     Description             ",             "------                     -----------             ",             "-c [BigDecimal: quantity]  a quantity (default: 10)",             EMPTY );     }      @Test     public void includesListOfDefaultsForArgumentWithDescription() throws Exception {         parser.accepts( "d", "dizzle" ).withOptionalArg().ofType( Integer.class )             .describedAs( "double dizzle" ).defaultsTo( 2, 3, 5, 7 );          parser.printHelpOn( sink );          assertHelpLines(             "Option                       Description                   ",             "------                       -----------                   ",             "-d [Integer: double dizzle]  dizzle (default: [2, 3, 5, 7])",             EMPTY );     }      @Test     public void marksRequiredOptionsSpecially() throws Exception {         parser.accepts( "e" ).withRequiredArg().required();          parser.printHelpOn( sink );          assertHelpLines(             "Option (* = required)  Description",             "---------------------  -----------",             "* -e <String>                     ",             EMPTY );     }      @Test     public void showsNonOptionArgumentDescription() throws Exception {         parser.nonOptions( "stuff" );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:",             "[String] -- stuff    ",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void showsNonOptionArgumentType() throws Exception {         parser.nonOptions().ofType( File.class );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:",             "[File]               ",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void showsNonOptionArgumentTypeDescribedAs() throws Exception {         parser.nonOptions().describedAs( "files" );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:",             "[String: files]      ",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void showsNonOptionArgumentTypeAndArgumentDescription() throws Exception {         parser.nonOptions().ofType( File.class ).describedAs( "files" );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:",             "[File: files]        ",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void showsNonOptionArgumentTypeAndDescription() throws Exception {         parser.nonOptions( "some files to operate on" ).ofType( File.class );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:             ",             "[File] -- some files to operate on",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void showsNonOptionArgumentTypeAndDescriptionAndArgumentDescription() throws Exception {         parser.nonOptions( "some files to operate on" ).ofType( File.class ).describedAs( "files" );          parser.printHelpOn( sink );          assertHelpLines(             "Non-option arguments:                    ",             "[File: files] -- some files to operate on",             EMPTY,             "No options specified  ",             EMPTY );     }      @Test     public void canUseCustomHelpFormatter() {         parser.accepts( "f" );          parser.formatHelpWith(options -> {             assertEquals( 1, options.size() );              OptionDescriptor only = options.get( "f" );             assertEquals( singletonList( "f" ), new ArrayList<>( only.options() ) );             assertFalse( only.acceptsArguments() );             assertEquals( "", only.argumentDescription() );             assertEquals( "", only.argumentTypeIndicator() );             assertEquals( emptyList(), only.defaultValues() );             assertEquals( "", only.description() );             assertFalse( only.isRequired() );             assertFalse( only.requiresArgument() );              return null;         });     }      @Test( expected = NullPointerException.class )     public void rejectsNullHelpFormatter() {         parser.formatHelpWith( null );     }      @Test     public void fixForIssue56() throws Exception {         parser.accepts( "password", "Server Password" ).withRequiredArg().ofType( String.class );         parser.accepts( "F", "Forward port mapping (ie: localhost:5900:localhost:5900)" ).withRequiredArg();         parser.accepts( "R", "Reverse port mapping (ie: localhost:5900:localhost:5900)" ).withRequiredArg();          parser.printHelpOn( sink );          assertHelpLines(             "Option               Description                                             ",             "------               -----------                                             ",             "-F <String>          Forward port mapping (ie: localhost:5900:localhost:5900)",             "-R <String>          Reverse port mapping (ie: localhost:5900:localhost:5900)",             "--password <String>  Server Password                                         ",             EMPTY );     }      @Test     public void fixForIssue85() throws Exception {         parser.acceptsAll( asList( "?", "help" ), "Display this help text" ).forHelp();         parser.acceptsAll( asList( "c", "check-avail" ),             "Check Galileo homepage for available books, compare with known ones" );         parser.acceptsAll( asList( "d", "download-dir" ),             "Download directory for openbooks; must exist" )             .withRequiredArg().ofType( File.class ).defaultsTo( new File( "." ) );         parser.acceptsAll( asList( "l", "log-level" ),             "Log level (0=normal, 1=verbose, 2=debug, 3=trace" )             .withRequiredArg().ofType( int.class ).defaultsTo( 0 );         parser.acceptsAll( asList( "m", "check-md5" ),             "Download all known books without storing them, verifying their MD5 checksum (slow! >1 Gb download)" );         parser.acceptsAll( asList( "t", "threading" ),             "Threading mode (0=single, 1=multi); single is slower, but better for diagnostics)" )             .withRequiredArg().ofType( int.class ).defaultsTo( 1 );         parser.acceptsAll( asList( "w", "write-config" ),             "Write editable book list to config.xml, enabling you to update MD5 checksums or add new books" );          parser.printHelpOn( sink );          assertHelpLines(             "Option                     Description                                          ",             "------                     -----------                                          ",             "-?, --help                 Display this help text                               ",             "-c, --check-avail          Check Galileo homepage for available books, compare  ",             "                             with known ones                                    ",             "-d, --download-dir <File>  Download directory for openbooks; must exist         ",             "                             (default: .)                                       ",             "-l, --log-level <Integer>  Log level (0=normal, 1=verbose, 2=debug, 3=trace     ",             "                             (default: 0)                                       ",             "-m, --check-md5            Download all known books without storing them,       ",             "                             verifying their MD5 checksum (slow! >1 Gb download)",             "-t, --threading <Integer>  Threading mode (0=single, 1=multi); single is        ",             "                             slower, but better for diagnostics) (default: 1)   ",             "-w, --write-config         Write editable book list to config.xml, enabling you ",             "                             to update MD5 checksums or add new books           ",             EMPTY );     }      private void assertHelpLines( String... expectedLines ) {         assertEquals(             Stream.of( expectedLines ).collect( joining( LINE_SEPARATOR ) ),             sink.toString() );     }      private static class FakeOutputStream extends ByteArrayOutputStream {         boolean closed;         boolean flushed;          @Override         public void close() {             this.closed = true;         }          @Override         public void flush() {             this.flushed = true;         }     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class WAsAbbreviationForLongOptionTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "Wally" ).withRequiredArg();     }      @Test     public void abbreviation() {         OptionSet options = parser.parse( "--W", "silent" );          assertOptionDetected( options, "Wally" );         assertOptionNotDetected( options, "W" );         assertEquals( singletonList( "silent" ), options.valuesOf( "Wally" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void recognizeLongOptionsTrumpsLongOptionAbbreviation() {         parser.recognizeAlternativeLongOptions( true );          thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "silent" ) );          parser.parse( "--W", "silent" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static joptsimple.ExceptionMatchers.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionParserOptionExceptionTest extends AbstractOptionParserFixture {     @Test     public void unrecognizedOption() {         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "a" ) );          parser.parse( "-a" );     }      @Test     public void illegalOptionCharacter() {         thrown.expect( IllegalOptionSpecificationException.class );         thrown.expect( withOption( "%" ) );          parser.accepts( "%" );     }      @Test     public void asteriskIsIllegalOptionCharacter() {         thrown.expect( IllegalOptionSpecificationException.class );         thrown.expect( withOption( "*" ) );          parser.accepts( "*" );     }      @Test     public void tooManyHyphens() {         parser.accepts( "b" );         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "-b" ) );          parser.parse( "---b" );     }      @Test     public void valueOfWhenMultiples() {         parser.accepts( "e" ).withRequiredArg();         OptionSet options = parser.parse( "-e", "foo", "-e", "bar" );         thrown.expect( MultipleArgumentsForOptionException.class );         thrown.expect( withOption( "e" ) );          options.valueOf( "e" );     }      @Test     public void valueOfOptionalWhenMultiples() {         parser.accepts( "e" ).withRequiredArg();         OptionSet options = parser.parse( "-e", "foo", "-e", "bar" );         thrown.expect( MultipleArgumentsForOptionException.class );         thrown.expect( withOption( "e" ) );          options.valueOfOptional( "e" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */  package joptsimple;  import java.util.Optional;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class PopulatedOptionSetTest {     private OptionSet populated;      @Before     public void setUp() {         populated = new OptionSet( emptyMap() );         populated.add( new NoArgumentOptionSpec( "a" ) );         populated.addWithArgument( new RequiredArgumentOptionSpec<String>( "b" ), "arg-of-b" );     }      @Test     public void hasArgument() {         assertFalse( populated.hasArgument( "a" ) );         assertTrue( populated.hasArgument( "b" ) );     }      @Test     public void valueOf() {         assertNull( populated.valueOf( "a" ) );         assertEquals( "arg-of-b", populated.valueOf( "b" ) );     }      @Test     public void valueOfOptional() {         assertEquals( Optional.empty(), populated.valueOfOptional( "a" ) );         assertEquals( Optional.of( "arg-of-b" ), populated.valueOfOptional( "b" ) );     }      @Test     public void valuesOf() {         assertEquals( emptyList(), populated.valuesOf( "a" ) );         assertEquals( singletonList( "arg-of-b" ), populated.valuesOf( "b" ) );     }      @Test     public void hasOptions() {         assertTrue( populated.hasOptions() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ClusterVersusLongOptionWithRequiredArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "fox" );         parser.accepts( "f" );         parser.accepts( "o" );         parser.accepts( "x" ).withRequiredArg();     }      @Test     public void resolvesToLongOptionEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "--fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesToLongOptionWithSingleDashEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "-fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesAbbreviationToLongOption() {         OptionSet options = parser.parse( "-fo" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );     }      @Test     public void resolvesShortOptionToShortOption() {         OptionSet options = parser.parse( "-f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     }      @Test     public void resolvesShortOptionToShortOptionEvenWithDoubleHyphen() {         OptionSet options = parser.parse( "--f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     }      @Test     public void resolvesToShortOptionsWithArgumentFollowingX() {         OptionSet options = parser.parse( "-foxbar" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertTrue( options.has( "x" ) );         assertEquals( singletonList( "bar" ), options.valuesOf( "x" ) );     }      @Test     public void shortOptionsInDifferentOrder() {         OptionSet options = parser.parse( "-fxo" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );         assertEquals( singletonList( "o" ), options.valuesOf( "x" ) );     }      @Test( expected = UnrecognizedOptionException.class )     public void longOptionWithMessedUpOrder() {         parser.parse( "--fxo" );     }      @Test     public void withArgumentComingAfterCluster() {         OptionSet options = parser.parse( "-fox", "bar" );          assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class Ctor {     private String s;      public Ctor( String s ) {         this.s = s;     }      public String getS() {         return s;     }      static Ctor valueOf( String s ) {         return new Ctor( s );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class InterleavedArgumentsTest {     @Test     public void onlyAppearingToHaveOptionArguments() {         OptionParser parser = new OptionParser( "c" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( emptyList(), options.valuesOf( "c" ) );         assertEquals( asList( "a", "b", "c", "d" ), options.nonOptionArguments() );     }      @Test     public void onlyAppearingToHaveOptionArgumentsButPosixlyCorrect() {         OptionParser parser = new OptionParser( "+c" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( emptyList(), options.valuesOf( "c" ) );         assertEquals(             asList( "a", "-c", "b", "-c", "c", "-c", "d" ),             options.nonOptionArguments() );     }      @Test     public void requiredArgument() {         OptionParser parser = new OptionParser( "c:" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( asList( "a", "b", "c", "d" ), options.valuesOf( "c" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void requiredArgumentAndPosixlyCorrect() {         OptionParser parser = new OptionParser( "+c:" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( asList( "a", "b", "c", "d" ), options.valuesOf( "c" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionalArgument() {         OptionParser parser = new OptionParser( "c::" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( asList( "a", "b", "c", "d" ), options.valuesOf( "c" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionalArgumentAndPosixlyCorrect() {         OptionParser parser = new OptionParser( "+c::" );          OptionSet options = parser.parse( "-c", "a", "-c", "b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( emptyList(), options.valuesOf( "c" ) );         assertEquals( asList( "a", "-c", "b", "-c", "c", "-c", "d" ), options.nonOptionArguments() );     }      @Test     public void leadingNonOptionCausesPosixlyCorrectToIgnoreRemainder() {         OptionParser parser = new OptionParser( "+c:" );         String[] args = { "boo", "-c", "a", "-c", "b", "-c", "c", "-c", "d" };          OptionSet options = parser.parse( args );          assertFalse( options.has( "c" ) );         assertEquals( emptyList(), options.valuesOf( "c" ) );         assertEquals( asList( args ), options.nonOptionArguments() );     }      @Test     public void optionalAbuttedArgumentVersusPosixlyCorrect() {         OptionParser parser = new OptionParser( "+c::" );          OptionSet options = parser.parse( "-ca", "-cb", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( asList( "a", "b" ), options.valuesOf( "c" ) );         assertEquals( asList( "c", "-c", "d" ), options.nonOptionArguments() );     }      @Test     public void optionalKeyValuePairArgumentVersusPosixlyCorrect() {         OptionParser parser = new OptionParser( "+c::" );          OptionSet options = parser.parse( "-c=a", "-c=b", "-c", "c", "-c", "d" );          assertTrue( options.has( "c" ) );         assertEquals( asList( "a", "b" ), options.valuesOf( "c" ) );         assertEquals( asList( "c", "-c", "d" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Collection;  import static com.google.common.collect.Lists.newArrayList; import static java.util.Arrays.*;  import joptsimple.util.KeyValuePair; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import static org.hamcrest.CoreMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ @RunWith( Parameterized.class ) public class ToStringTest {     private final Object subject;     private final String[] substrings;      public ToStringTest( Object subject, String[] substrings ) {         this.subject = subject;         this.substrings = substrings.clone();     }      @Parameterized.Parameters     public static Collection<?> objectsAndStringRepresentations() {         return asList( new Object[][] {             { KeyValuePair.valueOf( "key=value" ), new String[] { "key", "=", "value" } },             { new UnrecognizedOptionException( "a" ), new String[] { "a" } },             { new NoArgumentOptionSpec( asList( "a", "b" ), "" ), new String[] { "[a, b]" } },             { new UnavailableOptionException(                     newArrayList( new NoArgumentOptionSpec( "a" ), new NoArgumentOptionSpec( "b" ) ) ),               new String[] { "[a, b]" } },         } );     }      @Test     public void givesUsefulStringRepresentations() {         String stringRepresentation = subject.toString();          for ( String each : substrings )             assertThat( stringRepresentation, containsString( each ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class WAsShortOptionTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "W" );     }      @Test     public void wIsLegal() {         OptionSet options = parser.parse( "-W", "silent" );          assertOptionDetected( options, "W" );         assertEquals( emptyList(), options.valuesOf( "W" ) );         assertEquals( singletonList( "silent" ), options.nonOptionArguments() );     }      @Test     public void recognizeLongOptionsTrumpsShortOptionW() {         parser.recognizeAlternativeLongOptions( true );          thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "silent" ) );          parser.parse( "-W", "silent" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.infinitest.toolkit.EqualsHashCodeTestSupport; import org.junit.Test;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public abstract class AbstractOptionSpecFixture extends EqualsHashCodeTestSupport {     @Override     protected AbstractOptionSpec<?> equal() {         return createEqualOptionSpecInstance();     }      @Override     protected AbstractOptionSpec<?> notEqual() {         return createNotEqualOptionSpecInstance();     }      protected abstract AbstractOptionSpec<?> createEqualOptionSpecInstance();      protected abstract AbstractOptionSpec<?> createNotEqualOptionSpecInstance();      @Test( expected = NullPointerException.class )     public final void valuesWithNullOptionSet() {         createEqualOptionSpecInstance().values( null );     }      @Test( expected = NullPointerException.class )     public final void valueWithNullOptionSet() {         createNotEqualOptionSpecInstance().value( null );     }      @Test( expected = NullPointerException.class )     public final void valueOptionalWithNullOptionSet() {         createNotEqualOptionSpecInstance().valueOptional( null );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class CreateWithOptionSpecificationStringTest {     @Test     public void createsParserWithOptionSpecificationString() {         OptionParser first = new OptionParser() {             {                 accepts( "i" ).withOptionalArg();                 accepts( "j" ).withRequiredArg();                 accepts( "k" );             }         };          OptionParser second = new OptionParser( "i::j:k" );          String[] args = { "-k", "-ifoo", "-jbar" };         assertEquals( first.parse( args ), second.parse( args ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class AbbreviationMapToJavaUtilMapTest {     private AbbreviationMap<String> abbreviations;      @Before     public void setUp() {         abbreviations = new AbbreviationMap<>();     }      @Test     public void empty() {         assertEquals( emptyMap(), abbreviations.toJavaUtilMap() );     }      @Test     public void addingOne() {         abbreviations.put( "box", "2" );          assertEquals( singletonMap( "box", "2" ), abbreviations.toJavaUtilMap() );     }      @Test     public void addingManyWithNoCommonPrefix() {         abbreviations.put( "box", "1" );         abbreviations.put( "cat", "2" );         abbreviations.put( "dog", "3" );          assertEquals( "{box=1, cat=2, dog=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addingTwoWithCommonPrefix() {         abbreviations.put( "box", "3" );         abbreviations.put( "boy", "4" );          assertEquals( "{box=3, boy=4}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addingThreeWithSuccessivelySmallerPrefixes() {         abbreviations.put( "boy", "3" );         abbreviations.put( "bo", "2" );         abbreviations.put( "b", "1" );          assertEquals( "{b=1, bo=2, boy=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addingThreeWithSuccessivelyLargerPrefixes() {         abbreviations.put( "b", "1" );         abbreviations.put( "bo", "2" );         abbreviations.put( "boy", "3" );          assertEquals( "{b=1, bo=2, boy=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addingThreeWithMixOfPrefixSize() {         abbreviations.put( "boy", "3" );         abbreviations.put( "b", "1" );         abbreviations.put( "bo", "2" );          assertEquals( "{b=1, bo=2, boy=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addingOneThenReplacing() {         abbreviations.put( "box", "2" );         abbreviations.put( "box", "3" );          assertEquals( "{box=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void removeKeyWithCommonPrefix() {         abbreviations.put( "box", "-1" );         abbreviations.put( "boy", "-2" );         abbreviations.remove( "box" );          assertEquals( "{boy=-2}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addKeysWithCommonPrefixesStairstepStyle() {         abbreviations.put( "a", "1" );         abbreviations.put( "abc", "2" );         abbreviations.put( "abcde", "3" );          assertEquals( "{a=1, abc=2, abcde=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void addKeysWithCommonPrefixesStairstepStyleJumbled() {         abbreviations.put( "a", "1" );         abbreviations.put( "abcde", "3" );         abbreviations.put( "abc", "2" );          assertEquals( "{a=1, abc=2, abcde=3}", abbreviations.toJavaUtilMap().toString() );     }      @Test     public void multipleKeysWithCommonPrefix() {         abbreviations.put( "good", "4" );         abbreviations.put( "goodyear", "8" );         abbreviations.put( "go", "2" );         abbreviations.put( "goodyea", "7" );         abbreviations.put( "goodye", "6" );         abbreviations.remove( "goodyea" );          assertEquals( "{go=2, good=4, goodye=6, goodyear=8}", abbreviations.toJavaUtilMap().toString() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ class Problematic {     private Problematic() {         // no-op     }      Problematic( String s ) {         throw new IllegalStateException(s);     }      private static void boo() {         // no-op     }      static void mute() {         new Problematic().stuff();     }      void stuff() {         boo();     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import java.lang.reflect.Constructor; import java.lang.reflect.Method;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.internal.Reflection.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ReflectionTest {     @Rule public final ExpectedException thrown = none();      @Test     public void invokingConstructorQuietlyWrapsInstantiationException() throws Exception {         Constructor<AbstractProblematic> constructor = AbstractProblematic.class.getDeclaredConstructor();          thrown.expect( ReflectionException.class );         thrown.expectMessage( InstantiationException.class.getName() );          instantiate( constructor );     }      @Test     public void invokingConstructorQuietlyWrapsIllegalAccessException() throws Exception {         Constructor<Problematic> constructor = Problematic.class.getDeclaredConstructor();          thrown.expect( ReflectionException.class );         thrown.expectMessage( IllegalAccessException.class.getName() );          instantiate( constructor );     }      @Test     public void invokingConstructorQuietlyWrapsCauseOfInvocationTargetException() throws Exception {         Constructor<Problematic> constructor = Problematic.class.getDeclaredConstructor( String.class );          thrown.expect( ReflectionException.class );         thrown.expectMessage( IllegalStateException.class.getName() );          instantiate( constructor, "arg" );     }      @Test     public void invokingConstructorQuietlyWrapsIllegalArgumentException() throws Exception {         Constructor<Problematic> constructor = Problematic.class.getDeclaredConstructor(String.class);          thrown.expect( ReflectionException.class );         thrown.expectMessage( IllegalArgumentException.class.getName() );          instantiate( constructor );     }      @Test     public void invokingStaticMethodQuietlyWrapsIllegalAccessException() throws Exception {         Method method = Problematic.class.getDeclaredMethod( "boo" );          thrown.expect( ReflectionException.class );         thrown.expectMessage( IllegalAccessException.class.getName() );          invoke( method );     }      @Test     public void invokingStaticMethodQuietlyWrapsIllegalArgumentException() throws Exception {         Method method = Problematic.class.getDeclaredMethod( "mute" );          thrown.expect( ReflectionException.class );         thrown.expectMessage( IllegalArgumentException.class.getName() );          invoke( method, new Object() );     }      private abstract static class AbstractProblematic {         protected AbstractProblematic() {             // no-op         }     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import java.util.List; import java.util.Map;  import org.junit.Test;  import static java.util.Arrays.*;  import static org.junit.Assert.*;  public class SimpleOptionNameMapTest {     private static final Integer VALUE = 1;     private static final String KEY = "someKey";     private static final String KEY2 = "someOtherKey";      @Test     public void putAndContains() {         SimpleOptionNameMap<Integer> map = new SimpleOptionNameMap<>();         assertFalse( map.contains( KEY ) );          map.put( KEY, 1 );          assertTrue( map.contains( KEY ) );     }      @Test     public void get() {         SimpleOptionNameMap<Integer> map = new SimpleOptionNameMap<>();         assertNull( map.get( KEY ) );          map.put( KEY, VALUE );          assertEquals( VALUE, map.get( KEY ) );     }      @Test     public void putAll() {         SimpleOptionNameMap<Integer> map = new SimpleOptionNameMap<>();         List<String> keys = asList( KEY, KEY2 );          map.putAll( keys, VALUE );          assertEquals( VALUE, map.get( KEY ) );         assertEquals( VALUE, map.get( KEY2 ) );     }      @Test     public void remove() {         SimpleOptionNameMap<Integer> map = new SimpleOptionNameMap<>();         map.put( KEY, 1 );          map.remove( KEY );          assertFalse( map.contains( KEY ) );     }      @Test     public void toJavaUtilMap() {         SimpleOptionNameMap<Integer> map = new SimpleOptionNameMap<>();         map.put( KEY, VALUE );          Map<String, Integer> javaUtilMap = map.toJavaUtilMap();          assertEquals( VALUE, javaUtilMap.get( KEY ) );         assertEquals( 1, javaUtilMap.size() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import java.util.stream.Stream;  import static java.util.stream.Collectors.*;  import org.junit.Test;  import static joptsimple.internal.Strings.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RowsTest {     @Test     public void optionsAndDescriptionsWithinOverallWidth() {         Rows rows = new Rows( 40, 2 );         rows.add( "left one", "right one" );         rows.add( "another left one", "another right one" );          assertRows( rows,                 "left one          right one        ",                 "another left one  another right one" );     }      @Test     public void someOptionsExceedOverallWidth() {         Rows rows = new Rows( 40, 2 );         rows.add( "left one is pretty freaking long to be over here", "right one" );         rows.add( "another left one also has length that is quite excessive", "another right one" );          assertRows( rows,                 "left one is pretty  right one        ",                 "  freaking long to                   ",                 "  be over here                       ",                 "another left one    another right one",                 "  also has length                    ",                 "  that is quite                      ",                 "  excessive                          " );     }      @Test     public void someDescriptionsExceedOverallWidth() {         Rows rows = new Rows( 40, 2 );         rows.add( "left one", "right one for the time we have chosen" );         rows.add( "another left one", "another right one could be used here instead" );          assertRows( rows,             "left one          right one for the    ",             "                    time we have chosen",             "another left one  another right one    ",             "                    could be used here ",             "                    instead            " );     }      private void assertRows( Rows rows, String... expected ) {         rows.fitToWidth();          assertEquals(             Stream.of( expected ).collect( joining( LINE_SEPARATOR ) ) + LINE_SEPARATOR,             rows.render() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import joptsimple.UtilityClassesUninstantiabilityHarness;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ReflectionUtilityClassTest extends UtilityClassesUninstantiabilityHarness {     public ReflectionUtilityClassTest() {         super( Reflection.class );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import joptsimple.UtilityClassesUninstantiabilityHarness;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ClassesUtilityClassTest extends UtilityClassesUninstantiabilityHarness {     public ClassesUtilityClassTest() {         super( Classes.class );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import org.infinitest.toolkit.StrictEqualsHashCodeTestSupport;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RowEqualsHashCodeTest extends StrictEqualsHashCodeTestSupport {     @Override     protected Object equalButDifferentClass() {         return new Row( "o", "d" ) {         };     }      @Override     protected Object equal() throws Exception {         return new Row( "o", "d" );     }      @Override     protected Object notEqual() throws Exception {         return new Row( "o", "e" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import joptsimple.UtilityClassesUninstantiabilityHarness;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class MessagesUtilityClassTest extends UtilityClassesUninstantiabilityHarness {     public MessagesUtilityClassTest() {         super( Messages.class );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class AbbreviationMapTest {     private AbbreviationMap<String> abbreviations;      @Before     public void setUp() {         abbreviations = new AbbreviationMap<>();     }      @Test( expected = NullPointerException.class )     public void nullValuesAreIllegal() {         abbreviations.put( "cannotAddNullValue", null );     }      @Test( expected = NullPointerException.class )     public void nullKeysAreIllegalToAdd() {         abbreviations.put( null, "-1" );     }      @Test( expected = NullPointerException.class )     public void nullKeysAreIllegalToCheckForContains() {         abbreviations.contains( null );     }      @Test( expected = IllegalArgumentException.class )     public void zeroLengthKeysAreIllegalToAdd() {         abbreviations.put( "", "1" );     }      @Test( expected = NullPointerException.class )     public void nullKeysAreIllegalToRemove() {         abbreviations.remove( null );     }      @Test( expected = IllegalArgumentException.class )     public void zeroLengthKeysAreIllegalToRemove() {         abbreviations.remove( "" );     }      @Test     public void empty() {         assertFalse( abbreviations.contains( "boo" ) );         assertNull( abbreviations.get( "boo" ) );     }      @Test     public void addingOne() {         abbreviations.put( "box", "2" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "2", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "2", abbreviations.get( "b" ) );     }      @Test     public void addingManyWithNoCommonPrefix() {         abbreviations.put( "box", "1" );         abbreviations.put( "cat", "2" );         abbreviations.put( "dog", "3" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "1", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "1", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "1", abbreviations.get( "b" ) );         assertTrue( abbreviations.contains( "cat" ) );         assertEquals( "2", abbreviations.get( "cat" ) );         assertTrue( abbreviations.contains( "ca" ) );         assertEquals( "2", abbreviations.get( "ca" ) );         assertTrue( abbreviations.contains( "c" ) );         assertEquals( "2", abbreviations.get( "c" ) );         assertTrue( abbreviations.contains( "dog" ) );         assertEquals( "3", abbreviations.get( "dog" ) );         assertTrue( abbreviations.contains( "do" ) );         assertEquals( "3", abbreviations.get( "do" ) );         assertTrue( abbreviations.contains( "d" ) );         assertEquals( "3", abbreviations.get( "d" ) );     }      @Test     public void addingTwoWithCommonPrefix() {         abbreviations.put( "box", "3" );         abbreviations.put( "boy", "4" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "3", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "4", abbreviations.get( "boy" ) );         assertFalse( abbreviations.contains( "bo" ) );         assertNull( abbreviations.get( "bo" ) );         assertFalse( abbreviations.contains( "b" ) );         assertNull( abbreviations.get( "b" ) );     }      @Test     public void addingThreeWithSuccessivelySmallerPrefixes() {         abbreviations.put( "boy", "3" );         abbreviations.put( "bo", "2" );         abbreviations.put( "b", "1" );          assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "3", abbreviations.get( "boy" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "1", abbreviations.get( "b" ) );     }      @Test     public void addingThreeWithSuccessivelyLargerPrefixes() {         abbreviations.put( "b", "1" );         abbreviations.put( "bo", "2" );         abbreviations.put( "boy", "3" );          assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "3", abbreviations.get( "boy" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "1", abbreviations.get( "b" ) );     }      @Test     public void addingThreeWithMixOfPrefixSize() {         abbreviations.put( "boy", "3" );         abbreviations.put( "b", "1" );         abbreviations.put( "bo", "2" );          assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "3", abbreviations.get( "boy" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "1", abbreviations.get( "b" ) );     }      @Test     public void addingOneThenReplacing() {         abbreviations.put( "box", "2" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "2", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "2", abbreviations.get( "b" ) );          abbreviations.put( "box", "3" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "3", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "3", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "3", abbreviations.get( "b" ) );     }      @Test     public void removingNonExistentKeyHasNoEffect() {         abbreviations.put( "box", "2" );          abbreviations.remove( "cat" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "2", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "2", abbreviations.get( "b" ) );     }      @Test     public void removingSingleKey() {         abbreviations.put( "box", "3" );          abbreviations.remove( "box" );          assertFalse( abbreviations.contains( "box" ) );         assertNull( abbreviations.get( "box" ) );         assertFalse( abbreviations.contains( "bo" ) );         assertNull( abbreviations.get( "bo" ) );         assertFalse( abbreviations.contains( "b" ) );         assertNull( abbreviations.get( "b" ) );     }      @Test     public void cannotRemoveByUniqueAbbreviation() {         abbreviations.put( "box", "4" );          abbreviations.remove( "bo" );         abbreviations.remove( "b" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "4", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "4", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "4", abbreviations.get( "b" ) );     }      @Test     public void removeKeyWithCommonPrefix() {         abbreviations.put( "box", "-1" );         abbreviations.put( "boy", "-2" );          abbreviations.remove( "box" );          assertFalse( abbreviations.contains( "box" ) );         assertNull( abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "-2", abbreviations.get( "boy" ) );         assertTrue( abbreviations.contains( "bo" ) );         assertEquals( "-2", abbreviations.get( "bo" ) );         assertTrue( abbreviations.contains( "b" ) );         assertEquals( "-2", abbreviations.get( "b" ) );     }      @Test     public void addKeysWithCommonPrefixThenRemoveNonExistentKeyWithCommonPrefix() {         abbreviations.put( "box", "-1" );         abbreviations.put( "boy", "-2" );          abbreviations.remove( "bop" );          assertTrue( abbreviations.contains( "box" ) );         assertEquals( "-1", abbreviations.get( "box" ) );         assertTrue( abbreviations.contains( "boy" ) );         assertEquals( "-2", abbreviations.get( "boy" ) );         assertFalse( abbreviations.contains( "bo" ) );         assertNull( abbreviations.get( "bo" ) );         assertFalse( abbreviations.contains( "b" ) );         assertNull( abbreviations.get( "b" ) );     }      @Test     public void addKeysWithCommonPrefixesStairstepStyle() {         abbreviations.put( "a", "1" );         abbreviations.put( "abc", "2" );          assertTrue( abbreviations.contains( "a" ) );         assertEquals( "1", abbreviations.get( "a" ) );         assertTrue( abbreviations.contains( "ab" ) );         assertEquals( "2", abbreviations.get( "ab" ) );         assertTrue( abbreviations.contains( "abc" ) );         assertEquals( "2", abbreviations.get( "abc" ) );          abbreviations.put( "abcde", "3" );          assertTrue( abbreviations.contains( "a" ) );         assertEquals( "1", abbreviations.get( "a" ) );         assertFalse( abbreviations.contains( "ab" ) );         assertNull( abbreviations.get( "ab" ) );         assertTrue( abbreviations.contains( "abc" ) );         assertEquals( "2", abbreviations.get( "abc" ) );         assertTrue( abbreviations.contains( "abcd" ) );         assertEquals( "3", abbreviations.get( "abcd" ) );         assertTrue( abbreviations.contains( "abcde" ) );         assertEquals( "3", abbreviations.get( "abcde" ) );     }      @Test     public void addKeysWithCommonPrefixesStairstepStyleJumbled() {         abbreviations.put( "a", "1" );         abbreviations.put( "abcde", "3" );         abbreviations.put( "abc", "2" );          assertTrue( abbreviations.contains( "a" ) );         assertEquals( "1", abbreviations.get( "a" ) );         assertFalse( abbreviations.contains( "ab" ) );         assertNull( abbreviations.get( "ab" ) );         assertTrue( abbreviations.contains( "abc" ) );         assertEquals( "2", abbreviations.get( "abc" ) );         assertTrue( abbreviations.contains( "abcd" ) );         assertEquals( "3", abbreviations.get( "abcd" ) );         assertTrue( abbreviations.contains( "abcde" ) );         assertEquals( "3", abbreviations.get( "abcde" ) );     }      @Test     public void multipleKeysWithCommonPrefix() {         abbreviations.put( "good", "4" );         abbreviations.put( "goodyear", "8" );         abbreviations.put( "go", "2" );         abbreviations.put( "goodyea", "7" );         abbreviations.put( "goodye", "6" );          assertFalse( abbreviations.contains( "g" ) );         assertNull( abbreviations.get( "g" ) );         assertTrue( abbreviations.contains( "go" ) );         assertEquals( "2", abbreviations.get( "go" ) );         assertFalse( abbreviations.contains( "goo" ) );         assertNull( abbreviations.get( "goo" ) );         assertTrue( abbreviations.contains( "good" ) );         assertEquals( "4", abbreviations.get( "good" ) );         assertFalse( abbreviations.contains( "goody" ) );         assertNull( abbreviations.get( "goody" ) );         assertTrue( abbreviations.contains( "goodye" ) );         assertEquals( "6", abbreviations.get( "goodye" ) );         assertTrue( abbreviations.contains( "goodyea" ) );         assertEquals( "7", abbreviations.get( "goodyea" ) );         assertTrue( abbreviations.contains( "goodyea" ) );         assertEquals( "8", abbreviations.get( "goodyear" ) );          abbreviations.remove( "goodyea" );          assertFalse( abbreviations.contains( "g" ) );         assertNull( abbreviations.get( "g" ) );         assertTrue( abbreviations.contains( "go" ) );         assertEquals( "2", abbreviations.get( "go" ) );         assertFalse( abbreviations.contains( "goo" ) );         assertNull( abbreviations.get( "goo" ) );         assertTrue( abbreviations.contains( "good" ) );         assertEquals( "4", abbreviations.get( "good" ) );         assertFalse( abbreviations.contains( "goody" ) );         assertNull( abbreviations.get( "goody" ) );         assertTrue( abbreviations.contains( "goodye" ) );         assertEquals( "6", abbreviations.get( "goodye" ) );         assertTrue( abbreviations.contains( "goodyea" ) );         assertEquals( "8", abbreviations.get( "goodyea" ) );         assertTrue( abbreviations.contains( "goodyea" ) );         assertEquals( "8", abbreviations.get( "goodyear" ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.internal;  import joptsimple.UtilityClassesUninstantiabilityHarness;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class StringsUtilityClassTest extends UtilityClassesUninstantiabilityHarness {     public StringsUtilityClassTest() {         super( Strings.class );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RequiredArgumentOptionSpecEqualsHashCodeTest extends AbstractOptionSpecFixture {     @Override     protected RequiredArgumentOptionSpec<?> createEqualOptionSpecInstance() {         return new RequiredArgumentOptionSpec<Void>( "a" );     }      @Override     protected RequiredArgumentOptionSpec<?> createNotEqualOptionSpecInstance() {         return new RequiredArgumentOptionSpec<Void>( "b" );     } } 
/*  The MIT License   Copyright (c) 2004-2014 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Collections.emptyList;  import static org.junit.Assert.assertEquals;  public class AvailableUnlessAnyTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         parser.accepts( "a" );         parser.accepts( "b" );         OptionSpec<Void> c = parser.accepts( "c" );         parser.accepts( "d" );         parser.accepts( "n" ).availableUnless( "a" ).availableUnless( c );     }      @Test     public void rejectsCommandLineExistingForbiddenOption() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-a", "-n" );     }      @Test     public void rejectsCommandLineExistingOtherForbiddenOption() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-c", "-n" );     }      @Test     public void rejectsCommandLineOnlyForbiddenOption() {         OptionSet options = parser.parse( "-n" );          assertOptionDetected( options, "n" );     }      @Test     public void rejectsCommandLineWithNotAllConditionallyRequiredOptionsPresent() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-a", "-c", "-n" );     }      @Test     public void acceptsCommandLineWithAllowedOptionsPresent() {         OptionSet options = parser.parse( "-d", "-b", "-n" );                  assertOptionDetected( options, "b" );         assertOptionDetected( options, "d" );         assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */  package joptsimple;  import org.junit.Test;  import java.util.ArrayList; import java.util.Map;  import static java.util.Arrays.*;  import static org.junit.Assert.*;  public class OptionParserRecognizedOptionsTest extends AbstractOptionParserFixture {     @Test     public void basicOptionsRecognized() {         parser.accepts( "first" ).withRequiredArg().required();         parser.accepts( "second" ).withOptionalArg();         parser.accepts( "third" ).forHelp();          Map<String, OptionSpec<?>> recognizedOptions = parser.recognizedOptions();          assertEquals( 4, recognizedOptions.size() );         assertTrue( recognizedOptions.keySet().contains( "first" ) );         assertTrue( recognizedOptions.keySet().contains( "second" ) );         assertTrue( recognizedOptions.keySet().contains( "third" ) );         assertTrue( recognizedOptions.keySet().contains( "[arguments]" ) );         assertTrue( recognizedOptions.get( "third" ).isForHelp() );         assertFalse( recognizedOptions.get( "second" ).isForHelp() );         assertNotNull( recognizedOptions.get( "first" ).options() );     }      @Test     public void parserPreservesTrainingOrder() {         parser.acceptsAll( asList( "zebra", "aardvark" ) );         parser.accepts( "yak" );         parser.acceptsAll( asList( "baboon", "xantus" ) );          assertEquals(             asList( "[arguments]", "aardvark", "zebra", "yak", "baboon", "xantus" ),             new ArrayList<>( parser.recognizedOptions().keySet() ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*;  import org.junit.Before; import org.junit.Test;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSynonymCommonPrefixesTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.acceptsAll( asList( "v", "verbose" ) );     }      @Test     public void parsingFirstPrefix() {         assertDetections( "-v" );     }      @Test     public void parsingSecondPrefix() {         assertDetections( "-ve" );     }      @Test     public void parsingThirdPrefix() {         assertDetections( "-ver" );     }      @Test     public void parsingFourthPrefix() {         assertDetections( "-verb" );     }      @Test     public void parsingFifthPrefix() {         assertDetections( "-verbo" );     }      @Test     public void parsingSixthPrefix() {         assertDetections( "-verbos" );     }      @Test     public void parsingSeventhPrefix() {         assertDetections( "-verbose" );     }      private void assertDetections( String option ) {         OptionSet options = parser.parse( option );          assertOptionDetected( options, "v" );         assertOptionNotDetected( options, "ve" );         assertOptionNotDetected( options, "ver" );         assertOptionNotDetected( options, "verb" );         assertOptionNotDetected( options, "verbo" );         assertOptionNotDetected( options, "verbos" );         assertOptionDetected( options, "verbose" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.NoSuchElementException;  import static java.util.Collections.*;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static org.infinitest.toolkit.CollectionMatchers.*; import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSpecTokenizerTest {     @Rule public final ExpectedException thrown = none();      @Test     public void tokenizeEmpty() {         assertNoMoreTokens( new OptionSpecTokenizer( "" ) );     }      @Test     public void tokenizeOptionsWithoutArguments() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "ab" );         assertNextTokenTakesNoArgument( lexer, 'a', false );         assertNextTokenTakesNoArgument( lexer, 'b', false );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithRequiredArguments() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "c:d:" );         assertNextTokenRequiresAnArgument( lexer, 'c', false );         assertNextTokenRequiresAnArgument( lexer, 'd', false );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithOptionalArguments() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "e::f::" );         assertNextTokenTakesAnOptionalArgument( lexer, 'e', false );         assertNextTokenTakesAnOptionalArgument( lexer, 'f', false );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithMixtureOfSpecTypes() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "gh:i::j" );         assertNextTokenTakesNoArgument( lexer, 'g', false );         assertNextTokenRequiresAnArgument( lexer, 'h', false );         assertNextTokenTakesAnOptionalArgument( lexer, 'i', false );         assertNextTokenTakesNoArgument( lexer, 'j', false );         assertNoMoreTokens( lexer );     }      @Test     public void wByItself() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W" );         assertNextTokenTakesNoArgument( lexer, 'W', false );         assertNoMoreTokens( lexer );     }      @Test     public void wRequiredArg() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W:" );         assertNextTokenRequiresAnArgument( lexer, 'W', false );         assertNoMoreTokens( lexer );     }      @Test     public void wOptionalArg() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W::" );         assertNextTokenTakesAnOptionalArgument( lexer, 'W', false );         assertNoMoreTokens( lexer );     }      @Test     public void alternativeLongOptionsMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W;" );         assertNextTokenRequiresAnArgument( lexer, 'W', false );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithoutArgumentsAndHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "ab*" );         assertNextTokenTakesNoArgument( lexer, 'a', false );         assertNextTokenTakesNoArgument( lexer, 'b', true );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithRequiredArgumentsAndHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "c*:d:" );         assertNextTokenRequiresAnArgument( lexer, 'c', true );         assertNextTokenRequiresAnArgument( lexer, 'd', false );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithOptionalArgumentsAndHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "e*::f*::" );         assertNextTokenTakesAnOptionalArgument( lexer, 'e', true );         assertNextTokenTakesAnOptionalArgument( lexer, 'f', true );         assertNoMoreTokens( lexer );     }      @Test     public void tokenizeOptionsWithMixtureOfSpecTypesAndHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "g*h:i*::j" );         assertNextTokenTakesNoArgument( lexer, 'g', true );         assertNextTokenRequiresAnArgument( lexer, 'h', false );         assertNextTokenTakesAnOptionalArgument( lexer, 'i', true );         assertNextTokenTakesNoArgument( lexer, 'j', false );         assertNoMoreTokens( lexer );     }      @Test     public void wByItselfWithHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W*" );         assertNextTokenTakesNoArgument( lexer, 'W', true );         assertNoMoreTokens( lexer );     }      @Test     public void wRequiredArgWithHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W*:" );         assertNextTokenRequiresAnArgument( lexer, 'W', true );         assertNoMoreTokens( lexer );     }      @Test     public void wOptionalArgWithHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W*::" );         assertNextTokenTakesAnOptionalArgument( lexer, 'W', true );         assertNoMoreTokens( lexer );     }      @Test     public void alternativeLongOptionsMarkerWithHelpMarker() {         OptionSpecTokenizer lexer = new OptionSpecTokenizer( "W*;" );         assertNextTokenTakesNoArgument( lexer, 'W', true );     }      private void assertNoMoreTokens( OptionSpecTokenizer lexer ) {         assertFalse( lexer.hasMore() );          thrown.expect( NoSuchElementException.class );         lexer.next();     }      private static void assertNextTokenTakesNoArgument( OptionSpecTokenizer lexer, char option, boolean forHelp ) {         assertNextToken( lexer, option, false, false, forHelp );     }      private static void assertNextTokenRequiresAnArgument( OptionSpecTokenizer lexer, char option, boolean forHelp ) {         assertNextToken( lexer, option, true, true, forHelp );     }      private static void assertNextTokenTakesAnOptionalArgument( OptionSpecTokenizer lexer, char option,         boolean forHelp ) {          assertNextToken( lexer, option, true, false, forHelp );     }      private static void assertNextToken( OptionSpecTokenizer lexer, char option, boolean acceptsArguments,         boolean requiresArgument, boolean forHelp ) {          assertTrue( "no more tokens?", lexer.hasMore() );         AbstractOptionSpec<?> spec = lexer.next();         assertThat( "option?", spec.options(), hasSameContentsAs( singleton( String.valueOf( option ) ) ) );         assertEquals( "accepts args?", acceptsArguments, spec.acceptsArguments() );         assertEquals( "requires arg?", requiresArgument, spec.requiresArgument() );         assertEquals( "for help?", forHelp, spec.isForHelp() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*;  import joptsimple.util.KeyValuePair; import org.junit.Before; import org.junit.Test;  import static joptsimple.util.KeyValuePair.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class JVMSystemPropertiesArgumentParsingTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "D" ).withRequiredArg().ofType( KeyValuePair.class );     }      @Test     public void parsingJVMSystemPropertiesArguments() {         OptionSet options = parser.parse( "-Dfile.encoding=UTF-8", "-Dpath.separator=:" );         assertEquals(             asList( valueOf( "file.encoding=UTF-8" ), valueOf( "path.separator=:" ) ),             options.valuesOf( "D" ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Optional;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class EmptyOptionSetTest {     private OptionSet empty;      @Before     public void setUp() {         empty = new OptionSet( emptyMap() );         empty.add( new NonOptionArgumentSpec<>() );     }      @Test     public void valueOf() {         assertNull( empty.valueOf( "a" ) );     }      @Test     public void valueOfOptional() {         assertEquals( Optional.empty(), empty.valueOfOptional( "a" ) );     }      @Test     public void valuesOf() {         assertEquals( emptyList(), empty.valuesOf( "a" ) );     }      @Test     public void hasArgument() {         assertFalse( empty.hasArgument( "a" ) );     }      @Test     public void hasOptions() {         assertFalse( empty.hasOptions() );     }      @Test( expected = NullPointerException.class )     public void valueOfWithNullString() {         empty.valueOf( (String) null );     }      @Test( expected = NullPointerException.class )     public void valueOfOptionalWithNullString() {         empty.valueOfOptional( (String) null );     }      @Test( expected = NullPointerException.class )     public void valueOfOptionalWithNullOptionSpec() {         empty.valueOfOptional( (OptionSpec<?>) null );     }      @Test( expected = NullPointerException.class )     public void valueOfWithNullOptionSpec() {         empty.valueOf( (OptionSpec<?>) null );     }      @Test( expected = NullPointerException.class )     public void valuesOfWithNullString() {         empty.valuesOf( (String) null );     }      @Test( expected = NullPointerException.class )     public void valuesOfWithNullOptionSpec() {         empty.valuesOf( (OptionSpec<?>) null );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.IOException; import java.io.StringWriter; import java.util.Arrays;  import org.junit.Test;  import static java.util.Arrays.*; import static org.junit.Assert.*;  public class HelpDisplayForOptionsWithConvertedDefaultValuesTest     extends AbstractOptionParserFixture {      @Test     public void respectsRevertedDefaultValues() throws Exception {         parser.acceptsAll(             asList( "t", "traceIncrements" ),             "Turns tracing of increment requests 'on' or 'off'." )             .withRequiredArg()             .describedAs( "trace" )             .withValuesConvertedBy( new SwitchConverter() )             .defaultsTo( false );         StringWriter sink = new StringWriter();          parser.printHelpOn( sink );          String help = sink.toString();         assertFalse( help.contains( "false" ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetValuesOfOptionStringImmutabilityTest extends UnmodifiableListTestSupport<Object> {     @SuppressWarnings( "unchecked" )     @Override     protected List<Object> newList() {         RequiredArgumentOptionSpec<String> optionB = new RequiredArgumentOptionSpec<>( "b" );         OptionSet options = new OptionSet( emptyMap() );         options.addWithArgument( optionB, "foo" );          options.addWithArgument( optionB, "bar" );          return (List<Object>) options.valuesOf( "b" );     }      @Override     protected String newItem() {         return "baz";     }      @Override     protected String containedItem() {         return "bar";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Optional;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ShortOptionsRequiredArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "d" ).withRequiredArg();         parser.accepts( "e" );         parser.accepts( "f" );         parser.accepts( "infile" ).withOptionalArg();     }      @Test     public void argumentNotPresent() {         thrown.expect( OptionMissingRequiredArgumentException.class );         thrown.expect( withOption( "d" ) );          parser.parse( "-d" );     }      @Test     public void withArgument() {         OptionSet options = parser.parse( "-d", "foo" );          assertOptionDetected( options, "d" );         assertEquals( "foo", options.valueOf( "d" ) );         assertEquals( Optional.of( "foo" ), options.valueOfOptional( "d" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void clusteredOptionsWithLastOneAcceptingAnArgumentButMissing() {         thrown.expect( OptionMissingRequiredArgumentException.class );                  parser.parse( "-fed" );     }          @Test     public void clusteredOptionsWithLastOneAcceptingAnArgument() {         OptionSet options = parser.parse( "-fed", "foo" );                  assertOptionDetected( options, "d" );         assertOptionDetected( options, "f" );         assertOptionDetected( options, "e" );         assertEquals( "foo", options.valueOf( "d" ) );         assertEquals( Optional.of( "foo" ), options.valueOfOptional( "d" ) );     }          @Test     public void clusteredOptionsWithOneAcceptingAnArgument() {         OptionSet options = parser.parse( "-fde" );                  assertOptionDetected( options, "f" );         assertOptionDetected( options, "d" );         assertOptionNotDetected( options, "e" );                  assertEquals( "e", options.valueOf( "d" ) );         assertEquals( Optional.of( "e" ), options.valueOfOptional( "d" ) );     }      @Test     public void argumentNotPresentFollowedByAnotherOption() {         OptionSet options = parser.parse( "-d", "--infile" );          assertOptionDetected( options, "d" );         assertOptionNotDetected( options, "infile" );         assertEquals( "--infile", options.valueOf( "d" ) );         assertEquals( Optional.of( "--infile" ), options.valueOfOptional( "d" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void appearingMultipleTimes() {         OptionSet options = parser.parse( "-d", "foo", "-d", "bar" );          assertOptionDetected( options, "d" );         assertEquals( asList( "foo", "bar" ), options.valuesOf( "d" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void inSameToken() {         OptionSet options = parser.parse( "-dfoo" );          assertOptionDetected( options, "d" );         assertEquals( singletonList( "foo" ), options.valuesOf( "d" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void whenEndOfOptionsMarkerIsInPlaceOfRequiredArgument() {         OptionSet options = parser.parse( "-d", "--", "foo", "bar" );          assertOptionDetected( options, "d" );         assertEquals( singletonList( "--" ), options.valuesOf( "d" ) );         assertEquals( asList( "foo", "bar" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.File;  import static java.util.Arrays.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ParsingSeparatedTypedOptionValuesTest extends AbstractOptionParserFixture {     @Test     public void parsesSeparatedValuesAsSeparateArgument() {         assertCorrectParse( "classpath", ':', "--classpath", "/usr:/opt:/var" );     }      @Test     public void parsesSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", ':', "--classpath=/usr:/opt:/var" );     }      @Test     public void parsesEqualsSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", '=', "--classpath=/usr=/opt=/var" );     }      @Test     public void parsesSeparatedValuesAbutting() {         assertCorrectParse( "c", ':', "-c/usr:/opt:/var" );     }      private void assertCorrectParse( String option, char separator, String... args ) {         parser.accepts( option ).withRequiredArg().ofType( File.class ).withValuesSeparatedBy( separator );          OptionSet options = parser.parse( args );          assertEquals(             asList( new File( "/usr" ), new File( "/opt" ), new File( "/var" ) ),             options.valuesOf( option ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import java.text.DateFormat; import java.text.FieldPosition; import java.text.NumberFormat; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Date;  import static java.text.DateFormat.*;  import joptsimple.ValueConversionException; import joptsimple.ValueConverter; import org.joda.time.LocalDate; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.util.DateConverter.*; import static org.hamcrest.CoreMatchers.*; import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class DateConverterTest {     @Rule public final ExpectedException thrown = none();      private DateFormat notASimpleDateFormat;     private SimpleDateFormat monthDayYear;      @Before     public void setUp() {         notASimpleDateFormat = new DateFormat() {             private static final long serialVersionUID = -1L;              {                 setNumberFormat( NumberFormat.getInstance() );             }              @Override             public StringBuffer format( Date date, StringBuffer toAppendTo, FieldPosition fieldPosition ) {                 return null;             }              @Override             public Date parse( String source, ParsePosition pos ) {                 return null;             }         };          monthDayYear = new SimpleDateFormat( "MM/dd/yyyy" );     }      @Test( expected = NullPointerException.class )     public void rejectsNullDateFormatter() {         new DateConverter( null );     }      @Test     public void shouldConvertValuesToDatesUsingADateFormat() {         ValueConverter<Date> converter = new DateConverter( monthDayYear );          assertEquals( new LocalDate( 2009, 1, 24 ).toDate(), converter.convert( "01/24/2009" ) );     }      @Test     public void rejectsNonParsableValues() {         thrown.expect( ValueConversionException.class );          new DateConverter( getDateInstance() ).convert( "@(#*^" );     }      @Test     public void rejectsValuesThatDoNotEntirelyMatch() {         thrown.expect( ValueConversionException.class );          new DateConverter( monthDayYear ).convert( "12/25/09 00:00:00" );     }      @Test     public void shouldCreateSimpleDateFormatConverter() {         assertEquals( new LocalDate( 2009, 7, 4 ).toDate(), datePattern( "MM/dd/yyyy" ).convert( "07/04/2009" ) );     }      @Test     public void rejectsNullDatePattern() {         thrown.expect( NullPointerException.class );          datePattern( null );     }      @Test     public void shouldRaiseExceptionThatContainsDatePatternAndValue() {         thrown.expect( ValueConversionException.class );         thrown.expectMessage( "qwe" );         thrown.expectMessage( monthDayYear.toPattern() );          new DateConverter( monthDayYear ).convert( "qwe" );     }      @Test     public void shouldRaiseExceptionThatContainsValueOnlyIfNotASimpleDateFormat() {         thrown.expect( ValueConversionException.class );         thrown.expectMessage( "asdf" );         thrown.expectMessage( not( containsString( notASimpleDateFormat.toString() ) ) );          new DateConverter( notASimpleDateFormat ).convert( "asdf" );     }      @Test     public void shouldAnswerCorrectValueType() {         assertSame( Date.class, new DateConverter( monthDayYear ).valueType() );     }      @Test     public void shouldGiveNoValuePatternIfFormatterNotASimpleDateFormat() {         assertEquals( "", new DateConverter( notASimpleDateFormat ).valuePattern() );     }      @Test     public void shouldGiveValuePatternIfFormatterIsASimpleDateFormat() {         assertEquals( monthDayYear.toPattern(), datePattern( monthDayYear.toPattern() ).valuePattern() );     } } 
package joptsimple.util;  import java.nio.file.Files; import java.nio.file.Path;  import org.junit.Test;  import static org.junit.Assert.*;  import static joptsimple.util.PathProperties.*;  public class PathPropertiesTest {     @Test     public void readableFile() throws Exception {         Path path = Files.createTempFile( "prefix", null );          path.toFile().deleteOnExit();          assertTrue( READABLE.accept( path ) );         assertFalse( DIRECTORY_EXISTING.accept( path ) );         assertTrue( FILE_EXISTING.accept( path ) );         assertTrue( FILE_OVERWRITABLE.accept( path ) );         assertTrue( WRITABLE.accept( path ) );         assertFalse( NOT_EXISTING.accept( path ) );     }      @Test     public void nonExisting() throws Exception {         Path path = Files.createTempFile( "prefix", null );          Files.deleteIfExists( path );          assertFalse( READABLE.accept( path ) );         assertFalse( DIRECTORY_EXISTING.accept( path ) );         assertFalse( FILE_EXISTING.accept( path ) );         assertFalse( FILE_OVERWRITABLE.accept( path ) );         assertTrue( NOT_EXISTING.accept( path ) );         assertFalse( WRITABLE.accept( path ) );     }      @Test     public void directory() throws Exception {         Path path = Files.createTempDirectory( "prefix" );          path.toFile().deleteOnExit();          assertTrue( READABLE.accept( path ) );         assertTrue( DIRECTORY_EXISTING.accept( path ) );         assertFalse( FILE_EXISTING.accept( path ) );         assertFalse( FILE_OVERWRITABLE.accept( path ) );         assertFalse( NOT_EXISTING.accept( path ) );         assertTrue( WRITABLE.accept( path ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import org.infinitest.toolkit.EqualsHashCodeTestSupport;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class KeyValuePairUnequalValuesTest extends EqualsHashCodeTestSupport {     @Override     protected KeyValuePair equal() {         return KeyValuePair.valueOf( "x=y" );     }      @Override     protected KeyValuePair notEqual() {         return KeyValuePair.valueOf( "x=z" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import joptsimple.ValueConversionException; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.util.RegexMatcher.*; import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RegexMatcherTest {     @Rule public final ExpectedException thrown = none();      private RegexMatcher abc;      @Before     public void setUp() {         abc = new RegexMatcher( "abc", 0 );     }      @Test     public void shouldAttemptToMatchValueAgainstARegex() {         assertEquals( "abc", abc.convert( "abc" ) );     }      @Test( expected = ValueConversionException.class )     public void rejectsValueThatDoesNotMatchRegex() {         abc.convert( "abcd" );     }      @Test     public void raisesExceptionContainingValueAndPattern() {         thrown.expect( ValueConversionException.class );         thrown.expectMessage( "\\d+" );         thrown.expectMessage( "asdf" );          new RegexMatcher( "\\d+", 0 ).convert( "asdf" );     }      @Test     public void shouldOfferConvenienceMethodForCreatingMatcherWithNoFlags() {         assertEquals( "sourceforge.net", regex( "\\w+\\.\\w+" ).convert( "sourceforge.net" ) );     }      @Test     public void shouldAnswerCorrectValueType() {         assertEquals( String.class, abc.valueType() );     }      @Test     public void shouldGiveCorrectValuePattern() {         assertEquals( "abc", abc.valuePattern() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import java.net.InetAddress; import java.util.Random;  import joptsimple.ValueConversionException; import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*; import static org.junit.Assume.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class InetAddressConverterTest {     private InetAddressConverter converter;      @Before     public void setUp() {         converter = new InetAddressConverter();     }      @Test     public void localhost() throws Exception {         assumeTrue( InetAddress.getByName( "127.0.0.1" ).isReachable( 5000 ) );          assertEquals( "127.0.0.1", converter.convert( "localhost" ).getHostAddress() );     }      @Test( expected = ValueConversionException.class )     public void unknownHost() {         converter.convert( "!(@&#()!*@&#" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import org.infinitest.toolkit.EqualsHashCodeTestSupport;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class KeyValuePairUnequalKeysTest extends EqualsHashCodeTestSupport {     @Override     protected KeyValuePair equal() {         return KeyValuePair.valueOf( "x=z" );     }      @Override     protected KeyValuePair notEqual() {         return KeyValuePair.valueOf( "y=z" );     } } 
package joptsimple.util;  import java.nio.file.Files; import java.nio.file.Path;  import joptsimple.ValueConversionException; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.util.PathProperties.*; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  public class PathConverterTest {     @Rule     public ExpectedException exception = ExpectedException.none();      @Test     public void convertsValuesToPaths() throws Exception {         Path path = Files.createTempFile( "prefix", null );         path.toFile().deleteOnExit();          String pathName = path.toString();          assertEquals( path, new PathConverter( (PathProperties[]) null ).convert( pathName ) );         assertEquals( path, new PathConverter().convert( pathName ) );     }      @Test     public void answersCorrectValueType() {         assertEquals( Path.class, new PathConverter().valueType() );     }      @Test     public void testReadableAndOverwritableFile() throws Exception {         Path path = Files.createTempFile( "prefix", null );         path.toFile().deleteOnExit();          String pathName = path.toString();          assertTrue( Files.isReadable( new PathConverter( READABLE ).convert( pathName ) ) );         assertTrue( Files.exists( new PathConverter( READABLE ).convert( pathName ) ) );         assertTrue( Files.isWritable( new PathConverter( READABLE ).convert( pathName ) ) );         assertTrue( Files.isWritable( new PathConverter( FILE_OVERWRITABLE).convert( pathName ) ) );     }      @Test     public void testNotExisting() throws Exception {         Path path = Files.createTempFile( "prefix", null );          Files.deleteIfExists( path );          assertFalse( Files.exists( new PathConverter( NOT_EXISTING ).convert( path.toString() ) ) );     }      @Test     public void testNotReadable() throws Exception {         Path path = Files.createTempFile( "prefix", null );         String pathName = path.toString();         Files.deleteIfExists( path );          exception.expect( ValueConversionException.class );         exception.expectMessage( "File [" + pathName );          new PathConverter( READABLE ).convert( pathName );     }      @Test     public void testDirectoryExisting() throws Exception {         Path path = Files.createTempDirectory( "prefix" );         path.toFile().deleteOnExit();          String pathName = path.toString();          assertTrue( Files.isDirectory( new PathConverter( DIRECTORY_EXISTING ).convert( pathName ) ) );     }      @Test     public void testDirectoryNotOverwritable() throws Exception {         Path path = Files.createTempDirectory( "prefix" );         path.toFile().deleteOnExit();          String pathName = path.toString();          exception.expect( ValueConversionException.class );         exception.expectMessage( "File [" + pathName );          new PathConverter( FILE_OVERWRITABLE ).convert( pathName );     }      @Test     public void testNotExistingNotOverwritable() throws Exception {         Path path = Files.createTempDirectory( "prefix" );         String pathName = path.toString();         Files.deleteIfExists( path );          exception.expect( ValueConversionException.class );         exception.expectMessage( "File [" + pathName );          new PathConverter( FILE_OVERWRITABLE ).convert( pathName );     } } 
/*  The MIT License   Copyright (c) 2004-2014 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import joptsimple.ValueConversionException; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertSame; import static org.junit.rules.ExpectedException.none;  /**  * @author <a href="mailto:christian.ohr@gmail.com">Christian Ohr</a>  */ public class EnumConverterTest {     @Rule     public final ExpectedException thrown = none();      private EnumConverter<TestEnum> converter;      @Before     public void setUp() {         converter = new TestEnumConverter();     }      @Test     public void convertsEnumValuesToEnum() {         assertEquals( TestEnum.A, converter.convert( "A" ) );     }      @Test     public void rejectsNonEnumeratedValues() {         thrown.expect( ValueConversionException.class );          converter.convert( "Z" );     }      @Test     public void answersCorrectValueType() {         assertSame( TestEnum.class, converter.valueType() );     }      @Test     public void givesDefaultValuePattern() {         assertEquals( "[A,B,C,D]", converter.valuePattern() );     }      @Test     public void givesCustomValuePattern() {         converter.setDelimiters( "(|)" );          assertEquals( "(A|B|C|D)", converter.valuePattern() );     }      @Test     public void ignoresCase() {         assertEquals( TestEnum.A, converter.convert( "a" ) );     }      private static class TestEnumConverter extends EnumConverter<TestEnum> {         TestEnumConverter() {             super( TestEnum.class );         }     }      private static enum TestEnum {         A, B, C, D     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple.util;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class KeyValuePairTest {     @Test( expected = NullPointerException.class )     public void nullArg() {         KeyValuePair.valueOf( null );     }      @Test     public void empty() {         KeyValuePair pair = KeyValuePair.valueOf( "" );          assertEquals( "", pair.key );         assertNull( pair.value );     }      @Test     public void noEqualsSign() {         KeyValuePair pair = KeyValuePair.valueOf( "aString" );          assertEquals( "aString", pair.key );         assertNull( pair.value );     }      @Test     public void signAtEnd() {         KeyValuePair pair = KeyValuePair.valueOf( "aKey=" );          assertEquals( "aKey", pair.key );         assertEquals( "", pair.value );     }      @Test     public void signAtStart() {         KeyValuePair pair = KeyValuePair.valueOf( "=aValue" );          assertEquals( "", pair.key );         assertEquals( "aValue", pair.value );     }      @Test     public void typical() {         KeyValuePair pair = KeyValuePair.valueOf( "aKey=aValue" );          assertEquals( "aKey", pair.key );         assertEquals( "aValue", pair.value );     }      @Test     public void multipleEqualsSignsDoNotMatter() {         KeyValuePair pair = KeyValuePair.valueOf( "aKey=1=2=3=4" );          assertEquals( "aKey", pair.key );         assertEquals( "1=2=3=4", pair.value );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ClusterWhereManyOptionsAcceptArgumentsTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "f" );         parser.accepts( "o" ).withOptionalArg();         parser.accepts( "x" ).withRequiredArg();     }      @Test     public void foxPermutation() {         OptionSet options = parser.parse( "-fox" );          assertTrue( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "x" ), options.valuesOf( "o" ) );     }      @Test     public void fxoPermutation() {         OptionSet options = parser.parse( "-fxo" );          assertTrue( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "o" ), options.valuesOf( "x" ) );     }      @Test     public void ofxPermutation() {         OptionSet options = parser.parse( "-ofx" );          assertFalse( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "fx" ), options.valuesOf( "o" ) );     }      @Test     public void oxfPermutation() {         OptionSet options = parser.parse( "-oxf" );          assertFalse( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "xf" ), options.valuesOf( "o" ) );     }      @Test     public void xofPermutation() {         OptionSet options = parser.parse( "-xof" );          assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "of" ), options.valuesOf( "x" ) );     }      @Test     public void xfoPermutation() {         OptionSet options = parser.parse( "-xfo" );          assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "fo" ), options.valuesOf( "x" ) );     }      @Test     public void foxPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-fox", "bar" );          assertTrue( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "x" ), options.valuesOf( "o" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     }      @Test     public void fxoPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-fxo", "bar" );          assertTrue( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "o" ), options.valuesOf( "x" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     }      @Test     public void ofxPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-ofx", "bar" );          assertFalse( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "fx" ), options.valuesOf( "o" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     }      @Test     public void oxfPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-oxf", "bar" );          assertFalse( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertFalse( options.has( "x" ) );          assertEquals( singletonList( "xf" ), options.valuesOf( "o" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     }      @Test     public void xofPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-xof", "bar" );          assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "of" ), options.valuesOf( "x" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     }      @Test     public void xfoPermutationWithFollowingArg() {         OptionSet options = parser.parse( "-xfo", "bar" );          assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );          assertEquals( singletonList( "fo" ), options.valuesOf( "x" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class LongOptionNoArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "verbose" );         parser.accepts( "verb" );     }      @Test     public void singleLongOption() {         OptionSet options = parser.parse( "--verbose" );          assertTrue( options.has( "verbose" ) );         assertEquals( emptyList(), options.valuesOf( "verbose" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void singleLongOptionAbbreviated() {         OptionSet options = parser.parse( "--verbo" );          assertTrue( options.has( "verbose" ) );         assertFalse( options.has( "verb" ) );         assertEquals( emptyList(), options.valuesOf( "verbose" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void abbreviationIsALegalOption() {         OptionSet options = parser.parse( "--verb" );          assertFalse( options.has( "verbose" ) );         assertTrue( options.has( "verb" ) );         assertEquals( emptyList(), options.valuesOf( "verb" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void ambiguousAbbreviation() {         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "ver" ) );          parser.parse( "--ver" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public abstract class AbstractOptionSpecOptionsImmutabilityTestCase extends UnmodifiableListTestSupport<String> {     @Override     protected List<String> newList() {         AbstractOptionSpec<?> spec = newOptionSpec( containedItem() );         return spec.options();     }      @Override     protected final String newItem() {         return "not";     }      @Override     protected String containedItem() {         return "in";     }      protected abstract AbstractOptionSpec<?> newOptionSpec( String option ); } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetNonOptionArgumentsImmutabilityTest extends UnmodifiableListTestSupport<String> {     @SuppressWarnings( "unchecked" )     @Override     protected List<String> newList() {         OptionSet options = new OptionSet( emptyMap() );         NonOptionArgumentSpec<String> nonOptions = new NonOptionArgumentSpec<>( null );         options.addWithArgument( nonOptions, "1" );         options.addWithArgument( nonOptions, "2" );         return (List<String>) options.nonOptionArguments();     }      @Override     protected String newItem() {         return "3";     }      @Override     protected String containedItem() {         return "2";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSynonymRequiredArgumentTest extends AbstractOptionParserFixture {     private String optionArgument;      @Before     public final void initializeParser() {         parser.acceptsAll( asList( "N", "after-date", "newer" ), "date" ).withRequiredArg().ofType( Integer.class );         optionArgument = "2000";     }      @Test     public void hasAllSynonymsWhenFirstSynonymParsed() {         assertDetections( new String[] { "-N", optionArgument }, singletonList( Integer.valueOf( optionArgument ) ) );     }      @Test     public void hasAllSynonymsWhenSecondSynonymParsed() {         assertDetections(             new String[] { "--after-date", optionArgument },             singletonList( Integer.valueOf( optionArgument ) ) );     }      @Test     public void hasAllSynonymsWhenThirdSynonymParsed() {         assertDetections(             new String[] { "--newer", optionArgument },             singletonList( Integer.valueOf( optionArgument ) ) );     }      @Test     public void reportsSameListOfArgumentsForEverySynonymOption() {         assertDetections( new String[] { "-N", "1", "-aft", "2", "--ne", "3" }, asList( 1, 2, 3 ) );     }      private void assertDetections( String[] args, List<?> optionArguments ) {         OptionSet options = parser.parse( args );          assertEquals( optionArguments, options.valuesOf( "N" ) );         assertEquals( optionArguments, options.valuesOf( "after-date" ) );         assertEquals( optionArguments, options.valuesOf( "newer" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.StringWriter; import java.math.BigDecimal; import java.util.Date; import java.util.List; import java.util.stream.Stream;  import static java.math.BigDecimal.*; import static java.util.Arrays.*; import static java.util.Collections.*; import static java.util.stream.Collectors.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.internal.Strings.*; import static joptsimple.util.DateConverter.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ConfigurableOptionParserHelpTest extends AbstractOptionParserFixture {     private StringWriter sink;      @Before     public final void createSink() {         parser.formatHelpWith( new BuiltinHelpFormatter( 120, 3 ) );         sink = new StringWriter();     }      @Test     public void unconfiguredParser() throws Exception {         parser.printHelpOn( sink );          assertHelpLines( "No options specified   ", EMPTY );     }      @Test     public void oneOptionNoArgNoDescription() throws Exception {         parser.accepts( "apple" );          parser.printHelpOn( sink );          assertHelpLines(             "Option    Description",             "------    -----------",             "--apple              ",             EMPTY );     }      @Test     public void oneOptionNoArgWithDescription() throws Exception {         parser.accepts( "a", "some description" );          parser.printHelpOn( sink );          assertHelpLines(             "Option   Description     ",             "------   -----------     ",             "-a       some description",             EMPTY );     }      @Test     public void twoOptionsNoArgWithDescription() throws Exception {         parser.accepts( "a", "some description" );         parser.accepts( "verbose", "even more description" );          parser.printHelpOn( sink );          assertHelpLines(             "Option      Description          ",             "------      -----------          ",             "-a          some description     ",             "--verbose   even more description",             EMPTY );     }      @Test     public void oneOptionRequiredArgNoDescription() throws Exception {         parser.accepts( "a" ).withRequiredArg();          parser.printHelpOn( sink );          assertHelpLines(             "Option        Description",             "------        -----------",             "-a <String>              ",             EMPTY );     }      @Test     public void oneOptionRequiredArgNoDescriptionWithType() throws Exception {         parser.accepts( "a" ).withRequiredArg().ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option         Description",             "------         -----------",             "-a <Integer>              ",             EMPTY );     }      @Test     public void oneOptionRequiredArgWithDescription() throws Exception {         parser.accepts( "a", "some value you need" ).withRequiredArg().describedAs( "numerical" );          parser.printHelpOn( sink );          assertHelpLines(             "Option                   Description        ",             "------                   -----------        ",             "-a <String: numerical>   some value you need",             EMPTY );     }      @Test     public void oneOptionRequiredArgWithDescriptionAndType() throws Exception {         parser.accepts( "a", "some value you need" ).withRequiredArg().describedAs( "numerical" )             .ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                    Description        ",             "------                    -----------        ",             "-a <Integer: numerical>   some value you need",             EMPTY );     }      @Test     public void oneOptionOptionalArgNoDescription() throws Exception {         parser.accepts( "threshold" ).withOptionalArg();          parser.printHelpOn( sink );          assertHelpLines(             "Option                 Description",             "------                 -----------",             "--threshold [String]              ",             EMPTY );     }      @Test     public void oneOptionOptionalArgNoDescriptionWithType() throws Exception {         parser.accepts( "a" ).withOptionalArg().ofType( Float.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option       Description",             "------       -----------",             "-a [Float]              ",             EMPTY );     }      @Test     public void oneOptionOptionalArgWithDescription() throws Exception {         parser.accepts( "threshold", "some value you need" ).withOptionalArg().describedAs( "positive integer" );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                   Description        ",             "------                                   -----------        ",             "--threshold [String: positive integer]   some value you need",             EMPTY );     }      @Test     public void oneOptionOptionalArgWithDescriptionAndType() throws Exception {         parser.accepts( "threshold", "some value you need" ).withOptionalArg().describedAs( "positive decimal" )             .ofType( Double.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                   Description        ",             "------                                   -----------        ",             "--threshold [Double: positive decimal]   some value you need",             EMPTY );     }      @Test     public void alternativeLongOptions() throws Exception {         parser.recognizeAlternativeLongOptions( true );          parser.printHelpOn( sink );          assertHelpLines(             "Option                   Description                     ",             "------                   -----------                     ",             "-W <String: opt=value>   Alternative form of long options",             EMPTY );     }      @Test     public void optionSynonymsWithoutArguments() throws Exception {         parser.acceptsAll( asList( "v", "chatty" ), "be verbose" );          parser.printHelpOn( sink );          assertHelpLines(             "Option         Description",             "------         -----------",             "-v, --chatty   be verbose ",             EMPTY );     }      @Test     public void optionSynonymsWithRequiredArgument() throws Exception {         parser.acceptsAll( asList( "L", "index" ), "set level" ).withRequiredArg().ofType( Integer.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                  Description",             "------                  -----------",             "-L, --index <Integer>   set level  ",             EMPTY );     }      @Test     public void optionSynonymsWithOptionalArgument() throws Exception {         parser.acceptsAll( asList( "d", "since" ), "date filter" ).withOptionalArg().describedAs( "yyyyMMdd" )             .ofType( Date.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                         Description",             "------                         -----------",             "-d, --since [Date: yyyyMMdd]   date filter",             EMPTY );     }      @Test     public void optionSynonymsSortedByShortOptionThenLexicographical() throws Exception {         parser.acceptsAll( asList( "v", "prolix", "chatty" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option                   Description",             "------                   -----------",             "-v, --chatty, --prolix              ",             EMPTY );     }      @Test     public void bothColumnsExceedingAllocatedWidths() throws Exception {         parser.acceptsAll( asList( "t", "threshold", "cutoff" ),                 "a threshold value beyond which a certain level of the application should cease to write logs" )                 .withRequiredArg()                 .describedAs( "a positive decimal number that will represent the threshold that has been outlined" )                 .ofType( Double.class );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                                     Description                                          ",             "------                                                     -----------                                          ",             "-t, --cutoff, --threshold <Double: a positive decimal      a threshold value beyond which a certain level of the",             "  number that will represent the threshold that has been     application should cease to write logs             ",             "  outlined>                                                                                                     ",             EMPTY );     }      // Bug 2018262     @Test     public void gradleHelp() throws Exception {         parser.acceptsAll( asList( "n", "non-recursive" ), "Do not execute primary tasks of child projects." );         parser.acceptsAll( singletonList( "S" ),             "Don't trigger a System.exit(0) for normal termination. Used for Gradle's internal testing." );         parser.acceptsAll( asList( "I", "no-imports" ), "Disable usage of default imports for build script files." );         parser.acceptsAll( asList( "u", "no-search-upward" ),             "Don't search in parent folders for a settings.gradle file." );         parser.acceptsAll( asList( "x", "cache-off" ), "No caching of compiled build scripts." );         parser.acceptsAll( asList( "r", "rebuild-cache" ), "Rebuild the cache of compiled build scripts." );         parser.acceptsAll( asList( "v", "version" ), "Print version info." );         parser.acceptsAll( asList( "d", "debug" ), "Log in debug mode (includes normal stacktrace)." );         parser.acceptsAll( asList( "q", "quiet" ), "Log errors only." );         parser.acceptsAll( asList( "j", "ivy-debug" ), "Set Ivy log level to debug (very verbose)." );         parser.acceptsAll( asList( "i", "ivy-quiet" ), "Set Ivy log level to quiet." );         parser.acceptsAll( asList( "s", "stacktrace" ),             "Print out the stacktrace also for user exceptions (e.g. compile error)." );         parser.acceptsAll( asList( "f", "full-stacktrace" ),             "Print out the full (very verbose) stacktrace for any exceptions." );         parser.acceptsAll( asList( "t", "tasks" ), "Show list of all available tasks and their dependencies." );         parser.acceptsAll( asList( "p", "project-dir" ),             "Specifies the start dir for Gradle. Defaults to current dir." ).withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "g", "gradle-user-home" ), "Specifies the gradle user home dir." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "l", "plugin-properties-file" ), "Specifies the plugin.properties file." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "b", "buildfile" ),             "Specifies the build file name (also for subprojects). Defaults to build.gradle." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "D", "systemprop" ), "Set system property of the JVM (e.g. -Dmyprop=myvalue)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "P", "projectprop" ),             "Set project property for the build script (e.g. -Pmyprop=myvalue)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "e", "embedded" ), "Specify an embedded build script." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "B", "bootstrap-debug" ),             "Specify a text to be logged at the beginning (e.g. used by Gradle's bootstrap class)." )             .withRequiredArg().ofType( String.class );         parser.acceptsAll( asList( "h", "?" ), "Shows this help message." ).forHelp();          parser.printHelpOn( sink );          assertHelpLines(             "Option                                  Description                                                                    ",             "------                                  -----------                                                                    ",             "-?, -h                                  Shows this help message.                                                       ",             "-B, --bootstrap-debug <String>          Specify a text to be logged at the beginning (e.g. used by Gradle's bootstrap  ",             "                                          class).                                                                      ",             "-D, --systemprop <String>               Set system property of the JVM (e.g. -Dmyprop=myvalue).                        ",             "-I, --no-imports                        Disable usage of default imports for build script files.                       ",             "-P, --projectprop <String>              Set project property for the build script (e.g. -Pmyprop=myvalue).             ",             "-S                                      Don't trigger a System.exit(0) for normal termination. Used for Gradle's       ",             "                                          internal testing.                                                            ",             "-b, --buildfile <String>                Specifies the build file name (also for subprojects). Defaults to build.gradle.",             "-d, --debug                             Log in debug mode (includes normal stacktrace).                                ",             "-e, --embedded <String>                 Specify an embedded build script.                                              ",             "-f, --full-stacktrace                   Print out the full (very verbose) stacktrace for any exceptions.               ",             "-g, --gradle-user-home <String>         Specifies the gradle user home dir.                                            ",             "-i, --ivy-quiet                         Set Ivy log level to quiet.                                                    ",             "-j, --ivy-debug                         Set Ivy log level to debug (very verbose).                                     ",             "-l, --plugin-properties-file <String>   Specifies the plugin.properties file.                                          ",             "-n, --non-recursive                     Do not execute primary tasks of child projects.                                ",             "-p, --project-dir <String>              Specifies the start dir for Gradle. Defaults to current dir.                   ",             "-q, --quiet                             Log errors only.                                                               ",             "-r, --rebuild-cache                     Rebuild the cache of compiled build scripts.                                   ",             "-s, --stacktrace                        Print out the stacktrace also for user exceptions (e.g. compile error).        ",             "-t, --tasks                             Show list of all available tasks and their dependencies.                       ",             "-u, --no-search-upward                  Don't search in parent folders for a settings.gradle file.                     ",             "-v, --version                           Print version info.                                                            ",             "-x, --cache-off                         No caching of compiled build scripts.                                          ",             EMPTY );     }      @Test     public void dateConverterShowsDatePattern() throws Exception {         parser.accepts( "date", "a date" ).withRequiredArg().withValuesConvertedBy( datePattern( "MM/dd/yy" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option              Description",             "------              -----------",             "--date <MM/dd/yy>   a date     ",             EMPTY );     }      @Test     public void dateConverterShowsDatePatternInCombinationWithDescription() throws Exception {         parser.accepts( "date", "a date" ).withOptionalArg().describedAs( "your basic date pattern" )             .withValuesConvertedBy( datePattern( "MM/dd/yy" ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option                                       Description",             "------                                       -----------",             "--date [MM/dd/yy: your basic date pattern]   a date     ",             EMPTY );     }      @Test     public void leavesEmbeddedNewlinesInDescriptionsAlone() throws Exception {         List<String> descriptionPieces =             asList( "Specify the output type.", "'raw' = raw data.", "'java' = java class" );         parser.accepts(             "type",             descriptionPieces.stream().collect( joining( LINE_SEPARATOR ) ) );          parser.printHelpOn( sink );          assertHelpLines(             "Option   Description             ",             "------   -----------             ",             "--type   Specify the output type.",             "         'raw' = raw data.       ",             "         'java' = java class     ",             EMPTY );     }      @Test     public void includesDefaultValueForRequiredOptionArgument() throws Exception {         parser.accepts( "a" ).withRequiredArg().defaultsTo( "boo" );          parser.printHelpOn( sink );          assertHelpLines(             "Option        Description   ",             "------        -----------   ",             "-a <String>   (default: boo)",             EMPTY );     }      @Test     public void includesDefaultValueForOptionalOptionArgument() throws Exception {         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class ).defaultsTo( 5 );          parser.printHelpOn( sink );          assertHelpLines(             "Option         Description ",             "------         ----------- ",             "-b [Integer]   (default: 5)",             EMPTY );     }      @Test     public void includesDefaultValueForArgumentWithDescription() throws Exception {         parser.accepts( "c", "a quantity" ).withOptionalArg().ofType( BigDecimal.class )             .describedAs( "quantity" ).defaultsTo( TEN );          parser.printHelpOn( sink );          assertHelpLines(             "Option                      Description             ",             "------                      -----------             ",             "-c [BigDecimal: quantity]   a quantity (default: 10)",             EMPTY );     }      @Test     public void includesListOfDefaultsForArgumentWithDescription() throws Exception {         parser.accepts( "d", "dizzle" ).withOptionalArg().ofType( Integer.class )             .describedAs( "double dizzle" ).defaultsTo( 2, 3, 5, 7 );          parser.printHelpOn( sink );          assertHelpLines(             "Option                        Description                   ",             "------                        -----------                   ",             "-d [Integer: double dizzle]   dizzle (default: [2, 3, 5, 7])",             EMPTY );     }      @Test     public void marksRequiredOptionsSpecially() throws Exception {         parser.accepts( "e" ).withRequiredArg().required();          parser.printHelpOn( sink );          assertHelpLines(             "Option (* = required)   Description",             "---------------------   -----------",             "* -e <String>                      ",             EMPTY );     }      private void assertHelpLines( String... expectedLines ) {         assertEquals(             Stream.of( expectedLines ).collect( joining( LINE_SEPARATOR ) ),             sink.toString() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionalArgumentOptionSpecOptionsImmutabilityTest extends AbstractOptionSpecOptionsImmutabilityTestCase {     @Override     protected AbstractOptionSpec<?> newOptionSpec( String option ) {         return new OptionalArgumentOptionSpec<Integer>( option );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetValuesOfSpecImmutabilityTest extends UnmodifiableListTestSupport<String> {     @Override     protected List<String> newList() {         RequiredArgumentOptionSpec<String> optionA = new RequiredArgumentOptionSpec<>( "a" );         OptionSet options = new OptionSet( emptyMap() );         options.addWithArgument( optionA, "anArgument" );         options.addWithArgument( optionA, "anotherArgument" );         return options.valuesOf( optionA );     }      @Override     protected String newItem() {         return "yetAnotherArgument";     }      @Override     protected String containedItem() {         return "anArgument";     } } 
package joptsimple;  import java.util.HashMap; import java.util.List; import java.util.Map;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:binkley@alumni.rice.edu">B. K. Oxley (binkley)</a>  */ public class OptionSetAsMapTest extends AbstractOptionParserFixture {     @Test     public void gives() {         OptionSpec<Void> a = parser.accepts( "a" );         OptionSpec<String> b = parser.accepts( "b" ).withRequiredArg();         OptionSpec<String> c = parser.accepts( "c" ).withOptionalArg();         OptionSpec<String> d = parser.accepts( "d" ).withRequiredArg().defaultsTo( "1" );         OptionSpec<String> e = parser.accepts( "e" ).withOptionalArg().defaultsTo( "2" );         OptionSpec<String> f = parser.accepts( "f" ).withRequiredArg().defaultsTo( "3" );         OptionSpec<String> g = parser.accepts( "g" ).withOptionalArg().defaultsTo( "4" );         OptionSpec<Void> h = parser.accepts( "h" );          OptionSet options = parser.parse( "-a", "-e", "-c", "5", "-d", "6", "-b", "4", "-d", "7", "-e", "8" );          Map<OptionSpec<?>, List<?>> expected = new HashMap<OptionSpec<?>, List<?>>() {             private static final long serialVersionUID = Long.MIN_VALUE;              {                 put( a, emptyList() );                 put( b, singletonList( "4" ) );                 put( c, singletonList( "5" ) );                 put( d, asList( "6", "7" ) );                 put( e, singletonList( "8" ) );                 put( f, singletonList( "3" ) );                 put( g, singletonList( "4" ) );                 put( h, emptyList() );             }         };          assertEquals( expected, options.asMap() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ClusterVersusLongOptionWithOptionalArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "fox" );         parser.accepts( "f" );         parser.accepts( "o" );         parser.accepts( "x" ).withOptionalArg();     }      @Test     public void resolvesToLongOptionEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "--fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesToLongOptionWithSingleDashEvenWithMatchingShortOptions() {         OptionSet options = parser.parse( "-fox" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );     }      @Test     public void resolvesAbbreviationToLongOption() {         OptionSet options = parser.parse( "-fo" );         assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );     }      @Test     public void resolvesShortOptionToShortOption() {         OptionSet options = parser.parse( "-f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     }      @Test     public void resolvesShortOptionToShortOptionEvenWithDoubleHyphen() {         OptionSet options = parser.parse( "--f" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );     }      @Test     public void resolvesToShortOptionsWithArgumentFollowingX() {         OptionSet options = parser.parse( "-foxbar" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );         assertTrue( options.has( "o" ) );         assertTrue( options.has( "x" ) );         assertEquals( singletonList( "bar" ), options.valuesOf( "x" ) );     }      @Test     public void shortOptionsInDifferentOrder() {         OptionSet options = parser.parse( "-fxo" );         assertFalse( options.has( "fox" ) );         assertTrue( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertTrue( options.has( "x" ) );         assertEquals( singletonList( "o" ), options.valuesOf( "x" ) );     }      @Test( expected = UnrecognizedOptionException.class )     public void longOptionWithMessedUpOrder() {         parser.parse( "--fxo" );     }      @Test     public void withArgumentComingAfterCluster() {         OptionSet options = parser.parse( "-fox", "bar" );          assertTrue( options.has( "fox" ) );         assertFalse( options.has( "f" ) );         assertFalse( options.has( "o" ) );         assertFalse( options.has( "x" ) );         assertEquals( singletonList( "bar" ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ParserRulesUtilityClassTest extends UtilityClassesUninstantiabilityHarness {     public ParserRulesUtilityClassTest() {         super( ParserRules.class );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class NoArgumentOptionSpecOptionsImmutabilityTest extends AbstractOptionSpecOptionsImmutabilityTestCase {     @Override     protected AbstractOptionSpec<?> newOptionSpec( String option ) {         return new NoArgumentOptionSpec( option );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List; import java.util.Optional;  import org.junit.Test;  import static java.lang.Short.*; import static java.util.Arrays.*; import static java.util.Collections.*; import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class TypesafeOptionArgumentRetrievalTest extends AbstractOptionParserFixture {     @Test     public void retrievalOfTypedRequiredArgumentsInATypesafeManner() {         OptionSpec<Integer> optionA = parser.accepts( "a" ).withRequiredArg().ofType( Integer.class );          OptionSet options = parser.parse( "-a", "1" );          assertTrue( options.has( optionA ) );         Integer valueFromOption = optionA.value( options );         assertEquals( Integer.valueOf( 1 ), valueFromOption );         Integer valueFromOptionSet = options.valueOf( optionA );         assertEquals( valueFromOption, valueFromOptionSet );          List<Integer> valuesFromOption = optionA.values( options );         assertEquals( singletonList( 1 ), valuesFromOption );         List<Integer> valuesFromOptionSet = options.valuesOf( optionA );         assertEquals( valuesFromOption, valuesFromOptionSet );     }      @Test     public void retrievalOfTypedOptionalArgumentsInATypesafeManner() {         OptionSpec<Double> optionB = parser.accepts( "b" ).withOptionalArg().ofType( Double.class );          OptionSet options = parser.parse( "-b", "3.14D" );          assertTrue( options.has( optionB ) );         assertEquals( Double.valueOf( 3.14D ), optionB.value( options ) );         assertEquals( Optional.of( 3.14D ), optionB.valueOptional( options ) );         assertEquals( singletonList( 3.14D ), optionB.values( options ) );     }      @Test     public void retrievalOfUntypedRequiredArgumentsInATypesafeManner() {         OptionSpec<String> optionC = parser.accepts( "c" ).withRequiredArg();          OptionSet options = parser.parse( "-c", "foo", "-c", "bar" );          assertTrue( options.has( optionC ) );         assertEquals( asList( "foo", "bar" ), optionC.values( options ) );     }      @Test     public void retrievalOfUntypedOptionalArgumentsInATypesafeManner() {         OptionSpec<String> optionD = parser.accepts( "d" ).withRequiredArg();          OptionSet options = parser.parse( "-d", "foo", "-d", "bar", "-d", "baz" );          assertTrue( options.has( optionD ) );         List<String> valuesFromOption = optionD.values( options );         assertEquals( asList( "foo", "bar", "baz" ), valuesFromOption );         List<String> valuesFromOptionSet = options.valuesOf( optionD );         assertEquals( valuesFromOption, valuesFromOptionSet );     }      @Test     public void retrievalWithVoidOption() {         OptionSpec<Void> optionE = parser.accepts( "e" );          OptionSet options = parser.parse( "-e" );          assertTrue( options.has( optionE ) );         assertEquals( emptyList(), options.valuesOf( optionE ) );     }      @Test     public void primitiveBooleanAllowedAsTypeSpecifier() {         OptionSpec<Boolean> optionA = parser.accepts( "a" ).withRequiredArg().ofType( boolean.class );          OptionSet options = parser.parse( "-a", "false" );          assertTrue( options.has( optionA ) );         assertEquals( singletonList( false ), options.valuesOf( optionA ) );     }      @Test     public void primitiveByteAllowedAsTypeSpecifier() {         OptionSpec<Byte> optionB = parser.accepts( "b" ).withOptionalArg().ofType( byte.class );          OptionSet options = parser.parse( "-b", "3" );          assertTrue( options.has( optionB ) );         assertEquals( singletonList( Byte.valueOf( "3" ) ), options.valuesOf( optionB ) );     }      @Test( expected = IllegalArgumentException.class )     public void primitiveCharAllowedAsTypeSpecifier() {         parser.accepts( "c" ).withRequiredArg().ofType( char.class );     }      @Test     public void primitiveDoubleAllowedAsTypeSpecifier() {         OptionSpec<Double> optionD = parser.accepts( "d" ).withOptionalArg().ofType( double.class );          OptionSet options = parser.parse( "-d", "3.1" );          assertTrue( options.has( optionD ) );         assertEquals( singletonList( 3.1D ), options.valuesOf( optionD ) );     }      @Test     public void primitiveFloatAllowedAsTypeSpecifier() {         OptionSpec<Float> optionE = parser.accepts( "e" ).withRequiredArg().ofType( float.class );          OptionSet options = parser.parse( "-e", "2.09" );          assertTrue( options.has( optionE ) );         assertEquals( singletonList( 2.09F ), options.valuesOf( optionE ) );     }      @Test     public void primitiveIntAllowedAsTypeSpecifier() {         OptionSpec<Integer> optionF = parser.accepts( "F" ).withRequiredArg().ofType( int.class );          OptionSet options = parser.parse( "-F", "91" );          assertTrue( options.has( optionF ) );         assertEquals( singletonList( 91 ), options.valuesOf( optionF ) );     }      @Test     public void primitiveLongAllowedAsTypeSpecifier() {         OptionSpec<Long> optionG = parser.accepts( "g" ).withOptionalArg().ofType( long.class );          OptionSet options = parser.parse("-g", "12");          assertTrue( options.has( optionG ) );         assertEquals( singletonList( 12L ), options.valuesOf( optionG ) );     }      @Test     public void primitiveShortAllowedAsTypeSpecifier() {         OptionSpec<Short> optionH = parser.accepts( "H" ).withRequiredArg().ofType( short.class );          OptionSet options = parser.parse( "-H", "8" );          assertTrue( options.has( optionH ) );         assertEquals( singletonList( Short.valueOf( "8" ) ), options.valuesOf( optionH ) );     }      @Test     public void cannotFoolHasWithAnOptionNotIssuedFromBuilder() {         parser.accepts( "e" );          OptionSet options = parser.parse( "-e" );          assertFalse( options.has( new FakeOptionSpec<Void>( "e" ) ) );     }      @Test     public void cannotFoolHasArgumentWithAnOptionNotIssuedFromBuilder() {         parser.accepts( "f" ).withRequiredArg();         OptionSpec<String> fakeOptionF = new FakeOptionSpec<>( "f" );          OptionSet options = parser.parse( "-f", "boo" );          assertFalse( options.hasArgument( fakeOptionF ) );     }      @Test     public void cannotFoolValueOfWithAnOptionNotIssuedFromBuilder() {         parser.accepts( "g" ).withRequiredArg();          OptionSet options = parser.parse( "-g", "foo" );          assertNull( options.valueOf( new FakeOptionSpec<String>( "g" ) ) );     }      @Test     public void cannotFoolValuesOfWithAnOptionNotIssuedFromBuilder() {         parser.accepts( "h" ).withRequiredArg();          OptionSet options = parser.parse( "-h", "foo", "-h", "bar" );          assertEquals( emptyList(), options.valuesOf( new FakeOptionSpec<String>( "h" ) ) );     }      @Test( expected = ClassCastException.class )     public void canSubvertTypeSafetyIfYouUseAnOptionSpecAsTheWrongType() {         ArgumentAcceptingOptionSpec<String> optionI = parser.accepts( "i" ).withRequiredArg();         optionI.ofType( Integer.class );          OptionSet options = parser.parse( "-i", "2" );          @SuppressWarnings( "unused" )         String value = optionI.value( options );     }      @Test( expected = ClassCastException.class )     public void canSubvertTypeSafetyIfYouGiveAnOptionSpecToOptionSetAsTheWrongType() {         ArgumentAcceptingOptionSpec<String> optionJ = parser.accepts( "j" ).withRequiredArg();         optionJ.ofType( Integer.class );          OptionSet options = parser.parse( "-j", "3" );          @SuppressWarnings( "unused" )         String value = options.valuesOf( optionJ ).get( 0 );     }      @Test     public void canUseBooleanType() {         OptionSpec<Boolean> optionK = parser.accepts( "k" ).withRequiredArg().ofType( Boolean.class );          OptionSet options = parser.parse( "-k", "true" );          assertTrue( optionK.value( options ) );     }      @Test     public void usesConverterIfProvided() {         OptionSpec<Short> optionL = parser.accepts( "L" ).withRequiredArg().withValuesConvertedBy(             new ValueConverter<Short>() {                 @Override                 public Short convert( String value ) {                     return parseShort( value );                 }                  @Override                 public Class<Short> valueType() {                     return Short.class;                 }                  @Override                 public String valuePattern() {                     return null;                 }             } );          OptionSet options = parser.parse( "-L", "34" );          assertEquals( new Short( (short) 34 ), optionL.value( options ) );     }      @Test     public void wrapsValueConversionExceptionsRaisedByConverter() {         OptionSpec<Character> optionM = parser.accepts( "m" ).withRequiredArg().withValuesConvertedBy(             new ValueConverter<Character>() {                 @Override                 public Character convert( String value ) {                     throw new ValueConversionException( value );                 }                  @Override                 public Class<Character> valueType() {                     return Character.class;                 }                  @Override                 public String valuePattern() {                     return null;                 }             } );          OptionSet options = parser.parse( "-m", "a" );          thrown.expect( OptionArgumentConversionException.class );         thrown.expect( withCauseOfType( ValueConversionException.class ) );          optionM.value( options );     }      private static class FakeOptionSpec<V> implements OptionSpec<V> {         private final String option;          FakeOptionSpec( String option ) {             this.option = option;         }          @Override         public List<String> options() {             return singletonList( option );         }          @Override         public V value( OptionSet detectedOptions ) {             return detectedOptions.valueOf( this );         }          @Override         public List<V> values( OptionSet detectedOptions ) {             return detectedOptions.valuesOf( this );         }          @Override         public boolean isForHelp() {             return false;         }     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Collections.emptyList; import static org.junit.Assert.assertEquals;  public class RequiredUnlessAnyTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         parser.accepts( "a" );         parser.accepts( "b" );         OptionSpec<Void> c = parser.accepts( "c" );         OptionSpec<Void> d = parser.accepts( "d" );         parser.accepts( "e" );         parser.accepts( "n" ).requiredUnless( "a", "b" ).requiredUnless( c, d );     }      @Test     public void commandLineMissingConditionallyRequiredOption() {         OptionSet options = parser.parse( "-a" );         assertOptionDetected( options, "a" );         assertOptionNotDetected( options, "n" );     }      @Test     public void commandLineWithNotAllConditionallyRequiredOptionsPresent() {         OptionSet options = parser.parse( "-a", "-b", "-c", "-d" );         assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertOptionDetected( options, "c" );         assertOptionDetected( options, "d" );         assertOptionNotDetected( options, "n" );     }      @Test     public void acceptsCommandLineWithConditionallyRequiredOptionsPresent() {         OptionSet options = parser.parse( "-n" );          assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsOptionWithPrerequisiteAsNormalIfPrerequisiteNotInPlay() {         OptionSet options = parser.parse( "-a", "-n" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class LongOptionOptionalArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "output" ).withOptionalArg();         parser.accepts( "a" );     }      @Test     public void argumentMissingTrailedByAnotherOption() {         OptionSet options = parser.parse( "--output", "-a" );          assertTrue( options.has( "output" ) );         assertTrue( options.has( "a" ) );         assertEquals( emptyList(), options.valuesOf( "output" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void argumentSeparate() {         OptionSet options = parser.parse( "--output", "opt" );          assertTrue( options.has( "output" ) );         assertEquals( singletonList( "opt" ), options.valuesOf( "output" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void argumentTogether() {         OptionSet options = parser.parse( "--output=opt" );          assertTrue( options.has( "output" ) );         assertEquals( singletonList( "opt" ), options.valuesOf( "output" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class PunctuationInShortOptionTest {     @Test( expected = IllegalOptionSpecificationException.class )     public void disallowsHyphenAsShortOption() {         new OptionParser( "-" );     }      @Test     public void allowsQuestionMarkAsShortOption() {         assertOptionAllowed( "?" );     }      @Test     public void allowsDotAsShortOption() {         assertOptionAllowed( "." );     }      @Test     public void allowsUnderscoreAsShortOption() {         assertOptionAllowed( "_" );     }      private void assertOptionAllowed( String option ) {         OptionSet options = new OptionParser( option ).parse( '-' + option );          assertTrue( options.has( option ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.junit.Test;  import static java.util.Arrays.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetSpecsWithNonOptionsTest extends AbstractOptionParserFixture {     @Test     public void intermixOptionsAndNonOptions() {         parser.accepts( "a" );         parser.accepts( "b" ).withRequiredArg();         parser.accepts( "c" ).withOptionalArg();          OptionSet options =             parser.parse("-a", "foo", "bar", "-b", "baz", "xx", "-c", "quux", "d" );          List<OptionSpec<?>> specs = options.specsWithNonOptions();         assertEquals(             asList(                 new NoArgumentOptionSpec( "a" ),                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME ),                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME ),                 new RequiredArgumentOptionSpec<String>( "b" ),                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME ),                 new OptionalArgumentOptionSpec<String>( "c" ),                 new NonOptionArgumentSpec( NonOptionArgumentSpec.NAME )             ),             options.specsWithNonOptions() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Arrays; import java.util.Collection; import java.util.Locale;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import static com.google.common.collect.Lists.newArrayList; import static java.util.Arrays.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ @RunWith( Parameterized.class ) public class OptionExceptionMessageTest {     private final OptionException subject;     private final String expectedMessage;     private final String expectedLocalizedMessage;      public OptionExceptionMessageTest(         OptionException subject,         String expectedMessage,         String expectedLocalizedMessage ) {          this.subject = subject;         this.expectedMessage = expectedMessage;         this.expectedLocalizedMessage = expectedLocalizedMessage;     }      @Parameterized.Parameters     public static Collection<?> exceptionsAndMessages() {         return asList(             new Object[] {                 new IllegalOptionSpecificationException( "," ),                 ", is not a legal option character",                 "foo IllegalOptionSpecificationException"             },             new Object[] {                 new MultipleArgumentsForOptionException(new RequiredArgumentOptionSpec<>( asList( "b", "c" ), "d" ) ),                 "Found multiple arguments for option b/c, but you asked for only one",                 "foo MultipleArgumentsForOptionException"             },             new Object[] {                 new OptionArgumentConversionException(new RequiredArgumentOptionSpec<>( asList( "c", "number" ), "x" ), "d", null ),                 "Cannot parse argument 'd' of option c/number",                 "foo OptionArgumentConversionException"             },             new Object[] {                 new OptionMissingRequiredArgumentException(new RequiredArgumentOptionSpec<>( asList( "e", "honest" ), "" ) ),                 "Option e/honest requires an argument",                 "foo OptionMissingRequiredArgumentException"             },             new Object[] {                 new UnrecognizedOptionException( "f" ),                 "f is not a recognized option",                 "foo UnrecognizedOptionException"             },             new Object[] {                     new MissingRequiredOptionsException(Arrays.<AbstractOptionSpec<?>> asList(                         new NoArgumentOptionSpec( "g" ),                         new NoArgumentOptionSpec( "h" ) ) ),                 "Missing required option(s) [g, h]",                 "foo MissingRequiredOptionsException"             },             new Object[] { new MissingRequiredOptionsException(                 Arrays.<AbstractOptionSpec<?>> asList(                     new RequiredArgumentOptionSpec<>( asList( "p", "place" ), "spot" ),                     new RequiredArgumentOptionSpec<>( asList( "d", "data-dir" ), "dir" ) ) ),                 "Missing required option(s) [p/place, d/data-dir]",                 "foo MissingRequiredOptionsException"             },             new Object[] {                 new UnconfiguredOptionException( asList( "i", "j" ) ),                 "Option(s) [i, j] not configured on this parser",                 "foo UnconfiguredOptionException"             },             new Object[] {                 new UnavailableOptionException(newArrayList(                     new NoArgumentOptionSpec( "a" ),                     new NoArgumentOptionSpec( "b" ) ) ),                 "Option(s) [a, b] are unavailable given other options on the command line",                 "Option(s) [a, b] are unavailable given other options on the command line"             }         );     }      @Test     public void givesCorrectExceptionMessage() {         assertEquals( expectedMessage, subject.getMessage() );         assertEquals( subject.getClass().getName() + ": " + expectedMessage, subject.toString() );     }      @Test     public void givesEnglishMessageWhenLocaleIsNotEnglish() {         Locale defaultLocale = Locale.getDefault();         try {             Locale.setDefault( new Locale( "xx", "YY" ) );             assertEquals( expectedMessage, subject.getMessage() );         } finally {             Locale.setDefault( defaultLocale );         }     }      @Test     public void givesLocalizedMessageWhenLocaleIsNotEnglish() {         Locale defaultLocale = Locale.getDefault();         try {             Locale.setDefault( new Locale( "xx", "YY" ) );             assertEquals( expectedLocalizedMessage, subject.getLocalizedMessage() );         } finally {             Locale.setDefault( defaultLocale );         }     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static joptsimple.ParserRules.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class AlternativeLongOptionSpecOptionsImmutabilityTest extends AbstractOptionSpecOptionsImmutabilityTestCase {     @Override     protected AbstractOptionSpec<?> newOptionSpec( String option ) {         return new AlternativeLongOptionSpec();     }      @Override     protected String containedItem() {         return RESERVED_FOR_EXTENSIONS;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class WExtensionNoArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "silent" );         parser.recognizeAlternativeLongOptions( true );     }      @Test     public void turnOffWExtension() {         parser.recognizeAlternativeLongOptions( false );          thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "W" ) );          parser.parse( "-W", "silent" );     }      @Test     public void wExtensionWithLongOptionWithoutAnArgument() {         OptionSet options = parser.parse( "-W", "silent" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "silent" );         assertEquals( emptyList(), options.valuesOf( "silent" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Arrays.asList; import static java.util.Collections.emptyList; import static java.util.Collections.singletonList; import static org.junit.Assert.assertEquals;  public class RequiredUnlessTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         OptionSpec<Void> anonymous = parser.accepts( "anonymous" );         parser.acceptsAll( asList( "username", "userid" ) ).requiredUnless( "anonymous" ).withRequiredArg();         parser.acceptsAll( asList( "password", "pwd" ) ).requiredUnless( anonymous ).withRequiredArg();         parser.accepts( "?" ).forHelp();     }      @Test     public void rejectsCommandLineMissingConditionallyRequiredOption() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "" );     }      @Test     public void rejectsCommandLineWithNotAllConditionallyRequiredOptionsPresent() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "--username", "joe" );     }      @Test     public void acceptsCommandLineWithConditionallyRequiredOptionsPresent() {         OptionSet options = parser.parse( "--userid", "joe", "--password=secret" );          assertOptionNotDetected( options, "anonymous" );         assertOptionDetected( options, "username" );         assertOptionDetected( options, "password" );         assertEquals( singletonList( "joe" ), options.valuesOf( "username" ) );         assertEquals( singletonList( "secret" ), options.valuesOf( "password" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsOptionWithPrerequisite() {         OptionSet options = parser.parse( "--anonymous" );          assertOptionDetected( options, "anonymous" );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsOptionWithPrerequisiteAsNormal() {         OptionSet options = parser.parse( "--anonymous", "--pwd", "secret" );          assertOptionDetected( options, "anonymous" );         assertOptionDetected( options, "pwd" );         assertEquals( singletonList( "secret" ), options.valuesOf( "pwd" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void rejectsOptionNotAlreadyConfigured() {         thrown.expect( UnconfiguredOptionException.class );          parser.accepts( "foo" ).requiredIf( "bar" );     }      @Test     public void rejectsOptionSpecNotAlreadyConfigured() {         thrown.expect( UnconfiguredOptionException.class );          parser.accepts( "foo" ).requiredIf( "bar" );     }      @Test     public void presenceOfHelpOptionNegatesRequiredUnlessness() {         OptionSet options = parser.parse( "-?" );          assertOptionDetected( options, "?" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import java.util.ArrayList; import java.util.List;  import static java.util.Collections.*;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ValueConverterAdmitsSubclassesOfValueTypeTest {     @Test     public void subclassOfValueType() {         ValueConverter<List<String>> converter = new ValueConverter<List<String>>() {             @Override             public List<String> convert( String value ) {                 return singletonList( value );             }              @Override             public String revert( Object value ) {                 return valueType().cast( value ).get( 0 );             }              @Override             public Class<? extends List<String>> valueType() {                 return ListOfStrings.class;             }              @Override             public String valuePattern() {                 return null;             }         };          assertEquals( singletonList( "foo" ), converter.convert( "foo" ) );     }      static class ListOfStrings extends ArrayList<String> {         private static final long serialVersionUID = 1L;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class AlternativeLongOptionSpecValuesImmutabilityTest     extends AbstractOptionSpecValuesImmutabilityTestCase<String> {      @Override     protected AbstractOptionSpec<String> newOptionSpec() {         return new AlternativeLongOptionSpec();     }      @Override     protected String firstArg() {         return "x=y";     }      @Override     protected String secondArg() {         return "z=w";     }      @Override     protected String newItem() {         return "a=b";     }      @Override     protected String containedItem() {         return "x=y";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static java.util.Collections.*;  import static org.infinitest.toolkit.CollectionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class NoArgumentOptionSpecTest extends AbstractOptionSpecFixture {     @Override     protected NoArgumentOptionSpec createEqualOptionSpecInstance() {         return new NoArgumentOptionSpec( "a" );     }      @Override     protected NoArgumentOptionSpec createNotEqualOptionSpecInstance() {         return new NoArgumentOptionSpec( "b" );     }      @Test     public void optionsContents() {         assertThat( createNotEqualOptionSpecInstance().options(), hasSameContentsAs( singletonList( "b" ) ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetSpecsImmutabilityTest extends UnmodifiableListTestSupport<OptionSpec<?>> {     @Override     protected List<OptionSpec<?>> newList() {         OptionSet options = new OptionSet( emptyMap() );         options.add( new NoArgumentOptionSpec( "a" ) );         return options.specs();     }      @Override     protected OptionSpec<?> newItem() {         return new NoArgumentOptionSpec( "b" );     }      @Override     protected OptionSpec<?> containedItem() {         return new NoArgumentOptionSpec( "a" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class PunctuationInLongOptionTest extends AbstractOptionParserFixture {     @Test     public void allowsHyphensInTheMiddleOfOptionNames() {         assertOptionAllowed( "hyphenated-option" );     }      @Test     public void allowsHyphensPrettyMuchAnywhereButTheFront() {         assertOptionAllowed( "a-cra-zy-but-le--gal---o-p-t-i-o--n-----" );     }      @Test( expected = IllegalOptionSpecificationException.class )     public void disallowsHyphensAtFrontOfOptionName() {         parser.accepts( "-weird-option" );     }      @Test     public void allowsDotInOptionNames() {         assertOptionAllowed( "..what.is.the.d..e...a....l..." );     }      @Test     public void allowsQuestionMarkInOptionNames() {         assertOptionAllowed( "??who?k??n???e????w?" );     }      @Test     public void allowsUnderscoreInOptionNames() {         assertOptionAllowed( "super_long_option_name" );     }      private void assertOptionAllowed( String option ) {         parser.accepts( option );          OptionSet options = parser.parse( "--" + option );          assertTrue( options.has( option ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Arrays;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSetDetectedOptionsTest extends AbstractOptionParserFixture {     @Test     public void givesSpecsInOrderOfCommandLinePresentation() {         OptionSpec<Void> a = parser.accepts( "a" );         OptionSpec<String> b = parser.accepts( "b" ).withRequiredArg();         OptionSpec<String> c = parser.accepts( "c" ).withOptionalArg();         OptionSpec<String> d = parser.accepts( "d" ).withRequiredArg().defaultsTo( "1" );         OptionSpec<String> e = parser.accepts( "e" ).withOptionalArg().defaultsTo( "2" );          OptionSet options = parser.parse( "-a", "-e", "-c", "5", "-d", "6", "-b", "4", "-d", "7", "-e", "8" );          assertEquals( Arrays.asList( a, e, c, d, b, d, e ), options.specs() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public abstract class AbstractOptionSpecValuesImmutabilityTestCase<T> extends UnmodifiableListTestSupport<T> {     @Override     protected List<T> newList() {         AbstractOptionSpec<T> spec = newOptionSpec();         OptionSet options = new OptionSet( emptyMap() );         options.addWithArgument( spec, firstArg() );         options.addWithArgument( spec, secondArg() );          return spec.values( options );     }      protected abstract AbstractOptionSpec<T> newOptionSpec();      protected abstract String firstArg();      protected abstract String secondArg(); } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionalArgumentOptionSpecValuesImmutabilityTest     extends AbstractOptionSpecValuesImmutabilityTestCase<Integer> {      @Override     protected AbstractOptionSpec<Integer> newOptionSpec() {         return new OptionalArgumentOptionSpec<Integer>( "life" ).ofType( Integer.class );     }      @Override     protected String firstArg() {         return "1";     }      @Override     protected String secondArg() {         return "2";     }      @Override     protected Integer newItem() {         return 3;     }      @Override     protected Integer containedItem() {         return 2;     } } 
package joptsimple;  import static org.junit.Assert.*;  import java.util.Date; import java.util.HashMap;  import org.junit.Test;  import joptsimple.util.DateConverter;  public class BuiltinHelpFormatterTest {      @Test //for issue #127     public void testFormatHelpWithDateOptionAndPatternThatContainsDots() throws Exception {         NonOptionArgumentSpec<String> nonOptionArgumentSpec = new NonOptionArgumentSpec<>();          ArgumentAcceptingOptionSpec<Date> optionSpec = new RequiredArgumentOptionSpec<Date>( "date" )             .withValuesConvertedBy( DateConverter.datePattern( "dd.MM.yyyy" ) );          HashMap<String, OptionDescriptor> options = new HashMap<>();          options.put( "none", nonOptionArgumentSpec );         options.put( "date", optionSpec );          BuiltinHelpFormatter builtinHelpFormatter = new BuiltinHelpFormatter();          String actual = builtinHelpFormatter.format( options );          String expected =             "Option               Description\n" +                 "------               -----------\n" +                 "--date <dd.MM.yyyy>             \n";          assertEquals( expected, actual );     }  }
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.File; import java.util.List;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSynonymOptionalArgumentTest extends AbstractOptionParserFixture {     private String optionArgument;      @Before     public final void initializeParser() {         parser.acceptsAll( asList( "d", "output-dir", "folder" ), "file" ).withRequiredArg().ofType( File.class );         optionArgument = "tmp";     }      @Test     public void hasAllSynonymsWhenFirstSynonymParsed() {         assertDetections( new String[] { "-d", optionArgument }, singletonList( new File( optionArgument ) ) );     }      @Test     public void hasAllSynonymsWhenSecondSynonymParsed() {         assertDetections( new String[] { "--ou", optionArgument }, singletonList( new File( optionArgument ) ) );     }      @Test     public void hasAllSynonymsWhenThirdSynonymParsed() {         assertDetections( new String[] { "--fold", optionArgument }, singletonList( new File( optionArgument ) ) );     }      @Test     public void reportsSameListOfArgumentsForEverySynonymOption() {         assertDetections(             new String[] { "-d", "opt", "--output-dir", "tmp", "--folder", "usr" },             asList( new File( "opt" ), new File( "tmp" ), new File( "usr" ) ) );     }      private void assertDetections( String[] args, List<?> optionArguments ) {         OptionSet options = parser.parse( args );         assertEquals( optionArguments, options.valuesOf( "d" ) );         assertEquals( optionArguments, options.valuesOf( "output-dir" ) );         assertEquals( optionArguments, options.valuesOf( "folder" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  class SwitchConverter implements ValueConverter<Boolean> {     @Override     public Boolean convert( String value ) {         if ( "on".equalsIgnoreCase( value ) )             return true;         if ( "off".equalsIgnoreCase( value ) )             return false;          throw new IllegalArgumentException(             String.format(                 "String value '%s' must match '%s'.",                 value,                 valuePattern()));     }      @Override     public String revert( Object value ) {         boolean converted = valueType().cast( value );         return converted ? "on" : "off";     }      @Override     public Class<Boolean> valueType() {         return Boolean.class;     }      @Override     public String valuePattern() {         return "/(?:on|off)/i";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Collection;  import static java.util.Arrays.*;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ @RunWith( Parameterized.class ) public class PosixlyCorrectOptionParserTest {     private final OptionParser parser;      public PosixlyCorrectOptionParserTest( OptionParser parser ) {         this.parser = parser;     }      @Parameterized.Parameters     public static Collection<?> parsers() {         return asList( new Object[] {             new OptionParser() { {                 posixlyCorrect( true );                 accepts( "i" ).withRequiredArg();                 accepts( "j" ).withOptionalArg();                 accepts( "k" );             } } },             new Object[] { new OptionParser( "+i:j::k" ) } );     }      @Test     public void parseWithPosixlyCorrect() {         OptionSet options =             parser.parse( "-ibar", "-i", "junk", "xyz", "-jixnay", "foo", "-k", "blah", "--", "yermom" );          assertTrue( "i?", options.has( "i" ) );         assertFalse( "j?", options.has( "j" ) );         assertFalse( "k?", options.has( "k" ) );         assertEquals( "args of i?", asList( "bar", "junk" ), options.valuesOf( "i" ) );         assertEquals( "non-option args?",             asList( "xyz", "-jixnay", "foo", "-k", "blah", "--", "yermom" ),             options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*;  import org.junit.Before; import org.junit.Test;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSynonymOverwritingTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.acceptsAll( asList( "h", "help" ) );         parser.acceptsAll( asList( "h", "oops" ) );     }      @Test     public void treatsHAsThoughItWereLastDefinedSynonymOfH() {         OptionSet options = parser.parse( "-h" );          assertOptionDetected( options, "h" );         assertOptionDetected( options, "oops" );         assertOptionNotDetected( options, "help" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class PlainOldOptionParserTest extends AbstractOptionParserFixture {     @Test     public void nonOptionsOnly() {         String[] arguments = { "foo", "bar" };          OptionSet options = parser.parse( arguments );          assertEquals( asList( arguments ), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import java.util.Arrays; import java.util.Collection; import java.util.Locale;  import static java.util.Arrays.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ @RunWith( Parameterized.class ) public class OptionExceptionLocalizedMessageTest {     private final OptionException subject;     private final String expectedMessage;      public OptionExceptionLocalizedMessageTest( OptionException subject, String expectedMessage ) {         this.subject = subject;         this.expectedMessage = expectedMessage;     }      @Parameterized.Parameters     public static Collection<?> exceptionsAndMessages() {         return asList(             new Object[] { new IllegalOptionSpecificationException( "," ), "illegal option specification exception" },             new Object[] { new MultipleArgumentsForOptionException(                 new RequiredArgumentOptionSpec<>( asList( "b", "c" ), "d" ) ),                 "multiple arguments for option exception" },             new Object[] { new OptionArgumentConversionException(                 new RequiredArgumentOptionSpec<>( asList( "c", "number" ), "x" ), "d", null ),                 "option argument conversion exception" },             new Object[] { new OptionMissingRequiredArgumentException(                 new RequiredArgumentOptionSpec<>( asList( "e", "honest" ), "" ) ),                 "option missing required argument exception" },             new Object[] { new UnrecognizedOptionException( "f" ), "unrecognized option exception" },             new Object[] { new MissingRequiredOptionsException(                 Arrays.<AbstractOptionSpec<?>> asList(                     new NoArgumentOptionSpec( "g" ), new NoArgumentOptionSpec( "h" ) ) ),                 "missing required option exception" },             new Object[] { new MissingRequiredOptionsException(                     Arrays.<AbstractOptionSpec<?>> asList(                         new RequiredArgumentOptionSpec<>( asList( "p", "place" ), "spot" ),                         new RequiredArgumentOptionSpec<>( asList( "d", "data-dir" ), "dir" ) ) ),                     "missing required option exception" },             new Object[] { new UnconfiguredOptionException( asList( "i", "j" ) ),                 "unconfigured option exception" }         );     }      @Test     public void givesCorrectExceptionMessage() {         assertEquals( expectedMessage, subject.localizedMessage( new Locale( "aa", "BB" ) ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Test;  import static org.infinitest.toolkit.Assertions.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ArgumentAcceptingOptionSpecTest {     @Test( expected = NullPointerException.class )     public void requiredArgOfNullType() {         new RequiredArgumentOptionSpec<Void>( "a" ).ofType( null );     }      @Test( expected = NullPointerException.class )     public void optionalArgOfNullType() {         new OptionalArgumentOptionSpec<Void>( "verbose" ).ofType( null );     }      @Test( expected = IllegalArgumentException.class )     public void requiredArgOfNonValueType() {         new RequiredArgumentOptionSpec<Void>( "threshold" ).ofType( Object.class );     }      @Test( expected = IllegalArgumentException.class )     public void optionalArgOfNonValueType() {         new OptionalArgumentOptionSpec<Void>( "max" ).ofType( Object.class );     }      @Test     public void requiredArgOfValueTypeBasedOnValueOf() {         assertNoException(             () -> new RequiredArgumentOptionSpec<Void>( "threshold" ).ofType( ValueOfHaver.class ));     }      @Test     public void optionalArgOfValueTypeBasedOnValueOf() {         assertNoException(             () -> new OptionalArgumentOptionSpec<Void>( "abc" ).ofType( ValueOfHaver.class ));     }      @Test     public void requiredArgOfValueTypeBasedOnCtor() {         assertNoException(             () -> new RequiredArgumentOptionSpec<Void>( "threshold" ).ofType( Ctor.class ));     }      @Test     public void optionalArgOfValueTypeBasedOnCtor() {         final OptionalArgumentOptionSpec<Ctor> spec = new OptionalArgumentOptionSpec<>( "abc" );          assertNoException(() -> {             spec.ofType( Ctor.class );              assertEquals( "foo", spec.convert( "foo" ).getS() );         });     }      @Test( expected = IllegalArgumentException.class )     public void rejectsUnicodeZeroAsCharValueSeparatorForRequiredArgument() {         new RequiredArgumentOptionSpec<Void>( "a" ).withValuesSeparatedBy( '\u0000' );     }      @Test( expected = IllegalArgumentException.class )     public void rejectsUnicodeZeroAsCharValueSeparatorForOptionalArgument() {         new OptionalArgumentOptionSpec<Void>( "b" ).withValuesSeparatedBy( '\u0000' );     }      @Test( expected = IllegalArgumentException.class )     public void rejectsUnicodeZeroInStringValueSeparatorForRequiredArgument() {         new RequiredArgumentOptionSpec<Void>( "c" ).withValuesSeparatedBy( "::\u0000::" );     }      @Test( expected = IllegalArgumentException.class )     public void rejectsUnicodeZeroInStringValueSeparatorForOptionalArgument() {         new OptionalArgumentOptionSpec<Void>( "d" ).withValuesSeparatedBy( "::::\u0000" );     }      @Test( expected = NullPointerException.class )     public void rejectsNullConverter() {         new RequiredArgumentOptionSpec<Void>( "c" ).withValuesConvertedBy( null );     }      @Test( expected = NullPointerException.class )     public void rejectsNullDefaultValue() {         new RequiredArgumentOptionSpec<Integer>( "d" ).defaultsTo( null );     }      @Test( expected = NullPointerException.class )     public void rejectsNullDefaultValueRemainder() {         new RequiredArgumentOptionSpec<Integer>( "d" ).defaultsTo( 2, (Integer[]) null );     }      @Test( expected = NullPointerException.class )     public void rejectsNullInDefaultValueRemainder() {         new RequiredArgumentOptionSpec<Integer>( "d" ).defaultsTo( 2, 3, null );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ArgumentListTest {     private ArgumentList args;      @Before     public void setUp() {         args = new ArgumentList( "-a", "b", "c" );     }      @Test     public void nextAndPeek() {         assertNextArgumentIs( "-a" );         assertNextArgumentIs( "b" );         assertNextArgumentIs( "c" );         assertNoMoreArguments();     }      @Test     public void treatNextAsLongOption() {         args.treatNextAsLongOption();         assertNextArgumentIs( "-a" );          args.treatNextAsLongOption();         assertNextArgumentIs( "--b" );          args.treatNextAsLongOption();         assertNextArgumentIs( "--c" );          assertNoMoreArguments();     }      private void assertNextArgumentIs( String expectedArg ) {         assertTrue( "no more arguments?", args.hasMore() );         assertEquals( "peek?", expectedArg, args.peek() );         assertEquals( "next?", expectedArg, args.next() );     }      private void assertNoMoreArguments() {         assertFalse( "more arguments?", args.hasMore() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.math.BigDecimal; import java.util.List; import java.util.Optional;  import static java.math.BigDecimal.*; import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class HandlingDefaultValuesForOptionArgumentsTest extends AbstractOptionParserFixture {     @Test     public void requiredArgOptionWithDefaultGivesArgIfArgSpecifiedOnCommandLine() {         OptionSpec<Integer> optionA =             parser.accepts( "a" ).withRequiredArg().ofType( Integer.class ).defaultsTo( 2 );          OptionSet options = parser.parse( "-a", "1" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( optionA ) );         assertTrue( options.hasArgument( "a" ) );         assertTrue( options.hasArgument( optionA ) );         Integer expectedArgument = 1;         assertEquals( expectedArgument, options.valueOf( "a" ) );         assertEquals( expectedArgument, options.valueOf( optionA ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( "a" ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( optionA ) );         assertEquals( expectedArgument, optionA.value( options ) );         assertEquals( Optional.of( expectedArgument ), optionA.valueOptional( options ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( "a" ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( optionA ) );         assertEquals( singletonList( expectedArgument ), optionA.values( options ) );     }      @Test( expected = OptionMissingRequiredArgumentException.class )     public void requiredArgOptionWithDefaultStillsFailToParseIfArgNotSpecifiedOnCommandLine() {         parser.accepts( "a" ).withRequiredArg().defaultsTo( "boo" );          parser.parse( "-a" );     }      @Test     public void optionalArgOptionWithDefaultGivesDefaultIfArgNotSpecifiedOnCommandLine() {         OptionSpec<Long> optionA =             parser.accepts( "a" ).withOptionalArg().ofType( Long.class ).defaultsTo( -1L );          OptionSet options = parser.parse( "-a" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( optionA ) );         assertFalse( options.hasArgument( "a" ) );         assertFalse( options.hasArgument( optionA ) );         Long expectedArgument = -1L;         assertEquals( expectedArgument, options.valueOf( "a" ) );         assertEquals( expectedArgument, options.valueOf( optionA ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( "a" ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( optionA ) );         assertEquals( expectedArgument, optionA.value( options ) );         assertEquals( Optional.of( expectedArgument ), optionA.valueOptional( options ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( "a" ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( optionA ) );         assertEquals( singletonList( expectedArgument ), optionA.values( options ) );     }      @Test     public void optionalArgOptionWithDefaultGivesArgIfSpecifiedOnCommandLine() {         OptionSpec<Long> optionA =             parser.accepts( "a" ).withOptionalArg().ofType( Long.class ).defaultsTo( -1L );          OptionSet options = parser.parse( "-a", "2" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( optionA ) );         assertTrue( options.hasArgument( "a" ) );         assertTrue( options.hasArgument( optionA ) );         Long expectedArgument = 2L;         assertEquals( expectedArgument, options.valueOf( "a" ) );         assertEquals( expectedArgument, options.valueOf( optionA ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( "a" ) );         assertEquals( Optional.of( expectedArgument ), options.valueOfOptional( optionA ) );         assertEquals( expectedArgument, optionA.value( options ) );         assertEquals( Optional.of( expectedArgument ), optionA.valueOptional( options ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( "a" ) );         assertEquals( singletonList( expectedArgument ), options.valuesOf( optionA ) );         assertEquals( singletonList( expectedArgument ), optionA.values( options ) );     }      @Test     public void requiredArgOptionWithDefaultGivesDefaultIfOptionNotOnCommandLine() {         OptionSpec<BigDecimal> optionA =             parser.accepts( "a" ).withRequiredArg().ofType( BigDecimal.class ).defaultsTo( TEN );          OptionSet options = parser.parse();          assertFalse( options.has( "a" ) );         assertFalse( options.has( optionA ) );         assertFalse( options.hasArgument( "a" ) );         assertFalse( options.hasArgument( optionA ) );         assertEquals( TEN, options.valueOf( "a" ) );         assertEquals( TEN, options.valueOf( optionA ) );         assertEquals( Optional.of( TEN ), options.valueOfOptional( "a" ) );         assertEquals( Optional.of( TEN ), options.valueOfOptional( optionA ) );         assertEquals( TEN, optionA.value( options ) );         assertEquals( Optional.of( TEN ), optionA.valueOptional( options ) );         assertEquals( singletonList( TEN ), options.valuesOf( "a" ) );         assertEquals( singletonList( TEN ), options.valuesOf( optionA ) );         assertEquals( singletonList( TEN ), optionA.values( options ) );     }      @Test     public void optionalArgOptionWithDefaultGivesDefaultIfOptionNotOnCommandLine() {         OptionSpec<BigDecimal> optionA =             parser.accepts( "a" ).withOptionalArg().ofType( BigDecimal.class ).defaultsTo( TEN );          OptionSet options = parser.parse();          assertFalse( options.has( "a" ) );         assertFalse( options.has( optionA ) );         assertFalse( options.hasArgument( "a" ) );         assertFalse( options.hasArgument( optionA ) );         assertEquals( TEN, options.valueOf( "a" ) );         assertEquals( TEN, options.valueOf( optionA ) );         assertEquals( Optional.of( TEN ), options.valueOfOptional( "a" ) );         assertEquals( Optional.of( TEN ), options.valueOfOptional( optionA ) );         assertEquals( TEN, optionA.value( options ) );         assertEquals( Optional.of( TEN ), optionA.valueOptional( options ) );         assertEquals( singletonList( TEN ), options.valuesOf( "a" ) );         assertEquals( singletonList( TEN ), options.valuesOf( optionA ) );         assertEquals( singletonList( TEN ), optionA.values( options ) );     }      @Test     public void allowsListOfDefaults() {         OptionSpec<Integer> optionC =             parser.accepts( "c" ).withOptionalArg().ofType( Integer.class ).defaultsTo( 1, 2, 3 );          OptionSet options = parser.parse();          List<Integer> expected = asList( 1, 2, 3 );         assertEquals( expected, optionC.values( options ) );         assertEquals( expected, options.valuesOf( optionC ) );     }      @Test     public void specifiedOptionArgumentsTrumpsListOfDefaults() {         OptionSpec<Integer> optionC =             parser.accepts( "c" ).withRequiredArg().ofType( Integer.class )                 .defaultsTo( 1, 2, 3 ).withValuesSeparatedBy( ',' );          OptionSet options = parser.parse( "-c", "4", "-c", "5", "-c", "6,7,8" );          List<Integer> expected = asList( 4, 5, 6, 7, 8 );         assertEquals( expected, optionC.values( options ) );         assertEquals( expected, options.valuesOf( optionC ) );     }      @Test     public void withCompileTimeArraySpecifyingDefaults() {         OptionSpec<Integer> optionD =             parser.accepts( "d" ).withRequiredArg().ofType( Integer.class ).defaultsTo( new Integer[] { 1, 2, 3 } );          OptionSet options = parser.parse();          List<Integer> expected = asList( 1, 2, 3 );         assertEquals( expected, optionD.values( options ) );         assertEquals( expected, options.valuesOf( optionD ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class WExtensionWithArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.recognizeAlternativeLongOptions( true );         parser.accepts( "silent" ).withOptionalArg();     }      @Test     public void separateArgument() {         OptionSet options = parser.parse( "-W", "silent", "4" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "silent" );         assertEquals( singletonList( "4" ), options.valuesOf( "silent" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void togetherArgument() {         OptionSet options = parser.parse( "-W", "silent=6" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "silent" );         assertEquals( singletonList( "6" ), options.valuesOf( "silent" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void abbreviationWithTogetherArgument() {         OptionSet options = parser.parse( "-W", "s=6" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "silent" );         assertOptionNotDetected( options, "s" );         assertEquals( singletonList( "6" ), options.valuesOf( "silent" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void illegalLongOption() {         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "foo" ) );          parser.parse( "-W", "foo=bar" );     }      @Test     public void noMoreArguments() {         thrown.expect( OptionMissingRequiredArgumentException.class );         thrown.expect( withOption( "W" ) );          parser.parse( "-W" );     }      @Test     public void typedTogetherArg() {         OptionSpec<Integer> level = parser.accepts( "level" ).withRequiredArg().ofType( Integer.class );          OptionSet options = parser.parse( "-W", "level=4" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "level" );         assertEquals( singletonList( 4 ), options.valuesOf( level ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void typedSeparateArg() {         OptionSpec<Integer> floor = parser.accepts( "floor" ).withRequiredArg().ofType( Integer.class );          OptionSet options = parser.parse( "-W", "floor", "5" );          assertOptionNotDetected( options, "W" );         assertOptionDetected( options, "floor" );         assertEquals( singletonList( 5 ), options.valuesOf( floor ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.List;  import org.infinitest.toolkit.UnmodifiableListTestSupport;  import static java.util.Arrays.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionExceptionOptionsImmutabilityTest extends UnmodifiableListTestSupport<String> {     @Override     protected List<String> newList() {         return new OptionException( asList( "a", "b" ) ) {             private static final long serialVersionUID = -1L;              @Override             Object[] messageArguments() {                 return new Object[0];             }         }.options();     }      @Override     protected String newItem() {         return "c";     }      @Override     protected String containedItem() {         return "a";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.lang.reflect.InvocationTargetException;  import org.hamcrest.Description; import org.hamcrest.Matcher; import org.hamcrest.TypeSafeMatcher;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ExceptionMatchers {     private ExceptionMatchers() {         throw new UnsupportedOperationException();     }      public static Matcher<OptionException> withOption( final String option ) {         return new TypeSafeMatcher<OptionException>() {             @Override             public boolean matchesSafely( OptionException target ) {                 return target.options().contains( option );             }              public void describeTo( Description description ) {                 description.appendText( "an OptionException indicating the option ");                 description.appendValue( option );             }         };     }      public static Matcher<Throwable> withCauseOfType( final Class<? extends Throwable> type ) {         return new TypeSafeMatcher<Throwable>() {             @Override             public boolean matchesSafely( Throwable target ) {                 return type.isInstance( target.getCause() );             }              public void describeTo( Description description ) {                 description.appendText( "an exception with cause of type " );                 description.appendValue( type );             }         };     }      public static Matcher<InvocationTargetException> withTargetOfType( final Class<? extends Throwable> type ) {         return new TypeSafeMatcher<InvocationTargetException>() {             @Override             public boolean matchesSafely( InvocationTargetException target ) {                 return type.isInstance( target.getTargetException() );             }              public void describeTo( Description description ) {                 description.appendText( "an InvocationTargetException with target of type " );                 description.appendValue( type );             }         };     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ShortOptionsOptionalArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "f" ).withOptionalArg();         parser.accepts( "g" ).withOptionalArg();         parser.accepts( "bar" ).withOptionalArg();     }      @Test     public void optionWithOptionalArgumentNotPresent() {         OptionSet options = parser.parse( "-f" );          assertOptionDetected( options, "f" );         assertEquals( emptyList(), options.valuesOf( "f" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionWithOptionalArgumentPresent() {         OptionSet options = parser.parse( "-f", "bar" );          assertOptionDetected( options, "f" );         assertEquals( singletonList( "bar" ), options.valuesOf( "f" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionWithOptionalArgumentThatLooksLikeAnInvalidOption() {         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "biz" ) );          parser.parse( "-f", "--biz" );     }      @Test     public void optionWithOptionalArgumentThatLooksLikeAValidOption() {         OptionSet options = parser.parse( "-f", "--bar" );          assertOptionDetected( options, "f" );         assertOptionDetected( options, "bar" );         assertEquals( emptyList(), options.valuesOf( "f" ) );         assertEquals( emptyList(), options.valuesOf( "bar" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionWithOptionalArgumentFollowedByLegalOption() {         OptionSet options = parser.parse( "-f", "-g" );          assertOptionDetected( options, "f" );         assertOptionDetected( options, "g" );         assertEquals( emptyList(), options.valuesOf( "f" ) );         assertEquals( emptyList(), options.valuesOf( "g" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void multipleOfSameOptionSomeWithArgsAndSomeWithout() {         OptionSet options = parser.parse( "-f", "-f", "foo", "-f", "-f", "bar", "-f" );          assertEquals( asList( "foo", "bar" ), options.valuesOf( "f" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ValueOfHaver {     private ValueOfHaver() {         // no-op     }      public static ValueOfHaver valueOf( String s ) {         return null;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ArgumentListHasNoMoreArgsTest {     private ArgumentList noMore;      @Before     public void setUp() {         noMore = new ArgumentList();     }      @Test( expected = IndexOutOfBoundsException.class )     public void peek() {         noMore.peek();     }      @Test( expected = IndexOutOfBoundsException.class )     public void next() {         noMore.next();     }      @Test( expected = IndexOutOfBoundsException.class )     public void treatNextAsLongOption() {         noMore.treatNextAsLongOption();     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Arrays.asList; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class Issue76Test {     private OptionParser parser;     private OptionSpec<Integer> nonOptions;      @Before     public void setUp() {         parser = new OptionParser();         parser.accepts( "flag" ).withOptionalArg().withValuesConvertedBy( new ValueConverter<Boolean>() {             public Boolean convert( String value ) {                 if ( "true".equals( value ) )                     return true;                 if ( "false".equals( value ) )                     return false;                 throw new ValueConversionException( "need 'true' or 'false'" );             }              public Class<? extends Boolean> valueType() {                 return boolean.class;             }              public String valuePattern() {                 return null;             }         });         nonOptions = parser.nonOptions().ofType( Integer.class );     }      @Test     public void suppliedExample() {         OptionSet parsed = parser.parse( "--flag", "1", "2" );          assertTrue( parsed.has( "flag" ) );         assertEquals( asList( 1, 2 ), nonOptions.values( parsed ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Rule; import org.junit.rules.ExpectedException;  import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public abstract class AbstractOptionParserFixture {     @Rule public final ExpectedException thrown = none();      protected OptionParser parser;      @Before     public final void createNewParser() {         parser = new OptionParser();     }      static void assertOptionDetected( OptionSet detectedOptions, String option ) {         assertTrue( "option '" + option + "' not detected?", detectedOptions.has( option ) );     }      static void assertOptionNotDetected( OptionSet detectedOptions, String option ) {         assertOptionNotDetected( "option '" + option + "' detected?", detectedOptions, option );     }      static void assertOptionNotDetected( String message, OptionSet detectedOptions, String option ) {         assertFalse( message, detectedOptions.has( option ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class SingleHyphenTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "o" ).withOptionalArg();     }      @Test     public void singleHyphen() {         OptionSet options = parser.parse( "-" );          assertEquals( singletonList( "-" ), options.nonOptionArguments() );     }      @Test     public void asArgumentOfOption() {         OptionSet options = parser.parse( "-o", "-" );          assertOptionDetected( options, "o" );         assertEquals( singletonList( "-" ), options.valuesOf( "o" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void asArgumentOfOptionInSameToken() {         OptionSet options = parser.parse( "-o-" );          assertOptionDetected( options, "o" );         assertEquals( singletonList( "-" ), options.valuesOf( "o" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RequiredArgumentOptionSpecValuesImmutabilityTest     extends AbstractOptionSpecValuesImmutabilityTestCase<String> {      @Override     protected AbstractOptionSpec<String> newOptionSpec() {         return new RequiredArgumentOptionSpec<>( "file" );     }      @Override     protected String firstArg() {         return "arg1";     }      @Override     protected String secondArg() {         return "arg2";     }      @Override     protected String newItem() {         return "arg3";     }      @Override     protected String containedItem() {         return "arg1";     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Optional;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ParserRules.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ShortOptionsNoArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "a" );         parser.accepts( "b" );         parser.accepts( "c" );     }      @Test     public void singleOption() {         OptionSet options = parser.parse( "-a" );          assertOptionDetected( options, "a" );         assertNull( options.valueOf( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void twoSingleOptions() {         OptionSet options = parser.parse( "-a", "-b" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertNull( options.valueOf( "a" ) );         assertNull( options.valueOf( "b" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void singleOptionWithOneNonOptionArgument() {         OptionSet options = parser.parse( "-c", "foo" );          assertOptionDetected( options, "c" );         assertNull( options.valueOf( "c" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "c" ) );         assertEquals( singletonList( "foo" ), options.nonOptionArguments() );     }      @Test     public void clusteredOptions() {         OptionSet options = parser.parse( "-bac" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertOptionDetected( options, "c" );         assertNull( options.valueOf( "a" ) );         assertNull( options.valueOf( "b" ) );         assertNull( options.valueOf( "c" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "b" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "c" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void optionsTerminator() {         OptionSet options = parser.parse( "-a", OPTION_TERMINATOR, "-a", "-b" );          assertOptionDetected( options, "a" );         assertNull( options.valueOf( "a" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "a" ) );         assertOptionNotDetected( options, "b" );         assertEquals( asList( "-a", "-b" ), options.nonOptionArguments() );     }      @Test     public void appearingMultipleTimes() {         OptionSet options = parser.parse( "-b", "-b", "-b" );          assertOptionDetected( options, "b" );         assertNull( options.valueOf( "b" ) );         assertEquals( Optional.empty(), options.valueOfOptional( "b" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Test;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionParserArgumentExceptionTest extends AbstractOptionParserFixture {     @Test( expected = NullPointerException.class )     public void createWithNullOptionSpec() {         new OptionParser( null );     }      @Test( expected = NullPointerException.class )     public void parseNull() {         parser.parse( (String[]) null );     }      @Test( expected = NullPointerException.class )     public void nullOptionToAccepts() {         parser.accepts( null );     }      @Test( expected = NullPointerException.class )     public void nullOptionToAcceptsWithDescription() {         parser.accepts( null, "a weird option" );     }      @Test( expected = NullPointerException.class )     public void nullOptionListToAcceptsAll() {         parser.acceptsAll( null );     }      @Test( expected = IllegalArgumentException.class )     public void emptyOptionListToAcceptsAll() {         parser.acceptsAll( emptyList() );     }      @Test( expected = NullPointerException.class )     public void optionListContainingNullToAcceptsAll() {         parser.acceptsAll( singletonList( null ) );     }      @Test( expected = NullPointerException.class )     public void nullOptionListToAcceptsAllWithDescription() {         parser.acceptsAll( null, "some weird options" );     }      @Test( expected = NullPointerException.class )     public void optionListContainingNullToAcceptsAllWithDescription() {         parser.acceptsAll( singletonList( null ), "some weird options" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Test;  import static org.infinitest.toolkit.CollectionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionalArgumentOptionSpecTest extends AbstractOptionSpecFixture {     @Override     protected OptionalArgumentOptionSpec<?> createEqualOptionSpecInstance() {         return new OptionalArgumentOptionSpec<Void>( "d" );     }      @Override     protected OptionalArgumentOptionSpec<?> createNotEqualOptionSpecInstance() {         return new OptionalArgumentOptionSpec<Void>( "c" );     }      @Test     public void optionsContents() {         assertThat( createNotEqualOptionSpecInstance().options(), hasSameContentsAs( singletonList( "c" ) ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser;  public class RequiredUnlessExample {     public static void main( String[] args ) {         OptionParser parser = new OptionParser();         parser.accepts( "anonymous" );         parser.accepts( "username" ).requiredUnless( "anonymous" ).withRequiredArg();         parser.accepts( "password" ).requiredUnless( "anonymous" ).withRequiredArg();          parser.parse( "--anonymous" );     } } 
package joptsimple.examples;  import static java.util.Arrays.*;  import joptsimple.OptionException; import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  public class ShortOptionsWithMultipleArgumentsForSingleOptionTest {     @Rule public final ExpectedException thrown = none();      @Test     public void allowsMultipleValuesForAnOption() {         OptionParser parser = new OptionParser( "a:" );          OptionSet options = parser.parse( "-a", "foo", "-abar", "-a=baz" );          assertTrue( options.has( "a" ) );         assertTrue( options.hasArgument( "a" ) );         assertEquals( asList( "foo", "bar", "baz" ), options.valuesOf( "a" ) );          thrown.expect( OptionException.class );         options.valueOf( "a" );     } } 
package joptsimple.examples;  import static java.util.Collections.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class LongOptionsWithArgumentsTest {     @Test     public void supportsLongOptionsWithArgumentsAndAbbreviations() {         OptionParser parser = new OptionParser();         parser.accepts( "flag" );         parser.accepts( "count" ).withRequiredArg();         parser.accepts( "level" ).withOptionalArg();          OptionSet options = parser.parse( "-flag", "--co", "3", "--lev" );          assertTrue( options.has( "flag" ) );          assertTrue( options.has( "count" ) );         assertTrue( options.hasArgument( "count" ) );         assertEquals( "3", options.valueOf( "count" ) );         assertEquals( singletonList( "3" ), options.valuesOf( "count" ) );          assertTrue( options.has( "level" ) );         assertFalse( options.hasArgument( "level" ) );         assertNull( options.valueOf( "level" ) );         assertEquals( emptyList(), options.valuesOf( "level" ) );     }      @Test     public void supportsLongOptionsWithEmptyArguments() {         OptionParser parser = new OptionParser();         parser.accepts( "verbose" );         parser.accepts( "brief" );         parser.accepts( "add" );         parser.accepts( "append" );         parser.accepts( "delete" ).withRequiredArg();         parser.accepts( "create" ).withRequiredArg();         parser.accepts( "file" ).withRequiredArg();          OptionSet options = parser.parse( "--delete", "", "--add" );          assertTrue( options.has( "delete" ) );         assertTrue( options.hasArgument( "delete" ) );         assertEquals( "", options.valueOf( "delete" ) );          assertTrue( options.has( "add" ) );          options = parser.parse( "--delete=", "--add" );          assertTrue( options.has( "delete" ) );         assertTrue( options.hasArgument( "delete" ) );         assertEquals( "", options.valueOf( "delete" ) );          assertTrue( options.has( "add" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class LongOptionsWithArgumentPositioningTest {     @Test     public void allowsDifferentFormsOfPairingArgumentWithOption() {         OptionParser parser = new OptionParser();         parser.accepts( "count" ).withRequiredArg();         parser.accepts( "level" ).withOptionalArg();          OptionSet options = parser.parse( "--count", "4", "--level=3" );          assertTrue( options.has( "count" ) );         assertTrue( options.hasArgument( "count" ) );         assertEquals( "4", options.valueOf( "count" ) );          assertTrue( options.has( "level" ) );         assertTrue( options.hasArgument( "level" ) );         assertEquals( "3", options.valueOf( "level" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser;  public class ExceptionExample {     public static void main( String[] args ) {         OptionParser parser = new OptionParser();          parser.parse( "-x" );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class ShortOptionsClusteringWithArgumentTest {     @Test     public void allowsClusteringShortOptionsThatAcceptArguments() {         OptionParser parser = new OptionParser();         parser.accepts( "a" );         parser.accepts( "B" );         parser.accepts( "c" ).withRequiredArg();          OptionSet options = parser.parse( "-aBcfoo" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( "B" ) );         assertTrue( options.has( "c" ) );         assertEquals( "foo", options.valueOf( "c" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class LongOptionsTest {     @Test     public void acceptsLongOptions() {         OptionParser parser = new OptionParser();         parser.accepts( "flag" );         parser.accepts( "verbose" );          OptionSet options = parser.parse( "--flag" );          assertTrue( options.has( "flag" ) );         assertFalse( options.has( "verbose" ) );     } } 
package joptsimple.examples;  public enum Level {     WARNING,     INFO,     DEBUG } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.joda.time.LocalDate; import org.junit.Test;  import static joptsimple.util.DateConverter.*; import static joptsimple.util.RegexMatcher.*; import static org.junit.Assert.*;  public class OptionArgumentConverterTest {     @Test     public void usesConvertersOnOptionArgumentsWhenTold() {         OptionParser parser = new OptionParser();         parser.accepts( "birthdate" ).withRequiredArg().withValuesConvertedBy( datePattern( "MM/dd/yy" ) );         parser.accepts( "ssn" ).withRequiredArg().withValuesConvertedBy( regex( "\\d{3}-\\d{2}-\\d{4}" ));          OptionSet options = parser.parse( "--birthdate", "02/24/05", "--ssn", "123-45-6789" );          assertEquals( new LocalDate( 2005, 2, 24 ).toDate(), options.valueOf( "birthdate" ) );         assertEquals( "123-45-6789", options.valueOf( "ssn" ) );     } } 
package joptsimple.examples;  import java.io.File; import java.util.stream.Stream;  import static java.io.File.*; import static java.util.Arrays.*;  import static java.util.stream.Collectors.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import joptsimple.OptionSpec; import org.junit.Test;  import static org.junit.Assert.*;  public class MultipleDelimitedArgumentsTest {     @Test     public void supportsMultipleDelimitedArguments() {         OptionParser parser = new OptionParser();         OptionSpec<File> path = parser.accepts( "path" ).withRequiredArg().ofType( File.class )             .withValuesSeparatedBy( pathSeparatorChar );          OptionSet options = parser.parse(             "--path",             Stream.of( "/tmp", "/var", "/opt" ).collect( joining( pathSeparator ) ) );          assertTrue( options.has( path ) );         assertTrue( options.hasArgument( path ) );         assertEquals(             asList( new File( "/tmp" ), new File( "/var" ), new File( "/opt" ) ),             options.valuesOf( path ) );     } } 
package joptsimple.examples;  import java.io.File;  import static java.io.File.*; import static java.util.Arrays.*;  import joptsimple.OptionParser;  import static joptsimple.util.DateConverter.*;  public class HelpScreenExample {     public static void main( String[] args ) throws Exception {         OptionParser parser = new OptionParser() {             {                 accepts( "c" ).withRequiredArg().ofType( Integer.class )                     .describedAs( "count" ).defaultsTo( 1 );                 accepts( "q" ).withOptionalArg().ofType( Double.class )                     .describedAs( "quantity" );                 accepts( "d", "some date" ).withRequiredArg().required()                     .withValuesConvertedBy( datePattern( "MM/dd/yy" ) );                 acceptsAll( asList( "v", "talkative", "chatty" ), "be more verbose" );                 accepts( "output-file" ).withOptionalArg().ofType( File.class )                      .describedAs( "file" );                 acceptsAll( asList( "h", "?" ), "show help" ).forHelp();                 acceptsAll( asList( "cp", "classpath" ) ).withRequiredArg()                     .describedAs( "path1" + pathSeparatorChar + "path2:..." )                     .ofType( File.class )                     .withValuesSeparatedBy( pathSeparatorChar );             }         };          parser.printHelpOn( System.out );     } } 
package joptsimple.examples;  import java.io.File;  import static java.util.Arrays.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import joptsimple.OptionSpec; import org.junit.Test;  import static java.util.Collections.*; import static org.junit.Assert.*;  public class TypesafeOptionArgumentRetrievalTest {     @Test     public void allowsTypesafeRetrievalOfOptionArguments() {         OptionParser parser = new OptionParser();         OptionSpec<Integer> count = parser.accepts( "count" ).withRequiredArg().ofType( Integer.class );         OptionSpec<File> outputDir = parser.accepts( "output-dir" ).withOptionalArg().ofType( File.class );         OptionSpec<Void> verbose = parser.accepts( "verbose" );         OptionSpec<File> files = parser.nonOptions().ofType( File.class );          OptionSet options = parser.parse( "--count", "3", "--output-dir", "/tmp", "--verbose", "a.txt", "b.txt" );          assertTrue( options.has( verbose ) );          assertTrue( options.has( count ) );         assertTrue( options.hasArgument( count ) );         Integer expectedCount = 3;         assertEquals( expectedCount, options.valueOf( count ) );         assertEquals( expectedCount, count.value( options ) );         assertEquals( singletonList( expectedCount ), options.valuesOf( count ) );         assertEquals( singletonList( expectedCount ), count.values( options ) );         assertEquals( asList( new File( "a.txt" ), new File( "b.txt" ) ), options.valuesOf( files ) );          assertTrue( options.has( outputDir ) );         assertTrue( options.hasArgument( outputDir ) );         File expectedFile = new File( "/tmp" );         assertEquals( expectedFile, options.valueOf( outputDir ) );         assertEquals( expectedFile, outputDir.value( options ) );         assertEquals( singletonList( expectedFile ), options.valuesOf( outputDir ) );         assertEquals( singletonList( expectedFile ), outputDir.values( options ) );         assertEquals( asList( new File( "a.txt" ), new File( "b.txt" ) ), files.values( options ) );     } } 
package joptsimple.examples;  import static java.util.Arrays.*; import static java.util.Collections.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class SignallingEndOfOptionsTest {     @Test     public void doubleHyphenSignalsEndOfOptions() {         OptionParser parser = new OptionParser( "ab:c::de:f::" );          OptionSet options = parser.parse( "-a", "-b=foo", "-c=bar", "--", "-d", "-e", "baz", "-f", "biz" );          assertTrue( options.has( "a" ) );         assertFalse( options.hasArgument( "a" ) );         assertTrue( options.has( "b" ) );         assertTrue( options.hasArgument( "b" ) );         assertEquals( singletonList( "foo" ), options.valuesOf( "b" ) );         assertTrue( options.has( "c" ) );         assertTrue( options.hasArgument( "c" ) );         assertEquals( singletonList( "bar" ), options.valuesOf( "c" ) );         assertFalse( options.has( "d" ) );         assertFalse( options.has( "e" ) );         assertFalse( options.has( "f" ) );         assertEquals( asList( "-d", "-e", "baz", "-f", "biz" ), options.nonOptionArguments() );     } } 
package joptsimple.examples;  import java.util.List;  import static java.util.Arrays.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static java.util.Collections.*; import static org.junit.Assert.*;  public class OptionSynonymTest {     @Test     public void supportsOptionSynonyms() {         OptionParser parser = new OptionParser();         List<String> synonyms = asList( "message", "blurb", "greeting" );         parser.acceptsAll( synonyms ).withRequiredArg();         String expectedMessage = "Hello";          OptionSet options = parser.parse( "--message", expectedMessage );          for ( String each : synonyms ) {             assertTrue( each, options.has( each ) );             assertTrue( each, options.hasArgument( each ) );             assertEquals( each, expectedMessage, options.valueOf( each ) );             assertEquals( each, singletonList( expectedMessage ), options.valuesOf( each ) );         }     } } 
package joptsimple.examples;  import joptsimple.OptionException; import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class RequiredOptionsTest {     @Test( expected = OptionException.class )     public void allowsSpecificationOfRequiredOptions() {         OptionParser parser = new OptionParser() {             {                 accepts( "userid" ).withRequiredArg().required();                 accepts( "password" ).withRequiredArg().required();             }         };          parser.parse( "--userid", "bob" );     }      @Test     public void aHelpOptionMeansRequiredOptionsNeedNotBePresent() {         OptionParser parser = new OptionParser() {             {                 accepts( "userid" ).withRequiredArg().required();                 accepts( "password" ).withRequiredArg().required();                 accepts( "help" ).forHelp();             }         };          OptionSet options = parser.parse( "--help" );         assertTrue( options.has( "help" ) );     }          @Test( expected = OptionException.class )     public void missingHelpOptionMeansRequiredOptionsMustBePresent() {         OptionParser parser = new OptionParser() {             {                 accepts( "userid" ).withRequiredArg().required();                 accepts( "password" ).withRequiredArg().required();                 accepts( "help" ).forHelp();             }         };          parser.parse( "" );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class ShortOptionsTest {     @Test     public void supportsShortOptions() {         OptionParser parser = new OptionParser( "aB?*." );          OptionSet options = parser.parse( "-a", "-B", "-?" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( "B" ) );         assertTrue( options.has( "?" ) );         assertFalse( options.has( "." ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static java.util.Collections.*; import static org.junit.Assert.*;  public class UnrecognizedOptionsAllowedTest {     @Test     public void acceptsLongOptions() {         OptionParser parser = new OptionParser();         parser.allowsUnrecognizedOptions();         parser.accepts( "f" );          OptionSet options = parser.parse( "-f", "-d" );          assertTrue( options.has( "f" ) );         assertFalse( options.has( "d" ) );         assertEquals( singletonList( "-d" ), options.nonOptionArguments() );     } } 
package joptsimple.examples;  import com.google.common.base.Joiner; import joptsimple.OptionParser; import joptsimple.OptionSet; import joptsimple.OptionSpec; import org.junit.Test;  import java.io.File; import java.util.List; import java.util.Map.Entry; import java.util.Properties;  import static org.junit.Assert.assertEquals;  public class ExportOptionsTest {     private static Properties asProperties( OptionSet options, String prefix ) {         Properties properties = new Properties();         for ( Entry<OptionSpec<?>, List<?>> entry : options.asMap().entrySet() ) {             OptionSpec<?> spec = entry.getKey();             properties.setProperty(                 asPropertyKey( prefix, spec ),                 asPropertyValue( entry.getValue(), options.has( spec ) ) );         }         return properties;     }      private static String asPropertyKey( String prefix, OptionSpec<?> spec ) {         List<String> flags = spec.options();         for ( String flag : flags )             if ( 1 < flag.length() )                 return null == prefix ? flag : ( prefix + '.' + flag );         throw new IllegalArgumentException( "No usable non-short flag: " + flags );     }      private static String asPropertyValue( List<?> values, boolean present ) {         // Simple flags have no values; treat presence/absence as true/false         return values.isEmpty() ? String.valueOf( present ) : Joiner.on( "," ).join( values );     }      @Test     public void allowsExportOfOptions() {         Properties expected = new Properties();         expected.setProperty( "rice.count", "3" );         // Cannot check path as string directly - Windows flips the leading slash         expected.setProperty( "rice.output-dir", new File( "/tmp" ).toString() );         expected.setProperty( "rice.fun", "false" );         expected.setProperty( "rice.verbose", "true" );          OptionParser parser = new OptionParser();         OptionSpec<Integer> count = parser.accepts( "count" ).withRequiredArg().ofType( Integer.class );         OptionSpec<File> outputDir = parser.accepts( "output-dir" ).withOptionalArg().ofType( File.class );         OptionSpec<Void> verbose = parser.accepts( "verbose" );         OptionSpec<Void> fun = parser.accepts( "fun" );         OptionSpec<File> files = parser.nonOptions().ofType( File.class );          OptionSet options = parser.parse( "--count", "3", "--output-dir", "/tmp", "--verbose", "a.txt", "b.txt" );          assertEquals( expected, asProperties( options, "rice" ) );     } } 
package joptsimple.examples;  import static java.util.Collections.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class SpecialOptionalArgumentHandlingTest {     @Test     public void handlesNegativeNumberOptionalArguments() {         OptionParser parser = new OptionParser();         parser.accepts( "a" ).withOptionalArg().ofType( Integer.class );         parser.accepts( "2" );          OptionSet options = parser.parse( "-a", "-2" );          assertTrue( options.has( "a" ) );         assertFalse( options.has( "2" ) );         assertEquals( singletonList( -2 ), options.valuesOf( "a" ) );          options = parser.parse( "-2", "-a" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( "2" ) );         assertEquals( emptyList(), options.valuesOf( "a" ) );     } } 
package joptsimple.examples;  import static java.util.Arrays.*; import static java.util.Collections.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class PosixlyCorrectTest {     @Test     public void supportsPosixlyCorrectBehavior() {         OptionParser parser = new OptionParser( "i:j::k" );         String[] arguments = { "-ibar", "-i", "junk", "xyz", "-jixnay", "foo", "-k", "blah", "--", "bah" };          OptionSet options = parser.parse( arguments );          assertTrue( options.has( "i" ) );         assertTrue( options.has( "j" ) );         assertTrue( options.has( "k" ) );         assertEquals( asList( "bar", "junk" ), options.valuesOf( "i" ) );         assertEquals( singletonList( "ixnay" ), options.valuesOf( "j" ) );         assertEquals( asList( "xyz", "foo", "blah", "bah" ), options.nonOptionArguments() );          parser.posixlyCorrect( true );         options = parser.parse( arguments );          assertTrue( options.has( "i" ) );         assertFalse( options.has( "j" ) );         assertFalse( options.has( "k" ) );         assertEquals( asList( "bar", "junk" ), options.valuesOf( "i" ) );         assertEquals( emptyList(), options.valuesOf( "j" ) );         assertEquals( asList( "xyz", "-jixnay", "foo", "-k", "blah", "--", "bah" ), options.nonOptionArguments() );     } } 
package joptsimple.examples.ant.filters;  import java.io.IOException; import java.io.Reader; import java.util.HashMap; import java.util.Map;  import org.apache.tools.ant.filters.BaseFilterReader; import org.apache.tools.ant.filters.ChainableReader;  /**  * Ant filter class that transforms HTML special characters into their equivalent entities.  *  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class HTMLEntitifier extends BaseFilterReader implements ChainableReader {     private static final Map<Integer, String> ENTITIES = new HashMap<>();      static {         ENTITIES.put( (int) '<', "&lt;" );         ENTITIES.put( (int) '>', "&gt;" );         ENTITIES.put( (int) '"', "&quot;" );         ENTITIES.put( (int) '&', "&amp;" );     }      private String replacementData;     private int replacementIndex = -1;      /**      * Creates "dummy" instances.      */     public HTMLEntitifier() {         // empty on purpose     }      /**      * @param source where the data to filter comes from      */     public HTMLEntitifier( Reader source ) {         super( source );     }      /**      * {@inheritDoc}      */     public Reader chain( Reader source ) {         HTMLEntitifier newFilter = new HTMLEntitifier( source );         newFilter.setInitialized( true );          return newFilter;     }      /**      * {@inheritDoc}      */     @Override     public int read() throws IOException {         if ( !getInitialized() )             setInitialized( true );          if ( replacementIndex > -1 ) {             int ch = replacementData.charAt( replacementIndex++ );              if ( replacementIndex >= replacementData.length() )                 replacementIndex = -1;              return ch;         }          int nextChar = in.read();          if ( ENTITIES.containsKey( nextChar ) ) {             replacementData = ENTITIES.get( nextChar );             replacementIndex = 1;             return replacementData.charAt( 0 );         }          return nextChar;     } } 
package joptsimple.examples;  import java.io.File; import java.util.HashSet; import java.util.Map;  import static java.io.File.*; import static java.util.Arrays.*;  import joptsimple.HelpFormatter; import joptsimple.OptionDescriptor; import joptsimple.OptionParser;  import static joptsimple.util.DateConverter.*;  public class HelpFormatterExample {     private static class MyFormatter implements HelpFormatter {         public String format( Map<String, ? extends OptionDescriptor> options ) {             StringBuilder buffer = new StringBuilder();             for ( OptionDescriptor each : new HashSet<>( options.values() ) ) {                 buffer.append( lineFor( each ) );             }             return buffer.toString();         }          private String lineFor( OptionDescriptor descriptor ) {             if ( descriptor.representsNonOptions() ) {                 return descriptor.argumentDescription() + '(' + descriptor.argumentTypeIndicator() + "): "                     + descriptor.description() + System.getProperty( "line.separator" );             }              StringBuilder line = new StringBuilder( descriptor.options().toString() );             line.append( ": description = " ).append( descriptor.description() );             line.append( ", required = " ).append( descriptor.isRequired() );             line.append( ", accepts arguments = " ).append( descriptor.acceptsArguments() );             line.append( ", requires argument = " ).append( descriptor.requiresArgument() );             line.append( ", argument description = " ).append( descriptor.argumentDescription() );             line.append( ", argument type indicator = " ).append( descriptor.argumentTypeIndicator() );             line.append( ", default values = " ).append( descriptor.defaultValues() );             line.append( System.getProperty( "line.separator" ) );             return line.toString();         }     }      public static void main( String[] args ) throws Exception {         OptionParser parser = new OptionParser() {             {                 accepts( "c" ).withRequiredArg().ofType( Integer.class )                     .describedAs( "count" ).defaultsTo( 1 );                 accepts( "q" ).withOptionalArg().ofType( Double.class )                     .describedAs( "quantity" );                 accepts( "d", "some date" ).withRequiredArg().required()                     .withValuesConvertedBy( datePattern( "MM/dd/yy" ) );                 acceptsAll( asList( "v", "talkative", "chatty" ), "be more verbose" );                 accepts( "output-file" ).withOptionalArg().ofType( File.class )                      .describedAs( "file" );                 acceptsAll( asList( "h", "?" ), "show help" ).forHelp();                 acceptsAll( asList( "cp", "classpath" ) ).withRequiredArg()                     .describedAs( "path1" + pathSeparatorChar + "path2:..." )                     .ofType( File.class )                     .withValuesSeparatedBy( pathSeparatorChar );                 nonOptions( "files to chew on" ).ofType( File.class ).describedAs( "input files" );             }         };          parser.formatHelpWith( new MyFormatter() );         parser.printHelpOn( System.out );     } } 
package joptsimple.examples;  import joptsimple.OptionParser;  public class RequiredIfExample {     public static void main( String[] args ) {         OptionParser parser = new OptionParser();         parser.accepts( "ftp" );         parser.accepts( "username" ).requiredIf( "ftp" ).withRequiredArg();         parser.accepts( "password" ).requiredIf( "ftp" ).withRequiredArg();          parser.parse( "--ftp" );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class OptionArgumentValueTypeTest {     @Test     public void convertsArgumentsToJavaValueTypes() {         OptionParser parser = new OptionParser();         parser.accepts( "flag" );         parser.accepts( "count" ).withRequiredArg().ofType( Integer.class );         parser.accepts( "level" ).withOptionalArg().ofType( Level.class );          OptionSet options = parser.parse( "--count", "3", "--level", "DEBUG" );          assertTrue( options.has( "count" ) );         assertTrue( options.hasArgument( "count" ) );         assertEquals( 3, options.valueOf( "count" ) );          assertTrue( options.has( "level" ) );         assertTrue( options.hasArgument( "level" ) );         assertEquals( Level.DEBUG, options.valueOf( "level" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class ShortOptionsWithArgumentPositioningTest {     @Test     public void allowsDifferentFormsOfPairingArgumentWithOption() {         OptionParser parser = new OptionParser( "a:b:c::" );          OptionSet options = parser.parse( "-a", "foo", "-bbar", "-c=baz" );          assertTrue( options.has( "a" ) );         assertTrue( options.hasArgument( "a" ) );         assertEquals( "foo", options.valueOf( "a" ) );          assertTrue( options.has( "b" ) );         assertTrue( options.hasArgument( "b" ) );         assertEquals( "bar", options.valueOf( "b" ) );          assertTrue( options.has( "c" ) );         assertTrue( options.hasArgument( "c" ) );         assertEquals( "baz", options.valueOf( "c" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class ShortOptionsClusteringTest {     @Test     public void allowsClusteringShortOptions() {         OptionParser parser = new OptionParser( "aBcd" );          OptionSet options = parser.parse( "-cdBa" );          assertTrue( options.has( "a" ) );         assertTrue( options.has( "B" ) );         assertTrue( options.has( "c" ) );         assertTrue( options.has( "d" ) );     } } 
package joptsimple.examples;  import static java.util.Collections.*;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class ShortOptionsWithArgumentsTest {     @Test     public void allowsOptionsToAcceptArguments() {         OptionParser parser = new OptionParser( "fc:q::" );          OptionSet options = parser.parse( "-f", "-c", "foo", "-q" );          assertTrue( options.has( "f" ) );          assertTrue( options.has( "c" ) );         assertTrue( options.hasArgument( "c" ) );         assertEquals( "foo", options.valueOf( "c" ) );         assertEquals( singletonList( "foo" ), options.valuesOf( "c" ) );          assertTrue( options.has( "q" ) );         assertFalse( options.hasArgument( "q" ) );         assertNull( options.valueOf( "q" ) );         assertEquals( emptyList(), options.valuesOf( "q" ) );     } } 
package joptsimple.examples;  import joptsimple.OptionParser; import joptsimple.OptionSet; import org.junit.Test;  import static org.junit.Assert.*;  public class AlternativeLongOptionsTest {     @Test     public void handlesAlternativeLongOptions() {         OptionParser parser = new OptionParser( "W;" );         parser.recognizeAlternativeLongOptions( true );  // same effect as above         parser.accepts( "level" ).withRequiredArg();          OptionSet options = parser.parse( "-W", "level=5" );          assertTrue( options.has( "level" ) );         assertTrue( options.hasArgument( "level" ) );         assertEquals( "5", options.valueOf( "level" ) );     } } 
package joptsimple.examples;  import java.io.File;  import joptsimple.OptionException; import joptsimple.OptionParser; import joptsimple.OptionSet; import joptsimple.OptionSpec; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.examples.Level.*; import static org.junit.Assert.*; import static org.junit.rules.ExpectedException.*;  public class DefaultValuesForOptionArgumentsTest {     @Rule public final ExpectedException thrown = none();      @Test     public void allowsSpecificationOfDefaultValues() throws Exception {         File tempDir = new File( System.getProperty( "java.io.tmpdir" ) );         File tempFile = File.createTempFile( "aFile", ".txt" );         OptionParser parser = new OptionParser();         OptionSpec<File> infile =             parser.accepts( "infile" ).withRequiredArg().ofType( File.class ).defaultsTo( tempFile );         OptionSpec<File> outdir =             parser.accepts( "outdir" ).withRequiredArg().ofType( File.class ).defaultsTo( tempDir );         OptionSpec<Integer> bufferSize =             parser.accepts( "buffer-size" ).withOptionalArg().ofType( Integer.class ).defaultsTo( 4096 );         OptionSpec<Level> level =             parser.accepts( "level" ).withOptionalArg().ofType( Level.class ).defaultsTo( INFO );         OptionSpec<Integer> count =             parser.accepts( "count" ).withOptionalArg().ofType( Integer.class ).defaultsTo( 10 );          OptionSet options = parser.parse( "--level", "WARNING", "--count", "--infile", "/etc/passwd" );          assertEquals( new File( "/etc/passwd" ), infile.value( options ) );         assertTrue( options.has( infile ) );         assertTrue( options.hasArgument( infile ) );         assertEquals( tempDir, outdir.value( options ) );         assertFalse( options.has( outdir ) );         assertFalse( options.hasArgument( outdir ) );         assertEquals( Integer.valueOf( 4096 ), bufferSize.value( options ) );         assertFalse( options.has( bufferSize ) );         assertFalse( options.hasArgument( bufferSize ) );         assertEquals( WARNING, level.value( options ) );         assertTrue( options.has( level ) );         assertTrue( options.hasArgument( level ) );         assertEquals( Integer.valueOf( 10 ), count.value( options ) );         assertTrue( options.has( count ) );         assertFalse( options.hasArgument( count ) );          thrown.expect( OptionException.class );          parser.parse( "--outdir" );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSynonymNoArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.acceptsAll( asList( "N", "after-date", "newer" ) );     }      @Test     public void hasAllSynonymsWhenFirstSynonymParsed() {         assertDetections( "-N" );     }      @Test     public void hasAllSynonymsWhenSecondSynonymParsed() {         assertDetections( "--after-d" );     }      @Test     public void hasAllSynonymsWhenThirdSynonymParsed() {         assertDetections( "--n" );     }      private void assertDetections( String option ) {         OptionSet options = parser.parse( option );          assertOptionDetected( options, "N" );         assertOptionDetected( options, "after-date" );         assertOptionDetected( options, "newer" );         assertEquals( emptyList(), options.valuesOf( "N" ) );         assertEquals( emptyList(), options.valuesOf( "after-date" ) );         assertEquals( emptyList(), options.valuesOf( "newer" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class LongOptionRequiredArgumentTest extends AbstractOptionParserFixture {     @Before     public final void initializeParser() {         parser.accepts( "quiet" ).withRequiredArg();         parser.accepts( "a" ).withOptionalArg();         parser.accepts( "y" ).withRequiredArg();     }      @Test     public void argumentSeparate() {         OptionSet options = parser.parse( "--quiet", "23" );          assertOptionDetected( options, "quiet" );         assertEquals( singletonList( "23" ), options.valuesOf( "quiet" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void argumentFollowedByLegalOption() {         OptionSet options = parser.parse( "--quiet", "-a" );          assertOptionDetected( options, "quiet" );         assertOptionNotDetected( options, "a" );         assertEquals( singletonList( "-a" ), options.valuesOf( "quiet" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void argumentTogether() {         OptionSet options = parser.parse( "--quiet=23" );          assertOptionDetected( options, "quiet" );         assertEquals( singletonList( "23" ), options.valuesOf( "quiet" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void argumentMissing() {         thrown.expect( OptionMissingRequiredArgumentException.class );         thrown.expect( withOption( "quiet" ) );          parser.parse( "--quiet" );     }      @Test     public void shortOptionSpecifiedAsLongOptionWithArgument() {         OptionSet options = parser.parse( "--y=bar" );          assertOptionDetected( options, "y" );         assertEquals( singletonList( "bar" ), options.valuesOf( "y" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void whenEndOfOptionsMarkerIsInPlaceOfRequiredArgument() {         OptionSet options = parser.parse( "--quiet", "--", "-y", "foo", "-a" );          assertOptionDetected( options, "quiet" );         assertOptionDetected( options, "y" );         assertOptionDetected( options, "a" );         assertEquals( singletonList( "--" ), options.valuesOf( "quiet" ) );         assertEquals( singletonList( "foo" ), options.valuesOf( "y" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Collections.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionSpecBuilderValuesImmutabilityTest extends AbstractOptionSpecValuesImmutabilityTestCase<Void> {     @Override     protected AbstractOptionSpec<Void> newOptionSpec() {         return new OptionSpecBuilder( new OptionParser(), singletonList( "a" ), "" );     }      @Override     protected String firstArg() {         return "Q";     }      @Override     protected String secondArg() {         return "W";     }      @Override     protected Void newItem() {         return null;     }      @Override     protected Void containedItem() {         return null;     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException;  import static joptsimple.ExceptionMatchers.*; import static org.junit.rules.ExpectedException.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public abstract class UtilityClassesUninstantiabilityHarness {     @Rule public final ExpectedException thrown = none();      private final Class<?> utility;      protected UtilityClassesUninstantiabilityHarness( Class<?> utility ) {         this.utility = utility;     }      @Test     public final void attemptToInstantiate() throws Exception {         Constructor<?> constructor = utility.getDeclaredConstructor();         constructor.setAccessible( true );          thrown.expect( InvocationTargetException.class );         thrown.expect( withTargetOfType( UnsupportedOperationException.class ) );          constructor.newInstance();     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*; import static java.util.Collections.*;  import org.junit.Before; import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RequiredIfTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         OptionSpec<Void> ftp = parser.acceptsAll( asList( "ftp", "file-transfer" ) );         parser.acceptsAll( asList( "username", "userid" ) ).requiredIf( "file-transfer" ).withRequiredArg();         parser.acceptsAll( asList( "password", "pwd" ) ).requiredIf( ftp ).withRequiredArg();         parser.accepts( "?" ).forHelp();     }      @Test     public void rejectsCommandLineMissingConditionallyRequiredOption() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "--ftp" );     }      @Test     public void rejectsCommandLineMissingConditionallyRequiredOptionSynonym() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "--file-transfer" );     }      @Test     public void rejectsCommandLineWithNotAllConditionallyRequiredOptionsPresent() {         thrown.expect( MissingRequiredOptionsException.class );          parser.parse( "--ftp", "--username", "joe" );     }      @Test     public void acceptsCommandLineWithConditionallyRequiredOptionsPresent() {         OptionSet options = parser.parse( "--ftp", "--userid", "joe", "--password=secret" );          assertOptionDetected( options, "ftp" );         assertOptionDetected( options, "username" );         assertOptionDetected( options, "password" );         assertEquals( singletonList( "joe" ), options.valuesOf( "username" ) );         assertEquals( singletonList( "secret" ), options.valuesOf( "password" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsOptionWithPrerequisiteAsNormalIfPrerequisiteNotInPlay() {         OptionSet options = parser.parse( "--pwd", "secret" );          assertOptionDetected( options, "pwd" );         assertEquals( singletonList( "secret" ), options.valuesOf( "pwd" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void rejectsOptionNotAlreadyConfigured() {         thrown.expect( UnconfiguredOptionException.class );          parser.accepts( "foo" ).requiredIf( "bar" );     }      @Test     public void rejectsOptionSpecNotAlreadyConfigured() {         thrown.expect( UnconfiguredOptionException.class );          parser.accepts( "foo" ).requiredIf( "bar" );     }      @Test     public void presenceOfHelpOptionNegatesRequiredIfness() {         OptionSet options = parser.parse( "--ftp", "-?" );          assertOptionDetected( options, "ftp" );         assertOptionDetected( options, "?" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.util.Optional;  import static java.lang.Boolean.*; import static java.util.Arrays.*; import static java.util.Collections.*;  import org.hamcrest.Description; import org.hamcrest.TypeSafeMatcher; import org.junit.Test;  import static joptsimple.ExceptionMatchers.*; import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class OptionParserTest extends AbstractOptionParserFixture {     @Test     public void optionsAndNonOptionsInterspersed() {         parser.accepts("i" ).withOptionalArg();         parser.accepts( "j" ).withOptionalArg();         OptionSpec<Void> k = parser.accepts( "k" );          OptionSet options =             parser.parse( "-ibar", "-i", "junk", "xyz", "-jixnay", "foo", "-k", "blah", "--", "yermom" );          assertOptionDetected( options, "i" );         assertOptionDetected( options, "j" );         assertOptionDetected( options, "k" );         assertEquals( asList( "bar", "junk" ), options.valuesOf( "i" ) );         assertEquals( singletonList( "ixnay" ), options.valuesOf( "j" ) );         assertEquals( emptyList(), options.valuesOf( "k" ) );         assertEquals( asList( "xyz", "foo", "blah", "yermom" ), options.nonOptionArguments() );         assertEquals( Optional.empty(), k.valueOptional( options ) );     }      @Test     public void shortOptionSpecifiedAsLongOptionWithoutArgument() {         parser.accepts( "x" );          OptionSet options = parser.parse( "--x" );         assertOptionDetected( options, "x" );         assertEquals( emptyList(), options.valuesOf( "x" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void longOptionLeadsWithSingleDash() {         parser.accepts( "quiet" );         parser.accepts( "queen" );          OptionSet options = parser.parse( "-quiet" );         assertOptionDetected( options, "quiet" );         assertEquals( emptyList(), options.valuesOf( "quiet" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }          @Test     public void parsesLongOptionAsAbbreviatedShortOption() {         parser.accepts( "queen" );          parser.parse( "-que" );     }          @Test     public void parsesLongOptionAsAbbreviatedLongOption() {         parser.accepts( "queen" );          parser.parse( "--que" );     }      @Test     public void longOptionLeadsWithSingleDashAmbiguous() {         parser.accepts( "quiet" );         parser.accepts( "queen" );         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "q" ) );          parser.parse( "-q" );     }      @Test     public void longOptionLeadsWithSingleDashAmbiguousButShortsAreLegal() {         parser.accepts( "quiet" );         parser.accepts( "queen" );         parser.accepts( "q" );         parser.accepts( "u" );          OptionSet options = parser.parse( "-qu" );         assertOptionDetected( options, "q" );         assertOptionDetected( options, "u" );         assertOptionNotDetected( options, "quiet" );         assertOptionNotDetected( options, "queen" );         assertEquals( emptyList(), options.valuesOf( "q" ) );         assertEquals( emptyList(), options.valuesOf( "u" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void longOptionLeadsWithSingleDashAmbiguousButAShortIsIllegal() {         parser.accepts( "quiet" );         parser.accepts( "queen" );         parser.accepts( "q" );         thrown.expect( UnrecognizedOptionException.class );         thrown.expect( withOption( "u" ) );          parser.parse( "-qu" );     }      @Test     public void longOptionLeadsWithSingleDashAmbiguousButAShortAcceptsAnArgument() {         parser.accepts( "quiet" );         parser.accepts( "queen" );         parser.accepts( "q" ).withOptionalArg();          OptionSet options = parser.parse( "-qu" );         assertOptionDetected( options, "q" );         assertOptionNotDetected( options, "quiet" );         assertOptionNotDetected( options, "queen" );         assertEquals( singletonList( "u" ), options.valuesOf( "q" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void resetHappensAfterParsing() {         parser.accepts( "i" ).withOptionalArg();         parser.accepts( "j" ).withOptionalArg();         parser.accepts( "k" );          String[] args = { "-ibar", "-i", "junk", "xyz", "-jixnay", "foo", "-k", "blah", "--", "yermom" };          OptionSet options = parser.parse( args );         assertEquals( options, parser.parse( args ) );     }      @Test     public void typedArguments() {         parser.accepts( "a" ).withRequiredArg().ofType( Boolean.class );         parser.accepts( "b" ).withOptionalArg().ofType( Integer.class );          OptionSet options = parser.parse( "-a", "false", "-b", "3", "extra" );          assertOptionDetected( options, "a" );         assertOptionDetected( options, "b" );         assertEquals( FALSE, options.valueOf( "a" ) );         assertEquals( Optional.of( false ), options.valueOfOptional( "a" ) );         assertEquals( singletonList( false ), options.valuesOf( "a" ) );         assertEquals( Integer.valueOf( "3" ), options.valueOf( "b" ) );         assertEquals( Optional.of( 3 ), options.valueOfOptional( "b" ) );         assertEquals( singletonList( 3 ), options.valuesOf( "b" ) );         assertEquals( singletonList( "extra" ), options.nonOptionArguments() );     }      @Test     public void allowsMixingOfOptionsAndNonOptions() {         parser.accepts( "i" ).withRequiredArg();         parser.accepts( "j" ).withOptionalArg();         parser.accepts( "k" );          OptionSet options = parser.parse( "a", "b", "c", "-i", "boo", "d", "e", "-k", "f", "-j" );          assertOptionDetected( options, "i" );         assertEquals( singletonList( "boo" ), options.valuesOf( "i" ) );         assertOptionDetected( options, "j" );         assertEquals( emptyList(), options.valuesOf( "j" ) );         assertOptionDetected( options, "k" );         assertEquals( emptyList(), options.valuesOf( "k" ) );         assertEquals( asList( "a", "b", "c", "d", "e", "f" ), options.nonOptionArguments() );     }      @Test     public void disallowsMixingOfOptionsAndNonOptionsUnderPosixlyCorrect() {         parser.accepts( "i" ).withRequiredArg();         parser.accepts( "j" ).withOptionalArg();         parser.accepts( "k" );         parser.posixlyCorrect( true );          OptionSet options = parser.parse( "a", "b", "c", "-i", "boo", "d", "e", "-k", "f", "-j" );          assertOptionNotDetected( options, "i" );         assertEquals( emptyList(), options.valuesOf( "i" ) );         assertOptionNotDetected( options, "j" );         assertEquals( emptyList(), options.valuesOf( "j" ) );         assertOptionNotDetected( options, "k" );         assertEquals( emptyList(), options.valuesOf( "j" ) );         assertEquals( asList( "a", "b", "c", "-i", "boo", "d", "e", "-k", "f", "-j" ), options.nonOptionArguments() );     }      @Test     public void doubleHyphenSignalsEndsOfOptions() {         OptionSet options = new OptionParser( "ab:c::de:f::" ) {             {                 accepts( "verbose" );             }         }.parse( "-a", "-b=foo", "-c=bar", "--", "-d", "-verbose", "-e", "baz", "-f", "biz" );          assertOptionDetected( options, "a" );         assertEquals( emptyList(), options.valuesOf( "a" ) );         assertOptionDetected( options, "b" );         assertEquals( singletonList( "foo" ), options.valuesOf( "b" ) );         assertOptionDetected( options, "c" );         assertEquals( singletonList( "bar" ), options.valuesOf( "c" ) );         assertOptionNotDetected( options, "d" );         assertOptionNotDetected( options, "verbose" );         assertOptionNotDetected( options, "e" );         assertOptionNotDetected( options, "f" );         assertEquals( asList( "-d", "-verbose", "-e", "baz", "-f", "biz" ), options.nonOptionArguments() );     }      @Test     public void allowsEmptyStringAsArgumentOfOption() {         OptionSpec<String> optionI = parser.accepts( "i" ).withOptionalArg();          OptionSet options = parser.parse( "-i", "" );          assertOptionDetected( options, "i" );         assertEquals( "", optionI.value( options ) );         assertEquals( Optional.of( "" ), optionI.valueOptional( options ) );     }      @Test     public void allowsWhitespaceyStringAsArgumentOfOption() {         String whitespace = "     \t\t\n\n\f\f     \r\r   ";         OptionSpec<String> optionJ = parser.accepts( "j" ).withRequiredArg();          OptionSet options = parser.parse( "-j", whitespace );          assertOptionDetected( options, "j" );         assertEquals( whitespace, optionJ.value( options ) );         assertEquals( Optional.of( whitespace ), optionJ.valueOptional( options ) );     }      @Test     public void allowsEmbeddedWhitespaceInArgumentOfOption() {         String withEmbeddedWhitespace = "   look at me, I'm flaunting the rules!   ";         OptionSpec<String> optionJ = parser.accepts( "j" ).withRequiredArg();          OptionSet options = parser.parse( "-j", withEmbeddedWhitespace );          assertOptionDetected( options, "j" );         assertEquals( withEmbeddedWhitespace, optionJ.value( options ) );         assertEquals( Optional.of( withEmbeddedWhitespace ), optionJ.valueOptional( options ) );     }          @Test     public void requiredOptionWithArgMissing() {         parser.accepts( "t" ).withOptionalArg().required();         thrown.expect( MissingRequiredOptionsException.class );         thrown.expect( withOption( "t" ) );          parser.parse();     }      @Test     public void requiredOptionButHelpOptionPresent() {         parser.accepts( "t" ).withOptionalArg().required();         parser.accepts( "h" ).forHelp();          parser.parse( "-h" );     }      @Test     public void configurationPerformedLaterOverrideThosePerformedEarlierForTheSameOption() {         parser.accepts( "t" ).withRequiredArg();         parser.accepts( "t" ).withOptionalArg();          parser.parse( "-t" );     }      @Test     public void requiredOptionWithSynonymsMissing() {         parser.acceptsAll( asList( "h", "help", "?" ) );         parser.acceptsAll( asList( "f", "ff", "csv-file-name" ) ).withRequiredArg().required();          thrown.expect( MissingRequiredOptionsException.class );         thrown.expectMessage( new TypeSafeMatcher<String>() {             @Override             protected boolean matchesSafely( String item ) {                 return "Missing required option(s) [f/csv-file-name/ff]".equals( item );             }              @Override             public void describeTo( Description description ) {                 // purposely doing nothing here             }         } );          parser.parse();     }      @Test     public void abbreviationsCanBeDisallowed() {         OptionParser parser = new OptionParser(false);         parser.accepts( "abbreviatable" );          thrown.expect( UnrecognizedOptionException.class );          parser.parse( "--abb" );     } } 
/*  The MIT License   Copyright (c) 2004-2014 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Collections.emptyList;  import static org.junit.Assert.assertEquals;  public class AvailableIfAnyTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         OptionSpec<Void> a = parser.accepts( "a" );         parser.accepts( "b" );         OptionSpec<Void> c = parser.accepts( "c" );         parser.accepts( "d" );         parser.accepts( "n" ).availableIf( a, c );     }      @Test     public void rejectsCommandLineExistingForbiddenOption() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-b", "-n" );     }      @Test     public void rejectsCommandLineExistingOtherForbiddenOption() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-d", "-n" );     }      @Test     public void rejectsCommandLineOnlyForbiddenOption() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-n" );     }      @Test     public void rejectsCommandLineWithNotAllConditionallyRequiredOptionsPresent() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "-b", "-d", "-n" );     }      @Test     public void acceptsCommandLineWithAllowedOptionsPresent() {         OptionSet options = parser.parse( "-a", "-c", "-n" );                  assertOptionDetected( options, "a" );         assertOptionDetected( options, "c" );         assertOptionDetected( options, "n" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2014 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import org.junit.Before; import org.junit.Test;  import static java.util.Arrays.asList; import static java.util.Collections.emptyList; import static java.util.Collections.singletonList;  import static org.junit.Assert.assertEquals;  public class AvailableIfUnlessTest extends AbstractOptionParserFixture {     @Before     public void configureParser() {         parser.mutuallyExclusive(                 parser.acceptsAll( asList( "ftp", "file-transfer" ) ),                 parser.accepts( "file" ),                 parser.accepts( "http" )         );          parser.acceptsAll( asList( "username", "userid" ) ).availableIf( "file-transfer" ).withRequiredArg();         parser.acceptsAll( asList( "password", "pwd" ) ).availableIf( "ftp" ).withRequiredArg();         parser.acceptsAll( asList( "directory", "dir" ) ).availableIf( "file" ).withRequiredArg();         parser.accepts( "?" ).forHelp();     }      @Test     public void rejectsEmptyMutualExclusiveness() {         thrown.expect( NullPointerException.class );          parser.mutuallyExclusive( (OptionSpecBuilder[]) null );     }      @Test     public void rejectsConflictingCommandLineOptions1() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "--ftp", "--file" );     }      @Test     public void rejectsConflictingCommandLineOptions2() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "--ftp", "--http" );     }      @Test     public void rejectsIncompatibleOptions1() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "--file", "--username", "joe" );     }      @Test     public void rejectsIncompatibleOptions2() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "--ftp", "--directory", "/tmp" );     }       @Test     public void acceptsCommandLineWithConditionallyAllowedOptionsPresent1() {         OptionSet options = parser.parse( "--ftp", "--userid", "joe", "--password=secret" );          assertOptionDetected( options, "ftp" );         assertOptionDetected( options, "username" );         assertOptionDetected( options, "password" );         assertEquals( singletonList( "joe" ), options.valuesOf( "username" ) );         assertEquals( singletonList( "secret" ), options.valuesOf( "password" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void acceptsCommandLineWithConditionallyAllowedOptionsPresent2() {         OptionSet options = parser.parse( "--file", "--dir", "/tmp");          assertOptionDetected( options, "file" );         assertOptionDetected( options, "dir" );         assertEquals( singletonList( "/tmp" ), options.valuesOf( "dir" ) );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void rejectsCommandLineOnlyContainingForbiddenOptionSynonym() {         thrown.expect( UnavailableOptionException.class );          parser.parse( "--pwd", "secret" );     }      @Test     public void rejectsOptionNotAlreadyConfigured() {         thrown.expect( UnconfiguredOptionException.class );          parser.accepts( "foo" ).availableIf( "bar" );         parser.accepts( "foo" ).availableUnless( "bar" );     }      @Test     public void presenceOfHelpOptionNegatesAllowedIfness() {         OptionSet options = parser.parse( "--file", "--userid", "joe", "-?" );          assertOptionDetected( options, "file" );         assertOptionDetected( options, "?" );         assertEquals( emptyList(), options.nonOptionArguments() );     }      @Test     public void presenceOfHelpOptionNegatesAllowedUnlessness() {         OptionSet options = parser.parse( "--file", "--ftp",  "-?" );          assertOptionDetected( options, "file" );         assertOptionDetected( options, "file-transfer" );         assertOptionDetected( options, "?" );         assertEquals( emptyList(), options.nonOptionArguments() );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class RequiredArgumentOptionSpecOptionsImmutabilityTest extends AbstractOptionSpecOptionsImmutabilityTestCase {     @Override     protected AbstractOptionSpec<?> newOptionSpec( String option ) {         return new RequiredArgumentOptionSpec<String>( option );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import static java.util.Arrays.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ParsingSeparatedStringOptionValuesTest extends AbstractOptionParserFixture {     @Test     public void parsesSeparatedValuesAsSeparateArgument() {         assertCorrectParse( "classpath", ":::", "--classpath", "/usr:::/opt:::/var" );     }      @Test     public void parsesSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", ":", "--classpath=/usr:/opt:/var" );     }      @Test     public void parsesEqualsSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", ":=", "--classpath=/usr:=/opt:=/var" );     }      @Test     public void parsesSeparatedValuesAbutting() {         assertCorrectParse( "c", ";", "-c/usr;/opt;/var" );     }      @Test     public void parsesHyphenSeparatedValuesAbutting() {         assertCorrectParse( "c", "--", "-c/usr--/opt--/var" );     }      @Test     public void handlesConsecutiveDelimiters() {         assertCorrectParse( "c", ",", "-c,/usr,,,/opt,,,/var,,,,," );     }      private void assertCorrectParse( String option, String separator, String... args ) {         parser.accepts( option ).withRequiredArg().withValuesSeparatedBy( separator );          OptionSet options = parser.parse( args );          assertEquals( asList( "/usr", "/opt", "/var" ), options.valuesOf( option ) );     } } 
/*  The MIT License   Copyright (c) 2004-2016 Paul R. Holser, Jr.   Permission is hereby granted, free of charge, to any person obtaining  a copy of this software and associated documentation files (the  "Software"), to deal in the Software without restriction, including  without limitation the rights to use, copy, modify, merge, publish,  distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to  the following conditions:   The above copyright notice and this permission notice shall be  included in all copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */  package joptsimple;  import java.io.File;  import static java.util.Arrays.*;  import org.junit.Test;  import static org.junit.Assert.*;  /**  * @author <a href="mailto:pholser@alumni.rice.edu">Paul Holser</a>  */ public class ParsingSeparatedConvertedOptionValuesTest extends AbstractOptionParserFixture {     @Test     public void parsesSeparatedValuesAsSeparateArgument() {         assertCorrectParse( "classpath", ':', "--classpath", "/usr:/opt:/var" );     }      @Test     public void parsesSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", ':', "--classpath=/usr:/opt:/var" );     }      @Test     public void parsesEqualsSeparatedValuesWhenArgumentAbuttedWithEquals() {         assertCorrectParse( "classpath", '=', "--classpath=/usr=/opt=/var" );     }      @Test     public void parsesSeparatedValuesAbutting() {         assertCorrectParse( "c", ':', "-c/usr:/opt:/var" );     }      private void assertCorrectParse( String option, char separator, String... args ) {         parser.accepts( option ).withRequiredArg().withValuesSeparatedBy( separator )             .withValuesConvertedBy( new ValueConverter<File>() {                 @Override                 public File convert( String value ) {                     return new File( value );                 }                  @Override                 public String revert( Object value ) {                     return valueType().cast( value ).getPath();                 }                  @Override                 public Class<File> valueType() {                     return File.class;                 }                  @Override                 public String valuePattern() {                     return null;                 }             } );          OptionSet options = parser.parse( args );          assertEquals(             asList( new File( "/usr" ), new File( "/opt" ), new File( "/var" ) ),             options.valuesOf( option ) );     } } 
